declare module vspherevim {
   interface vimService {
      addHandler(handler: Function): void;
      removeHandler(handler: Function): void;
      serializeObject(obj: Object, name: string): Node;
      deserializeObject(obj: Node): Object;
      serviceInstance: vimService.vim.ManagedObjectReference;
      serviceContent: vimService.vim.ServiceContent;
      xs: {
         AnyType: {
            (options?: vimService.xs.AnyType): vimService.xs.AnyType;
         };
         AnyURI: {
            (options?: vimService.xs.AnyURI): vimService.xs.AnyURI;
         };
         Base64Binary: {
            (options?: vimService.xs.Base64Binary): vimService.xs.Base64Binary;
         };
         Boolean: {
            (options?: vimService.xs.Boolean): vimService.xs.Boolean;
         };
         Byte: {
            (options?: vimService.xs.Byte): vimService.xs.Byte;
         };
         DateTime: {
            (options?: vimService.xs.DateTime): vimService.xs.DateTime;
         };
         Double: {
            (options?: vimService.xs.Double): vimService.xs.Double;
         };
         Float: {
            (options?: vimService.xs.Float): vimService.xs.Float;
         };
         ID: {
            (options?: vimService.xs.ID): vimService.xs.ID;
         };
         Int: {
            (options?: vimService.xs.Int): vimService.xs.Int;
         };
         Integer: {
            (options?: vimService.xs.Integer): vimService.xs.Integer;
         };
         Long: {
            (options?: vimService.xs.Long): vimService.xs.Long;
         };
         NCName: {
            (options?: vimService.xs.NCName): vimService.xs.NCName;
         };
         NegativeInteger: {
            (options?: vimService.xs.NegativeInteger): vimService.xs.NegativeInteger;
         };
         NonNegativeInteger: {
            (options?: vimService.xs.NonNegativeInteger): vimService.xs.NonNegativeInteger;
         };
         NonPositiveInteger: {
            (options?: vimService.xs.NonPositiveInteger): vimService.xs.NonPositiveInteger;
         };
         PositiveInteger: {
            (options?: vimService.xs.PositiveInteger): vimService.xs.PositiveInteger;
         };
         QName: {
            (options?: vimService.xs.QName): vimService.xs.QName;
         };
         Short: {
            (options?: vimService.xs.Short): vimService.xs.Short;
         };
         String: {
            (options?: vimService.xs.String): vimService.xs.String;
         };
         UnsignedLong: {
            (options?: vimService.xs.UnsignedLong): vimService.xs.UnsignedLong;
         };
      }
      vim: {
         DynamicArray: {
            (options?: vimService.vim.DynamicArray): vimService.vim.DynamicArray;
         };
         DynamicData: {
            (options?: vimService.vim.DynamicData): vimService.vim.DynamicData;
         };
         DynamicProperty: {
            (options?: vimService.vim.DynamicProperty): vimService.vim.DynamicProperty;
         };
         ArrayOfDynamicProperty: {
            (options?: vimService.vim.ArrayOfDynamicProperty): vimService.vim.ArrayOfDynamicProperty;
         };
         KeyAnyValue: {
            (options?: vimService.vim.KeyAnyValue): vimService.vim.KeyAnyValue;
         };
         ArrayOfKeyAnyValue: {
            (options?: vimService.vim.ArrayOfKeyAnyValue): vimService.vim.ArrayOfKeyAnyValue;
         };
         LocalizableMessage: {
            (options?: vimService.vim.LocalizableMessage): vimService.vim.LocalizableMessage;
         };
         ArrayOfLocalizableMessage: {
            (options?: vimService.vim.ArrayOfLocalizableMessage): vimService.vim.ArrayOfLocalizableMessage;
         };
         LocalizedMethodFault: {
            (options?: vimService.vim.LocalizedMethodFault): vimService.vim.LocalizedMethodFault;
         };
         MethodFault: {
            (options?: vimService.vim.MethodFault): vimService.vim.MethodFault;
         };
         ArrayOfMethodFault: {
            (options?: vimService.vim.ArrayOfMethodFault): vimService.vim.ArrayOfMethodFault;
         };
         RuntimeFault: {
            (options?: vimService.vim.RuntimeFault): vimService.vim.RuntimeFault;
         };
         HostCommunication: {
            (options?: vimService.vim.HostCommunication): vimService.vim.HostCommunication;
         };
         HostNotConnected: {
            (options?: vimService.vim.HostNotConnected): vimService.vim.HostNotConnected;
         };
         HostNotReachable: {
            (options?: vimService.vim.HostNotReachable): vimService.vim.HostNotReachable;
         };
         InvalidArgument: {
            (options?: vimService.vim.InvalidArgument): vimService.vim.InvalidArgument;
         };
         InvalidRequest: {
            (options?: vimService.vim.InvalidRequest): vimService.vim.InvalidRequest;
         };
         InvalidType: {
            (options?: vimService.vim.InvalidType): vimService.vim.InvalidType;
         };
         ManagedObjectNotFound: {
            (options?: vimService.vim.ManagedObjectNotFound): vimService.vim.ManagedObjectNotFound;
         };
         MethodNotFound: {
            (options?: vimService.vim.MethodNotFound): vimService.vim.MethodNotFound;
         };
         NotEnoughLicenses: {
            (options?: vimService.vim.NotEnoughLicenses): vimService.vim.NotEnoughLicenses;
         };
         NotImplemented: {
            (options?: vimService.vim.NotImplemented): vimService.vim.NotImplemented;
         };
         NotSupported: {
            (options?: vimService.vim.NotSupported): vimService.vim.NotSupported;
         };
         RequestCanceled: {
            (options?: vimService.vim.RequestCanceled): vimService.vim.RequestCanceled;
         };
         SecurityError: {
            (options?: vimService.vim.SecurityError): vimService.vim.SecurityError;
         };
         SystemError: {
            (options?: vimService.vim.SystemError): vimService.vim.SystemError;
         };
         UnexpectedFault: {
            (options?: vimService.vim.UnexpectedFault): vimService.vim.UnexpectedFault;
         };
         ManagedObjectReference: {
            (options?: vimService.vim.ManagedObjectReference): vimService.vim.ManagedObjectReference;
         };
         ArrayOfString: {
            (options?: vimService.vim.ArrayOfString): vimService.vim.ArrayOfString;
         };
         ArrayOfAnyType: {
            (options?: vimService.vim.ArrayOfAnyType): vimService.vim.ArrayOfAnyType;
         };
         ArrayOfAnyURI: {
            (options?: vimService.vim.ArrayOfAnyURI): vimService.vim.ArrayOfAnyURI;
         };
         ArrayOfManagedObjectReference: {
            (options?: vimService.vim.ArrayOfManagedObjectReference): vimService.vim.ArrayOfManagedObjectReference;
         };
         ArrayOfBoolean: {
            (options?: vimService.vim.ArrayOfBoolean): vimService.vim.ArrayOfBoolean;
         };
         ArrayOfByte: {
            (options?: vimService.vim.ArrayOfByte): vimService.vim.ArrayOfByte;
         };
         ArrayOfDouble: {
            (options?: vimService.vim.ArrayOfDouble): vimService.vim.ArrayOfDouble;
         };
         ArrayOfInt: {
            (options?: vimService.vim.ArrayOfInt): vimService.vim.ArrayOfInt;
         };
         ArrayOfLong: {
            (options?: vimService.vim.ArrayOfLong): vimService.vim.ArrayOfLong;
         };
         ArrayOfShort: {
            (options?: vimService.vim.ArrayOfShort): vimService.vim.ArrayOfShort;
         };
         InvalidCollectorVersion: {
            (options?: vimService.vim.InvalidCollectorVersion): vimService.vim.InvalidCollectorVersion;
         };
         InvalidProperty: {
            (options?: vimService.vim.InvalidProperty): vimService.vim.InvalidProperty;
         };
         PropertyFilterSpec: {
            (options?: vimService.vim.PropertyFilterSpec): vimService.vim.PropertyFilterSpec;
         };
         ArrayOfPropertyFilterSpec: {
            (options?: vimService.vim.ArrayOfPropertyFilterSpec): vimService.vim.ArrayOfPropertyFilterSpec;
         };
         PropertySpec: {
            (options?: vimService.vim.PropertySpec): vimService.vim.PropertySpec;
         };
         ArrayOfPropertySpec: {
            (options?: vimService.vim.ArrayOfPropertySpec): vimService.vim.ArrayOfPropertySpec;
         };
         ObjectSpec: {
            (options?: vimService.vim.ObjectSpec): vimService.vim.ObjectSpec;
         };
         ArrayOfObjectSpec: {
            (options?: vimService.vim.ArrayOfObjectSpec): vimService.vim.ArrayOfObjectSpec;
         };
         SelectionSpec: {
            (options?: vimService.vim.SelectionSpec): vimService.vim.SelectionSpec;
         };
         ArrayOfSelectionSpec: {
            (options?: vimService.vim.ArrayOfSelectionSpec): vimService.vim.ArrayOfSelectionSpec;
         };
         TraversalSpec: {
            (options?: vimService.vim.TraversalSpec): vimService.vim.TraversalSpec;
         };
         ObjectContent: {
            (options?: vimService.vim.ObjectContent): vimService.vim.ObjectContent;
         };
         ArrayOfObjectContent: {
            (options?: vimService.vim.ArrayOfObjectContent): vimService.vim.ArrayOfObjectContent;
         };
         UpdateSet: {
            (options?: vimService.vim.UpdateSet): vimService.vim.UpdateSet;
         };
         PropertyFilterUpdate: {
            (options?: vimService.vim.PropertyFilterUpdate): vimService.vim.PropertyFilterUpdate;
         };
         ArrayOfPropertyFilterUpdate: {
            (options?: vimService.vim.ArrayOfPropertyFilterUpdate): vimService.vim.ArrayOfPropertyFilterUpdate;
         };
         ObjectUpdateKind: {
            "modify": string;
            "enter": string;
            "leave": string;
         };
         ObjectUpdate: {
            (options?: vimService.vim.ObjectUpdate): vimService.vim.ObjectUpdate;
         };
         ArrayOfObjectUpdate: {
            (options?: vimService.vim.ArrayOfObjectUpdate): vimService.vim.ArrayOfObjectUpdate;
         };
         PropertyChangeOp: {
            "add": string;
            "remove": string;
            "assign": string;
            "indirectRemove": string;
         };
         PropertyChange: {
            (options?: vimService.vim.PropertyChange): vimService.vim.PropertyChange;
         };
         ArrayOfPropertyChange: {
            (options?: vimService.vim.ArrayOfPropertyChange): vimService.vim.ArrayOfPropertyChange;
         };
         MissingProperty: {
            (options?: vimService.vim.MissingProperty): vimService.vim.MissingProperty;
         };
         ArrayOfMissingProperty: {
            (options?: vimService.vim.ArrayOfMissingProperty): vimService.vim.ArrayOfMissingProperty;
         };
         MissingObject: {
            (options?: vimService.vim.MissingObject): vimService.vim.MissingObject;
         };
         ArrayOfMissingObject: {
            (options?: vimService.vim.ArrayOfMissingObject): vimService.vim.ArrayOfMissingObject;
         };
         WaitOptions: {
            (options?: vimService.vim.WaitOptions): vimService.vim.WaitOptions;
         };
         RetrieveOptions: {
            (options?: vimService.vim.RetrieveOptions): vimService.vim.RetrieveOptions;
         };
         RetrieveResult: {
            (options?: vimService.vim.RetrieveResult): vimService.vim.RetrieveResult;
         };
         AboutInfo: {
            (options?: vimService.vim.AboutInfo): vimService.vim.AboutInfo;
         };
         AuthorizationDescription: {
            (options?: vimService.vim.AuthorizationDescription): vimService.vim.AuthorizationDescription;
         };
         Permission: {
            (options?: vimService.vim.Permission): vimService.vim.Permission;
         };
         ArrayOfPermission: {
            (options?: vimService.vim.ArrayOfPermission): vimService.vim.ArrayOfPermission;
         };
         AuthorizationRole: {
            (options?: vimService.vim.AuthorizationRole): vimService.vim.AuthorizationRole;
         };
         ArrayOfAuthorizationRole: {
            (options?: vimService.vim.ArrayOfAuthorizationRole): vimService.vim.ArrayOfAuthorizationRole;
         };
         AuthorizationPrivilege: {
            (options?: vimService.vim.AuthorizationPrivilege): vimService.vim.AuthorizationPrivilege;
         };
         ArrayOfAuthorizationPrivilege: {
            (options?: vimService.vim.ArrayOfAuthorizationPrivilege): vimService.vim.ArrayOfAuthorizationPrivilege;
         };
         PrivilegeAvailability: {
            (options?: vimService.vim.PrivilegeAvailability): vimService.vim.PrivilegeAvailability;
         };
         ArrayOfPrivilegeAvailability: {
            (options?: vimService.vim.ArrayOfPrivilegeAvailability): vimService.vim.ArrayOfPrivilegeAvailability;
         };
         EntityPrivilege: {
            (options?: vimService.vim.EntityPrivilege): vimService.vim.EntityPrivilege;
         };
         ArrayOfEntityPrivilege: {
            (options?: vimService.vim.ArrayOfEntityPrivilege): vimService.vim.ArrayOfEntityPrivilege;
         };
         UserPrivilegeResult: {
            (options?: vimService.vim.UserPrivilegeResult): vimService.vim.UserPrivilegeResult;
         };
         ArrayOfUserPrivilegeResult: {
            (options?: vimService.vim.ArrayOfUserPrivilegeResult): vimService.vim.ArrayOfUserPrivilegeResult;
         };
         BatchResultResult: {
            "success": string;
            "fail": string;
         };
         BatchResult: {
            (options?: vimService.vim.BatchResult): vimService.vim.BatchResult;
         };
         BoolPolicy: {
            (options?: vimService.vim.BoolPolicy): vimService.vim.BoolPolicy;
         };
         Capability: {
            (options?: vimService.vim.Capability): vimService.vim.Capability;
         };
         ClusterComputeResourceSummary: {
            (options?: vimService.vim.ClusterComputeResourceSummary): vimService.vim.ClusterComputeResourceSummary;
         };
         ComputeResourceSummary: {
            (options?: vimService.vim.ComputeResourceSummary): vimService.vim.ComputeResourceSummary;
         };
         ComputeResourceConfigInfo: {
            (options?: vimService.vim.ComputeResourceConfigInfo): vimService.vim.ComputeResourceConfigInfo;
         };
         ComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState: {
            "licensed": string;
            "unlicensed": string;
            "unknown": string;
         };
         ComputeResourceHostSPBMLicenseInfo: {
            (options?: vimService.vim.ComputeResourceHostSPBMLicenseInfo): vimService.vim.ComputeResourceHostSPBMLicenseInfo;
         };
         ArrayOfComputeResourceHostSPBMLicenseInfo: {
            (options?: vimService.vim.ArrayOfComputeResourceHostSPBMLicenseInfo): vimService.vim.ArrayOfComputeResourceHostSPBMLicenseInfo;
         };
         ComputeResourceConfigSpec: {
            (options?: vimService.vim.ComputeResourceConfigSpec): vimService.vim.ComputeResourceConfigSpec;
         };
         ConfigSpecOperation: {
            "add": string;
            "edit": string;
            "remove": string;
         };
         CustomFieldDef: {
            (options?: vimService.vim.CustomFieldDef): vimService.vim.CustomFieldDef;
         };
         ArrayOfCustomFieldDef: {
            (options?: vimService.vim.ArrayOfCustomFieldDef): vimService.vim.ArrayOfCustomFieldDef;
         };
         CustomFieldValue: {
            (options?: vimService.vim.CustomFieldValue): vimService.vim.CustomFieldValue;
         };
         ArrayOfCustomFieldValue: {
            (options?: vimService.vim.ArrayOfCustomFieldValue): vimService.vim.ArrayOfCustomFieldValue;
         };
         CustomFieldStringValue: {
            (options?: vimService.vim.CustomFieldStringValue): vimService.vim.CustomFieldStringValue;
         };
         CustomizationSpecInfo: {
            (options?: vimService.vim.CustomizationSpecInfo): vimService.vim.CustomizationSpecInfo;
         };
         ArrayOfCustomizationSpecInfo: {
            (options?: vimService.vim.ArrayOfCustomizationSpecInfo): vimService.vim.ArrayOfCustomizationSpecInfo;
         };
         CustomizationSpecItem: {
            (options?: vimService.vim.CustomizationSpecItem): vimService.vim.CustomizationSpecItem;
         };
         DatacenterConfigInfo: {
            (options?: vimService.vim.DatacenterConfigInfo): vimService.vim.DatacenterConfigInfo;
         };
         DatacenterConfigSpec: {
            (options?: vimService.vim.DatacenterConfigSpec): vimService.vim.DatacenterConfigSpec;
         };
         DatastoreAccessible: {
            "True": string;
            "False": string;
         };
         DatastoreSummaryMaintenanceModeState: {
            "normal": string;
            "enteringMaintenance": string;
            "inMaintenance": string;
         };
         DatastoreSummary: {
            (options?: vimService.vim.DatastoreSummary): vimService.vim.DatastoreSummary;
         };
         DatastoreInfo: {
            (options?: vimService.vim.DatastoreInfo): vimService.vim.DatastoreInfo;
         };
         DatastoreCapability: {
            (options?: vimService.vim.DatastoreCapability): vimService.vim.DatastoreCapability;
         };
         DatastoreHostMount: {
            (options?: vimService.vim.DatastoreHostMount): vimService.vim.DatastoreHostMount;
         };
         ArrayOfDatastoreHostMount: {
            (options?: vimService.vim.ArrayOfDatastoreHostMount): vimService.vim.ArrayOfDatastoreHostMount;
         };
         DatastoreMountPathDatastorePair: {
            (options?: vimService.vim.DatastoreMountPathDatastorePair): vimService.vim.DatastoreMountPathDatastorePair;
         };
         ArrayOfDatastoreMountPathDatastorePair: {
            (options?: vimService.vim.ArrayOfDatastoreMountPathDatastorePair): vimService.vim.ArrayOfDatastoreMountPathDatastorePair;
         };
         DatastoreVVolContainerFailoverPair: {
            (options?: vimService.vim.DatastoreVVolContainerFailoverPair): vimService.vim.DatastoreVVolContainerFailoverPair;
         };
         ArrayOfDatastoreVVolContainerFailoverPair: {
            (options?: vimService.vim.ArrayOfDatastoreVVolContainerFailoverPair): vimService.vim.ArrayOfDatastoreVVolContainerFailoverPair;
         };
         Description: {
            (options?: vimService.vim.Description): vimService.vim.Description;
         };
         DiagnosticManagerLogCreator: {
            "vpxd": string;
            "vpxa": string;
            "hostd": string;
            "serverd": string;
            "install": string;
            "vpxClient": string;
            "recordLog": string;
         };
         DiagnosticManagerLogFormat: {
            "plain": string;
         };
         DiagnosticManagerLogDescriptor: {
            (options?: vimService.vim.DiagnosticManagerLogDescriptor): vimService.vim.DiagnosticManagerLogDescriptor;
         };
         ArrayOfDiagnosticManagerLogDescriptor: {
            (options?: vimService.vim.ArrayOfDiagnosticManagerLogDescriptor): vimService.vim.ArrayOfDiagnosticManagerLogDescriptor;
         };
         DiagnosticManagerLogHeader: {
            (options?: vimService.vim.DiagnosticManagerLogHeader): vimService.vim.DiagnosticManagerLogHeader;
         };
         DiagnosticManagerBundleInfo: {
            (options?: vimService.vim.DiagnosticManagerBundleInfo): vimService.vim.DiagnosticManagerBundleInfo;
         };
         ArrayOfDiagnosticManagerBundleInfo: {
            (options?: vimService.vim.ArrayOfDiagnosticManagerBundleInfo): vimService.vim.ArrayOfDiagnosticManagerBundleInfo;
         };
         DistributedVirtualSwitchProductSpecOperationType: {
            "preInstall": string;
            "upgrade": string;
            "notifyAvailableUpgrade": string;
            "proceedWithUpgrade": string;
            "updateBundleInfo": string;
         };
         DVSContactInfo: {
            (options?: vimService.vim.DVSContactInfo): vimService.vim.DVSContactInfo;
         };
         DistributedVirtualSwitchNicTeamingPolicyMode: {
            "loadbalance_ip": string;
            "loadbalance_srcmac": string;
            "loadbalance_srcid": string;
            "failover_explicit": string;
            "loadbalance_loadbased": string;
         };
         DVSNetworkResourceManagementCapability: {
            (options?: vimService.vim.DVSNetworkResourceManagementCapability): vimService.vim.DVSNetworkResourceManagementCapability;
         };
         DVSRollbackCapability: {
            (options?: vimService.vim.DVSRollbackCapability): vimService.vim.DVSRollbackCapability;
         };
         DVSBackupRestoreCapability: {
            (options?: vimService.vim.DVSBackupRestoreCapability): vimService.vim.DVSBackupRestoreCapability;
         };
         DVSFeatureCapability: {
            (options?: vimService.vim.DVSFeatureCapability): vimService.vim.DVSFeatureCapability;
         };
         DVSHealthCheckCapability: {
            (options?: vimService.vim.DVSHealthCheckCapability): vimService.vim.DVSHealthCheckCapability;
         };
         DVSCapability: {
            (options?: vimService.vim.DVSCapability): vimService.vim.DVSCapability;
         };
         DVSSummary: {
            (options?: vimService.vim.DVSSummary): vimService.vim.DVSSummary;
         };
         DVSPolicy: {
            (options?: vimService.vim.DVSPolicy): vimService.vim.DVSPolicy;
         };
         DVSUplinkPortPolicy: {
            (options?: vimService.vim.DVSUplinkPortPolicy): vimService.vim.DVSUplinkPortPolicy;
         };
         DVSNameArrayUplinkPortPolicy: {
            (options?: vimService.vim.DVSNameArrayUplinkPortPolicy): vimService.vim.DVSNameArrayUplinkPortPolicy;
         };
         DVSConfigSpec: {
            (options?: vimService.vim.DVSConfigSpec): vimService.vim.DVSConfigSpec;
         };
         DVSCreateSpec: {
            (options?: vimService.vim.DVSCreateSpec): vimService.vim.DVSCreateSpec;
         };
         DVSConfigInfo: {
            (options?: vimService.vim.DVSConfigInfo): vimService.vim.DVSConfigInfo;
         };
         DistributedVirtualSwitchNetworkResourceControlVersion: {
            "version2": string;
            "version3": string;
         };
         DistributedVirtualSwitchHostInfrastructureTrafficClass: {
            "management": string;
            "faultTolerance": string;
            "vmotion": string;
            "virtualMachine": string;
            "iSCSI": string;
            "nfs": string;
            "hbr": string;
            "vsan": string;
            "vdp": string;
         };
         DvsHostInfrastructureTrafficResourceAllocation: {
            (options?: vimService.vim.DvsHostInfrastructureTrafficResourceAllocation): vimService.vim.DvsHostInfrastructureTrafficResourceAllocation;
         };
         DvsHostInfrastructureTrafficResource: {
            (options?: vimService.vim.DvsHostInfrastructureTrafficResource): vimService.vim.DvsHostInfrastructureTrafficResource;
         };
         ArrayOfDvsHostInfrastructureTrafficResource: {
            (options?: vimService.vim.ArrayOfDvsHostInfrastructureTrafficResource): vimService.vim.ArrayOfDvsHostInfrastructureTrafficResource;
         };
         DVSHealthCheckConfig: {
            (options?: vimService.vim.DVSHealthCheckConfig): vimService.vim.DVSHealthCheckConfig;
         };
         ArrayOfDVSHealthCheckConfig: {
            (options?: vimService.vim.ArrayOfDVSHealthCheckConfig): vimService.vim.ArrayOfDVSHealthCheckConfig;
         };
         DvsResourceRuntimeInfo: {
            (options?: vimService.vim.DvsResourceRuntimeInfo): vimService.vim.DvsResourceRuntimeInfo;
         };
         DVSRuntimeInfo: {
            (options?: vimService.vim.DVSRuntimeInfo): vimService.vim.DVSRuntimeInfo;
         };
         DrsInjectorWorkloadCorrelationState: {
            "Correlated": string;
            "Uncorrelated": string;
         };
         EVCMode: {
            (options?: vimService.vim.EVCMode): vimService.vim.EVCMode;
         };
         ArrayOfEVCMode: {
            (options?: vimService.vim.ArrayOfEVCMode): vimService.vim.ArrayOfEVCMode;
         };
         ElementDescription: {
            (options?: vimService.vim.ElementDescription): vimService.vim.ElementDescription;
         };
         ArrayOfElementDescription: {
            (options?: vimService.vim.ArrayOfElementDescription): vimService.vim.ArrayOfElementDescription;
         };
         EnumDescription: {
            (options?: vimService.vim.EnumDescription): vimService.vim.EnumDescription;
         };
         ArrayOfEnumDescription: {
            (options?: vimService.vim.ArrayOfEnumDescription): vimService.vim.ArrayOfEnumDescription;
         };
         EnvironmentBrowserConfigOptionQuerySpec: {
            (options?: vimService.vim.EnvironmentBrowserConfigOptionQuerySpec): vimService.vim.EnvironmentBrowserConfigOptionQuerySpec;
         };
         ExtendedDescription: {
            (options?: vimService.vim.ExtendedDescription): vimService.vim.ExtendedDescription;
         };
         ExtendedElementDescription: {
            (options?: vimService.vim.ExtendedElementDescription): vimService.vim.ExtendedElementDescription;
         };
         ExtensionServerInfo: {
            (options?: vimService.vim.ExtensionServerInfo): vimService.vim.ExtensionServerInfo;
         };
         ArrayOfExtensionServerInfo: {
            (options?: vimService.vim.ArrayOfExtensionServerInfo): vimService.vim.ArrayOfExtensionServerInfo;
         };
         ExtensionClientInfo: {
            (options?: vimService.vim.ExtensionClientInfo): vimService.vim.ExtensionClientInfo;
         };
         ArrayOfExtensionClientInfo: {
            (options?: vimService.vim.ArrayOfExtensionClientInfo): vimService.vim.ArrayOfExtensionClientInfo;
         };
         ExtensionTaskTypeInfo: {
            (options?: vimService.vim.ExtensionTaskTypeInfo): vimService.vim.ExtensionTaskTypeInfo;
         };
         ArrayOfExtensionTaskTypeInfo: {
            (options?: vimService.vim.ArrayOfExtensionTaskTypeInfo): vimService.vim.ArrayOfExtensionTaskTypeInfo;
         };
         ExtensionEventTypeInfo: {
            (options?: vimService.vim.ExtensionEventTypeInfo): vimService.vim.ExtensionEventTypeInfo;
         };
         ArrayOfExtensionEventTypeInfo: {
            (options?: vimService.vim.ArrayOfExtensionEventTypeInfo): vimService.vim.ArrayOfExtensionEventTypeInfo;
         };
         ExtensionFaultTypeInfo: {
            (options?: vimService.vim.ExtensionFaultTypeInfo): vimService.vim.ExtensionFaultTypeInfo;
         };
         ArrayOfExtensionFaultTypeInfo: {
            (options?: vimService.vim.ArrayOfExtensionFaultTypeInfo): vimService.vim.ArrayOfExtensionFaultTypeInfo;
         };
         ExtensionPrivilegeInfo: {
            (options?: vimService.vim.ExtensionPrivilegeInfo): vimService.vim.ExtensionPrivilegeInfo;
         };
         ArrayOfExtensionPrivilegeInfo: {
            (options?: vimService.vim.ArrayOfExtensionPrivilegeInfo): vimService.vim.ArrayOfExtensionPrivilegeInfo;
         };
         ExtensionResourceInfo: {
            (options?: vimService.vim.ExtensionResourceInfo): vimService.vim.ExtensionResourceInfo;
         };
         ArrayOfExtensionResourceInfo: {
            (options?: vimService.vim.ArrayOfExtensionResourceInfo): vimService.vim.ArrayOfExtensionResourceInfo;
         };
         ExtensionHealthInfo: {
            (options?: vimService.vim.ExtensionHealthInfo): vimService.vim.ExtensionHealthInfo;
         };
         ExtensionOvfConsumerInfo: {
            (options?: vimService.vim.ExtensionOvfConsumerInfo): vimService.vim.ExtensionOvfConsumerInfo;
         };
         Extension: {
            (options?: vimService.vim.Extension): vimService.vim.Extension;
         };
         ArrayOfExtension: {
            (options?: vimService.vim.ArrayOfExtension): vimService.vim.ArrayOfExtension;
         };
         ExtensionManagerIpAllocationUsage: {
            (options?: vimService.vim.ExtensionManagerIpAllocationUsage): vimService.vim.ExtensionManagerIpAllocationUsage;
         };
         ArrayOfExtensionManagerIpAllocationUsage: {
            (options?: vimService.vim.ArrayOfExtensionManagerIpAllocationUsage): vimService.vim.ArrayOfExtensionManagerIpAllocationUsage;
         };
         ReplicationVmState: {
            "none": string;
            "paused": string;
            "syncing": string;
            "idle": string;
            "active": string;
            "error": string;
         };
         ReplicationVmProgressInfo: {
            (options?: vimService.vim.ReplicationVmProgressInfo): vimService.vim.ReplicationVmProgressInfo;
         };
         HbrManagerReplicationVmInfo: {
            (options?: vimService.vim.HbrManagerReplicationVmInfo): vimService.vim.HbrManagerReplicationVmInfo;
         };
         QuiesceMode: {
            "application": string;
            "filesystem": string;
            "none": string;
         };
         HbrManagerVmReplicationCapability: {
            (options?: vimService.vim.HbrManagerVmReplicationCapability): vimService.vim.HbrManagerVmReplicationCapability;
         };
         ArrayOfHbrManagerVmReplicationCapability: {
            (options?: vimService.vim.ArrayOfHbrManagerVmReplicationCapability): vimService.vim.ArrayOfHbrManagerVmReplicationCapability;
         };
         HealthUpdateInfoComponentType: {
            "Memory": string;
            "Power": string;
            "Fan": string;
            "Network": string;
            "Storage": string;
         };
         HealthUpdateInfo: {
            (options?: vimService.vim.HealthUpdateInfo): vimService.vim.HealthUpdateInfo;
         };
         ArrayOfHealthUpdateInfo: {
            (options?: vimService.vim.ArrayOfHealthUpdateInfo): vimService.vim.ArrayOfHealthUpdateInfo;
         };
         HealthUpdate: {
            (options?: vimService.vim.HealthUpdate): vimService.vim.HealthUpdate;
         };
         ArrayOfHealthUpdate: {
            (options?: vimService.vim.ArrayOfHealthUpdate): vimService.vim.ArrayOfHealthUpdate;
         };
         HostServiceTicket: {
            (options?: vimService.vim.HostServiceTicket): vimService.vim.HostServiceTicket;
         };
         HostSystemConnectionState: {
            "connected": string;
            "notResponding": string;
            "disconnected": string;
         };
         HostSystemPowerState: {
            "poweredOn": string;
            "poweredOff": string;
            "standBy": string;
            "unknown": string;
         };
         HostStandbyMode: {
            "entering": string;
            "exiting": string;
            "in": string;
            "none": string;
         };
         HostCryptoState: {
            "incapable": string;
            "prepared": string;
            "safe": string;
         };
         HostSystemReconnectSpec: {
            (options?: vimService.vim.HostSystemReconnectSpec): vimService.vim.HostSystemReconnectSpec;
         };
         HttpNfcLeaseState: {
            "initializing": string;
            "ready": string;
            "done": string;
            "error": string;
         };
         HttpNfcLeaseDatastoreLeaseInfo: {
            (options?: vimService.vim.HttpNfcLeaseDatastoreLeaseInfo): vimService.vim.HttpNfcLeaseDatastoreLeaseInfo;
         };
         ArrayOfHttpNfcLeaseDatastoreLeaseInfo: {
            (options?: vimService.vim.ArrayOfHttpNfcLeaseDatastoreLeaseInfo): vimService.vim.ArrayOfHttpNfcLeaseDatastoreLeaseInfo;
         };
         HttpNfcLeaseHostInfo: {
            (options?: vimService.vim.HttpNfcLeaseHostInfo): vimService.vim.HttpNfcLeaseHostInfo;
         };
         ArrayOfHttpNfcLeaseHostInfo: {
            (options?: vimService.vim.ArrayOfHttpNfcLeaseHostInfo): vimService.vim.ArrayOfHttpNfcLeaseHostInfo;
         };
         HttpNfcLeaseInfo: {
            (options?: vimService.vim.HttpNfcLeaseInfo): vimService.vim.HttpNfcLeaseInfo;
         };
         HttpNfcLeaseDeviceUrl: {
            (options?: vimService.vim.HttpNfcLeaseDeviceUrl): vimService.vim.HttpNfcLeaseDeviceUrl;
         };
         ArrayOfHttpNfcLeaseDeviceUrl: {
            (options?: vimService.vim.ArrayOfHttpNfcLeaseDeviceUrl): vimService.vim.ArrayOfHttpNfcLeaseDeviceUrl;
         };
         HttpNfcLeaseManifestEntry: {
            (options?: vimService.vim.HttpNfcLeaseManifestEntry): vimService.vim.HttpNfcLeaseManifestEntry;
         };
         ArrayOfHttpNfcLeaseManifestEntry: {
            (options?: vimService.vim.ArrayOfHttpNfcLeaseManifestEntry): vimService.vim.ArrayOfHttpNfcLeaseManifestEntry;
         };
         ImportSpec: {
            (options?: vimService.vim.ImportSpec): vimService.vim.ImportSpec;
         };
         ArrayOfImportSpec: {
            (options?: vimService.vim.ArrayOfImportSpec): vimService.vim.ArrayOfImportSpec;
         };
         InheritablePolicy: {
            (options?: vimService.vim.InheritablePolicy): vimService.vim.InheritablePolicy;
         };
         IntExpression: {
            (options?: vimService.vim.IntExpression): vimService.vim.IntExpression;
         };
         IntPolicy: {
            (options?: vimService.vim.IntPolicy): vimService.vim.IntPolicy;
         };
         IoFilterInfo: {
            (options?: vimService.vim.IoFilterInfo): vimService.vim.IoFilterInfo;
         };
         HostIoFilterInfo: {
            (options?: vimService.vim.HostIoFilterInfo): vimService.vim.HostIoFilterInfo;
         };
         ArrayOfHostIoFilterInfo: {
            (options?: vimService.vim.ArrayOfHostIoFilterInfo): vimService.vim.ArrayOfHostIoFilterInfo;
         };
         IoFilterOperation: {
            "install": string;
            "uninstall": string;
            "upgrade": string;
         };
         ClusterIoFilterInfo: {
            (options?: vimService.vim.ClusterIoFilterInfo): vimService.vim.ClusterIoFilterInfo;
         };
         ArrayOfClusterIoFilterInfo: {
            (options?: vimService.vim.ArrayOfClusterIoFilterInfo): vimService.vim.ArrayOfClusterIoFilterInfo;
         };
         IoFilterType: {
            "cache": string;
            "replication": string;
            "encryption": string;
            "compression": string;
            "inspection": string;
            "datastoreIoControl": string;
            "dataProvider": string;
         };
         IoFilterHostIssue: {
            (options?: vimService.vim.IoFilterHostIssue): vimService.vim.IoFilterHostIssue;
         };
         ArrayOfIoFilterHostIssue: {
            (options?: vimService.vim.ArrayOfIoFilterHostIssue): vimService.vim.ArrayOfIoFilterHostIssue;
         };
         IoFilterQueryIssueResult: {
            (options?: vimService.vim.IoFilterQueryIssueResult): vimService.vim.IoFilterQueryIssueResult;
         };
         IpAddress: {
            (options?: vimService.vim.IpAddress): vimService.vim.IpAddress;
         };
         IpPoolManagerIpAllocation: {
            (options?: vimService.vim.IpPoolManagerIpAllocation): vimService.vim.IpPoolManagerIpAllocation;
         };
         ArrayOfIpPoolManagerIpAllocation: {
            (options?: vimService.vim.ArrayOfIpPoolManagerIpAllocation): vimService.vim.ArrayOfIpPoolManagerIpAllocation;
         };
         IpRange: {
            (options?: vimService.vim.IpRange): vimService.vim.IpRange;
         };
         KeyValue: {
            (options?: vimService.vim.KeyValue): vimService.vim.KeyValue;
         };
         ArrayOfKeyValue: {
            (options?: vimService.vim.ArrayOfKeyValue): vimService.vim.ArrayOfKeyValue;
         };
         LatencySensitivitySensitivityLevel: {
            "low": string;
            "normal": string;
            "medium": string;
            "high": string;
            "custom": string;
         };
         LatencySensitivity: {
            (options?: vimService.vim.LatencySensitivity): vimService.vim.LatencySensitivity;
         };
         LicenseAssignmentManagerLicenseAssignment: {
            (options?: vimService.vim.LicenseAssignmentManagerLicenseAssignment): vimService.vim.LicenseAssignmentManagerLicenseAssignment;
         };
         ArrayOfLicenseAssignmentManagerLicenseAssignment: {
            (options?: vimService.vim.ArrayOfLicenseAssignmentManagerLicenseAssignment): vimService.vim.ArrayOfLicenseAssignmentManagerLicenseAssignment;
         };
         LicenseManagerState: {
            "initializing": string;
            "normal": string;
            "marginal": string;
            "fault": string;
         };
         LicenseManagerLicenseKey: {
            "esxFull": string;
            "esxVmtn": string;
            "esxExpress": string;
            "san": string;
            "iscsi": string;
            "nas": string;
            "vsmp": string;
            "backup": string;
            "vc": string;
            "vcExpress": string;
            "esxHost": string;
            "gsxHost": string;
            "serverHost": string;
            "drsPower": string;
            "vmotion": string;
            "drs": string;
            "das": string;
         };
         LicenseSource: {
            (options?: vimService.vim.LicenseSource): vimService.vim.LicenseSource;
         };
         LicenseServerSource: {
            (options?: vimService.vim.LicenseServerSource): vimService.vim.LicenseServerSource;
         };
         LocalLicenseSource: {
            (options?: vimService.vim.LocalLicenseSource): vimService.vim.LocalLicenseSource;
         };
         EvaluationLicenseSource: {
            (options?: vimService.vim.EvaluationLicenseSource): vimService.vim.EvaluationLicenseSource;
         };
         LicenseFeatureInfoUnit: {
            "host": string;
            "cpuCore": string;
            "cpuPackage": string;
            "server": string;
            "vm": string;
         };
         LicenseFeatureInfoState: {
            "enabled": string;
            "disabled": string;
            "optional": string;
         };
         LicenseFeatureInfoSourceRestriction: {
            "unrestricted": string;
            "served": string;
            "file": string;
         };
         LicenseFeatureInfo: {
            (options?: vimService.vim.LicenseFeatureInfo): vimService.vim.LicenseFeatureInfo;
         };
         ArrayOfLicenseFeatureInfo: {
            (options?: vimService.vim.ArrayOfLicenseFeatureInfo): vimService.vim.ArrayOfLicenseFeatureInfo;
         };
         LicenseReservationInfoState: {
            "notUsed": string;
            "noLicense": string;
            "unlicensedUse": string;
            "licensed": string;
         };
         LicenseReservationInfo: {
            (options?: vimService.vim.LicenseReservationInfo): vimService.vim.LicenseReservationInfo;
         };
         ArrayOfLicenseReservationInfo: {
            (options?: vimService.vim.ArrayOfLicenseReservationInfo): vimService.vim.ArrayOfLicenseReservationInfo;
         };
         LicenseAvailabilityInfo: {
            (options?: vimService.vim.LicenseAvailabilityInfo): vimService.vim.LicenseAvailabilityInfo;
         };
         ArrayOfLicenseAvailabilityInfo: {
            (options?: vimService.vim.ArrayOfLicenseAvailabilityInfo): vimService.vim.ArrayOfLicenseAvailabilityInfo;
         };
         LicenseDiagnostics: {
            (options?: vimService.vim.LicenseDiagnostics): vimService.vim.LicenseDiagnostics;
         };
         LicenseUsageInfo: {
            (options?: vimService.vim.LicenseUsageInfo): vimService.vim.LicenseUsageInfo;
         };
         LicenseManagerEvaluationInfo: {
            (options?: vimService.vim.LicenseManagerEvaluationInfo): vimService.vim.LicenseManagerEvaluationInfo;
         };
         HostLicensableResourceKey: {
            "numCpuPackages": string;
            "numCpuCores": string;
            "memorySize": string;
            "memoryForVms": string;
            "numVmsStarted": string;
            "numVmsStarting": string;
         };
         HostLicensableResourceInfo: {
            (options?: vimService.vim.HostLicensableResourceInfo): vimService.vim.HostLicensableResourceInfo;
         };
         LicenseManagerLicenseInfo: {
            (options?: vimService.vim.LicenseManagerLicenseInfo): vimService.vim.LicenseManagerLicenseInfo;
         };
         ArrayOfLicenseManagerLicenseInfo: {
            (options?: vimService.vim.ArrayOfLicenseManagerLicenseInfo): vimService.vim.ArrayOfLicenseManagerLicenseInfo;
         };
         LocalizationManagerMessageCatalog: {
            (options?: vimService.vim.LocalizationManagerMessageCatalog): vimService.vim.LocalizationManagerMessageCatalog;
         };
         ArrayOfLocalizationManagerMessageCatalog: {
            (options?: vimService.vim.ArrayOfLocalizationManagerMessageCatalog): vimService.vim.ArrayOfLocalizationManagerMessageCatalog;
         };
         LongPolicy: {
            (options?: vimService.vim.LongPolicy): vimService.vim.LongPolicy;
         };
         MacAddress: {
            (options?: vimService.vim.MacAddress): vimService.vim.MacAddress;
         };
         MacRange: {
            (options?: vimService.vim.MacRange): vimService.vim.MacRange;
         };
         ManagedEntityStatus: {
            "gray": string;
            "green": string;
            "yellow": string;
            "red": string;
         };
         MethodDescription: {
            (options?: vimService.vim.MethodDescription): vimService.vim.MethodDescription;
         };
         NegatableExpression: {
            (options?: vimService.vim.NegatableExpression): vimService.vim.NegatableExpression;
         };
         NetworkSummary: {
            (options?: vimService.vim.NetworkSummary): vimService.vim.NetworkSummary;
         };
         NumericRange: {
            (options?: vimService.vim.NumericRange): vimService.vim.NumericRange;
         };
         ArrayOfNumericRange: {
            (options?: vimService.vim.ArrayOfNumericRange): vimService.vim.ArrayOfNumericRange;
         };
         OpaqueNetworkSummary: {
            (options?: vimService.vim.OpaqueNetworkSummary): vimService.vim.OpaqueNetworkSummary;
         };
         OpaqueNetworkCapability: {
            (options?: vimService.vim.OpaqueNetworkCapability): vimService.vim.OpaqueNetworkCapability;
         };
         OvfConsumerOvfSection: {
            (options?: vimService.vim.OvfConsumerOvfSection): vimService.vim.OvfConsumerOvfSection;
         };
         ArrayOfOvfConsumerOvfSection: {
            (options?: vimService.vim.ArrayOfOvfConsumerOvfSection): vimService.vim.ArrayOfOvfConsumerOvfSection;
         };
         OvfConsumerOstNodeType: {
            "envelope": string;
            "virtualSystem": string;
            "virtualSystemCollection": string;
         };
         OvfConsumerOstNode: {
            (options?: vimService.vim.OvfConsumerOstNode): vimService.vim.OvfConsumerOstNode;
         };
         ArrayOfOvfConsumerOstNode: {
            (options?: vimService.vim.ArrayOfOvfConsumerOstNode): vimService.vim.ArrayOfOvfConsumerOstNode;
         };
         OvfOptionInfo: {
            (options?: vimService.vim.OvfOptionInfo): vimService.vim.OvfOptionInfo;
         };
         ArrayOfOvfOptionInfo: {
            (options?: vimService.vim.ArrayOfOvfOptionInfo): vimService.vim.ArrayOfOvfOptionInfo;
         };
         OvfDeploymentOption: {
            (options?: vimService.vim.OvfDeploymentOption): vimService.vim.OvfDeploymentOption;
         };
         ArrayOfOvfDeploymentOption: {
            (options?: vimService.vim.ArrayOfOvfDeploymentOption): vimService.vim.ArrayOfOvfDeploymentOption;
         };
         OvfManagerCommonParams: {
            (options?: vimService.vim.OvfManagerCommonParams): vimService.vim.OvfManagerCommonParams;
         };
         OvfValidateHostParams: {
            (options?: vimService.vim.OvfValidateHostParams): vimService.vim.OvfValidateHostParams;
         };
         OvfValidateHostResult: {
            (options?: vimService.vim.OvfValidateHostResult): vimService.vim.OvfValidateHostResult;
         };
         OvfParseDescriptorParams: {
            (options?: vimService.vim.OvfParseDescriptorParams): vimService.vim.OvfParseDescriptorParams;
         };
         OvfParseDescriptorResult: {
            (options?: vimService.vim.OvfParseDescriptorResult): vimService.vim.OvfParseDescriptorResult;
         };
         OvfNetworkInfo: {
            (options?: vimService.vim.OvfNetworkInfo): vimService.vim.OvfNetworkInfo;
         };
         ArrayOfOvfNetworkInfo: {
            (options?: vimService.vim.ArrayOfOvfNetworkInfo): vimService.vim.ArrayOfOvfNetworkInfo;
         };
         OvfCreateImportSpecParamsDiskProvisioningType: {
            "monolithicSparse": string;
            "monolithicFlat": string;
            "twoGbMaxExtentSparse": string;
            "twoGbMaxExtentFlat": string;
            "thin": string;
            "thick": string;
            "seSparse": string;
            "eagerZeroedThick": string;
            "sparse": string;
            "flat": string;
         };
         OvfCreateImportSpecParams: {
            (options?: vimService.vim.OvfCreateImportSpecParams): vimService.vim.OvfCreateImportSpecParams;
         };
         OvfResourceMap: {
            (options?: vimService.vim.OvfResourceMap): vimService.vim.OvfResourceMap;
         };
         ArrayOfOvfResourceMap: {
            (options?: vimService.vim.ArrayOfOvfResourceMap): vimService.vim.ArrayOfOvfResourceMap;
         };
         OvfNetworkMapping: {
            (options?: vimService.vim.OvfNetworkMapping): vimService.vim.OvfNetworkMapping;
         };
         ArrayOfOvfNetworkMapping: {
            (options?: vimService.vim.ArrayOfOvfNetworkMapping): vimService.vim.ArrayOfOvfNetworkMapping;
         };
         OvfCreateImportSpecResult: {
            (options?: vimService.vim.OvfCreateImportSpecResult): vimService.vim.OvfCreateImportSpecResult;
         };
         OvfFileItem: {
            (options?: vimService.vim.OvfFileItem): vimService.vim.OvfFileItem;
         };
         ArrayOfOvfFileItem: {
            (options?: vimService.vim.ArrayOfOvfFileItem): vimService.vim.ArrayOfOvfFileItem;
         };
         OvfCreateDescriptorParams: {
            (options?: vimService.vim.OvfCreateDescriptorParams): vimService.vim.OvfCreateDescriptorParams;
         };
         OvfCreateDescriptorResult: {
            (options?: vimService.vim.OvfCreateDescriptorResult): vimService.vim.OvfCreateDescriptorResult;
         };
         OvfFile: {
            (options?: vimService.vim.OvfFile): vimService.vim.OvfFile;
         };
         ArrayOfOvfFile: {
            (options?: vimService.vim.ArrayOfOvfFile): vimService.vim.ArrayOfOvfFile;
         };
         PasswordField: {
            (options?: vimService.vim.PasswordField): vimService.vim.PasswordField;
         };
         PerformanceDescription: {
            (options?: vimService.vim.PerformanceDescription): vimService.vim.PerformanceDescription;
         };
         PerfFormat: {
            "normal": string;
            "csv": string;
         };
         PerfProviderSummary: {
            (options?: vimService.vim.PerfProviderSummary): vimService.vim.PerfProviderSummary;
         };
         PerfSummaryType: {
            "average": string;
            "maximum": string;
            "minimum": string;
            "latest": string;
            "summation": string;
            "none": string;
         };
         PerfStatsType: {
            "absolute": string;
            "delta": string;
            "rate": string;
         };
         PerformanceManagerUnit: {
            "percent": string;
            "kiloBytes": string;
            "megaBytes": string;
            "megaHertz": string;
            "number": string;
            "microsecond": string;
            "millisecond": string;
            "second": string;
            "kiloBytesPerSecond": string;
            "megaBytesPerSecond": string;
            "watt": string;
            "joule": string;
            "teraBytes": string;
         };
         PerfCounterInfo: {
            (options?: vimService.vim.PerfCounterInfo): vimService.vim.PerfCounterInfo;
         };
         ArrayOfPerfCounterInfo: {
            (options?: vimService.vim.ArrayOfPerfCounterInfo): vimService.vim.ArrayOfPerfCounterInfo;
         };
         PerfMetricId: {
            (options?: vimService.vim.PerfMetricId): vimService.vim.PerfMetricId;
         };
         ArrayOfPerfMetricId: {
            (options?: vimService.vim.ArrayOfPerfMetricId): vimService.vim.ArrayOfPerfMetricId;
         };
         PerfQuerySpec: {
            (options?: vimService.vim.PerfQuerySpec): vimService.vim.PerfQuerySpec;
         };
         ArrayOfPerfQuerySpec: {
            (options?: vimService.vim.ArrayOfPerfQuerySpec): vimService.vim.ArrayOfPerfQuerySpec;
         };
         PerfSampleInfo: {
            (options?: vimService.vim.PerfSampleInfo): vimService.vim.PerfSampleInfo;
         };
         ArrayOfPerfSampleInfo: {
            (options?: vimService.vim.ArrayOfPerfSampleInfo): vimService.vim.ArrayOfPerfSampleInfo;
         };
         PerfMetricSeries: {
            (options?: vimService.vim.PerfMetricSeries): vimService.vim.PerfMetricSeries;
         };
         ArrayOfPerfMetricSeries: {
            (options?: vimService.vim.ArrayOfPerfMetricSeries): vimService.vim.ArrayOfPerfMetricSeries;
         };
         PerfMetricIntSeries: {
            (options?: vimService.vim.PerfMetricIntSeries): vimService.vim.PerfMetricIntSeries;
         };
         PerfMetricSeriesCSV: {
            (options?: vimService.vim.PerfMetricSeriesCSV): vimService.vim.PerfMetricSeriesCSV;
         };
         ArrayOfPerfMetricSeriesCSV: {
            (options?: vimService.vim.ArrayOfPerfMetricSeriesCSV): vimService.vim.ArrayOfPerfMetricSeriesCSV;
         };
         PerfEntityMetricBase: {
            (options?: vimService.vim.PerfEntityMetricBase): vimService.vim.PerfEntityMetricBase;
         };
         ArrayOfPerfEntityMetricBase: {
            (options?: vimService.vim.ArrayOfPerfEntityMetricBase): vimService.vim.ArrayOfPerfEntityMetricBase;
         };
         PerfEntityMetric: {
            (options?: vimService.vim.PerfEntityMetric): vimService.vim.PerfEntityMetric;
         };
         PerfEntityMetricCSV: {
            (options?: vimService.vim.PerfEntityMetricCSV): vimService.vim.PerfEntityMetricCSV;
         };
         PerfCompositeMetric: {
            (options?: vimService.vim.PerfCompositeMetric): vimService.vim.PerfCompositeMetric;
         };
         PerformanceManagerCounterLevelMapping: {
            (options?: vimService.vim.PerformanceManagerCounterLevelMapping): vimService.vim.PerformanceManagerCounterLevelMapping;
         };
         ArrayOfPerformanceManagerCounterLevelMapping: {
            (options?: vimService.vim.ArrayOfPerformanceManagerCounterLevelMapping): vimService.vim.ArrayOfPerformanceManagerCounterLevelMapping;
         };
         PerfInterval: {
            (options?: vimService.vim.PerfInterval): vimService.vim.PerfInterval;
         };
         ArrayOfPerfInterval: {
            (options?: vimService.vim.ArrayOfPerfInterval): vimService.vim.ArrayOfPerfInterval;
         };
         PosixUserSearchResult: {
            (options?: vimService.vim.PosixUserSearchResult): vimService.vim.PosixUserSearchResult;
         };
         PrivilegePolicyDef: {
            (options?: vimService.vim.PrivilegePolicyDef): vimService.vim.PrivilegePolicyDef;
         };
         ResourceAllocationInfo: {
            (options?: vimService.vim.ResourceAllocationInfo): vimService.vim.ResourceAllocationInfo;
         };
         ResourceAllocationOption: {
            (options?: vimService.vim.ResourceAllocationOption): vimService.vim.ResourceAllocationOption;
         };
         ResourceConfigOption: {
            (options?: vimService.vim.ResourceConfigOption): vimService.vim.ResourceConfigOption;
         };
         ResourceConfigSpec: {
            (options?: vimService.vim.ResourceConfigSpec): vimService.vim.ResourceConfigSpec;
         };
         ArrayOfResourceConfigSpec: {
            (options?: vimService.vim.ArrayOfResourceConfigSpec): vimService.vim.ArrayOfResourceConfigSpec;
         };
         DatabaseSizeParam: {
            (options?: vimService.vim.DatabaseSizeParam): vimService.vim.DatabaseSizeParam;
         };
         InventoryDescription: {
            (options?: vimService.vim.InventoryDescription): vimService.vim.InventoryDescription;
         };
         PerformanceStatisticsDescription: {
            (options?: vimService.vim.PerformanceStatisticsDescription): vimService.vim.PerformanceStatisticsDescription;
         };
         DatabaseSizeEstimate: {
            (options?: vimService.vim.DatabaseSizeEstimate): vimService.vim.DatabaseSizeEstimate;
         };
         ResourcePoolResourceUsage: {
            (options?: vimService.vim.ResourcePoolResourceUsage): vimService.vim.ResourcePoolResourceUsage;
         };
         ResourcePoolRuntimeInfo: {
            (options?: vimService.vim.ResourcePoolRuntimeInfo): vimService.vim.ResourcePoolRuntimeInfo;
         };
         ResourcePoolQuickStats: {
            (options?: vimService.vim.ResourcePoolQuickStats): vimService.vim.ResourcePoolQuickStats;
         };
         ResourcePoolSummary: {
            (options?: vimService.vim.ResourcePoolSummary): vimService.vim.ResourcePoolSummary;
         };
         SelectionSet: {
            (options?: vimService.vim.SelectionSet): vimService.vim.SelectionSet;
         };
         ArrayOfSelectionSet: {
            (options?: vimService.vim.ArrayOfSelectionSet): vimService.vim.ArrayOfSelectionSet;
         };
         ValidateMigrationTestType: {
            "sourceTests": string;
            "compatibilityTests": string;
            "diskAccessibilityTests": string;
            "resourceTests": string;
         };
         VMotionCompatibilityType: {
            "cpu": string;
            "software": string;
         };
         HostVMotionCompatibility: {
            (options?: vimService.vim.HostVMotionCompatibility): vimService.vim.HostVMotionCompatibility;
         };
         ArrayOfHostVMotionCompatibility: {
            (options?: vimService.vim.ArrayOfHostVMotionCompatibility): vimService.vim.ArrayOfHostVMotionCompatibility;
         };
         ProductComponentInfo: {
            (options?: vimService.vim.ProductComponentInfo): vimService.vim.ProductComponentInfo;
         };
         ArrayOfProductComponentInfo: {
            (options?: vimService.vim.ArrayOfProductComponentInfo): vimService.vim.ArrayOfProductComponentInfo;
         };
         ServiceContent: {
            (options?: vimService.vim.ServiceContent): vimService.vim.ServiceContent;
         };
         ServiceLocatorCredential: {
            (options?: vimService.vim.ServiceLocatorCredential): vimService.vim.ServiceLocatorCredential;
         };
         ServiceLocatorNamePassword: {
            (options?: vimService.vim.ServiceLocatorNamePassword): vimService.vim.ServiceLocatorNamePassword;
         };
         ServiceLocatorSAMLCredential: {
            (options?: vimService.vim.ServiceLocatorSAMLCredential): vimService.vim.ServiceLocatorSAMLCredential;
         };
         ServiceLocator: {
            (options?: vimService.vim.ServiceLocator): vimService.vim.ServiceLocator;
         };
         ArrayOfServiceLocator: {
            (options?: vimService.vim.ArrayOfServiceLocator): vimService.vim.ArrayOfServiceLocator;
         };
         ServiceManagerServiceInfo: {
            (options?: vimService.vim.ServiceManagerServiceInfo): vimService.vim.ServiceManagerServiceInfo;
         };
         ArrayOfServiceManagerServiceInfo: {
            (options?: vimService.vim.ArrayOfServiceManagerServiceInfo): vimService.vim.ArrayOfServiceManagerServiceInfo;
         };
         SessionManagerLocalTicket: {
            (options?: vimService.vim.SessionManagerLocalTicket): vimService.vim.SessionManagerLocalTicket;
         };
         SessionManagerGenericServiceTicket: {
            (options?: vimService.vim.SessionManagerGenericServiceTicket): vimService.vim.SessionManagerGenericServiceTicket;
         };
         SessionManagerServiceRequestSpec: {
            (options?: vimService.vim.SessionManagerServiceRequestSpec): vimService.vim.SessionManagerServiceRequestSpec;
         };
         SessionManagerVmomiServiceRequestSpec: {
            (options?: vimService.vim.SessionManagerVmomiServiceRequestSpec): vimService.vim.SessionManagerVmomiServiceRequestSpec;
         };
         SessionManagerHttpServiceRequestSpecMethod: {
            "httpOptions": string;
            "httpGet": string;
            "httpHead": string;
            "httpPost": string;
            "httpPut": string;
            "httpDelete": string;
            "httpTrace": string;
            "httpConnect": string;
         };
         SessionManagerHttpServiceRequestSpec: {
            (options?: vimService.vim.SessionManagerHttpServiceRequestSpec): vimService.vim.SessionManagerHttpServiceRequestSpec;
         };
         SharesLevel: {
            "low": string;
            "normal": string;
            "high": string;
            "custom": string;
         };
         SharesInfo: {
            (options?: vimService.vim.SharesInfo): vimService.vim.SharesInfo;
         };
         SharesOption: {
            (options?: vimService.vim.SharesOption): vimService.vim.SharesOption;
         };
         SimpleCommandEncoding: {
            "CSV": string;
            "HEX": string;
            "STRING": string;
         };
         SingleIp: {
            (options?: vimService.vim.SingleIp): vimService.vim.SingleIp;
         };
         SingleMac: {
            (options?: vimService.vim.SingleMac): vimService.vim.SingleMac;
         };
         StoragePodSummary: {
            (options?: vimService.vim.StoragePodSummary): vimService.vim.StoragePodSummary;
         };
         StorageIOAllocationInfo: {
            (options?: vimService.vim.StorageIOAllocationInfo): vimService.vim.StorageIOAllocationInfo;
         };
         StorageIOAllocationOption: {
            (options?: vimService.vim.StorageIOAllocationOption): vimService.vim.StorageIOAllocationOption;
         };
         StorageIORMThresholdMode: {
            "automatic": string;
            "manual": string;
         };
         StorageIORMInfo: {
            (options?: vimService.vim.StorageIORMInfo): vimService.vim.StorageIORMInfo;
         };
         StorageIORMConfigSpec: {
            (options?: vimService.vim.StorageIORMConfigSpec): vimService.vim.StorageIORMConfigSpec;
         };
         StorageIORMConfigOption: {
            (options?: vimService.vim.StorageIORMConfigOption): vimService.vim.StorageIORMConfigOption;
         };
         StoragePerformanceSummary: {
            (options?: vimService.vim.StoragePerformanceSummary): vimService.vim.StoragePerformanceSummary;
         };
         ArrayOfStoragePerformanceSummary: {
            (options?: vimService.vim.ArrayOfStoragePerformanceSummary): vimService.vim.ArrayOfStoragePerformanceSummary;
         };
         PodStorageDrsEntry: {
            (options?: vimService.vim.PodStorageDrsEntry): vimService.vim.PodStorageDrsEntry;
         };
         StorageResourceManagerStorageProfileStatistics: {
            (options?: vimService.vim.StorageResourceManagerStorageProfileStatistics): vimService.vim.StorageResourceManagerStorageProfileStatistics;
         };
         StringExpression: {
            (options?: vimService.vim.StringExpression): vimService.vim.StringExpression;
         };
         StringPolicy: {
            (options?: vimService.vim.StringPolicy): vimService.vim.StringPolicy;
         };
         Tag: {
            (options?: vimService.vim.Tag): vimService.vim.Tag;
         };
         ArrayOfTag: {
            (options?: vimService.vim.ArrayOfTag): vimService.vim.ArrayOfTag;
         };
         TaskDescription: {
            (options?: vimService.vim.TaskDescription): vimService.vim.TaskDescription;
         };
         TaskFilterSpecRecursionOption: {
            "self": string;
            "children": string;
            "all": string;
         };
         TaskFilterSpecTimeOption: {
            "queuedTime": string;
            "startedTime": string;
            "completedTime": string;
         };
         TaskFilterSpecByEntity: {
            (options?: vimService.vim.TaskFilterSpecByEntity): vimService.vim.TaskFilterSpecByEntity;
         };
         TaskFilterSpecByTime: {
            (options?: vimService.vim.TaskFilterSpecByTime): vimService.vim.TaskFilterSpecByTime;
         };
         TaskFilterSpecByUsername: {
            (options?: vimService.vim.TaskFilterSpecByUsername): vimService.vim.TaskFilterSpecByUsername;
         };
         TaskFilterSpec: {
            (options?: vimService.vim.TaskFilterSpec): vimService.vim.TaskFilterSpec;
         };
         TaskInfoState: {
            "queued": string;
            "running": string;
            "success": string;
            "error": string;
         };
         ArrayOfTaskInfoState: {
            (options?: vimService.vim.ArrayOfTaskInfoState): vimService.vim.ArrayOfTaskInfoState;
         };
         TaskInfo: {
            (options?: vimService.vim.TaskInfo): vimService.vim.TaskInfo;
         };
         ArrayOfTaskInfo: {
            (options?: vimService.vim.ArrayOfTaskInfo): vimService.vim.ArrayOfTaskInfo;
         };
         TaskReason: {
            (options?: vimService.vim.TaskReason): vimService.vim.TaskReason;
         };
         TaskReasonSystem: {
            (options?: vimService.vim.TaskReasonSystem): vimService.vim.TaskReasonSystem;
         };
         TaskReasonUser: {
            (options?: vimService.vim.TaskReasonUser): vimService.vim.TaskReasonUser;
         };
         TaskReasonAlarm: {
            (options?: vimService.vim.TaskReasonAlarm): vimService.vim.TaskReasonAlarm;
         };
         TaskReasonSchedule: {
            (options?: vimService.vim.TaskReasonSchedule): vimService.vim.TaskReasonSchedule;
         };
         TypeDescription: {
            (options?: vimService.vim.TypeDescription): vimService.vim.TypeDescription;
         };
         ArrayOfTypeDescription: {
            (options?: vimService.vim.ArrayOfTypeDescription): vimService.vim.ArrayOfTypeDescription;
         };
         UpdateVirtualMachineFilesResultFailedVmFileInfo: {
            (options?: vimService.vim.UpdateVirtualMachineFilesResultFailedVmFileInfo): vimService.vim.UpdateVirtualMachineFilesResultFailedVmFileInfo;
         };
         ArrayOfUpdateVirtualMachineFilesResultFailedVmFileInfo: {
            (options?: vimService.vim.ArrayOfUpdateVirtualMachineFilesResultFailedVmFileInfo): vimService.vim.ArrayOfUpdateVirtualMachineFilesResultFailedVmFileInfo;
         };
         UpdateVirtualMachineFilesResult: {
            (options?: vimService.vim.UpdateVirtualMachineFilesResult): vimService.vim.UpdateVirtualMachineFilesResult;
         };
         UserSearchResult: {
            (options?: vimService.vim.UserSearchResult): vimService.vim.UserSearchResult;
         };
         ArrayOfUserSearchResult: {
            (options?: vimService.vim.ArrayOfUserSearchResult): vimService.vim.ArrayOfUserSearchResult;
         };
         UserSession: {
            (options?: vimService.vim.UserSession): vimService.vim.UserSession;
         };
         ArrayOfUserSession: {
            (options?: vimService.vim.ArrayOfUserSession): vimService.vim.ArrayOfUserSession;
         };
         VrpResourceAllocationInfo: {
            (options?: vimService.vim.VrpResourceAllocationInfo): vimService.vim.VrpResourceAllocationInfo;
         };
         VirtualResourcePoolSpec: {
            (options?: vimService.vim.VirtualResourcePoolSpec): vimService.vim.VirtualResourcePoolSpec;
         };
         VRPEditSpec: {
            (options?: vimService.vim.VRPEditSpec): vimService.vim.VRPEditSpec;
         };
         VirtualResourcePoolUsage: {
            (options?: vimService.vim.VirtualResourcePoolUsage): vimService.vim.VirtualResourcePoolUsage;
         };
         VVolVmConfigFileUpdateResultFailedVmConfigFileInfo: {
            (options?: vimService.vim.VVolVmConfigFileUpdateResultFailedVmConfigFileInfo): vimService.vim.VVolVmConfigFileUpdateResultFailedVmConfigFileInfo;
         };
         ArrayOfVVolVmConfigFileUpdateResultFailedVmConfigFileInfo: {
            (options?: vimService.vim.ArrayOfVVolVmConfigFileUpdateResultFailedVmConfigFileInfo): vimService.vim.ArrayOfVVolVmConfigFileUpdateResultFailedVmConfigFileInfo;
         };
         VVolVmConfigFileUpdateResult: {
            (options?: vimService.vim.VVolVmConfigFileUpdateResult): vimService.vim.VVolVmConfigFileUpdateResult;
         };
         VASAStorageArray: {
            (options?: vimService.vim.VASAStorageArray): vimService.vim.VASAStorageArray;
         };
         ArrayOfVASAStorageArray: {
            (options?: vimService.vim.ArrayOfVASAStorageArray): vimService.vim.ArrayOfVASAStorageArray;
         };
         VasaProviderContainerSpec: {
            (options?: vimService.vim.VasaProviderContainerSpec): vimService.vim.VasaProviderContainerSpec;
         };
         VimVasaProviderStatePerArray: {
            (options?: vimService.vim.VimVasaProviderStatePerArray): vimService.vim.VimVasaProviderStatePerArray;
         };
         ArrayOfVimVasaProviderStatePerArray: {
            (options?: vimService.vim.ArrayOfVimVasaProviderStatePerArray): vimService.vim.ArrayOfVimVasaProviderStatePerArray;
         };
         VimVasaProvider: {
            (options?: vimService.vim.VimVasaProvider): vimService.vim.VimVasaProvider;
         };
         VimVasaProviderInfo: {
            (options?: vimService.vim.VimVasaProviderInfo): vimService.vim.VimVasaProviderInfo;
         };
         ArrayOfVimVasaProviderInfo: {
            (options?: vimService.vim.ArrayOfVimVasaProviderInfo): vimService.vim.ArrayOfVimVasaProviderInfo;
         };
         VirtualAppVAppState: {
            "started": string;
            "stopped": string;
            "starting": string;
            "stopping": string;
         };
         VirtualAppSummary: {
            (options?: vimService.vim.VirtualAppSummary): vimService.vim.VirtualAppSummary;
         };
         VirtualAppLinkInfo: {
            (options?: vimService.vim.VirtualAppLinkInfo): vimService.vim.VirtualAppLinkInfo;
         };
         ArrayOfVirtualAppLinkInfo: {
            (options?: vimService.vim.ArrayOfVirtualAppLinkInfo): vimService.vim.ArrayOfVirtualAppLinkInfo;
         };
         VirtualDiskType: {
            "preallocated": string;
            "thin": string;
            "seSparse": string;
            "rdm": string;
            "rdmp": string;
            "raw": string;
            "delta": string;
            "sparse2Gb": string;
            "thick2Gb": string;
            "eagerZeroedThick": string;
            "sparseMonolithic": string;
            "flatMonolithic": string;
            "thick": string;
         };
         VirtualDiskAdapterType: {
            "ide": string;
            "busLogic": string;
            "lsiLogic": string;
         };
         VirtualDiskSpec: {
            (options?: vimService.vim.VirtualDiskSpec): vimService.vim.VirtualDiskSpec;
         };
         FileBackedVirtualDiskSpec: {
            (options?: vimService.vim.FileBackedVirtualDiskSpec): vimService.vim.FileBackedVirtualDiskSpec;
         };
         SeSparseVirtualDiskSpec: {
            (options?: vimService.vim.SeSparseVirtualDiskSpec): vimService.vim.SeSparseVirtualDiskSpec;
         };
         DeviceBackedVirtualDiskSpec: {
            (options?: vimService.vim.DeviceBackedVirtualDiskSpec): vimService.vim.DeviceBackedVirtualDiskSpec;
         };
         StorageRequirement: {
            (options?: vimService.vim.StorageRequirement): vimService.vim.StorageRequirement;
         };
         ArrayOfStorageRequirement: {
            (options?: vimService.vim.ArrayOfStorageRequirement): vimService.vim.ArrayOfStorageRequirement;
         };
         VirtualMachinePowerState: {
            "poweredOff": string;
            "poweredOn": string;
            "suspended": string;
         };
         VirtualMachineAppHeartbeatStatusType: {
            "appStatusGray": string;
            "appStatusGreen": string;
            "appStatusRed": string;
         };
         VirtualMachineConnectionState: {
            "connected": string;
            "disconnected": string;
            "orphaned": string;
            "inaccessible": string;
            "invalid": string;
         };
         VirtualMachineMovePriority: {
            "lowPriority": string;
            "highPriority": string;
            "defaultPriority": string;
         };
         VirtualMachineTicket: {
            (options?: vimService.vim.VirtualMachineTicket): vimService.vim.VirtualMachineTicket;
         };
         VirtualMachineMksTicket: {
            (options?: vimService.vim.VirtualMachineMksTicket): vimService.vim.VirtualMachineMksTicket;
         };
         VirtualMachineFaultToleranceState: {
            "notConfigured": string;
            "disabled": string;
            "enabled": string;
            "needSecondary": string;
            "starting": string;
            "running": string;
         };
         VirtualMachineRecordReplayState: {
            "recording": string;
            "replaying": string;
            "inactive": string;
         };
         VirtualMachineNeedSecondaryReason: {
            "initializing": string;
            "divergence": string;
            "lostConnection": string;
            "partialHardwareFailure": string;
            "userAction": string;
            "checkpointError": string;
            "other": string;
         };
         VirtualMachineFaultToleranceType: {
            "unset": string;
            "recordReplay": string;
            "checkpointing": string;
         };
         VirtualMachineTicketType: {
            "mks": string;
            "device": string;
            "guestControl": string;
            "webmks": string;
         };
         VirtualMachineDisplayTopology: {
            (options?: vimService.vim.VirtualMachineDisplayTopology): vimService.vim.VirtualMachineDisplayTopology;
         };
         ArrayOfVirtualMachineDisplayTopology: {
            (options?: vimService.vim.ArrayOfVirtualMachineDisplayTopology): vimService.vim.ArrayOfVirtualMachineDisplayTopology;
         };
         DiskChangeExtent: {
            (options?: vimService.vim.DiskChangeExtent): vimService.vim.DiskChangeExtent;
         };
         ArrayOfDiskChangeExtent: {
            (options?: vimService.vim.ArrayOfDiskChangeExtent): vimService.vim.ArrayOfDiskChangeExtent;
         };
         DiskChangeInfo: {
            (options?: vimService.vim.DiskChangeInfo): vimService.vim.DiskChangeInfo;
         };
         VirtualMachineWipeResult: {
            (options?: vimService.vim.VirtualMachineWipeResult): vimService.vim.VirtualMachineWipeResult;
         };
         VsanUpgradeSystemPreflightCheckIssue: {
            (options?: vimService.vim.VsanUpgradeSystemPreflightCheckIssue): vimService.vim.VsanUpgradeSystemPreflightCheckIssue;
         };
         ArrayOfVsanUpgradeSystemPreflightCheckIssue: {
            (options?: vimService.vim.ArrayOfVsanUpgradeSystemPreflightCheckIssue): vimService.vim.ArrayOfVsanUpgradeSystemPreflightCheckIssue;
         };
         VsanUpgradeSystemHostsDisconnectedIssue: {
            (options?: vimService.vim.VsanUpgradeSystemHostsDisconnectedIssue): vimService.vim.VsanUpgradeSystemHostsDisconnectedIssue;
         };
         VsanUpgradeSystemMissingHostsInClusterIssue: {
            (options?: vimService.vim.VsanUpgradeSystemMissingHostsInClusterIssue): vimService.vim.VsanUpgradeSystemMissingHostsInClusterIssue;
         };
         VsanUpgradeSystemRogueHostsInClusterIssue: {
            (options?: vimService.vim.VsanUpgradeSystemRogueHostsInClusterIssue): vimService.vim.VsanUpgradeSystemRogueHostsInClusterIssue;
         };
         VsanUpgradeSystemWrongEsxVersionIssue: {
            (options?: vimService.vim.VsanUpgradeSystemWrongEsxVersionIssue): vimService.vim.VsanUpgradeSystemWrongEsxVersionIssue;
         };
         VsanUpgradeSystemAutoClaimEnabledOnHostsIssue: {
            (options?: vimService.vim.VsanUpgradeSystemAutoClaimEnabledOnHostsIssue): vimService.vim.VsanUpgradeSystemAutoClaimEnabledOnHostsIssue;
         };
         VsanUpgradeSystemAPIBrokenIssue: {
            (options?: vimService.vim.VsanUpgradeSystemAPIBrokenIssue): vimService.vim.VsanUpgradeSystemAPIBrokenIssue;
         };
         VsanUpgradeSystemV2ObjectsPresentDuringDowngradeIssue: {
            (options?: vimService.vim.VsanUpgradeSystemV2ObjectsPresentDuringDowngradeIssue): vimService.vim.VsanUpgradeSystemV2ObjectsPresentDuringDowngradeIssue;
         };
         VsanUpgradeSystemNotEnoughFreeCapacityIssue: {
            (options?: vimService.vim.VsanUpgradeSystemNotEnoughFreeCapacityIssue): vimService.vim.VsanUpgradeSystemNotEnoughFreeCapacityIssue;
         };
         VsanUpgradeSystemNetworkPartitionInfo: {
            (options?: vimService.vim.VsanUpgradeSystemNetworkPartitionInfo): vimService.vim.VsanUpgradeSystemNetworkPartitionInfo;
         };
         ArrayOfVsanUpgradeSystemNetworkPartitionInfo: {
            (options?: vimService.vim.ArrayOfVsanUpgradeSystemNetworkPartitionInfo): vimService.vim.ArrayOfVsanUpgradeSystemNetworkPartitionInfo;
         };
         VsanUpgradeSystemNetworkPartitionIssue: {
            (options?: vimService.vim.VsanUpgradeSystemNetworkPartitionIssue): vimService.vim.VsanUpgradeSystemNetworkPartitionIssue;
         };
         VsanUpgradeSystemPreflightCheckResult: {
            (options?: vimService.vim.VsanUpgradeSystemPreflightCheckResult): vimService.vim.VsanUpgradeSystemPreflightCheckResult;
         };
         VsanUpgradeSystemUpgradeHistoryItem: {
            (options?: vimService.vim.VsanUpgradeSystemUpgradeHistoryItem): vimService.vim.VsanUpgradeSystemUpgradeHistoryItem;
         };
         ArrayOfVsanUpgradeSystemUpgradeHistoryItem: {
            (options?: vimService.vim.ArrayOfVsanUpgradeSystemUpgradeHistoryItem): vimService.vim.ArrayOfVsanUpgradeSystemUpgradeHistoryItem;
         };
         VsanUpgradeSystemUpgradeHistoryDiskGroupOpType: {
            "add": string;
            "remove": string;
         };
         VsanUpgradeSystemUpgradeHistoryDiskGroupOp: {
            (options?: vimService.vim.VsanUpgradeSystemUpgradeHistoryDiskGroupOp): vimService.vim.VsanUpgradeSystemUpgradeHistoryDiskGroupOp;
         };
         VsanUpgradeSystemUpgradeHistoryPreflightFail: {
            (options?: vimService.vim.VsanUpgradeSystemUpgradeHistoryPreflightFail): vimService.vim.VsanUpgradeSystemUpgradeHistoryPreflightFail;
         };
         VsanUpgradeSystemUpgradeStatus: {
            (options?: vimService.vim.VsanUpgradeSystemUpgradeStatus): vimService.vim.VsanUpgradeSystemUpgradeStatus;
         };
         ActionParameter: {
            "targetName": string;
            "alarmName": string;
            "oldStatus": string;
            "newStatus": string;
            "triggeringSummary": string;
            "declaringSummary": string;
            "eventDescription": string;
            "target": string;
            "alarm": string;
         };
         Action: {
            (options?: vimService.vim.Action): vimService.vim.Action;
         };
         MethodActionArgument: {
            (options?: vimService.vim.MethodActionArgument): vimService.vim.MethodActionArgument;
         };
         ArrayOfMethodActionArgument: {
            (options?: vimService.vim.ArrayOfMethodActionArgument): vimService.vim.ArrayOfMethodActionArgument;
         };
         MethodAction: {
            (options?: vimService.vim.MethodAction): vimService.vim.MethodAction;
         };
         SendEmailAction: {
            (options?: vimService.vim.SendEmailAction): vimService.vim.SendEmailAction;
         };
         SendSNMPAction: {
            (options?: vimService.vim.SendSNMPAction): vimService.vim.SendSNMPAction;
         };
         RunScriptAction: {
            (options?: vimService.vim.RunScriptAction): vimService.vim.RunScriptAction;
         };
         CreateTaskAction: {
            (options?: vimService.vim.CreateTaskAction): vimService.vim.CreateTaskAction;
         };
         AlarmAction: {
            (options?: vimService.vim.AlarmAction): vimService.vim.AlarmAction;
         };
         ArrayOfAlarmAction: {
            (options?: vimService.vim.ArrayOfAlarmAction): vimService.vim.ArrayOfAlarmAction;
         };
         AlarmTriggeringActionTransitionSpec: {
            (options?: vimService.vim.AlarmTriggeringActionTransitionSpec): vimService.vim.AlarmTriggeringActionTransitionSpec;
         };
         ArrayOfAlarmTriggeringActionTransitionSpec: {
            (options?: vimService.vim.ArrayOfAlarmTriggeringActionTransitionSpec): vimService.vim.ArrayOfAlarmTriggeringActionTransitionSpec;
         };
         AlarmTriggeringAction: {
            (options?: vimService.vim.AlarmTriggeringAction): vimService.vim.AlarmTriggeringAction;
         };
         GroupAlarmAction: {
            (options?: vimService.vim.GroupAlarmAction): vimService.vim.GroupAlarmAction;
         };
         AlarmDescription: {
            (options?: vimService.vim.AlarmDescription): vimService.vim.AlarmDescription;
         };
         AlarmExpression: {
            (options?: vimService.vim.AlarmExpression): vimService.vim.AlarmExpression;
         };
         ArrayOfAlarmExpression: {
            (options?: vimService.vim.ArrayOfAlarmExpression): vimService.vim.ArrayOfAlarmExpression;
         };
         AndAlarmExpression: {
            (options?: vimService.vim.AndAlarmExpression): vimService.vim.AndAlarmExpression;
         };
         OrAlarmExpression: {
            (options?: vimService.vim.OrAlarmExpression): vimService.vim.OrAlarmExpression;
         };
         StateAlarmOperator: {
            "isEqual": string;
            "isUnequal": string;
         };
         StateAlarmExpression: {
            (options?: vimService.vim.StateAlarmExpression): vimService.vim.StateAlarmExpression;
         };
         EventAlarmExpressionComparisonOperator: {
            "equals": string;
            "notEqualTo": string;
            "startsWith": string;
            "doesNotStartWith": string;
            "endsWith": string;
            "doesNotEndWith": string;
         };
         EventAlarmExpressionComparison: {
            (options?: vimService.vim.EventAlarmExpressionComparison): vimService.vim.EventAlarmExpressionComparison;
         };
         ArrayOfEventAlarmExpressionComparison: {
            (options?: vimService.vim.ArrayOfEventAlarmExpressionComparison): vimService.vim.ArrayOfEventAlarmExpressionComparison;
         };
         EventAlarmExpression: {
            (options?: vimService.vim.EventAlarmExpression): vimService.vim.EventAlarmExpression;
         };
         MetricAlarmOperator: {
            "isAbove": string;
            "isBelow": string;
         };
         MetricAlarmExpression: {
            (options?: vimService.vim.MetricAlarmExpression): vimService.vim.MetricAlarmExpression;
         };
         AlarmInfo: {
            (options?: vimService.vim.AlarmInfo): vimService.vim.AlarmInfo;
         };
         AlarmSetting: {
            (options?: vimService.vim.AlarmSetting): vimService.vim.AlarmSetting;
         };
         AlarmSpec: {
            (options?: vimService.vim.AlarmSpec): vimService.vim.AlarmSpec;
         };
         AlarmState: {
            (options?: vimService.vim.AlarmState): vimService.vim.AlarmState;
         };
         ArrayOfAlarmState: {
            (options?: vimService.vim.ArrayOfAlarmState): vimService.vim.ArrayOfAlarmState;
         };
         ActionType: {
            "MigrationV1": string;
            "VmPowerV1": string;
            "HostPowerV1": string;
            "HostMaintenanceV1": string;
            "StorageMigrationV1": string;
            "StoragePlacementV1": string;
            "PlacementV1": string;
            "HostInfraUpdateHaV1": string;
         };
         ClusterAction: {
            (options?: vimService.vim.ClusterAction): vimService.vim.ClusterAction;
         };
         ArrayOfClusterAction: {
            (options?: vimService.vim.ArrayOfClusterAction): vimService.vim.ArrayOfClusterAction;
         };
         ClusterActionHistory: {
            (options?: vimService.vim.ClusterActionHistory): vimService.vim.ClusterActionHistory;
         };
         ArrayOfClusterActionHistory: {
            (options?: vimService.vim.ArrayOfClusterActionHistory): vimService.vim.ArrayOfClusterActionHistory;
         };
         ClusterAffinityRuleSpec: {
            (options?: vimService.vim.ClusterAffinityRuleSpec): vimService.vim.ClusterAffinityRuleSpec;
         };
         ClusterAntiAffinityRuleSpec: {
            (options?: vimService.vim.ClusterAntiAffinityRuleSpec): vimService.vim.ClusterAntiAffinityRuleSpec;
         };
         ClusterAttemptedVmInfo: {
            (options?: vimService.vim.ClusterAttemptedVmInfo): vimService.vim.ClusterAttemptedVmInfo;
         };
         ArrayOfClusterAttemptedVmInfo: {
            (options?: vimService.vim.ArrayOfClusterAttemptedVmInfo): vimService.vim.ArrayOfClusterAttemptedVmInfo;
         };
         ClusterConfigInfo: {
            (options?: vimService.vim.ClusterConfigInfo): vimService.vim.ClusterConfigInfo;
         };
         DrsBehavior: {
            "manual": string;
            "partiallyAutomated": string;
            "fullyAutomated": string;
         };
         ClusterDrsConfigInfo: {
            (options?: vimService.vim.ClusterDrsConfigInfo): vimService.vim.ClusterDrsConfigInfo;
         };
         ClusterDrsVmConfigInfo: {
            (options?: vimService.vim.ClusterDrsVmConfigInfo): vimService.vim.ClusterDrsVmConfigInfo;
         };
         ArrayOfClusterDrsVmConfigInfo: {
            (options?: vimService.vim.ArrayOfClusterDrsVmConfigInfo): vimService.vim.ArrayOfClusterDrsVmConfigInfo;
         };
         ClusterConfigInfoEx: {
            (options?: vimService.vim.ClusterConfigInfoEx): vimService.vim.ClusterConfigInfoEx;
         };
         DpmBehavior: {
            "manual": string;
            "automated": string;
         };
         ClusterDpmConfigInfo: {
            (options?: vimService.vim.ClusterDpmConfigInfo): vimService.vim.ClusterDpmConfigInfo;
         };
         ClusterDpmHostConfigInfo: {
            (options?: vimService.vim.ClusterDpmHostConfigInfo): vimService.vim.ClusterDpmHostConfigInfo;
         };
         ArrayOfClusterDpmHostConfigInfo: {
            (options?: vimService.vim.ArrayOfClusterDpmHostConfigInfo): vimService.vim.ArrayOfClusterDpmHostConfigInfo;
         };
         ClusterInfraUpdateHaConfigInfoBehaviorType: {
            "Manual": string;
            "Automated": string;
         };
         ClusterInfraUpdateHaConfigInfoRemediationType: {
            "QuarantineMode": string;
            "MaintenanceMode": string;
         };
         ClusterInfraUpdateHaConfigInfo: {
            (options?: vimService.vim.ClusterInfraUpdateHaConfigInfo): vimService.vim.ClusterInfraUpdateHaConfigInfo;
         };
         ClusterProactiveDrsConfigInfo: {
            (options?: vimService.vim.ClusterProactiveDrsConfigInfo): vimService.vim.ClusterProactiveDrsConfigInfo;
         };
         ClusterConfigSpec: {
            (options?: vimService.vim.ClusterConfigSpec): vimService.vim.ClusterConfigSpec;
         };
         ClusterDasVmConfigSpec: {
            (options?: vimService.vim.ClusterDasVmConfigSpec): vimService.vim.ClusterDasVmConfigSpec;
         };
         ArrayOfClusterDasVmConfigSpec: {
            (options?: vimService.vim.ArrayOfClusterDasVmConfigSpec): vimService.vim.ArrayOfClusterDasVmConfigSpec;
         };
         ClusterDrsVmConfigSpec: {
            (options?: vimService.vim.ClusterDrsVmConfigSpec): vimService.vim.ClusterDrsVmConfigSpec;
         };
         ArrayOfClusterDrsVmConfigSpec: {
            (options?: vimService.vim.ArrayOfClusterDrsVmConfigSpec): vimService.vim.ArrayOfClusterDrsVmConfigSpec;
         };
         ClusterConfigSpecEx: {
            (options?: vimService.vim.ClusterConfigSpecEx): vimService.vim.ClusterConfigSpecEx;
         };
         ClusterDpmHostConfigSpec: {
            (options?: vimService.vim.ClusterDpmHostConfigSpec): vimService.vim.ClusterDpmHostConfigSpec;
         };
         ArrayOfClusterDpmHostConfigSpec: {
            (options?: vimService.vim.ArrayOfClusterDpmHostConfigSpec): vimService.vim.ArrayOfClusterDpmHostConfigSpec;
         };
         ClusterGroupSpec: {
            (options?: vimService.vim.ClusterGroupSpec): vimService.vim.ClusterGroupSpec;
         };
         ArrayOfClusterGroupSpec: {
            (options?: vimService.vim.ArrayOfClusterGroupSpec): vimService.vim.ArrayOfClusterGroupSpec;
         };
         ClusterVmOrchestrationSpec: {
            (options?: vimService.vim.ClusterVmOrchestrationSpec): vimService.vim.ClusterVmOrchestrationSpec;
         };
         ArrayOfClusterVmOrchestrationSpec: {
            (options?: vimService.vim.ArrayOfClusterVmOrchestrationSpec): vimService.vim.ArrayOfClusterVmOrchestrationSpec;
         };
         ClusterDasAamHostInfo: {
            (options?: vimService.vim.ClusterDasAamHostInfo): vimService.vim.ClusterDasAamHostInfo;
         };
         ClusterDasAamNodeStateDasState: {
            "uninitialized": string;
            "initialized": string;
            "configuring": string;
            "unconfiguring": string;
            "running": string;
            "error": string;
            "agentShutdown": string;
            "nodeFailed": string;
         };
         ClusterDasAamNodeState: {
            (options?: vimService.vim.ClusterDasAamNodeState): vimService.vim.ClusterDasAamNodeState;
         };
         ArrayOfClusterDasAamNodeState: {
            (options?: vimService.vim.ArrayOfClusterDasAamNodeState): vimService.vim.ArrayOfClusterDasAamNodeState;
         };
         ClusterDasAdmissionControlInfo: {
            (options?: vimService.vim.ClusterDasAdmissionControlInfo): vimService.vim.ClusterDasAdmissionControlInfo;
         };
         ClusterDasAdmissionControlPolicy: {
            (options?: vimService.vim.ClusterDasAdmissionControlPolicy): vimService.vim.ClusterDasAdmissionControlPolicy;
         };
         ClusterDasAdvancedRuntimeInfoVmcpCapabilityInfo: {
            (options?: vimService.vim.ClusterDasAdvancedRuntimeInfoVmcpCapabilityInfo): vimService.vim.ClusterDasAdvancedRuntimeInfoVmcpCapabilityInfo;
         };
         DasHeartbeatDatastoreInfo: {
            (options?: vimService.vim.DasHeartbeatDatastoreInfo): vimService.vim.DasHeartbeatDatastoreInfo;
         };
         ArrayOfDasHeartbeatDatastoreInfo: {
            (options?: vimService.vim.ArrayOfDasHeartbeatDatastoreInfo): vimService.vim.ArrayOfDasHeartbeatDatastoreInfo;
         };
         ClusterDasAdvancedRuntimeInfo: {
            (options?: vimService.vim.ClusterDasAdvancedRuntimeInfo): vimService.vim.ClusterDasAdvancedRuntimeInfo;
         };
         ClusterDasConfigInfoServiceState: {
            "disabled": string;
            "enabled": string;
         };
         ClusterDasConfigInfoVmMonitoringState: {
            "vmMonitoringDisabled": string;
            "vmMonitoringOnly": string;
            "vmAndAppMonitoring": string;
         };
         ClusterDasConfigInfoHBDatastoreCandidate: {
            "userSelectedDs": string;
            "allFeasibleDs": string;
            "allFeasibleDsWithUserPreference": string;
         };
         ClusterDasConfigInfo: {
            (options?: vimService.vim.ClusterDasConfigInfo): vimService.vim.ClusterDasConfigInfo;
         };
         ClusterDasData: {
            (options?: vimService.vim.ClusterDasData): vimService.vim.ClusterDasData;
         };
         ClusterDasDataSummary: {
            (options?: vimService.vim.ClusterDasDataSummary): vimService.vim.ClusterDasDataSummary;
         };
         ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo: {
            (options?: vimService.vim.ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo): vimService.vim.ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo;
         };
         ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots: {
            (options?: vimService.vim.ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots): vimService.vim.ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots;
         };
         ArrayOfClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots: {
            (options?: vimService.vim.ArrayOfClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots): vimService.vim.ArrayOfClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots;
         };
         ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots: {
            (options?: vimService.vim.ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots): vimService.vim.ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots;
         };
         ArrayOfClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots: {
            (options?: vimService.vim.ArrayOfClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots): vimService.vim.ArrayOfClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots;
         };
         ClusterDasFailoverLevelAdvancedRuntimeInfo: {
            (options?: vimService.vim.ClusterDasFailoverLevelAdvancedRuntimeInfo): vimService.vim.ClusterDasFailoverLevelAdvancedRuntimeInfo;
         };
         ClusterDasFdmAvailabilityState: {
            "uninitialized": string;
            "election": string;
            "master": string;
            "connectedToMaster": string;
            "networkPartitionedFromMaster": string;
            "networkIsolated": string;
            "hostDown": string;
            "initializationError": string;
            "uninitializationError": string;
            "fdmUnreachable": string;
         };
         ClusterDasFdmHostState: {
            (options?: vimService.vim.ClusterDasFdmHostState): vimService.vim.ClusterDasFdmHostState;
         };
         ClusterDasHostInfo: {
            (options?: vimService.vim.ClusterDasHostInfo): vimService.vim.ClusterDasHostInfo;
         };
         ClusterDasHostRecommendation: {
            (options?: vimService.vim.ClusterDasHostRecommendation): vimService.vim.ClusterDasHostRecommendation;
         };
         DasVmPriority: {
            "disabled": string;
            "low": string;
            "medium": string;
            "high": string;
         };
         ClusterDasVmConfigInfo: {
            (options?: vimService.vim.ClusterDasVmConfigInfo): vimService.vim.ClusterDasVmConfigInfo;
         };
         ArrayOfClusterDasVmConfigInfo: {
            (options?: vimService.vim.ArrayOfClusterDasVmConfigInfo): vimService.vim.ArrayOfClusterDasVmConfigInfo;
         };
         ClusterDasVmSettingsRestartPriority: {
            "disabled": string;
            "lowest": string;
            "low": string;
            "medium": string;
            "high": string;
            "highest": string;
            "clusterRestartPriority": string;
         };
         ClusterDasVmSettingsIsolationResponse: {
            "none": string;
            "powerOff": string;
            "shutdown": string;
            "clusterIsolationResponse": string;
         };
         ClusterDasVmSettings: {
            (options?: vimService.vim.ClusterDasVmSettings): vimService.vim.ClusterDasVmSettings;
         };
         ClusterDependencyRuleInfo: {
            (options?: vimService.vim.ClusterDependencyRuleInfo): vimService.vim.ClusterDependencyRuleInfo;
         };
         ClusterDrsFaultsFaultsByVm: {
            (options?: vimService.vim.ClusterDrsFaultsFaultsByVm): vimService.vim.ClusterDrsFaultsFaultsByVm;
         };
         ArrayOfClusterDrsFaultsFaultsByVm: {
            (options?: vimService.vim.ArrayOfClusterDrsFaultsFaultsByVm): vimService.vim.ArrayOfClusterDrsFaultsFaultsByVm;
         };
         ClusterDrsFaultsFaultsByVirtualDisk: {
            (options?: vimService.vim.ClusterDrsFaultsFaultsByVirtualDisk): vimService.vim.ClusterDrsFaultsFaultsByVirtualDisk;
         };
         ClusterDrsFaults: {
            (options?: vimService.vim.ClusterDrsFaults): vimService.vim.ClusterDrsFaults;
         };
         ArrayOfClusterDrsFaults: {
            (options?: vimService.vim.ArrayOfClusterDrsFaults): vimService.vim.ArrayOfClusterDrsFaults;
         };
         ClusterDrsMigration: {
            (options?: vimService.vim.ClusterDrsMigration): vimService.vim.ClusterDrsMigration;
         };
         ArrayOfClusterDrsMigration: {
            (options?: vimService.vim.ArrayOfClusterDrsMigration): vimService.vim.ArrayOfClusterDrsMigration;
         };
         DrsRecommendationReasonCode: {
            "fairnessCpuAvg": string;
            "fairnessMemAvg": string;
            "jointAffin": string;
            "antiAffin": string;
            "hostMaint": string;
         };
         ClusterDrsRecommendation: {
            (options?: vimService.vim.ClusterDrsRecommendation): vimService.vim.ClusterDrsRecommendation;
         };
         ArrayOfClusterDrsRecommendation: {
            (options?: vimService.vim.ArrayOfClusterDrsRecommendation): vimService.vim.ArrayOfClusterDrsRecommendation;
         };
         ClusterEVCManagerEVCState: {
            (options?: vimService.vim.ClusterEVCManagerEVCState): vimService.vim.ClusterEVCManagerEVCState;
         };
         ClusterEVCManagerCheckResult: {
            (options?: vimService.vim.ClusterEVCManagerCheckResult): vimService.vim.ClusterEVCManagerCheckResult;
         };
         ArrayOfClusterEVCManagerCheckResult: {
            (options?: vimService.vim.ArrayOfClusterEVCManagerCheckResult): vimService.vim.ArrayOfClusterEVCManagerCheckResult;
         };
         ClusterEnterMaintenanceResult: {
            (options?: vimService.vim.ClusterEnterMaintenanceResult): vimService.vim.ClusterEnterMaintenanceResult;
         };
         ClusterFailoverHostAdmissionControlInfoHostStatus: {
            (options?: vimService.vim.ClusterFailoverHostAdmissionControlInfoHostStatus): vimService.vim.ClusterFailoverHostAdmissionControlInfoHostStatus;
         };
         ArrayOfClusterFailoverHostAdmissionControlInfoHostStatus: {
            (options?: vimService.vim.ArrayOfClusterFailoverHostAdmissionControlInfoHostStatus): vimService.vim.ArrayOfClusterFailoverHostAdmissionControlInfoHostStatus;
         };
         ClusterFailoverHostAdmissionControlInfo: {
            (options?: vimService.vim.ClusterFailoverHostAdmissionControlInfo): vimService.vim.ClusterFailoverHostAdmissionControlInfo;
         };
         ClusterFailoverHostAdmissionControlPolicy: {
            (options?: vimService.vim.ClusterFailoverHostAdmissionControlPolicy): vimService.vim.ClusterFailoverHostAdmissionControlPolicy;
         };
         ClusterFailoverLevelAdmissionControlInfo: {
            (options?: vimService.vim.ClusterFailoverLevelAdmissionControlInfo): vimService.vim.ClusterFailoverLevelAdmissionControlInfo;
         };
         ClusterFailoverLevelAdmissionControlPolicy: {
            (options?: vimService.vim.ClusterFailoverLevelAdmissionControlPolicy): vimService.vim.ClusterFailoverLevelAdmissionControlPolicy;
         };
         ClusterFailoverResourcesAdmissionControlInfo: {
            (options?: vimService.vim.ClusterFailoverResourcesAdmissionControlInfo): vimService.vim.ClusterFailoverResourcesAdmissionControlInfo;
         };
         ClusterFailoverResourcesAdmissionControlPolicy: {
            (options?: vimService.vim.ClusterFailoverResourcesAdmissionControlPolicy): vimService.vim.ClusterFailoverResourcesAdmissionControlPolicy;
         };
         ClusterGroupInfo: {
            (options?: vimService.vim.ClusterGroupInfo): vimService.vim.ClusterGroupInfo;
         };
         ArrayOfClusterGroupInfo: {
            (options?: vimService.vim.ArrayOfClusterGroupInfo): vimService.vim.ArrayOfClusterGroupInfo;
         };
         ClusterHostGroup: {
            (options?: vimService.vim.ClusterHostGroup): vimService.vim.ClusterHostGroup;
         };
         ClusterHostInfraUpdateHaModeActionOperationType: {
            "enterQuarantine": string;
            "exitQuarantine": string;
            "enterMaintenance": string;
         };
         ClusterHostInfraUpdateHaModeAction: {
            (options?: vimService.vim.ClusterHostInfraUpdateHaModeAction): vimService.vim.ClusterHostInfraUpdateHaModeAction;
         };
         HostPowerOperationType: {
            "powerOn": string;
            "powerOff": string;
         };
         ClusterHostPowerAction: {
            (options?: vimService.vim.ClusterHostPowerAction): vimService.vim.ClusterHostPowerAction;
         };
         ClusterHostRecommendation: {
            (options?: vimService.vim.ClusterHostRecommendation): vimService.vim.ClusterHostRecommendation;
         };
         ArrayOfClusterHostRecommendation: {
            (options?: vimService.vim.ArrayOfClusterHostRecommendation): vimService.vim.ArrayOfClusterHostRecommendation;
         };
         ClusterInitialPlacementAction: {
            (options?: vimService.vim.ClusterInitialPlacementAction): vimService.vim.ClusterInitialPlacementAction;
         };
         ClusterMigrationAction: {
            (options?: vimService.vim.ClusterMigrationAction): vimService.vim.ClusterMigrationAction;
         };
         ClusterNotAttemptedVmInfo: {
            (options?: vimService.vim.ClusterNotAttemptedVmInfo): vimService.vim.ClusterNotAttemptedVmInfo;
         };
         ArrayOfClusterNotAttemptedVmInfo: {
            (options?: vimService.vim.ArrayOfClusterNotAttemptedVmInfo): vimService.vim.ArrayOfClusterNotAttemptedVmInfo;
         };
         ClusterOrchestrationInfo: {
            (options?: vimService.vim.ClusterOrchestrationInfo): vimService.vim.ClusterOrchestrationInfo;
         };
         PlacementAction: {
            (options?: vimService.vim.PlacementAction): vimService.vim.PlacementAction;
         };
         PlacementResult: {
            (options?: vimService.vim.PlacementResult): vimService.vim.PlacementResult;
         };
         PlacementSpecPlacementType: {
            "create": string;
            "reconfigure": string;
            "relocate": string;
            "clone": string;
         };
         PlacementSpec: {
            (options?: vimService.vim.PlacementSpec): vimService.vim.PlacementSpec;
         };
         ArrayOfPlacementSpec: {
            (options?: vimService.vim.ArrayOfPlacementSpec): vimService.vim.ArrayOfPlacementSpec;
         };
         ClusterPowerOnVmOption: {
            "OverrideAutomationLevel": string;
            "ReserveResources": string;
         };
         ClusterPowerOnVmResult: {
            (options?: vimService.vim.ClusterPowerOnVmResult): vimService.vim.ClusterPowerOnVmResult;
         };
         RecommendationType: {
            "V1": string;
         };
         RecommendationReasonCode: {
            "fairnessCpuAvg": string;
            "fairnessMemAvg": string;
            "jointAffin": string;
            "antiAffin": string;
            "hostMaint": string;
            "enterStandby": string;
            "reservationCpu": string;
            "reservationMem": string;
            "powerOnVm": string;
            "powerSaving": string;
            "increaseCapacity": string;
            "checkResource": string;
            "unreservedCapacity": string;
            "vmHostHardAffinity": string;
            "vmHostSoftAffinity": string;
            "balanceDatastoreSpaceUsage": string;
            "balanceDatastoreIOLoad": string;
            "balanceDatastoreIOPSReservation": string;
            "datastoreMaint": string;
            "virtualDiskJointAffin": string;
            "virtualDiskAntiAffin": string;
            "datastoreSpaceOutage": string;
            "storagePlacement": string;
            "iolbDisabledInternal": string;
            "xvmotionPlacement": string;
            "networkBandwidthReservation": string;
            "hostInDegradation": string;
            "hostExitDegradation": string;
            "maxVmsConstraint": string;
            "ftConstraints": string;
         };
         ClusterRecommendation: {
            (options?: vimService.vim.ClusterRecommendation): vimService.vim.ClusterRecommendation;
         };
         ArrayOfClusterRecommendation: {
            (options?: vimService.vim.ArrayOfClusterRecommendation): vimService.vim.ArrayOfClusterRecommendation;
         };
         ClusterResourceUsageSummary: {
            (options?: vimService.vim.ClusterResourceUsageSummary): vimService.vim.ClusterResourceUsageSummary;
         };
         ClusterRuleInfo: {
            (options?: vimService.vim.ClusterRuleInfo): vimService.vim.ClusterRuleInfo;
         };
         ArrayOfClusterRuleInfo: {
            (options?: vimService.vim.ArrayOfClusterRuleInfo): vimService.vim.ArrayOfClusterRuleInfo;
         };
         ClusterRuleSpec: {
            (options?: vimService.vim.ClusterRuleSpec): vimService.vim.ClusterRuleSpec;
         };
         ArrayOfClusterRuleSpec: {
            (options?: vimService.vim.ArrayOfClusterRuleSpec): vimService.vim.ArrayOfClusterRuleSpec;
         };
         ClusterSlotPolicy: {
            (options?: vimService.vim.ClusterSlotPolicy): vimService.vim.ClusterSlotPolicy;
         };
         ClusterFixedSizeSlotPolicy: {
            (options?: vimService.vim.ClusterFixedSizeSlotPolicy): vimService.vim.ClusterFixedSizeSlotPolicy;
         };
         ClusterUsageSummary: {
            (options?: vimService.vim.ClusterUsageSummary): vimService.vim.ClusterUsageSummary;
         };
         ClusterVmComponentProtectionSettingsStorageVmReaction: {
            "disabled": string;
            "warning": string;
            "restartConservative": string;
            "restartAggressive": string;
            "clusterDefault": string;
         };
         ClusterVmComponentProtectionSettingsVmReactionOnAPDCleared: {
            "none": string;
            "reset": string;
            "useClusterDefault": string;
         };
         ClusterVmComponentProtectionSettings: {
            (options?: vimService.vim.ClusterVmComponentProtectionSettings): vimService.vim.ClusterVmComponentProtectionSettings;
         };
         ClusterVmGroup: {
            (options?: vimService.vim.ClusterVmGroup): vimService.vim.ClusterVmGroup;
         };
         ClusterVmHostRuleInfo: {
            (options?: vimService.vim.ClusterVmHostRuleInfo): vimService.vim.ClusterVmHostRuleInfo;
         };
         ClusterVmOrchestrationInfo: {
            (options?: vimService.vim.ClusterVmOrchestrationInfo): vimService.vim.ClusterVmOrchestrationInfo;
         };
         ArrayOfClusterVmOrchestrationInfo: {
            (options?: vimService.vim.ArrayOfClusterVmOrchestrationInfo): vimService.vim.ArrayOfClusterVmOrchestrationInfo;
         };
         ClusterVmReadinessReadyCondition: {
            "none": string;
            "poweredOn": string;
            "guestHbStatusGreen": string;
            "appHbStatusGreen": string;
            "useClusterDefault": string;
         };
         ClusterVmReadiness: {
            (options?: vimService.vim.ClusterVmReadiness): vimService.vim.ClusterVmReadiness;
         };
         ClusterVmToolsMonitoringSettings: {
            (options?: vimService.vim.ClusterVmToolsMonitoringSettings): vimService.vim.ClusterVmToolsMonitoringSettings;
         };
         DVPortConfigSpec: {
            (options?: vimService.vim.DVPortConfigSpec): vimService.vim.DVPortConfigSpec;
         };
         ArrayOfDVPortConfigSpec: {
            (options?: vimService.vim.ArrayOfDVPortConfigSpec): vimService.vim.ArrayOfDVPortConfigSpec;
         };
         DVPortConfigInfo: {
            (options?: vimService.vim.DVPortConfigInfo): vimService.vim.DVPortConfigInfo;
         };
         DVSTrafficShapingPolicy: {
            (options?: vimService.vim.DVSTrafficShapingPolicy): vimService.vim.DVSTrafficShapingPolicy;
         };
         DVSHostLocalPortInfo: {
            (options?: vimService.vim.DVSHostLocalPortInfo): vimService.vim.DVSHostLocalPortInfo;
         };
         DVSVendorSpecificConfig: {
            (options?: vimService.vim.DVSVendorSpecificConfig): vimService.vim.DVSVendorSpecificConfig;
         };
         DvsFilterParameter: {
            (options?: vimService.vim.DvsFilterParameter): vimService.vim.DvsFilterParameter;
         };
         DvsFilterOnFailure: {
            "failOpen": string;
            "failClosed": string;
         };
         DvsFilterConfig: {
            (options?: vimService.vim.DvsFilterConfig): vimService.vim.DvsFilterConfig;
         };
         ArrayOfDvsFilterConfig: {
            (options?: vimService.vim.ArrayOfDvsFilterConfig): vimService.vim.ArrayOfDvsFilterConfig;
         };
         DvsTrafficFilterConfig: {
            (options?: vimService.vim.DvsTrafficFilterConfig): vimService.vim.DvsTrafficFilterConfig;
         };
         DvsFilterConfigSpec: {
            (options?: vimService.vim.DvsFilterConfigSpec): vimService.vim.DvsFilterConfigSpec;
         };
         DvsTrafficFilterConfigSpec: {
            (options?: vimService.vim.DvsTrafficFilterConfigSpec): vimService.vim.DvsTrafficFilterConfigSpec;
         };
         DvsFilterPolicy: {
            (options?: vimService.vim.DvsFilterPolicy): vimService.vim.DvsFilterPolicy;
         };
         DVPortSetting: {
            (options?: vimService.vim.DVPortSetting): vimService.vim.DVPortSetting;
         };
         DVPortStatusVmDirectPathGen2InactiveReasonNetwork: {
            "portNptIncompatibleDvs": string;
            "portNptNoCompatibleNics": string;
            "portNptNoVirtualFunctionsAvailable": string;
            "portNptDisabledForPort": string;
         };
         DVPortStatusVmDirectPathGen2InactiveReasonOther: {
            "portNptIncompatibleHost": string;
            "portNptIncompatibleConnectee": string;
         };
         DVPortStatus: {
            (options?: vimService.vim.DVPortStatus): vimService.vim.DVPortStatus;
         };
         DVPortState: {
            (options?: vimService.vim.DVPortState): vimService.vim.DVPortState;
         };
         DistributedVirtualPort: {
            (options?: vimService.vim.DistributedVirtualPort): vimService.vim.DistributedVirtualPort;
         };
         ArrayOfDistributedVirtualPort: {
            (options?: vimService.vim.ArrayOfDistributedVirtualPort): vimService.vim.ArrayOfDistributedVirtualPort;
         };
         DistributedVirtualPortgroupPortgroupType: {
            "earlyBinding": string;
            "lateBinding": string;
            "ephemeral": string;
         };
         DVPortgroupPolicy: {
            (options?: vimService.vim.DVPortgroupPolicy): vimService.vim.DVPortgroupPolicy;
         };
         DistributedVirtualPortgroupMetaTagName: {
            "dvsName": string;
            "portgroupName": string;
            "portIndex": string;
         };
         DVPortgroupConfigSpec: {
            (options?: vimService.vim.DVPortgroupConfigSpec): vimService.vim.DVPortgroupConfigSpec;
         };
         ArrayOfDVPortgroupConfigSpec: {
            (options?: vimService.vim.ArrayOfDVPortgroupConfigSpec): vimService.vim.ArrayOfDVPortgroupConfigSpec;
         };
         DVPortgroupConfigInfo: {
            (options?: vimService.vim.DVPortgroupConfigInfo): vimService.vim.DVPortgroupConfigInfo;
         };
         DistributedVirtualPortgroupInfo: {
            (options?: vimService.vim.DistributedVirtualPortgroupInfo): vimService.vim.DistributedVirtualPortgroupInfo;
         };
         ArrayOfDistributedVirtualPortgroupInfo: {
            (options?: vimService.vim.ArrayOfDistributedVirtualPortgroupInfo): vimService.vim.ArrayOfDistributedVirtualPortgroupInfo;
         };
         DVPortgroupSelection: {
            (options?: vimService.vim.DVPortgroupSelection): vimService.vim.DVPortgroupSelection;
         };
         DistributedVirtualSwitchInfo: {
            (options?: vimService.vim.DistributedVirtualSwitchInfo): vimService.vim.DistributedVirtualSwitchInfo;
         };
         ArrayOfDistributedVirtualSwitchInfo: {
            (options?: vimService.vim.ArrayOfDistributedVirtualSwitchInfo): vimService.vim.ArrayOfDistributedVirtualSwitchInfo;
         };
         DVSManagerDvsConfigTarget: {
            (options?: vimService.vim.DVSManagerDvsConfigTarget): vimService.vim.DVSManagerDvsConfigTarget;
         };
         DistributedVirtualSwitchManagerCompatibilityResult: {
            (options?: vimService.vim.DistributedVirtualSwitchManagerCompatibilityResult): vimService.vim.DistributedVirtualSwitchManagerCompatibilityResult;
         };
         ArrayOfDistributedVirtualSwitchManagerCompatibilityResult: {
            (options?: vimService.vim.ArrayOfDistributedVirtualSwitchManagerCompatibilityResult): vimService.vim.ArrayOfDistributedVirtualSwitchManagerCompatibilityResult;
         };
         DistributedVirtualSwitchManagerHostContainer: {
            (options?: vimService.vim.DistributedVirtualSwitchManagerHostContainer): vimService.vim.DistributedVirtualSwitchManagerHostContainer;
         };
         DistributedVirtualSwitchManagerHostDvsFilterSpec: {
            (options?: vimService.vim.DistributedVirtualSwitchManagerHostDvsFilterSpec): vimService.vim.DistributedVirtualSwitchManagerHostDvsFilterSpec;
         };
         ArrayOfDistributedVirtualSwitchManagerHostDvsFilterSpec: {
            (options?: vimService.vim.ArrayOfDistributedVirtualSwitchManagerHostDvsFilterSpec): vimService.vim.ArrayOfDistributedVirtualSwitchManagerHostDvsFilterSpec;
         };
         DistributedVirtualSwitchManagerHostArrayFilter: {
            (options?: vimService.vim.DistributedVirtualSwitchManagerHostArrayFilter): vimService.vim.DistributedVirtualSwitchManagerHostArrayFilter;
         };
         DistributedVirtualSwitchManagerHostContainerFilter: {
            (options?: vimService.vim.DistributedVirtualSwitchManagerHostContainerFilter): vimService.vim.DistributedVirtualSwitchManagerHostContainerFilter;
         };
         DistributedVirtualSwitchManagerHostDvsMembershipFilter: {
            (options?: vimService.vim.DistributedVirtualSwitchManagerHostDvsMembershipFilter): vimService.vim.DistributedVirtualSwitchManagerHostDvsMembershipFilter;
         };
         DistributedVirtualSwitchManagerDvsProductSpec: {
            (options?: vimService.vim.DistributedVirtualSwitchManagerDvsProductSpec): vimService.vim.DistributedVirtualSwitchManagerDvsProductSpec;
         };
         DistributedVirtualSwitchManagerImportResult: {
            (options?: vimService.vim.DistributedVirtualSwitchManagerImportResult): vimService.vim.DistributedVirtualSwitchManagerImportResult;
         };
         DVSSelection: {
            (options?: vimService.vim.DVSSelection): vimService.vim.DVSSelection;
         };
         EntityBackupConfig: {
            (options?: vimService.vim.EntityBackupConfig): vimService.vim.EntityBackupConfig;
         };
         ArrayOfEntityBackupConfig: {
            (options?: vimService.vim.ArrayOfEntityBackupConfig): vimService.vim.ArrayOfEntityBackupConfig;
         };
         EntityType: {
            "distributedVirtualSwitch": string;
            "distributedVirtualPortgroup": string;
         };
         EntityImportType: {
            "createEntityWithNewIdentifier": string;
            "createEntityWithOriginalIdentifier": string;
            "applyToEntitySpecified": string;
         };
         EntityBackup: {
            (options?: vimService.vim.EntityBackup): vimService.vim.EntityBackup;
         };
         DistributedVirtualSwitchHostMemberHostComponentState: {
            "up": string;
            "pending": string;
            "outOfSync": string;
            "warning": string;
            "disconnected": string;
            "down": string;
         };
         DistributedVirtualSwitchHostMemberConfigSpec: {
            (options?: vimService.vim.DistributedVirtualSwitchHostMemberConfigSpec): vimService.vim.DistributedVirtualSwitchHostMemberConfigSpec;
         };
         ArrayOfDistributedVirtualSwitchHostMemberConfigSpec: {
            (options?: vimService.vim.ArrayOfDistributedVirtualSwitchHostMemberConfigSpec): vimService.vim.ArrayOfDistributedVirtualSwitchHostMemberConfigSpec;
         };
         DistributedVirtualSwitchHostMemberPnicSpec: {
            (options?: vimService.vim.DistributedVirtualSwitchHostMemberPnicSpec): vimService.vim.DistributedVirtualSwitchHostMemberPnicSpec;
         };
         ArrayOfDistributedVirtualSwitchHostMemberPnicSpec: {
            (options?: vimService.vim.ArrayOfDistributedVirtualSwitchHostMemberPnicSpec): vimService.vim.ArrayOfDistributedVirtualSwitchHostMemberPnicSpec;
         };
         DistributedVirtualSwitchHostMemberBacking: {
            (options?: vimService.vim.DistributedVirtualSwitchHostMemberBacking): vimService.vim.DistributedVirtualSwitchHostMemberBacking;
         };
         DistributedVirtualSwitchHostMemberPnicBacking: {
            (options?: vimService.vim.DistributedVirtualSwitchHostMemberPnicBacking): vimService.vim.DistributedVirtualSwitchHostMemberPnicBacking;
         };
         DistributedVirtualSwitchHostMemberRuntimeState: {
            (options?: vimService.vim.DistributedVirtualSwitchHostMemberRuntimeState): vimService.vim.DistributedVirtualSwitchHostMemberRuntimeState;
         };
         DistributedVirtualSwitchHostMemberConfigInfo: {
            (options?: vimService.vim.DistributedVirtualSwitchHostMemberConfigInfo): vimService.vim.DistributedVirtualSwitchHostMemberConfigInfo;
         };
         HostMemberRuntimeInfo: {
            (options?: vimService.vim.HostMemberRuntimeInfo): vimService.vim.HostMemberRuntimeInfo;
         };
         ArrayOfHostMemberRuntimeInfo: {
            (options?: vimService.vim.ArrayOfHostMemberRuntimeInfo): vimService.vim.ArrayOfHostMemberRuntimeInfo;
         };
         HostMemberHealthCheckResult: {
            (options?: vimService.vim.HostMemberHealthCheckResult): vimService.vim.HostMemberHealthCheckResult;
         };
         ArrayOfHostMemberHealthCheckResult: {
            (options?: vimService.vim.ArrayOfHostMemberHealthCheckResult): vimService.vim.ArrayOfHostMemberHealthCheckResult;
         };
         HostMemberUplinkHealthCheckResult: {
            (options?: vimService.vim.HostMemberUplinkHealthCheckResult): vimService.vim.HostMemberUplinkHealthCheckResult;
         };
         DistributedVirtualSwitchHostMember: {
            (options?: vimService.vim.DistributedVirtualSwitchHostMember): vimService.vim.DistributedVirtualSwitchHostMember;
         };
         ArrayOfDistributedVirtualSwitchHostMember: {
            (options?: vimService.vim.ArrayOfDistributedVirtualSwitchHostMember): vimService.vim.ArrayOfDistributedVirtualSwitchHostMember;
         };
         DistributedVirtualSwitchHostProductSpec: {
            (options?: vimService.vim.DistributedVirtualSwitchHostProductSpec): vimService.vim.DistributedVirtualSwitchHostProductSpec;
         };
         ArrayOfDistributedVirtualSwitchHostProductSpec: {
            (options?: vimService.vim.ArrayOfDistributedVirtualSwitchHostProductSpec): vimService.vim.ArrayOfDistributedVirtualSwitchHostProductSpec;
         };
         DistributedVirtualSwitchKeyedOpaqueBlob: {
            (options?: vimService.vim.DistributedVirtualSwitchKeyedOpaqueBlob): vimService.vim.DistributedVirtualSwitchKeyedOpaqueBlob;
         };
         ArrayOfDistributedVirtualSwitchKeyedOpaqueBlob: {
            (options?: vimService.vim.ArrayOfDistributedVirtualSwitchKeyedOpaqueBlob): vimService.vim.ArrayOfDistributedVirtualSwitchKeyedOpaqueBlob;
         };
         DVSNetworkResourcePoolAllocationInfo: {
            (options?: vimService.vim.DVSNetworkResourcePoolAllocationInfo): vimService.vim.DVSNetworkResourcePoolAllocationInfo;
         };
         DVSNetworkResourcePoolConfigSpec: {
            (options?: vimService.vim.DVSNetworkResourcePoolConfigSpec): vimService.vim.DVSNetworkResourcePoolConfigSpec;
         };
         ArrayOfDVSNetworkResourcePoolConfigSpec: {
            (options?: vimService.vim.ArrayOfDVSNetworkResourcePoolConfigSpec): vimService.vim.ArrayOfDVSNetworkResourcePoolConfigSpec;
         };
         DVSNetworkResourcePool: {
            (options?: vimService.vim.DVSNetworkResourcePool): vimService.vim.DVSNetworkResourcePool;
         };
         ArrayOfDVSNetworkResourcePool: {
            (options?: vimService.vim.ArrayOfDVSNetworkResourcePool): vimService.vim.ArrayOfDVSNetworkResourcePool;
         };
         DistributedVirtualSwitchPortConnecteeConnecteeType: {
            "pnic": string;
            "vmVnic": string;
            "hostConsoleVnic": string;
            "hostVmkVnic": string;
         };
         DistributedVirtualSwitchPortConnectee: {
            (options?: vimService.vim.DistributedVirtualSwitchPortConnectee): vimService.vim.DistributedVirtualSwitchPortConnectee;
         };
         DistributedVirtualSwitchPortConnection: {
            (options?: vimService.vim.DistributedVirtualSwitchPortConnection): vimService.vim.DistributedVirtualSwitchPortConnection;
         };
         DistributedVirtualSwitchPortCriteria: {
            (options?: vimService.vim.DistributedVirtualSwitchPortCriteria): vimService.vim.DistributedVirtualSwitchPortCriteria;
         };
         DistributedVirtualSwitchPortStatistics: {
            (options?: vimService.vim.DistributedVirtualSwitchPortStatistics): vimService.vim.DistributedVirtualSwitchPortStatistics;
         };
         DistributedVirtualSwitchProductSpec: {
            (options?: vimService.vim.DistributedVirtualSwitchProductSpec): vimService.vim.DistributedVirtualSwitchProductSpec;
         };
         ArrayOfDistributedVirtualSwitchProductSpec: {
            (options?: vimService.vim.ArrayOfDistributedVirtualSwitchProductSpec): vimService.vim.ArrayOfDistributedVirtualSwitchProductSpec;
         };
         DvsNetworkRuleQualifier: {
            (options?: vimService.vim.DvsNetworkRuleQualifier): vimService.vim.DvsNetworkRuleQualifier;
         };
         ArrayOfDvsNetworkRuleQualifier: {
            (options?: vimService.vim.ArrayOfDvsNetworkRuleQualifier): vimService.vim.ArrayOfDvsNetworkRuleQualifier;
         };
         DvsNetworkRuleAction: {
            (options?: vimService.vim.DvsNetworkRuleAction): vimService.vim.DvsNetworkRuleAction;
         };
         DvsNetworkRuleDirectionType: {
            "incomingPackets": string;
            "outgoingPackets": string;
            "both": string;
         };
         DvsIpNetworkRuleQualifier: {
            (options?: vimService.vim.DvsIpNetworkRuleQualifier): vimService.vim.DvsIpNetworkRuleQualifier;
         };
         DvsIpPort: {
            (options?: vimService.vim.DvsIpPort): vimService.vim.DvsIpPort;
         };
         DvsSingleIpPort: {
            (options?: vimService.vim.DvsSingleIpPort): vimService.vim.DvsSingleIpPort;
         };
         DvsIpPortRange: {
            (options?: vimService.vim.DvsIpPortRange): vimService.vim.DvsIpPortRange;
         };
         DvsMacNetworkRuleQualifier: {
            (options?: vimService.vim.DvsMacNetworkRuleQualifier): vimService.vim.DvsMacNetworkRuleQualifier;
         };
         DvsSystemTrafficNetworkRuleQualifier: {
            (options?: vimService.vim.DvsSystemTrafficNetworkRuleQualifier): vimService.vim.DvsSystemTrafficNetworkRuleQualifier;
         };
         DvsDropNetworkRuleAction: {
            (options?: vimService.vim.DvsDropNetworkRuleAction): vimService.vim.DvsDropNetworkRuleAction;
         };
         DvsAcceptNetworkRuleAction: {
            (options?: vimService.vim.DvsAcceptNetworkRuleAction): vimService.vim.DvsAcceptNetworkRuleAction;
         };
         DvsUpdateTagNetworkRuleAction: {
            (options?: vimService.vim.DvsUpdateTagNetworkRuleAction): vimService.vim.DvsUpdateTagNetworkRuleAction;
         };
         DvsRateLimitNetworkRuleAction: {
            (options?: vimService.vim.DvsRateLimitNetworkRuleAction): vimService.vim.DvsRateLimitNetworkRuleAction;
         };
         DvsLogNetworkRuleAction: {
            (options?: vimService.vim.DvsLogNetworkRuleAction): vimService.vim.DvsLogNetworkRuleAction;
         };
         DvsGreEncapNetworkRuleAction: {
            (options?: vimService.vim.DvsGreEncapNetworkRuleAction): vimService.vim.DvsGreEncapNetworkRuleAction;
         };
         DvsMacRewriteNetworkRuleAction: {
            (options?: vimService.vim.DvsMacRewriteNetworkRuleAction): vimService.vim.DvsMacRewriteNetworkRuleAction;
         };
         DvsPuntNetworkRuleAction: {
            (options?: vimService.vim.DvsPuntNetworkRuleAction): vimService.vim.DvsPuntNetworkRuleAction;
         };
         DvsCopyNetworkRuleAction: {
            (options?: vimService.vim.DvsCopyNetworkRuleAction): vimService.vim.DvsCopyNetworkRuleAction;
         };
         DvsTrafficRule: {
            (options?: vimService.vim.DvsTrafficRule): vimService.vim.DvsTrafficRule;
         };
         ArrayOfDvsTrafficRule: {
            (options?: vimService.vim.ArrayOfDvsTrafficRule): vimService.vim.ArrayOfDvsTrafficRule;
         };
         DvsTrafficRuleset: {
            (options?: vimService.vim.DvsTrafficRuleset): vimService.vim.DvsTrafficRuleset;
         };
         DvsVmVnicResourceAllocation: {
            (options?: vimService.vim.DvsVmVnicResourceAllocation): vimService.vim.DvsVmVnicResourceAllocation;
         };
         DvsVmVnicResourcePoolConfigSpec: {
            (options?: vimService.vim.DvsVmVnicResourcePoolConfigSpec): vimService.vim.DvsVmVnicResourcePoolConfigSpec;
         };
         ArrayOfDvsVmVnicResourcePoolConfigSpec: {
            (options?: vimService.vim.ArrayOfDvsVmVnicResourcePoolConfigSpec): vimService.vim.ArrayOfDvsVmVnicResourcePoolConfigSpec;
         };
         DvsVnicAllocatedResource: {
            (options?: vimService.vim.DvsVnicAllocatedResource): vimService.vim.DvsVnicAllocatedResource;
         };
         ArrayOfDvsVnicAllocatedResource: {
            (options?: vimService.vim.ArrayOfDvsVnicAllocatedResource): vimService.vim.ArrayOfDvsVnicAllocatedResource;
         };
         DvsVmVnicNetworkResourcePoolRuntimeInfo: {
            (options?: vimService.vim.DvsVmVnicNetworkResourcePoolRuntimeInfo): vimService.vim.DvsVmVnicNetworkResourcePoolRuntimeInfo;
         };
         ArrayOfDvsVmVnicNetworkResourcePoolRuntimeInfo: {
            (options?: vimService.vim.ArrayOfDvsVmVnicNetworkResourcePoolRuntimeInfo): vimService.vim.ArrayOfDvsVmVnicNetworkResourcePoolRuntimeInfo;
         };
         DVSVmVnicNetworkResourcePool: {
            (options?: vimService.vim.DVSVmVnicNetworkResourcePool): vimService.vim.DVSVmVnicNetworkResourcePool;
         };
         ArrayOfDVSVmVnicNetworkResourcePool: {
            (options?: vimService.vim.ArrayOfDVSVmVnicNetworkResourcePool): vimService.vim.ArrayOfDVSVmVnicNetworkResourcePool;
         };
         VMwareDVSFeatureCapability: {
            (options?: vimService.vim.VMwareDVSFeatureCapability): vimService.vim.VMwareDVSFeatureCapability;
         };
         VMwareDvsIpfixCapability: {
            (options?: vimService.vim.VMwareDvsIpfixCapability): vimService.vim.VMwareDvsIpfixCapability;
         };
         VMwareDvsLacpCapability: {
            (options?: vimService.vim.VMwareDvsLacpCapability): vimService.vim.VMwareDvsLacpCapability;
         };
         VMwareDVSHealthCheckCapability: {
            (options?: vimService.vim.VMwareDVSHealthCheckCapability): vimService.vim.VMwareDVSHealthCheckCapability;
         };
         VMwareDVSVspanCapability: {
            (options?: vimService.vim.VMwareDVSVspanCapability): vimService.vim.VMwareDVSVspanCapability;
         };
         VMwareVspanPort: {
            (options?: vimService.vim.VMwareVspanPort): vimService.vim.VMwareVspanPort;
         };
         VMwareVspanSession: {
            (options?: vimService.vim.VMwareVspanSession): vimService.vim.VMwareVspanSession;
         };
         ArrayOfVMwareVspanSession: {
            (options?: vimService.vim.ArrayOfVMwareVspanSession): vimService.vim.ArrayOfVMwareVspanSession;
         };
         VMwareIpfixConfig: {
            (options?: vimService.vim.VMwareIpfixConfig): vimService.vim.VMwareIpfixConfig;
         };
         VMwareDVSConfigInfo: {
            (options?: vimService.vim.VMwareDVSConfigInfo): vimService.vim.VMwareDVSConfigInfo;
         };
         VMwareDVSConfigSpec: {
            (options?: vimService.vim.VMwareDVSConfigSpec): vimService.vim.VMwareDVSConfigSpec;
         };
         VMwareUplinkPortOrderPolicy: {
            (options?: vimService.vim.VMwareUplinkPortOrderPolicy): vimService.vim.VMwareUplinkPortOrderPolicy;
         };
         DVSFailureCriteria: {
            (options?: vimService.vim.DVSFailureCriteria): vimService.vim.DVSFailureCriteria;
         };
         VmwareUplinkPortTeamingPolicy: {
            (options?: vimService.vim.VmwareUplinkPortTeamingPolicy): vimService.vim.VmwareUplinkPortTeamingPolicy;
         };
         VmwareDistributedVirtualSwitchVlanSpec: {
            (options?: vimService.vim.VmwareDistributedVirtualSwitchVlanSpec): vimService.vim.VmwareDistributedVirtualSwitchVlanSpec;
         };
         VmwareDistributedVirtualSwitchPvlanSpec: {
            (options?: vimService.vim.VmwareDistributedVirtualSwitchPvlanSpec): vimService.vim.VmwareDistributedVirtualSwitchPvlanSpec;
         };
         VmwareDistributedVirtualSwitchVlanIdSpec: {
            (options?: vimService.vim.VmwareDistributedVirtualSwitchVlanIdSpec): vimService.vim.VmwareDistributedVirtualSwitchVlanIdSpec;
         };
         VmwareDistributedVirtualSwitchTrunkVlanSpec: {
            (options?: vimService.vim.VmwareDistributedVirtualSwitchTrunkVlanSpec): vimService.vim.VmwareDistributedVirtualSwitchTrunkVlanSpec;
         };
         DVSSecurityPolicy: {
            (options?: vimService.vim.DVSSecurityPolicy): vimService.vim.DVSSecurityPolicy;
         };
         VMwareDVSPortSetting: {
            (options?: vimService.vim.VMwareDVSPortSetting): vimService.vim.VMwareDVSPortSetting;
         };
         VMwareDVSPortgroupPolicy: {
            (options?: vimService.vim.VMwareDVSPortgroupPolicy): vimService.vim.VMwareDVSPortgroupPolicy;
         };
         VmwareDistributedVirtualSwitchPvlanPortType: {
            "promiscuous": string;
            "isolated": string;
            "community": string;
         };
         VMwareDVSPvlanConfigSpec: {
            (options?: vimService.vim.VMwareDVSPvlanConfigSpec): vimService.vim.VMwareDVSPvlanConfigSpec;
         };
         ArrayOfVMwareDVSPvlanConfigSpec: {
            (options?: vimService.vim.ArrayOfVMwareDVSPvlanConfigSpec): vimService.vim.ArrayOfVMwareDVSPvlanConfigSpec;
         };
         VMwareDVSPvlanMapEntry: {
            (options?: vimService.vim.VMwareDVSPvlanMapEntry): vimService.vim.VMwareDVSPvlanMapEntry;
         };
         ArrayOfVMwareDVSPvlanMapEntry: {
            (options?: vimService.vim.ArrayOfVMwareDVSPvlanMapEntry): vimService.vim.ArrayOfVMwareDVSPvlanMapEntry;
         };
         VMwareDVSVspanConfigSpec: {
            (options?: vimService.vim.VMwareDVSVspanConfigSpec): vimService.vim.VMwareDVSVspanConfigSpec;
         };
         ArrayOfVMwareDVSVspanConfigSpec: {
            (options?: vimService.vim.ArrayOfVMwareDVSVspanConfigSpec): vimService.vim.ArrayOfVMwareDVSVspanConfigSpec;
         };
         VMwareDVSVspanSessionEncapType: {
            "gre": string;
            "erspan2": string;
            "erspan3": string;
         };
         VMwareDVSVspanSessionType: {
            "mixedDestMirror": string;
            "dvPortMirror": string;
            "remoteMirrorSource": string;
            "remoteMirrorDest": string;
            "encapsulatedRemoteMirrorSource": string;
         };
         VMwareDVSHealthCheckConfig: {
            (options?: vimService.vim.VMwareDVSHealthCheckConfig): vimService.vim.VMwareDVSHealthCheckConfig;
         };
         VMwareDVSVlanMtuHealthCheckConfig: {
            (options?: vimService.vim.VMwareDVSVlanMtuHealthCheckConfig): vimService.vim.VMwareDVSVlanMtuHealthCheckConfig;
         };
         VMwareDVSTeamingHealthCheckConfig: {
            (options?: vimService.vim.VMwareDVSTeamingHealthCheckConfig): vimService.vim.VMwareDVSTeamingHealthCheckConfig;
         };
         VMwareDVSVlanHealthCheckResult: {
            (options?: vimService.vim.VMwareDVSVlanHealthCheckResult): vimService.vim.VMwareDVSVlanHealthCheckResult;
         };
         VMwareDVSMtuHealthCheckResult: {
            (options?: vimService.vim.VMwareDVSMtuHealthCheckResult): vimService.vim.VMwareDVSMtuHealthCheckResult;
         };
         VMwareDVSTeamingMatchStatus: {
            "iphashMatch": string;
            "nonIphashMatch": string;
            "iphashMismatch": string;
            "nonIphashMismatch": string;
         };
         VMwareDVSTeamingHealthCheckResult: {
            (options?: vimService.vim.VMwareDVSTeamingHealthCheckResult): vimService.vim.VMwareDVSTeamingHealthCheckResult;
         };
         VMwareUplinkLacpPolicy: {
            (options?: vimService.vim.VMwareUplinkLacpPolicy): vimService.vim.VMwareUplinkLacpPolicy;
         };
         VMwareDvsLacpGroupConfig: {
            (options?: vimService.vim.VMwareDvsLacpGroupConfig): vimService.vim.VMwareDvsLacpGroupConfig;
         };
         ArrayOfVMwareDvsLacpGroupConfig: {
            (options?: vimService.vim.ArrayOfVMwareDvsLacpGroupConfig): vimService.vim.ArrayOfVMwareDvsLacpGroupConfig;
         };
         VMwareDvsLagVlanConfig: {
            (options?: vimService.vim.VMwareDvsLagVlanConfig): vimService.vim.VMwareDvsLagVlanConfig;
         };
         VMwareDvsLagIpfixConfig: {
            (options?: vimService.vim.VMwareDvsLagIpfixConfig): vimService.vim.VMwareDvsLagIpfixConfig;
         };
         VMwareUplinkLacpMode: {
            "active": string;
            "passive": string;
         };
         VMwareDvsLacpGroupSpec: {
            (options?: vimService.vim.VMwareDvsLacpGroupSpec): vimService.vim.VMwareDvsLacpGroupSpec;
         };
         ArrayOfVMwareDvsLacpGroupSpec: {
            (options?: vimService.vim.ArrayOfVMwareDvsLacpGroupSpec): vimService.vim.ArrayOfVMwareDvsLacpGroupSpec;
         };
         VMwareDvsLacpLoadBalanceAlgorithm: {
            "srcMac": string;
            "destMac": string;
            "srcDestMac": string;
            "destIpVlan": string;
            "srcIpVlan": string;
            "srcDestIpVlan": string;
            "destTcpUdpPort": string;
            "srcTcpUdpPort": string;
            "srcDestTcpUdpPort": string;
            "destIpTcpUdpPort": string;
            "srcIpTcpUdpPort": string;
            "srcDestIpTcpUdpPort": string;
            "destIpTcpUdpPortVlan": string;
            "srcIpTcpUdpPortVlan": string;
            "srcDestIpTcpUdpPortVlan": string;
            "destIp": string;
            "srcIp": string;
            "srcDestIp": string;
            "vlan": string;
            "srcPortId": string;
         };
         VMwareDvsLacpApiVersion: {
            "singleLag": string;
            "multipleLag": string;
         };
         VMwareDvsMulticastFilteringMode: {
            "legacyFiltering": string;
            "snooping": string;
         };
         CryptoKeyId: {
            (options?: vimService.vim.CryptoKeyId): vimService.vim.CryptoKeyId;
         };
         ArrayOfCryptoKeyId: {
            (options?: vimService.vim.ArrayOfCryptoKeyId): vimService.vim.ArrayOfCryptoKeyId;
         };
         CryptoKeyPlain: {
            (options?: vimService.vim.CryptoKeyPlain): vimService.vim.CryptoKeyPlain;
         };
         ArrayOfCryptoKeyPlain: {
            (options?: vimService.vim.ArrayOfCryptoKeyPlain): vimService.vim.ArrayOfCryptoKeyPlain;
         };
         CryptoKeyResult: {
            (options?: vimService.vim.CryptoKeyResult): vimService.vim.CryptoKeyResult;
         };
         ArrayOfCryptoKeyResult: {
            (options?: vimService.vim.ArrayOfCryptoKeyResult): vimService.vim.ArrayOfCryptoKeyResult;
         };
         CryptoManagerKmipCertificateInfo: {
            (options?: vimService.vim.CryptoManagerKmipCertificateInfo): vimService.vim.CryptoManagerKmipCertificateInfo;
         };
         CryptoManagerKmipServerStatus: {
            (options?: vimService.vim.CryptoManagerKmipServerStatus): vimService.vim.CryptoManagerKmipServerStatus;
         };
         ArrayOfCryptoManagerKmipServerStatus: {
            (options?: vimService.vim.ArrayOfCryptoManagerKmipServerStatus): vimService.vim.ArrayOfCryptoManagerKmipServerStatus;
         };
         CryptoManagerKmipClusterStatus: {
            (options?: vimService.vim.CryptoManagerKmipClusterStatus): vimService.vim.CryptoManagerKmipClusterStatus;
         };
         ArrayOfCryptoManagerKmipClusterStatus: {
            (options?: vimService.vim.ArrayOfCryptoManagerKmipClusterStatus): vimService.vim.ArrayOfCryptoManagerKmipClusterStatus;
         };
         CryptoManagerKmipServerCertInfo: {
            (options?: vimService.vim.CryptoManagerKmipServerCertInfo): vimService.vim.CryptoManagerKmipServerCertInfo;
         };
         CryptoSpec: {
            (options?: vimService.vim.CryptoSpec): vimService.vim.CryptoSpec;
         };
         CryptoSpecDecrypt: {
            (options?: vimService.vim.CryptoSpecDecrypt): vimService.vim.CryptoSpecDecrypt;
         };
         CryptoSpecDeepRecrypt: {
            (options?: vimService.vim.CryptoSpecDeepRecrypt): vimService.vim.CryptoSpecDeepRecrypt;
         };
         CryptoSpecEncrypt: {
            (options?: vimService.vim.CryptoSpecEncrypt): vimService.vim.CryptoSpecEncrypt;
         };
         CryptoSpecNoOp: {
            (options?: vimService.vim.CryptoSpecNoOp): vimService.vim.CryptoSpecNoOp;
         };
         CryptoSpecRegister: {
            (options?: vimService.vim.CryptoSpecRegister): vimService.vim.CryptoSpecRegister;
         };
         CryptoSpecShallowRecrypt: {
            (options?: vimService.vim.CryptoSpecShallowRecrypt): vimService.vim.CryptoSpecShallowRecrypt;
         };
         KeyProviderId: {
            (options?: vimService.vim.KeyProviderId): vimService.vim.KeyProviderId;
         };
         KmipClusterInfo: {
            (options?: vimService.vim.KmipClusterInfo): vimService.vim.KmipClusterInfo;
         };
         ArrayOfKmipClusterInfo: {
            (options?: vimService.vim.ArrayOfKmipClusterInfo): vimService.vim.ArrayOfKmipClusterInfo;
         };
         KmipServerInfo: {
            (options?: vimService.vim.KmipServerInfo): vimService.vim.KmipServerInfo;
         };
         ArrayOfKmipServerInfo: {
            (options?: vimService.vim.ArrayOfKmipServerInfo): vimService.vim.ArrayOfKmipServerInfo;
         };
         KmipServerSpec: {
            (options?: vimService.vim.KmipServerSpec): vimService.vim.KmipServerSpec;
         };
         KmipServerStatus: {
            (options?: vimService.vim.KmipServerStatus): vimService.vim.KmipServerStatus;
         };
         EventEventSeverity: {
            "error": string;
            "warning": string;
            "info": string;
            "user": string;
         };
         Event: {
            (options?: vimService.vim.Event): vimService.vim.Event;
         };
         ArrayOfEvent: {
            (options?: vimService.vim.ArrayOfEvent): vimService.vim.ArrayOfEvent;
         };
         GeneralEvent: {
            (options?: vimService.vim.GeneralEvent): vimService.vim.GeneralEvent;
         };
         GeneralHostInfoEvent: {
            (options?: vimService.vim.GeneralHostInfoEvent): vimService.vim.GeneralHostInfoEvent;
         };
         GeneralHostWarningEvent: {
            (options?: vimService.vim.GeneralHostWarningEvent): vimService.vim.GeneralHostWarningEvent;
         };
         GeneralHostErrorEvent: {
            (options?: vimService.vim.GeneralHostErrorEvent): vimService.vim.GeneralHostErrorEvent;
         };
         GeneralVmInfoEvent: {
            (options?: vimService.vim.GeneralVmInfoEvent): vimService.vim.GeneralVmInfoEvent;
         };
         GeneralVmWarningEvent: {
            (options?: vimService.vim.GeneralVmWarningEvent): vimService.vim.GeneralVmWarningEvent;
         };
         GeneralVmErrorEvent: {
            (options?: vimService.vim.GeneralVmErrorEvent): vimService.vim.GeneralVmErrorEvent;
         };
         GeneralUserEvent: {
            (options?: vimService.vim.GeneralUserEvent): vimService.vim.GeneralUserEvent;
         };
         ExtendedEventPair: {
            (options?: vimService.vim.ExtendedEventPair): vimService.vim.ExtendedEventPair;
         };
         ArrayOfExtendedEventPair: {
            (options?: vimService.vim.ArrayOfExtendedEventPair): vimService.vim.ArrayOfExtendedEventPair;
         };
         ExtendedEvent: {
            (options?: vimService.vim.ExtendedEvent): vimService.vim.ExtendedEvent;
         };
         HealthStatusChangedEvent: {
            (options?: vimService.vim.HealthStatusChangedEvent): vimService.vim.HealthStatusChangedEvent;
         };
         HostInventoryUnreadableEvent: {
            (options?: vimService.vim.HostInventoryUnreadableEvent): vimService.vim.HostInventoryUnreadableEvent;
         };
         DatacenterEvent: {
            (options?: vimService.vim.DatacenterEvent): vimService.vim.DatacenterEvent;
         };
         DatacenterCreatedEvent: {
            (options?: vimService.vim.DatacenterCreatedEvent): vimService.vim.DatacenterCreatedEvent;
         };
         DatacenterRenamedEvent: {
            (options?: vimService.vim.DatacenterRenamedEvent): vimService.vim.DatacenterRenamedEvent;
         };
         SessionEvent: {
            (options?: vimService.vim.SessionEvent): vimService.vim.SessionEvent;
         };
         ServerStartedSessionEvent: {
            (options?: vimService.vim.ServerStartedSessionEvent): vimService.vim.ServerStartedSessionEvent;
         };
         UserLoginSessionEvent: {
            (options?: vimService.vim.UserLoginSessionEvent): vimService.vim.UserLoginSessionEvent;
         };
         UserLogoutSessionEvent: {
            (options?: vimService.vim.UserLogoutSessionEvent): vimService.vim.UserLogoutSessionEvent;
         };
         BadUsernameSessionEvent: {
            (options?: vimService.vim.BadUsernameSessionEvent): vimService.vim.BadUsernameSessionEvent;
         };
         AlreadyAuthenticatedSessionEvent: {
            (options?: vimService.vim.AlreadyAuthenticatedSessionEvent): vimService.vim.AlreadyAuthenticatedSessionEvent;
         };
         NoAccessUserEvent: {
            (options?: vimService.vim.NoAccessUserEvent): vimService.vim.NoAccessUserEvent;
         };
         SessionTerminatedEvent: {
            (options?: vimService.vim.SessionTerminatedEvent): vimService.vim.SessionTerminatedEvent;
         };
         GlobalMessageChangedEvent: {
            (options?: vimService.vim.GlobalMessageChangedEvent): vimService.vim.GlobalMessageChangedEvent;
         };
         UpgradeEvent: {
            (options?: vimService.vim.UpgradeEvent): vimService.vim.UpgradeEvent;
         };
         InfoUpgradeEvent: {
            (options?: vimService.vim.InfoUpgradeEvent): vimService.vim.InfoUpgradeEvent;
         };
         WarningUpgradeEvent: {
            (options?: vimService.vim.WarningUpgradeEvent): vimService.vim.WarningUpgradeEvent;
         };
         ErrorUpgradeEvent: {
            (options?: vimService.vim.ErrorUpgradeEvent): vimService.vim.ErrorUpgradeEvent;
         };
         UserUpgradeEvent: {
            (options?: vimService.vim.UserUpgradeEvent): vimService.vim.UserUpgradeEvent;
         };
         HostEvent: {
            (options?: vimService.vim.HostEvent): vimService.vim.HostEvent;
         };
         HostDasEvent: {
            (options?: vimService.vim.HostDasEvent): vimService.vim.HostDasEvent;
         };
         HostConnectedEvent: {
            (options?: vimService.vim.HostConnectedEvent): vimService.vim.HostConnectedEvent;
         };
         HostDisconnectedEventReasonCode: {
            "sslThumbprintVerifyFailed": string;
            "licenseExpired": string;
            "agentUpgrade": string;
            "userRequest": string;
            "insufficientLicenses": string;
            "agentOutOfDate": string;
            "passwordDecryptFailure": string;
            "unknown": string;
            "vcVRAMCapacityExceeded": string;
         };
         HostDisconnectedEvent: {
            (options?: vimService.vim.HostDisconnectedEvent): vimService.vim.HostDisconnectedEvent;
         };
         HostSyncFailedEvent: {
            (options?: vimService.vim.HostSyncFailedEvent): vimService.vim.HostSyncFailedEvent;
         };
         HostConnectionLostEvent: {
            (options?: vimService.vim.HostConnectionLostEvent): vimService.vim.HostConnectionLostEvent;
         };
         HostReconnectionFailedEvent: {
            (options?: vimService.vim.HostReconnectionFailedEvent): vimService.vim.HostReconnectionFailedEvent;
         };
         HostCnxFailedNoConnectionEvent: {
            (options?: vimService.vim.HostCnxFailedNoConnectionEvent): vimService.vim.HostCnxFailedNoConnectionEvent;
         };
         HostCnxFailedBadUsernameEvent: {
            (options?: vimService.vim.HostCnxFailedBadUsernameEvent): vimService.vim.HostCnxFailedBadUsernameEvent;
         };
         HostCnxFailedBadVersionEvent: {
            (options?: vimService.vim.HostCnxFailedBadVersionEvent): vimService.vim.HostCnxFailedBadVersionEvent;
         };
         HostCnxFailedAlreadyManagedEvent: {
            (options?: vimService.vim.HostCnxFailedAlreadyManagedEvent): vimService.vim.HostCnxFailedAlreadyManagedEvent;
         };
         HostCnxFailedNoLicenseEvent: {
            (options?: vimService.vim.HostCnxFailedNoLicenseEvent): vimService.vim.HostCnxFailedNoLicenseEvent;
         };
         HostCnxFailedNetworkErrorEvent: {
            (options?: vimService.vim.HostCnxFailedNetworkErrorEvent): vimService.vim.HostCnxFailedNetworkErrorEvent;
         };
         HostRemovedEvent: {
            (options?: vimService.vim.HostRemovedEvent): vimService.vim.HostRemovedEvent;
         };
         HostCnxFailedCcagentUpgradeEvent: {
            (options?: vimService.vim.HostCnxFailedCcagentUpgradeEvent): vimService.vim.HostCnxFailedCcagentUpgradeEvent;
         };
         HostCnxFailedBadCcagentEvent: {
            (options?: vimService.vim.HostCnxFailedBadCcagentEvent): vimService.vim.HostCnxFailedBadCcagentEvent;
         };
         HostCnxFailedEvent: {
            (options?: vimService.vim.HostCnxFailedEvent): vimService.vim.HostCnxFailedEvent;
         };
         HostCnxFailedAccountFailedEvent: {
            (options?: vimService.vim.HostCnxFailedAccountFailedEvent): vimService.vim.HostCnxFailedAccountFailedEvent;
         };
         HostCnxFailedNoAccessEvent: {
            (options?: vimService.vim.HostCnxFailedNoAccessEvent): vimService.vim.HostCnxFailedNoAccessEvent;
         };
         HostShutdownEvent: {
            (options?: vimService.vim.HostShutdownEvent): vimService.vim.HostShutdownEvent;
         };
         HostCnxFailedNotFoundEvent: {
            (options?: vimService.vim.HostCnxFailedNotFoundEvent): vimService.vim.HostCnxFailedNotFoundEvent;
         };
         HostCnxFailedTimeoutEvent: {
            (options?: vimService.vim.HostCnxFailedTimeoutEvent): vimService.vim.HostCnxFailedTimeoutEvent;
         };
         HostUpgradeFailedEvent: {
            (options?: vimService.vim.HostUpgradeFailedEvent): vimService.vim.HostUpgradeFailedEvent;
         };
         EnteringMaintenanceModeEvent: {
            (options?: vimService.vim.EnteringMaintenanceModeEvent): vimService.vim.EnteringMaintenanceModeEvent;
         };
         EnteredMaintenanceModeEvent: {
            (options?: vimService.vim.EnteredMaintenanceModeEvent): vimService.vim.EnteredMaintenanceModeEvent;
         };
         ExitMaintenanceModeEvent: {
            (options?: vimService.vim.ExitMaintenanceModeEvent): vimService.vim.ExitMaintenanceModeEvent;
         };
         CanceledHostOperationEvent: {
            (options?: vimService.vim.CanceledHostOperationEvent): vimService.vim.CanceledHostOperationEvent;
         };
         TimedOutHostOperationEvent: {
            (options?: vimService.vim.TimedOutHostOperationEvent): vimService.vim.TimedOutHostOperationEvent;
         };
         HostDasEnabledEvent: {
            (options?: vimService.vim.HostDasEnabledEvent): vimService.vim.HostDasEnabledEvent;
         };
         HostDasDisabledEvent: {
            (options?: vimService.vim.HostDasDisabledEvent): vimService.vim.HostDasDisabledEvent;
         };
         HostDasEnablingEvent: {
            (options?: vimService.vim.HostDasEnablingEvent): vimService.vim.HostDasEnablingEvent;
         };
         HostDasDisablingEvent: {
            (options?: vimService.vim.HostDasDisablingEvent): vimService.vim.HostDasDisablingEvent;
         };
         HostDasErrorEventHostDasErrorReason: {
            "configFailed": string;
            "timeout": string;
            "communicationInitFailed": string;
            "healthCheckScriptFailed": string;
            "agentFailed": string;
            "agentShutdown": string;
            "isolationAddressUnpingable": string;
            "other": string;
         };
         HostDasErrorEvent: {
            (options?: vimService.vim.HostDasErrorEvent): vimService.vim.HostDasErrorEvent;
         };
         HostDasOkEvent: {
            (options?: vimService.vim.HostDasOkEvent): vimService.vim.HostDasOkEvent;
         };
         VcAgentUpgradedEvent: {
            (options?: vimService.vim.VcAgentUpgradedEvent): vimService.vim.VcAgentUpgradedEvent;
         };
         VcAgentUninstalledEvent: {
            (options?: vimService.vim.VcAgentUninstalledEvent): vimService.vim.VcAgentUninstalledEvent;
         };
         VcAgentUpgradeFailedEvent: {
            (options?: vimService.vim.VcAgentUpgradeFailedEvent): vimService.vim.VcAgentUpgradeFailedEvent;
         };
         VcAgentUninstallFailedEvent: {
            (options?: vimService.vim.VcAgentUninstallFailedEvent): vimService.vim.VcAgentUninstallFailedEvent;
         };
         HostAddedEvent: {
            (options?: vimService.vim.HostAddedEvent): vimService.vim.HostAddedEvent;
         };
         HostAddFailedEvent: {
            (options?: vimService.vim.HostAddFailedEvent): vimService.vim.HostAddFailedEvent;
         };
         HostIpChangedEvent: {
            (options?: vimService.vim.HostIpChangedEvent): vimService.vim.HostIpChangedEvent;
         };
         EnteringStandbyModeEvent: {
            (options?: vimService.vim.EnteringStandbyModeEvent): vimService.vim.EnteringStandbyModeEvent;
         };
         DrsEnteringStandbyModeEvent: {
            (options?: vimService.vim.DrsEnteringStandbyModeEvent): vimService.vim.DrsEnteringStandbyModeEvent;
         };
         EnteredStandbyModeEvent: {
            (options?: vimService.vim.EnteredStandbyModeEvent): vimService.vim.EnteredStandbyModeEvent;
         };
         DrsEnteredStandbyModeEvent: {
            (options?: vimService.vim.DrsEnteredStandbyModeEvent): vimService.vim.DrsEnteredStandbyModeEvent;
         };
         ExitingStandbyModeEvent: {
            (options?: vimService.vim.ExitingStandbyModeEvent): vimService.vim.ExitingStandbyModeEvent;
         };
         DrsExitingStandbyModeEvent: {
            (options?: vimService.vim.DrsExitingStandbyModeEvent): vimService.vim.DrsExitingStandbyModeEvent;
         };
         ExitedStandbyModeEvent: {
            (options?: vimService.vim.ExitedStandbyModeEvent): vimService.vim.ExitedStandbyModeEvent;
         };
         DrsExitedStandbyModeEvent: {
            (options?: vimService.vim.DrsExitedStandbyModeEvent): vimService.vim.DrsExitedStandbyModeEvent;
         };
         ExitStandbyModeFailedEvent: {
            (options?: vimService.vim.ExitStandbyModeFailedEvent): vimService.vim.ExitStandbyModeFailedEvent;
         };
         DrsExitStandbyModeFailedEvent: {
            (options?: vimService.vim.DrsExitStandbyModeFailedEvent): vimService.vim.DrsExitStandbyModeFailedEvent;
         };
         UpdatedAgentBeingRestartedEvent: {
            (options?: vimService.vim.UpdatedAgentBeingRestartedEvent): vimService.vim.UpdatedAgentBeingRestartedEvent;
         };
         AccountCreatedEvent: {
            (options?: vimService.vim.AccountCreatedEvent): vimService.vim.AccountCreatedEvent;
         };
         AccountRemovedEvent: {
            (options?: vimService.vim.AccountRemovedEvent): vimService.vim.AccountRemovedEvent;
         };
         UserPasswordChanged: {
            (options?: vimService.vim.UserPasswordChanged): vimService.vim.UserPasswordChanged;
         };
         AccountUpdatedEvent: {
            (options?: vimService.vim.AccountUpdatedEvent): vimService.vim.AccountUpdatedEvent;
         };
         UserAssignedToGroup: {
            (options?: vimService.vim.UserAssignedToGroup): vimService.vim.UserAssignedToGroup;
         };
         UserUnassignedFromGroup: {
            (options?: vimService.vim.UserUnassignedFromGroup): vimService.vim.UserUnassignedFromGroup;
         };
         DatastorePrincipalConfigured: {
            (options?: vimService.vim.DatastorePrincipalConfigured): vimService.vim.DatastorePrincipalConfigured;
         };
         VMFSDatastoreCreatedEvent: {
            (options?: vimService.vim.VMFSDatastoreCreatedEvent): vimService.vim.VMFSDatastoreCreatedEvent;
         };
         NASDatastoreCreatedEvent: {
            (options?: vimService.vim.NASDatastoreCreatedEvent): vimService.vim.NASDatastoreCreatedEvent;
         };
         LocalDatastoreCreatedEvent: {
            (options?: vimService.vim.LocalDatastoreCreatedEvent): vimService.vim.LocalDatastoreCreatedEvent;
         };
         VMFSDatastoreExtendedEvent: {
            (options?: vimService.vim.VMFSDatastoreExtendedEvent): vimService.vim.VMFSDatastoreExtendedEvent;
         };
         VMFSDatastoreExpandedEvent: {
            (options?: vimService.vim.VMFSDatastoreExpandedEvent): vimService.vim.VMFSDatastoreExpandedEvent;
         };
         DatastoreRemovedOnHostEvent: {
            (options?: vimService.vim.DatastoreRemovedOnHostEvent): vimService.vim.DatastoreRemovedOnHostEvent;
         };
         DatastoreRenamedOnHostEvent: {
            (options?: vimService.vim.DatastoreRenamedOnHostEvent): vimService.vim.DatastoreRenamedOnHostEvent;
         };
         DuplicateIpDetectedEvent: {
            (options?: vimService.vim.DuplicateIpDetectedEvent): vimService.vim.DuplicateIpDetectedEvent;
         };
         DatastoreDiscoveredEvent: {
            (options?: vimService.vim.DatastoreDiscoveredEvent): vimService.vim.DatastoreDiscoveredEvent;
         };
         DrsResourceConfigureFailedEvent: {
            (options?: vimService.vim.DrsResourceConfigureFailedEvent): vimService.vim.DrsResourceConfigureFailedEvent;
         };
         DrsResourceConfigureSyncedEvent: {
            (options?: vimService.vim.DrsResourceConfigureSyncedEvent): vimService.vim.DrsResourceConfigureSyncedEvent;
         };
         HostGetShortNameFailedEvent: {
            (options?: vimService.vim.HostGetShortNameFailedEvent): vimService.vim.HostGetShortNameFailedEvent;
         };
         HostShortNameToIpFailedEvent: {
            (options?: vimService.vim.HostShortNameToIpFailedEvent): vimService.vim.HostShortNameToIpFailedEvent;
         };
         HostIpToShortNameFailedEvent: {
            (options?: vimService.vim.HostIpToShortNameFailedEvent): vimService.vim.HostIpToShortNameFailedEvent;
         };
         HostPrimaryAgentNotShortNameEvent: {
            (options?: vimService.vim.HostPrimaryAgentNotShortNameEvent): vimService.vim.HostPrimaryAgentNotShortNameEvent;
         };
         HostNotInClusterEvent: {
            (options?: vimService.vim.HostNotInClusterEvent): vimService.vim.HostNotInClusterEvent;
         };
         HostIsolationIpPingFailedEvent: {
            (options?: vimService.vim.HostIsolationIpPingFailedEvent): vimService.vim.HostIsolationIpPingFailedEvent;
         };
         HostIpInconsistentEvent: {
            (options?: vimService.vim.HostIpInconsistentEvent): vimService.vim.HostIpInconsistentEvent;
         };
         HostUserWorldSwapNotEnabledEvent: {
            (options?: vimService.vim.HostUserWorldSwapNotEnabledEvent): vimService.vim.HostUserWorldSwapNotEnabledEvent;
         };
         HostNonCompliantEvent: {
            (options?: vimService.vim.HostNonCompliantEvent): vimService.vim.HostNonCompliantEvent;
         };
         HostCompliantEvent: {
            (options?: vimService.vim.HostCompliantEvent): vimService.vim.HostCompliantEvent;
         };
         HostComplianceCheckedEvent: {
            (options?: vimService.vim.HostComplianceCheckedEvent): vimService.vim.HostComplianceCheckedEvent;
         };
         ClusterComplianceCheckedEvent: {
            (options?: vimService.vim.ClusterComplianceCheckedEvent): vimService.vim.ClusterComplianceCheckedEvent;
         };
         ProfileEvent: {
            (options?: vimService.vim.ProfileEvent): vimService.vim.ProfileEvent;
         };
         ProfileCreatedEvent: {
            (options?: vimService.vim.ProfileCreatedEvent): vimService.vim.ProfileCreatedEvent;
         };
         ProfileRemovedEvent: {
            (options?: vimService.vim.ProfileRemovedEvent): vimService.vim.ProfileRemovedEvent;
         };
         ProfileAssociatedEvent: {
            (options?: vimService.vim.ProfileAssociatedEvent): vimService.vim.ProfileAssociatedEvent;
         };
         ProfileDissociatedEvent: {
            (options?: vimService.vim.ProfileDissociatedEvent): vimService.vim.ProfileDissociatedEvent;
         };
         HostConfigAppliedEvent: {
            (options?: vimService.vim.HostConfigAppliedEvent): vimService.vim.HostConfigAppliedEvent;
         };
         ProfileReferenceHostChangedEvent: {
            (options?: vimService.vim.ProfileReferenceHostChangedEvent): vimService.vim.ProfileReferenceHostChangedEvent;
         };
         ProfileChangedEvent: {
            (options?: vimService.vim.ProfileChangedEvent): vimService.vim.ProfileChangedEvent;
         };
         HostProfileAppliedEvent: {
            (options?: vimService.vim.HostProfileAppliedEvent): vimService.vim.HostProfileAppliedEvent;
         };
         HostShortNameInconsistentEvent: {
            (options?: vimService.vim.HostShortNameInconsistentEvent): vimService.vim.HostShortNameInconsistentEvent;
         };
         HostNoRedundantManagementNetworkEvent: {
            (options?: vimService.vim.HostNoRedundantManagementNetworkEvent): vimService.vim.HostNoRedundantManagementNetworkEvent;
         };
         HostNoAvailableNetworksEvent: {
            (options?: vimService.vim.HostNoAvailableNetworksEvent): vimService.vim.HostNoAvailableNetworksEvent;
         };
         HostExtraNetworksEvent: {
            (options?: vimService.vim.HostExtraNetworksEvent): vimService.vim.HostExtraNetworksEvent;
         };
         HostNoHAEnabledPortGroupsEvent: {
            (options?: vimService.vim.HostNoHAEnabledPortGroupsEvent): vimService.vim.HostNoHAEnabledPortGroupsEvent;
         };
         HostMissingNetworksEvent: {
            (options?: vimService.vim.HostMissingNetworksEvent): vimService.vim.HostMissingNetworksEvent;
         };
         VnicPortArgument: {
            (options?: vimService.vim.VnicPortArgument): vimService.vim.VnicPortArgument;
         };
         ArrayOfVnicPortArgument: {
            (options?: vimService.vim.ArrayOfVnicPortArgument): vimService.vim.ArrayOfVnicPortArgument;
         };
         HostVnicConnectedToCustomizedDVPortEvent: {
            (options?: vimService.vim.HostVnicConnectedToCustomizedDVPortEvent): vimService.vim.HostVnicConnectedToCustomizedDVPortEvent;
         };
         GhostDvsProxySwitchDetectedEvent: {
            (options?: vimService.vim.GhostDvsProxySwitchDetectedEvent): vimService.vim.GhostDvsProxySwitchDetectedEvent;
         };
         GhostDvsProxySwitchRemovedEvent: {
            (options?: vimService.vim.GhostDvsProxySwitchRemovedEvent): vimService.vim.GhostDvsProxySwitchRemovedEvent;
         };
         VmEvent: {
            (options?: vimService.vim.VmEvent): vimService.vim.VmEvent;
         };
         VmPoweredOffEvent: {
            (options?: vimService.vim.VmPoweredOffEvent): vimService.vim.VmPoweredOffEvent;
         };
         VmPoweredOnEvent: {
            (options?: vimService.vim.VmPoweredOnEvent): vimService.vim.VmPoweredOnEvent;
         };
         VmSuspendedEvent: {
            (options?: vimService.vim.VmSuspendedEvent): vimService.vim.VmSuspendedEvent;
         };
         VmStartingEvent: {
            (options?: vimService.vim.VmStartingEvent): vimService.vim.VmStartingEvent;
         };
         VmStoppingEvent: {
            (options?: vimService.vim.VmStoppingEvent): vimService.vim.VmStoppingEvent;
         };
         VmSuspendingEvent: {
            (options?: vimService.vim.VmSuspendingEvent): vimService.vim.VmSuspendingEvent;
         };
         VmResumingEvent: {
            (options?: vimService.vim.VmResumingEvent): vimService.vim.VmResumingEvent;
         };
         VmDisconnectedEvent: {
            (options?: vimService.vim.VmDisconnectedEvent): vimService.vim.VmDisconnectedEvent;
         };
         VmRemoteConsoleConnectedEvent: {
            (options?: vimService.vim.VmRemoteConsoleConnectedEvent): vimService.vim.VmRemoteConsoleConnectedEvent;
         };
         VmRemoteConsoleDisconnectedEvent: {
            (options?: vimService.vim.VmRemoteConsoleDisconnectedEvent): vimService.vim.VmRemoteConsoleDisconnectedEvent;
         };
         VmDiscoveredEvent: {
            (options?: vimService.vim.VmDiscoveredEvent): vimService.vim.VmDiscoveredEvent;
         };
         VmOrphanedEvent: {
            (options?: vimService.vim.VmOrphanedEvent): vimService.vim.VmOrphanedEvent;
         };
         VmBeingCreatedEvent: {
            (options?: vimService.vim.VmBeingCreatedEvent): vimService.vim.VmBeingCreatedEvent;
         };
         VmCreatedEvent: {
            (options?: vimService.vim.VmCreatedEvent): vimService.vim.VmCreatedEvent;
         };
         VmStartRecordingEvent: {
            (options?: vimService.vim.VmStartRecordingEvent): vimService.vim.VmStartRecordingEvent;
         };
         VmEndRecordingEvent: {
            (options?: vimService.vim.VmEndRecordingEvent): vimService.vim.VmEndRecordingEvent;
         };
         VmStartReplayingEvent: {
            (options?: vimService.vim.VmStartReplayingEvent): vimService.vim.VmStartReplayingEvent;
         };
         VmEndReplayingEvent: {
            (options?: vimService.vim.VmEndReplayingEvent): vimService.vim.VmEndReplayingEvent;
         };
         VmRegisteredEvent: {
            (options?: vimService.vim.VmRegisteredEvent): vimService.vim.VmRegisteredEvent;
         };
         VmAutoRenameEvent: {
            (options?: vimService.vim.VmAutoRenameEvent): vimService.vim.VmAutoRenameEvent;
         };
         VmBeingHotMigratedEvent: {
            (options?: vimService.vim.VmBeingHotMigratedEvent): vimService.vim.VmBeingHotMigratedEvent;
         };
         VmResettingEvent: {
            (options?: vimService.vim.VmResettingEvent): vimService.vim.VmResettingEvent;
         };
         VmStaticMacConflictEvent: {
            (options?: vimService.vim.VmStaticMacConflictEvent): vimService.vim.VmStaticMacConflictEvent;
         };
         VmMacConflictEvent: {
            (options?: vimService.vim.VmMacConflictEvent): vimService.vim.VmMacConflictEvent;
         };
         VmBeingDeployedEvent: {
            (options?: vimService.vim.VmBeingDeployedEvent): vimService.vim.VmBeingDeployedEvent;
         };
         VmDeployFailedEvent: {
            (options?: vimService.vim.VmDeployFailedEvent): vimService.vim.VmDeployFailedEvent;
         };
         VmDeployedEvent: {
            (options?: vimService.vim.VmDeployedEvent): vimService.vim.VmDeployedEvent;
         };
         VmMacChangedEvent: {
            (options?: vimService.vim.VmMacChangedEvent): vimService.vim.VmMacChangedEvent;
         };
         VmMacAssignedEvent: {
            (options?: vimService.vim.VmMacAssignedEvent): vimService.vim.VmMacAssignedEvent;
         };
         VmUuidConflictEvent: {
            (options?: vimService.vim.VmUuidConflictEvent): vimService.vim.VmUuidConflictEvent;
         };
         VmInstanceUuidConflictEvent: {
            (options?: vimService.vim.VmInstanceUuidConflictEvent): vimService.vim.VmInstanceUuidConflictEvent;
         };
         VmBeingMigratedEvent: {
            (options?: vimService.vim.VmBeingMigratedEvent): vimService.vim.VmBeingMigratedEvent;
         };
         VmFailedMigrateEvent: {
            (options?: vimService.vim.VmFailedMigrateEvent): vimService.vim.VmFailedMigrateEvent;
         };
         VmMigratedEvent: {
            (options?: vimService.vim.VmMigratedEvent): vimService.vim.VmMigratedEvent;
         };
         VmUnsupportedStartingEvent: {
            (options?: vimService.vim.VmUnsupportedStartingEvent): vimService.vim.VmUnsupportedStartingEvent;
         };
         DrsVmMigratedEvent: {
            (options?: vimService.vim.DrsVmMigratedEvent): vimService.vim.DrsVmMigratedEvent;
         };
         DrsVmPoweredOnEvent: {
            (options?: vimService.vim.DrsVmPoweredOnEvent): vimService.vim.DrsVmPoweredOnEvent;
         };
         DrsRuleViolationEvent: {
            (options?: vimService.vim.DrsRuleViolationEvent): vimService.vim.DrsRuleViolationEvent;
         };
         DrsSoftRuleViolationEvent: {
            (options?: vimService.vim.DrsSoftRuleViolationEvent): vimService.vim.DrsSoftRuleViolationEvent;
         };
         DrsRuleComplianceEvent: {
            (options?: vimService.vim.DrsRuleComplianceEvent): vimService.vim.DrsRuleComplianceEvent;
         };
         VmRelocateSpecEvent: {
            (options?: vimService.vim.VmRelocateSpecEvent): vimService.vim.VmRelocateSpecEvent;
         };
         VmBeingRelocatedEvent: {
            (options?: vimService.vim.VmBeingRelocatedEvent): vimService.vim.VmBeingRelocatedEvent;
         };
         VmRelocatedEvent: {
            (options?: vimService.vim.VmRelocatedEvent): vimService.vim.VmRelocatedEvent;
         };
         VmRelocateFailedEvent: {
            (options?: vimService.vim.VmRelocateFailedEvent): vimService.vim.VmRelocateFailedEvent;
         };
         VmEmigratingEvent: {
            (options?: vimService.vim.VmEmigratingEvent): vimService.vim.VmEmigratingEvent;
         };
         VmCloneEvent: {
            (options?: vimService.vim.VmCloneEvent): vimService.vim.VmCloneEvent;
         };
         VmBeingClonedEvent: {
            (options?: vimService.vim.VmBeingClonedEvent): vimService.vim.VmBeingClonedEvent;
         };
         VmBeingClonedNoFolderEvent: {
            (options?: vimService.vim.VmBeingClonedNoFolderEvent): vimService.vim.VmBeingClonedNoFolderEvent;
         };
         VmCloneFailedEvent: {
            (options?: vimService.vim.VmCloneFailedEvent): vimService.vim.VmCloneFailedEvent;
         };
         VmClonedEvent: {
            (options?: vimService.vim.VmClonedEvent): vimService.vim.VmClonedEvent;
         };
         VmResourceReallocatedEvent: {
            (options?: vimService.vim.VmResourceReallocatedEvent): vimService.vim.VmResourceReallocatedEvent;
         };
         VmRenamedEvent: {
            (options?: vimService.vim.VmRenamedEvent): vimService.vim.VmRenamedEvent;
         };
         VmDateRolledBackEvent: {
            (options?: vimService.vim.VmDateRolledBackEvent): vimService.vim.VmDateRolledBackEvent;
         };
         VmNoNetworkAccessEvent: {
            (options?: vimService.vim.VmNoNetworkAccessEvent): vimService.vim.VmNoNetworkAccessEvent;
         };
         VmDiskFailedEvent: {
            (options?: vimService.vim.VmDiskFailedEvent): vimService.vim.VmDiskFailedEvent;
         };
         VmFailedToPowerOnEvent: {
            (options?: vimService.vim.VmFailedToPowerOnEvent): vimService.vim.VmFailedToPowerOnEvent;
         };
         VmFailedToPowerOffEvent: {
            (options?: vimService.vim.VmFailedToPowerOffEvent): vimService.vim.VmFailedToPowerOffEvent;
         };
         VmFailedToSuspendEvent: {
            (options?: vimService.vim.VmFailedToSuspendEvent): vimService.vim.VmFailedToSuspendEvent;
         };
         VmFailedToResetEvent: {
            (options?: vimService.vim.VmFailedToResetEvent): vimService.vim.VmFailedToResetEvent;
         };
         VmFailedToShutdownGuestEvent: {
            (options?: vimService.vim.VmFailedToShutdownGuestEvent): vimService.vim.VmFailedToShutdownGuestEvent;
         };
         VmFailedToRebootGuestEvent: {
            (options?: vimService.vim.VmFailedToRebootGuestEvent): vimService.vim.VmFailedToRebootGuestEvent;
         };
         VmFailedToStandbyGuestEvent: {
            (options?: vimService.vim.VmFailedToStandbyGuestEvent): vimService.vim.VmFailedToStandbyGuestEvent;
         };
         VmRemovedEvent: {
            (options?: vimService.vim.VmRemovedEvent): vimService.vim.VmRemovedEvent;
         };
         VmGuestShutdownEvent: {
            (options?: vimService.vim.VmGuestShutdownEvent): vimService.vim.VmGuestShutdownEvent;
         };
         VmGuestRebootEvent: {
            (options?: vimService.vim.VmGuestRebootEvent): vimService.vim.VmGuestRebootEvent;
         };
         VmGuestStandbyEvent: {
            (options?: vimService.vim.VmGuestStandbyEvent): vimService.vim.VmGuestStandbyEvent;
         };
         VmUpgradingEvent: {
            (options?: vimService.vim.VmUpgradingEvent): vimService.vim.VmUpgradingEvent;
         };
         VmUpgradeCompleteEvent: {
            (options?: vimService.vim.VmUpgradeCompleteEvent): vimService.vim.VmUpgradeCompleteEvent;
         };
         VmUpgradeFailedEvent: {
            (options?: vimService.vim.VmUpgradeFailedEvent): vimService.vim.VmUpgradeFailedEvent;
         };
         VmRestartedOnAlternateHostEvent: {
            (options?: vimService.vim.VmRestartedOnAlternateHostEvent): vimService.vim.VmRestartedOnAlternateHostEvent;
         };
         VmReconfiguredEvent: {
            (options?: vimService.vim.VmReconfiguredEvent): vimService.vim.VmReconfiguredEvent;
         };
         VmMessageEvent: {
            (options?: vimService.vim.VmMessageEvent): vimService.vim.VmMessageEvent;
         };
         VmMessageWarningEvent: {
            (options?: vimService.vim.VmMessageWarningEvent): vimService.vim.VmMessageWarningEvent;
         };
         VmMessageErrorEvent: {
            (options?: vimService.vim.VmMessageErrorEvent): vimService.vim.VmMessageErrorEvent;
         };
         VmConfigMissingEvent: {
            (options?: vimService.vim.VmConfigMissingEvent): vimService.vim.VmConfigMissingEvent;
         };
         VmPowerOffOnIsolationEvent: {
            (options?: vimService.vim.VmPowerOffOnIsolationEvent): vimService.vim.VmPowerOffOnIsolationEvent;
         };
         VmShutdownOnIsolationEventOperation: {
            "shutdown": string;
            "poweredOff": string;
         };
         VmShutdownOnIsolationEvent: {
            (options?: vimService.vim.VmShutdownOnIsolationEvent): vimService.vim.VmShutdownOnIsolationEvent;
         };
         VmFailoverFailed: {
            (options?: vimService.vim.VmFailoverFailed): vimService.vim.VmFailoverFailed;
         };
         VmDasBeingResetEventReasonCode: {
            "vmtoolsHeartbeatFailure": string;
            "appHeartbeatFailure": string;
            "appImmediateResetRequest": string;
            "vmcpResetApdCleared": string;
         };
         VmDasBeingResetEvent: {
            (options?: vimService.vim.VmDasBeingResetEvent): vimService.vim.VmDasBeingResetEvent;
         };
         VmDasResetFailedEvent: {
            (options?: vimService.vim.VmDasResetFailedEvent): vimService.vim.VmDasResetFailedEvent;
         };
         VmMaxRestartCountReached: {
            (options?: vimService.vim.VmMaxRestartCountReached): vimService.vim.VmMaxRestartCountReached;
         };
         VmMaxFTRestartCountReached: {
            (options?: vimService.vim.VmMaxFTRestartCountReached): vimService.vim.VmMaxFTRestartCountReached;
         };
         VmDasBeingResetWithScreenshotEvent: {
            (options?: vimService.vim.VmDasBeingResetWithScreenshotEvent): vimService.vim.VmDasBeingResetWithScreenshotEvent;
         };
         NotEnoughResourcesToStartVmEvent: {
            (options?: vimService.vim.NotEnoughResourcesToStartVmEvent): vimService.vim.NotEnoughResourcesToStartVmEvent;
         };
         VmUuidAssignedEvent: {
            (options?: vimService.vim.VmUuidAssignedEvent): vimService.vim.VmUuidAssignedEvent;
         };
         VmInstanceUuidAssignedEvent: {
            (options?: vimService.vim.VmInstanceUuidAssignedEvent): vimService.vim.VmInstanceUuidAssignedEvent;
         };
         VmUuidChangedEvent: {
            (options?: vimService.vim.VmUuidChangedEvent): vimService.vim.VmUuidChangedEvent;
         };
         VmInstanceUuidChangedEvent: {
            (options?: vimService.vim.VmInstanceUuidChangedEvent): vimService.vim.VmInstanceUuidChangedEvent;
         };
         VmWwnConflictEvent: {
            (options?: vimService.vim.VmWwnConflictEvent): vimService.vim.VmWwnConflictEvent;
         };
         VmAcquiredMksTicketEvent: {
            (options?: vimService.vim.VmAcquiredMksTicketEvent): vimService.vim.VmAcquiredMksTicketEvent;
         };
         VmAcquiredTicketEvent: {
            (options?: vimService.vim.VmAcquiredTicketEvent): vimService.vim.VmAcquiredTicketEvent;
         };
         VmGuestOSCrashedEvent: {
            (options?: vimService.vim.VmGuestOSCrashedEvent): vimService.vim.VmGuestOSCrashedEvent;
         };
         HostWwnConflictEvent: {
            (options?: vimService.vim.HostWwnConflictEvent): vimService.vim.HostWwnConflictEvent;
         };
         VmWwnAssignedEvent: {
            (options?: vimService.vim.VmWwnAssignedEvent): vimService.vim.VmWwnAssignedEvent;
         };
         VmWwnChangedEvent: {
            (options?: vimService.vim.VmWwnChangedEvent): vimService.vim.VmWwnChangedEvent;
         };
         VmSecondaryAddedEvent: {
            (options?: vimService.vim.VmSecondaryAddedEvent): vimService.vim.VmSecondaryAddedEvent;
         };
         VmFaultToleranceTurnedOffEvent: {
            (options?: vimService.vim.VmFaultToleranceTurnedOffEvent): vimService.vim.VmFaultToleranceTurnedOffEvent;
         };
         VmFaultToleranceStateChangedEvent: {
            (options?: vimService.vim.VmFaultToleranceStateChangedEvent): vimService.vim.VmFaultToleranceStateChangedEvent;
         };
         VmSecondaryDisabledEvent: {
            (options?: vimService.vim.VmSecondaryDisabledEvent): vimService.vim.VmSecondaryDisabledEvent;
         };
         VmSecondaryDisabledBySystemEvent: {
            (options?: vimService.vim.VmSecondaryDisabledBySystemEvent): vimService.vim.VmSecondaryDisabledBySystemEvent;
         };
         VmSecondaryEnabledEvent: {
            (options?: vimService.vim.VmSecondaryEnabledEvent): vimService.vim.VmSecondaryEnabledEvent;
         };
         VmStartingSecondaryEvent: {
            (options?: vimService.vim.VmStartingSecondaryEvent): vimService.vim.VmStartingSecondaryEvent;
         };
         VmSecondaryStartedEvent: {
            (options?: vimService.vim.VmSecondaryStartedEvent): vimService.vim.VmSecondaryStartedEvent;
         };
         VmFailedUpdatingSecondaryConfig: {
            (options?: vimService.vim.VmFailedUpdatingSecondaryConfig): vimService.vim.VmFailedUpdatingSecondaryConfig;
         };
         VmFailedStartingSecondaryEventFailureReason: {
            "incompatibleHost": string;
            "loginFailed": string;
            "registerVmFailed": string;
            "migrateFailed": string;
         };
         VmFailedStartingSecondaryEvent: {
            (options?: vimService.vim.VmFailedStartingSecondaryEvent): vimService.vim.VmFailedStartingSecondaryEvent;
         };
         VmTimedoutStartingSecondaryEvent: {
            (options?: vimService.vim.VmTimedoutStartingSecondaryEvent): vimService.vim.VmTimedoutStartingSecondaryEvent;
         };
         VmNoCompatibleHostForSecondaryEvent: {
            (options?: vimService.vim.VmNoCompatibleHostForSecondaryEvent): vimService.vim.VmNoCompatibleHostForSecondaryEvent;
         };
         VmPrimaryFailoverEvent: {
            (options?: vimService.vim.VmPrimaryFailoverEvent): vimService.vim.VmPrimaryFailoverEvent;
         };
         VmFaultToleranceVmTerminatedEvent: {
            (options?: vimService.vim.VmFaultToleranceVmTerminatedEvent): vimService.vim.VmFaultToleranceVmTerminatedEvent;
         };
         HostWwnChangedEvent: {
            (options?: vimService.vim.HostWwnChangedEvent): vimService.vim.HostWwnChangedEvent;
         };
         HostAdminDisableEvent: {
            (options?: vimService.vim.HostAdminDisableEvent): vimService.vim.HostAdminDisableEvent;
         };
         HostAdminEnableEvent: {
            (options?: vimService.vim.HostAdminEnableEvent): vimService.vim.HostAdminEnableEvent;
         };
         HostEnableAdminFailedEvent: {
            (options?: vimService.vim.HostEnableAdminFailedEvent): vimService.vim.HostEnableAdminFailedEvent;
         };
         VmFailedRelayoutOnVmfs2DatastoreEvent: {
            (options?: vimService.vim.VmFailedRelayoutOnVmfs2DatastoreEvent): vimService.vim.VmFailedRelayoutOnVmfs2DatastoreEvent;
         };
         VmFailedRelayoutEvent: {
            (options?: vimService.vim.VmFailedRelayoutEvent): vimService.vim.VmFailedRelayoutEvent;
         };
         VmRelayoutSuccessfulEvent: {
            (options?: vimService.vim.VmRelayoutSuccessfulEvent): vimService.vim.VmRelayoutSuccessfulEvent;
         };
         VmRelayoutUpToDateEvent: {
            (options?: vimService.vim.VmRelayoutUpToDateEvent): vimService.vim.VmRelayoutUpToDateEvent;
         };
         VmConnectedEvent: {
            (options?: vimService.vim.VmConnectedEvent): vimService.vim.VmConnectedEvent;
         };
         VmPoweringOnWithCustomizedDVPortEvent: {
            (options?: vimService.vim.VmPoweringOnWithCustomizedDVPortEvent): vimService.vim.VmPoweringOnWithCustomizedDVPortEvent;
         };
         VmDasUpdateErrorEvent: {
            (options?: vimService.vim.VmDasUpdateErrorEvent): vimService.vim.VmDasUpdateErrorEvent;
         };
         NoMaintenanceModeDrsRecommendationForVM: {
            (options?: vimService.vim.NoMaintenanceModeDrsRecommendationForVM): vimService.vim.NoMaintenanceModeDrsRecommendationForVM;
         };
         VmDasUpdateOkEvent: {
            (options?: vimService.vim.VmDasUpdateOkEvent): vimService.vim.VmDasUpdateOkEvent;
         };
         ScheduledTaskEvent: {
            (options?: vimService.vim.ScheduledTaskEvent): vimService.vim.ScheduledTaskEvent;
         };
         ScheduledTaskCreatedEvent: {
            (options?: vimService.vim.ScheduledTaskCreatedEvent): vimService.vim.ScheduledTaskCreatedEvent;
         };
         ScheduledTaskStartedEvent: {
            (options?: vimService.vim.ScheduledTaskStartedEvent): vimService.vim.ScheduledTaskStartedEvent;
         };
         ScheduledTaskRemovedEvent: {
            (options?: vimService.vim.ScheduledTaskRemovedEvent): vimService.vim.ScheduledTaskRemovedEvent;
         };
         ScheduledTaskReconfiguredEvent: {
            (options?: vimService.vim.ScheduledTaskReconfiguredEvent): vimService.vim.ScheduledTaskReconfiguredEvent;
         };
         ScheduledTaskCompletedEvent: {
            (options?: vimService.vim.ScheduledTaskCompletedEvent): vimService.vim.ScheduledTaskCompletedEvent;
         };
         ScheduledTaskFailedEvent: {
            (options?: vimService.vim.ScheduledTaskFailedEvent): vimService.vim.ScheduledTaskFailedEvent;
         };
         ScheduledTaskEmailCompletedEvent: {
            (options?: vimService.vim.ScheduledTaskEmailCompletedEvent): vimService.vim.ScheduledTaskEmailCompletedEvent;
         };
         ScheduledTaskEmailFailedEvent: {
            (options?: vimService.vim.ScheduledTaskEmailFailedEvent): vimService.vim.ScheduledTaskEmailFailedEvent;
         };
         AlarmEvent: {
            (options?: vimService.vim.AlarmEvent): vimService.vim.AlarmEvent;
         };
         AlarmCreatedEvent: {
            (options?: vimService.vim.AlarmCreatedEvent): vimService.vim.AlarmCreatedEvent;
         };
         AlarmStatusChangedEvent: {
            (options?: vimService.vim.AlarmStatusChangedEvent): vimService.vim.AlarmStatusChangedEvent;
         };
         AlarmActionTriggeredEvent: {
            (options?: vimService.vim.AlarmActionTriggeredEvent): vimService.vim.AlarmActionTriggeredEvent;
         };
         AlarmEmailCompletedEvent: {
            (options?: vimService.vim.AlarmEmailCompletedEvent): vimService.vim.AlarmEmailCompletedEvent;
         };
         AlarmEmailFailedEvent: {
            (options?: vimService.vim.AlarmEmailFailedEvent): vimService.vim.AlarmEmailFailedEvent;
         };
         AlarmSnmpCompletedEvent: {
            (options?: vimService.vim.AlarmSnmpCompletedEvent): vimService.vim.AlarmSnmpCompletedEvent;
         };
         AlarmSnmpFailedEvent: {
            (options?: vimService.vim.AlarmSnmpFailedEvent): vimService.vim.AlarmSnmpFailedEvent;
         };
         AlarmScriptCompleteEvent: {
            (options?: vimService.vim.AlarmScriptCompleteEvent): vimService.vim.AlarmScriptCompleteEvent;
         };
         AlarmScriptFailedEvent: {
            (options?: vimService.vim.AlarmScriptFailedEvent): vimService.vim.AlarmScriptFailedEvent;
         };
         AlarmRemovedEvent: {
            (options?: vimService.vim.AlarmRemovedEvent): vimService.vim.AlarmRemovedEvent;
         };
         AlarmReconfiguredEvent: {
            (options?: vimService.vim.AlarmReconfiguredEvent): vimService.vim.AlarmReconfiguredEvent;
         };
         AlarmAcknowledgedEvent: {
            (options?: vimService.vim.AlarmAcknowledgedEvent): vimService.vim.AlarmAcknowledgedEvent;
         };
         AlarmClearedEvent: {
            (options?: vimService.vim.AlarmClearedEvent): vimService.vim.AlarmClearedEvent;
         };
         CustomFieldEvent: {
            (options?: vimService.vim.CustomFieldEvent): vimService.vim.CustomFieldEvent;
         };
         CustomFieldDefEvent: {
            (options?: vimService.vim.CustomFieldDefEvent): vimService.vim.CustomFieldDefEvent;
         };
         CustomFieldDefAddedEvent: {
            (options?: vimService.vim.CustomFieldDefAddedEvent): vimService.vim.CustomFieldDefAddedEvent;
         };
         CustomFieldDefRemovedEvent: {
            (options?: vimService.vim.CustomFieldDefRemovedEvent): vimService.vim.CustomFieldDefRemovedEvent;
         };
         CustomFieldDefRenamedEvent: {
            (options?: vimService.vim.CustomFieldDefRenamedEvent): vimService.vim.CustomFieldDefRenamedEvent;
         };
         CustomFieldValueChangedEvent: {
            (options?: vimService.vim.CustomFieldValueChangedEvent): vimService.vim.CustomFieldValueChangedEvent;
         };
         AuthorizationEvent: {
            (options?: vimService.vim.AuthorizationEvent): vimService.vim.AuthorizationEvent;
         };
         PermissionEvent: {
            (options?: vimService.vim.PermissionEvent): vimService.vim.PermissionEvent;
         };
         PermissionAddedEvent: {
            (options?: vimService.vim.PermissionAddedEvent): vimService.vim.PermissionAddedEvent;
         };
         PermissionUpdatedEvent: {
            (options?: vimService.vim.PermissionUpdatedEvent): vimService.vim.PermissionUpdatedEvent;
         };
         PermissionRemovedEvent: {
            (options?: vimService.vim.PermissionRemovedEvent): vimService.vim.PermissionRemovedEvent;
         };
         RoleEvent: {
            (options?: vimService.vim.RoleEvent): vimService.vim.RoleEvent;
         };
         RoleAddedEvent: {
            (options?: vimService.vim.RoleAddedEvent): vimService.vim.RoleAddedEvent;
         };
         RoleUpdatedEvent: {
            (options?: vimService.vim.RoleUpdatedEvent): vimService.vim.RoleUpdatedEvent;
         };
         RoleRemovedEvent: {
            (options?: vimService.vim.RoleRemovedEvent): vimService.vim.RoleRemovedEvent;
         };
         DatastoreEvent: {
            (options?: vimService.vim.DatastoreEvent): vimService.vim.DatastoreEvent;
         };
         DatastoreDestroyedEvent: {
            (options?: vimService.vim.DatastoreDestroyedEvent): vimService.vim.DatastoreDestroyedEvent;
         };
         DatastoreRenamedEvent: {
            (options?: vimService.vim.DatastoreRenamedEvent): vimService.vim.DatastoreRenamedEvent;
         };
         DatastoreCapacityIncreasedEvent: {
            (options?: vimService.vim.DatastoreCapacityIncreasedEvent): vimService.vim.DatastoreCapacityIncreasedEvent;
         };
         DatastoreDuplicatedEvent: {
            (options?: vimService.vim.DatastoreDuplicatedEvent): vimService.vim.DatastoreDuplicatedEvent;
         };
         DatastoreFileEvent: {
            (options?: vimService.vim.DatastoreFileEvent): vimService.vim.DatastoreFileEvent;
         };
         DatastoreFileCopiedEvent: {
            (options?: vimService.vim.DatastoreFileCopiedEvent): vimService.vim.DatastoreFileCopiedEvent;
         };
         DatastoreFileMovedEvent: {
            (options?: vimService.vim.DatastoreFileMovedEvent): vimService.vim.DatastoreFileMovedEvent;
         };
         DatastoreFileDeletedEvent: {
            (options?: vimService.vim.DatastoreFileDeletedEvent): vimService.vim.DatastoreFileDeletedEvent;
         };
         NonVIWorkloadDetectedOnDatastoreEvent: {
            (options?: vimService.vim.NonVIWorkloadDetectedOnDatastoreEvent): vimService.vim.NonVIWorkloadDetectedOnDatastoreEvent;
         };
         DatastoreIORMReconfiguredEvent: {
            (options?: vimService.vim.DatastoreIORMReconfiguredEvent): vimService.vim.DatastoreIORMReconfiguredEvent;
         };
         TaskEvent: {
            (options?: vimService.vim.TaskEvent): vimService.vim.TaskEvent;
         };
         TaskTimeoutEvent: {
            (options?: vimService.vim.TaskTimeoutEvent): vimService.vim.TaskTimeoutEvent;
         };
         LicenseEvent: {
            (options?: vimService.vim.LicenseEvent): vimService.vim.LicenseEvent;
         };
         ServerLicenseExpiredEvent: {
            (options?: vimService.vim.ServerLicenseExpiredEvent): vimService.vim.ServerLicenseExpiredEvent;
         };
         HostLicenseExpiredEvent: {
            (options?: vimService.vim.HostLicenseExpiredEvent): vimService.vim.HostLicenseExpiredEvent;
         };
         VMotionLicenseExpiredEvent: {
            (options?: vimService.vim.VMotionLicenseExpiredEvent): vimService.vim.VMotionLicenseExpiredEvent;
         };
         NoLicenseEvent: {
            (options?: vimService.vim.NoLicenseEvent): vimService.vim.NoLicenseEvent;
         };
         LicenseServerUnavailableEvent: {
            (options?: vimService.vim.LicenseServerUnavailableEvent): vimService.vim.LicenseServerUnavailableEvent;
         };
         LicenseServerAvailableEvent: {
            (options?: vimService.vim.LicenseServerAvailableEvent): vimService.vim.LicenseServerAvailableEvent;
         };
         LicenseExpiredEvent: {
            (options?: vimService.vim.LicenseExpiredEvent): vimService.vim.LicenseExpiredEvent;
         };
         InvalidEditionEvent: {
            (options?: vimService.vim.InvalidEditionEvent): vimService.vim.InvalidEditionEvent;
         };
         HostInventoryFullEvent: {
            (options?: vimService.vim.HostInventoryFullEvent): vimService.vim.HostInventoryFullEvent;
         };
         LicenseRestrictedEvent: {
            (options?: vimService.vim.LicenseRestrictedEvent): vimService.vim.LicenseRestrictedEvent;
         };
         IncorrectHostInformationEvent: {
            (options?: vimService.vim.IncorrectHostInformationEvent): vimService.vim.IncorrectHostInformationEvent;
         };
         UnlicensedVirtualMachinesEvent: {
            (options?: vimService.vim.UnlicensedVirtualMachinesEvent): vimService.vim.UnlicensedVirtualMachinesEvent;
         };
         UnlicensedVirtualMachinesFoundEvent: {
            (options?: vimService.vim.UnlicensedVirtualMachinesFoundEvent): vimService.vim.UnlicensedVirtualMachinesFoundEvent;
         };
         AllVirtualMachinesLicensedEvent: {
            (options?: vimService.vim.AllVirtualMachinesLicensedEvent): vimService.vim.AllVirtualMachinesLicensedEvent;
         };
         LicenseNonComplianceEvent: {
            (options?: vimService.vim.LicenseNonComplianceEvent): vimService.vim.LicenseNonComplianceEvent;
         };
         MigrationEvent: {
            (options?: vimService.vim.MigrationEvent): vimService.vim.MigrationEvent;
         };
         MigrationWarningEvent: {
            (options?: vimService.vim.MigrationWarningEvent): vimService.vim.MigrationWarningEvent;
         };
         MigrationErrorEvent: {
            (options?: vimService.vim.MigrationErrorEvent): vimService.vim.MigrationErrorEvent;
         };
         MigrationHostWarningEvent: {
            (options?: vimService.vim.MigrationHostWarningEvent): vimService.vim.MigrationHostWarningEvent;
         };
         MigrationHostErrorEvent: {
            (options?: vimService.vim.MigrationHostErrorEvent): vimService.vim.MigrationHostErrorEvent;
         };
         MigrationResourceWarningEvent: {
            (options?: vimService.vim.MigrationResourceWarningEvent): vimService.vim.MigrationResourceWarningEvent;
         };
         MigrationResourceErrorEvent: {
            (options?: vimService.vim.MigrationResourceErrorEvent): vimService.vim.MigrationResourceErrorEvent;
         };
         ClusterEvent: {
            (options?: vimService.vim.ClusterEvent): vimService.vim.ClusterEvent;
         };
         DasEnabledEvent: {
            (options?: vimService.vim.DasEnabledEvent): vimService.vim.DasEnabledEvent;
         };
         DasDisabledEvent: {
            (options?: vimService.vim.DasDisabledEvent): vimService.vim.DasDisabledEvent;
         };
         DasAdmissionControlDisabledEvent: {
            (options?: vimService.vim.DasAdmissionControlDisabledEvent): vimService.vim.DasAdmissionControlDisabledEvent;
         };
         DasAdmissionControlEnabledEvent: {
            (options?: vimService.vim.DasAdmissionControlEnabledEvent): vimService.vim.DasAdmissionControlEnabledEvent;
         };
         DasHostFailedEvent: {
            (options?: vimService.vim.DasHostFailedEvent): vimService.vim.DasHostFailedEvent;
         };
         DasHostIsolatedEvent: {
            (options?: vimService.vim.DasHostIsolatedEvent): vimService.vim.DasHostIsolatedEvent;
         };
         DasClusterIsolatedEvent: {
            (options?: vimService.vim.DasClusterIsolatedEvent): vimService.vim.DasClusterIsolatedEvent;
         };
         DasAgentUnavailableEvent: {
            (options?: vimService.vim.DasAgentUnavailableEvent): vimService.vim.DasAgentUnavailableEvent;
         };
         DasAgentFoundEvent: {
            (options?: vimService.vim.DasAgentFoundEvent): vimService.vim.DasAgentFoundEvent;
         };
         InsufficientFailoverResourcesEvent: {
            (options?: vimService.vim.InsufficientFailoverResourcesEvent): vimService.vim.InsufficientFailoverResourcesEvent;
         };
         FailoverLevelRestored: {
            (options?: vimService.vim.FailoverLevelRestored): vimService.vim.FailoverLevelRestored;
         };
         ClusterOvercommittedEvent: {
            (options?: vimService.vim.ClusterOvercommittedEvent): vimService.vim.ClusterOvercommittedEvent;
         };
         HostOvercommittedEvent: {
            (options?: vimService.vim.HostOvercommittedEvent): vimService.vim.HostOvercommittedEvent;
         };
         ClusterStatusChangedEvent: {
            (options?: vimService.vim.ClusterStatusChangedEvent): vimService.vim.ClusterStatusChangedEvent;
         };
         HostStatusChangedEvent: {
            (options?: vimService.vim.HostStatusChangedEvent): vimService.vim.HostStatusChangedEvent;
         };
         ClusterCreatedEvent: {
            (options?: vimService.vim.ClusterCreatedEvent): vimService.vim.ClusterCreatedEvent;
         };
         ClusterDestroyedEvent: {
            (options?: vimService.vim.ClusterDestroyedEvent): vimService.vim.ClusterDestroyedEvent;
         };
         DrsEnabledEvent: {
            (options?: vimService.vim.DrsEnabledEvent): vimService.vim.DrsEnabledEvent;
         };
         DrsDisabledEvent: {
            (options?: vimService.vim.DrsDisabledEvent): vimService.vim.DrsDisabledEvent;
         };
         ClusterReconfiguredEvent: {
            (options?: vimService.vim.ClusterReconfiguredEvent): vimService.vim.ClusterReconfiguredEvent;
         };
         HostMonitoringStateChangedEvent: {
            (options?: vimService.vim.HostMonitoringStateChangedEvent): vimService.vim.HostMonitoringStateChangedEvent;
         };
         VmHealthMonitoringStateChangedEvent: {
            (options?: vimService.vim.VmHealthMonitoringStateChangedEvent): vimService.vim.VmHealthMonitoringStateChangedEvent;
         };
         ResourcePoolEvent: {
            (options?: vimService.vim.ResourcePoolEvent): vimService.vim.ResourcePoolEvent;
         };
         ResourcePoolCreatedEvent: {
            (options?: vimService.vim.ResourcePoolCreatedEvent): vimService.vim.ResourcePoolCreatedEvent;
         };
         ResourcePoolDestroyedEvent: {
            (options?: vimService.vim.ResourcePoolDestroyedEvent): vimService.vim.ResourcePoolDestroyedEvent;
         };
         ResourcePoolMovedEvent: {
            (options?: vimService.vim.ResourcePoolMovedEvent): vimService.vim.ResourcePoolMovedEvent;
         };
         ResourcePoolReconfiguredEvent: {
            (options?: vimService.vim.ResourcePoolReconfiguredEvent): vimService.vim.ResourcePoolReconfiguredEvent;
         };
         ResourceViolatedEvent: {
            (options?: vimService.vim.ResourceViolatedEvent): vimService.vim.ResourceViolatedEvent;
         };
         VmResourcePoolMovedEvent: {
            (options?: vimService.vim.VmResourcePoolMovedEvent): vimService.vim.VmResourcePoolMovedEvent;
         };
         TemplateUpgradeEvent: {
            (options?: vimService.vim.TemplateUpgradeEvent): vimService.vim.TemplateUpgradeEvent;
         };
         TemplateBeingUpgradedEvent: {
            (options?: vimService.vim.TemplateBeingUpgradedEvent): vimService.vim.TemplateBeingUpgradedEvent;
         };
         TemplateUpgradeFailedEvent: {
            (options?: vimService.vim.TemplateUpgradeFailedEvent): vimService.vim.TemplateUpgradeFailedEvent;
         };
         TemplateUpgradedEvent: {
            (options?: vimService.vim.TemplateUpgradedEvent): vimService.vim.TemplateUpgradedEvent;
         };
         CustomizationEvent: {
            (options?: vimService.vim.CustomizationEvent): vimService.vim.CustomizationEvent;
         };
         CustomizationStartedEvent: {
            (options?: vimService.vim.CustomizationStartedEvent): vimService.vim.CustomizationStartedEvent;
         };
         CustomizationSucceeded: {
            (options?: vimService.vim.CustomizationSucceeded): vimService.vim.CustomizationSucceeded;
         };
         CustomizationFailed: {
            (options?: vimService.vim.CustomizationFailed): vimService.vim.CustomizationFailed;
         };
         CustomizationUnknownFailure: {
            (options?: vimService.vim.CustomizationUnknownFailure): vimService.vim.CustomizationUnknownFailure;
         };
         CustomizationSysprepFailed: {
            (options?: vimService.vim.CustomizationSysprepFailed): vimService.vim.CustomizationSysprepFailed;
         };
         CustomizationLinuxIdentityFailed: {
            (options?: vimService.vim.CustomizationLinuxIdentityFailed): vimService.vim.CustomizationLinuxIdentityFailed;
         };
         CustomizationNetworkSetupFailed: {
            (options?: vimService.vim.CustomizationNetworkSetupFailed): vimService.vim.CustomizationNetworkSetupFailed;
         };
         LockerMisconfiguredEvent: {
            (options?: vimService.vim.LockerMisconfiguredEvent): vimService.vim.LockerMisconfiguredEvent;
         };
         LockerReconfiguredEvent: {
            (options?: vimService.vim.LockerReconfiguredEvent): vimService.vim.LockerReconfiguredEvent;
         };
         NoDatastoresConfiguredEvent: {
            (options?: vimService.vim.NoDatastoresConfiguredEvent): vimService.vim.NoDatastoresConfiguredEvent;
         };
         AdminPasswordNotChangedEvent: {
            (options?: vimService.vim.AdminPasswordNotChangedEvent): vimService.vim.AdminPasswordNotChangedEvent;
         };
         HostInAuditModeEvent: {
            (options?: vimService.vim.HostInAuditModeEvent): vimService.vim.HostInAuditModeEvent;
         };
         LocalTSMEnabledEvent: {
            (options?: vimService.vim.LocalTSMEnabledEvent): vimService.vim.LocalTSMEnabledEvent;
         };
         RemoteTSMEnabledEvent: {
            (options?: vimService.vim.RemoteTSMEnabledEvent): vimService.vim.RemoteTSMEnabledEvent;
         };
         VimAccountPasswordChangedEvent: {
            (options?: vimService.vim.VimAccountPasswordChangedEvent): vimService.vim.VimAccountPasswordChangedEvent;
         };
         IScsiBootFailureEvent: {
            (options?: vimService.vim.IScsiBootFailureEvent): vimService.vim.IScsiBootFailureEvent;
         };
         DvsHealthStatusChangeEvent: {
            (options?: vimService.vim.DvsHealthStatusChangeEvent): vimService.vim.DvsHealthStatusChangeEvent;
         };
         NetworkRollbackEvent: {
            (options?: vimService.vim.NetworkRollbackEvent): vimService.vim.NetworkRollbackEvent;
         };
         UplinkPortVlanTrunkedEvent: {
            (options?: vimService.vim.UplinkPortVlanTrunkedEvent): vimService.vim.UplinkPortVlanTrunkedEvent;
         };
         UplinkPortVlanUntrunkedEvent: {
            (options?: vimService.vim.UplinkPortVlanUntrunkedEvent): vimService.vim.UplinkPortVlanUntrunkedEvent;
         };
         MtuMatchEvent: {
            (options?: vimService.vim.MtuMatchEvent): vimService.vim.MtuMatchEvent;
         };
         MtuMismatchEvent: {
            (options?: vimService.vim.MtuMismatchEvent): vimService.vim.MtuMismatchEvent;
         };
         UplinkPortMtuNotSupportEvent: {
            (options?: vimService.vim.UplinkPortMtuNotSupportEvent): vimService.vim.UplinkPortMtuNotSupportEvent;
         };
         UplinkPortMtuSupportEvent: {
            (options?: vimService.vim.UplinkPortMtuSupportEvent): vimService.vim.UplinkPortMtuSupportEvent;
         };
         TeamingMatchEvent: {
            (options?: vimService.vim.TeamingMatchEvent): vimService.vim.TeamingMatchEvent;
         };
         TeamingMisMatchEvent: {
            (options?: vimService.vim.TeamingMisMatchEvent): vimService.vim.TeamingMisMatchEvent;
         };
         DvsEventPortBlockState: {
            "unset": string;
            "blocked": string;
            "unblocked": string;
            "unknown": string;
         };
         DvsEvent: {
            (options?: vimService.vim.DvsEvent): vimService.vim.DvsEvent;
         };
         DvsCreatedEvent: {
            (options?: vimService.vim.DvsCreatedEvent): vimService.vim.DvsCreatedEvent;
         };
         DvsRenamedEvent: {
            (options?: vimService.vim.DvsRenamedEvent): vimService.vim.DvsRenamedEvent;
         };
         DvsReconfiguredEvent: {
            (options?: vimService.vim.DvsReconfiguredEvent): vimService.vim.DvsReconfiguredEvent;
         };
         DvsUpgradeAvailableEvent: {
            (options?: vimService.vim.DvsUpgradeAvailableEvent): vimService.vim.DvsUpgradeAvailableEvent;
         };
         DvsUpgradeInProgressEvent: {
            (options?: vimService.vim.DvsUpgradeInProgressEvent): vimService.vim.DvsUpgradeInProgressEvent;
         };
         DvsUpgradeRejectedEvent: {
            (options?: vimService.vim.DvsUpgradeRejectedEvent): vimService.vim.DvsUpgradeRejectedEvent;
         };
         DvsUpgradedEvent: {
            (options?: vimService.vim.DvsUpgradedEvent): vimService.vim.DvsUpgradedEvent;
         };
         DvsHostJoinedEvent: {
            (options?: vimService.vim.DvsHostJoinedEvent): vimService.vim.DvsHostJoinedEvent;
         };
         DvsHostLeftEvent: {
            (options?: vimService.vim.DvsHostLeftEvent): vimService.vim.DvsHostLeftEvent;
         };
         DvsOutOfSyncHostArgument: {
            (options?: vimService.vim.DvsOutOfSyncHostArgument): vimService.vim.DvsOutOfSyncHostArgument;
         };
         ArrayOfDvsOutOfSyncHostArgument: {
            (options?: vimService.vim.ArrayOfDvsOutOfSyncHostArgument): vimService.vim.ArrayOfDvsOutOfSyncHostArgument;
         };
         OutOfSyncDvsHost: {
            (options?: vimService.vim.OutOfSyncDvsHost): vimService.vim.OutOfSyncDvsHost;
         };
         DvsHostWentOutOfSyncEvent: {
            (options?: vimService.vim.DvsHostWentOutOfSyncEvent): vimService.vim.DvsHostWentOutOfSyncEvent;
         };
         DvsHostBackInSyncEvent: {
            (options?: vimService.vim.DvsHostBackInSyncEvent): vimService.vim.DvsHostBackInSyncEvent;
         };
         DvsHostStatusUpdated: {
            (options?: vimService.vim.DvsHostStatusUpdated): vimService.vim.DvsHostStatusUpdated;
         };
         DvsPortCreatedEvent: {
            (options?: vimService.vim.DvsPortCreatedEvent): vimService.vim.DvsPortCreatedEvent;
         };
         DvsPortReconfiguredEvent: {
            (options?: vimService.vim.DvsPortReconfiguredEvent): vimService.vim.DvsPortReconfiguredEvent;
         };
         DvsPortDeletedEvent: {
            (options?: vimService.vim.DvsPortDeletedEvent): vimService.vim.DvsPortDeletedEvent;
         };
         DvsPortConnectedEvent: {
            (options?: vimService.vim.DvsPortConnectedEvent): vimService.vim.DvsPortConnectedEvent;
         };
         DvsPortDisconnectedEvent: {
            (options?: vimService.vim.DvsPortDisconnectedEvent): vimService.vim.DvsPortDisconnectedEvent;
         };
         DvsPortVendorSpecificStateChangeEvent: {
            (options?: vimService.vim.DvsPortVendorSpecificStateChangeEvent): vimService.vim.DvsPortVendorSpecificStateChangeEvent;
         };
         DvsPortRuntimeChangeEvent: {
            (options?: vimService.vim.DvsPortRuntimeChangeEvent): vimService.vim.DvsPortRuntimeChangeEvent;
         };
         DvsPortLinkUpEvent: {
            (options?: vimService.vim.DvsPortLinkUpEvent): vimService.vim.DvsPortLinkUpEvent;
         };
         DvsPortLinkDownEvent: {
            (options?: vimService.vim.DvsPortLinkDownEvent): vimService.vim.DvsPortLinkDownEvent;
         };
         DvsPortJoinPortgroupEvent: {
            (options?: vimService.vim.DvsPortJoinPortgroupEvent): vimService.vim.DvsPortJoinPortgroupEvent;
         };
         DvsPortLeavePortgroupEvent: {
            (options?: vimService.vim.DvsPortLeavePortgroupEvent): vimService.vim.DvsPortLeavePortgroupEvent;
         };
         DvsPortBlockedEvent: {
            (options?: vimService.vim.DvsPortBlockedEvent): vimService.vim.DvsPortBlockedEvent;
         };
         DvsPortUnblockedEvent: {
            (options?: vimService.vim.DvsPortUnblockedEvent): vimService.vim.DvsPortUnblockedEvent;
         };
         DvsPortEnteredPassthruEvent: {
            (options?: vimService.vim.DvsPortEnteredPassthruEvent): vimService.vim.DvsPortEnteredPassthruEvent;
         };
         DvsPortExitedPassthruEvent: {
            (options?: vimService.vim.DvsPortExitedPassthruEvent): vimService.vim.DvsPortExitedPassthruEvent;
         };
         DvsDestroyedEvent: {
            (options?: vimService.vim.DvsDestroyedEvent): vimService.vim.DvsDestroyedEvent;
         };
         DvsMergedEvent: {
            (options?: vimService.vim.DvsMergedEvent): vimService.vim.DvsMergedEvent;
         };
         HostLocalPortCreatedEvent: {
            (options?: vimService.vim.HostLocalPortCreatedEvent): vimService.vim.HostLocalPortCreatedEvent;
         };
         RollbackEvent: {
            (options?: vimService.vim.RollbackEvent): vimService.vim.RollbackEvent;
         };
         RecoveryEvent: {
            (options?: vimService.vim.RecoveryEvent): vimService.vim.RecoveryEvent;
         };
         DvsImportEvent: {
            (options?: vimService.vim.DvsImportEvent): vimService.vim.DvsImportEvent;
         };
         DvsRestoreEvent: {
            (options?: vimService.vim.DvsRestoreEvent): vimService.vim.DvsRestoreEvent;
         };
         VmVnicPoolReservationViolationRaiseEvent: {
            (options?: vimService.vim.VmVnicPoolReservationViolationRaiseEvent): vimService.vim.VmVnicPoolReservationViolationRaiseEvent;
         };
         VmVnicPoolReservationViolationClearEvent: {
            (options?: vimService.vim.VmVnicPoolReservationViolationClearEvent): vimService.vim.VmVnicPoolReservationViolationClearEvent;
         };
         DVPortgroupEvent: {
            (options?: vimService.vim.DVPortgroupEvent): vimService.vim.DVPortgroupEvent;
         };
         DVPortgroupCreatedEvent: {
            (options?: vimService.vim.DVPortgroupCreatedEvent): vimService.vim.DVPortgroupCreatedEvent;
         };
         DVPortgroupRenamedEvent: {
            (options?: vimService.vim.DVPortgroupRenamedEvent): vimService.vim.DVPortgroupRenamedEvent;
         };
         DVPortgroupReconfiguredEvent: {
            (options?: vimService.vim.DVPortgroupReconfiguredEvent): vimService.vim.DVPortgroupReconfiguredEvent;
         };
         DVPortgroupDestroyedEvent: {
            (options?: vimService.vim.DVPortgroupDestroyedEvent): vimService.vim.DVPortgroupDestroyedEvent;
         };
         DvpgImportEvent: {
            (options?: vimService.vim.DvpgImportEvent): vimService.vim.DvpgImportEvent;
         };
         DvpgRestoreEvent: {
            (options?: vimService.vim.DvpgRestoreEvent): vimService.vim.DvpgRestoreEvent;
         };
         DrsInvocationFailedEvent: {
            (options?: vimService.vim.DrsInvocationFailedEvent): vimService.vim.DrsInvocationFailedEvent;
         };
         DrsRecoveredFromFailureEvent: {
            (options?: vimService.vim.DrsRecoveredFromFailureEvent): vimService.vim.DrsRecoveredFromFailureEvent;
         };
         VmReloadFromPathEvent: {
            (options?: vimService.vim.VmReloadFromPathEvent): vimService.vim.VmReloadFromPathEvent;
         };
         VmReloadFromPathFailedEvent: {
            (options?: vimService.vim.VmReloadFromPathFailedEvent): vimService.vim.VmReloadFromPathFailedEvent;
         };
         VmRequirementsExceedCurrentEVCModeEvent: {
            (options?: vimService.vim.VmRequirementsExceedCurrentEVCModeEvent): vimService.vim.VmRequirementsExceedCurrentEVCModeEvent;
         };
         EventArgument: {
            (options?: vimService.vim.EventArgument): vimService.vim.EventArgument;
         };
         RoleEventArgument: {
            (options?: vimService.vim.RoleEventArgument): vimService.vim.RoleEventArgument;
         };
         EntityEventArgument: {
            (options?: vimService.vim.EntityEventArgument): vimService.vim.EntityEventArgument;
         };
         ManagedEntityEventArgument: {
            (options?: vimService.vim.ManagedEntityEventArgument): vimService.vim.ManagedEntityEventArgument;
         };
         FolderEventArgument: {
            (options?: vimService.vim.FolderEventArgument): vimService.vim.FolderEventArgument;
         };
         DatacenterEventArgument: {
            (options?: vimService.vim.DatacenterEventArgument): vimService.vim.DatacenterEventArgument;
         };
         ComputeResourceEventArgument: {
            (options?: vimService.vim.ComputeResourceEventArgument): vimService.vim.ComputeResourceEventArgument;
         };
         ResourcePoolEventArgument: {
            (options?: vimService.vim.ResourcePoolEventArgument): vimService.vim.ResourcePoolEventArgument;
         };
         HostEventArgument: {
            (options?: vimService.vim.HostEventArgument): vimService.vim.HostEventArgument;
         };
         ArrayOfHostEventArgument: {
            (options?: vimService.vim.ArrayOfHostEventArgument): vimService.vim.ArrayOfHostEventArgument;
         };
         VmEventArgument: {
            (options?: vimService.vim.VmEventArgument): vimService.vim.VmEventArgument;
         };
         ArrayOfVmEventArgument: {
            (options?: vimService.vim.ArrayOfVmEventArgument): vimService.vim.ArrayOfVmEventArgument;
         };
         DatastoreEventArgument: {
            (options?: vimService.vim.DatastoreEventArgument): vimService.vim.DatastoreEventArgument;
         };
         NetworkEventArgument: {
            (options?: vimService.vim.NetworkEventArgument): vimService.vim.NetworkEventArgument;
         };
         AlarmEventArgument: {
            (options?: vimService.vim.AlarmEventArgument): vimService.vim.AlarmEventArgument;
         };
         ScheduledTaskEventArgument: {
            (options?: vimService.vim.ScheduledTaskEventArgument): vimService.vim.ScheduledTaskEventArgument;
         };
         ProfileEventArgument: {
            (options?: vimService.vim.ProfileEventArgument): vimService.vim.ProfileEventArgument;
         };
         DvsEventArgument: {
            (options?: vimService.vim.DvsEventArgument): vimService.vim.DvsEventArgument;
         };
         ChangesInfoEventArgument: {
            (options?: vimService.vim.ChangesInfoEventArgument): vimService.vim.ChangesInfoEventArgument;
         };
         ArrayOfChangesInfoEventArgument: {
            (options?: vimService.vim.ArrayOfChangesInfoEventArgument): vimService.vim.ArrayOfChangesInfoEventArgument;
         };
         EventCategory: {
            "info": string;
            "warning": string;
            "error": string;
            "user": string;
         };
         EventArgDesc: {
            (options?: vimService.vim.EventArgDesc): vimService.vim.EventArgDesc;
         };
         ArrayOfEventArgDesc: {
            (options?: vimService.vim.ArrayOfEventArgDesc): vimService.vim.ArrayOfEventArgDesc;
         };
         EventDescriptionEventDetail: {
            (options?: vimService.vim.EventDescriptionEventDetail): vimService.vim.EventDescriptionEventDetail;
         };
         ArrayOfEventDescriptionEventDetail: {
            (options?: vimService.vim.ArrayOfEventDescriptionEventDetail): vimService.vim.ArrayOfEventDescriptionEventDetail;
         };
         EventDescription: {
            (options?: vimService.vim.EventDescription): vimService.vim.EventDescription;
         };
         EventEx: {
            (options?: vimService.vim.EventEx): vimService.vim.EventEx;
         };
         EventFilterSpecRecursionOption: {
            "self": string;
            "children": string;
            "all": string;
         };
         EventFilterSpecByEntity: {
            (options?: vimService.vim.EventFilterSpecByEntity): vimService.vim.EventFilterSpecByEntity;
         };
         EventFilterSpecByTime: {
            (options?: vimService.vim.EventFilterSpecByTime): vimService.vim.EventFilterSpecByTime;
         };
         EventFilterSpecByUsername: {
            (options?: vimService.vim.EventFilterSpecByUsername): vimService.vim.EventFilterSpecByUsername;
         };
         EventFilterSpec: {
            (options?: vimService.vim.EventFilterSpec): vimService.vim.EventFilterSpec;
         };
         ExtExtendedProductInfo: {
            (options?: vimService.vim.ExtExtendedProductInfo): vimService.vim.ExtExtendedProductInfo;
         };
         ManagedByInfo: {
            (options?: vimService.vim.ManagedByInfo): vimService.vim.ManagedByInfo;
         };
         ExtManagedEntityInfo: {
            (options?: vimService.vim.ExtManagedEntityInfo): vimService.vim.ExtManagedEntityInfo;
         };
         ArrayOfExtManagedEntityInfo: {
            (options?: vimService.vim.ArrayOfExtManagedEntityInfo): vimService.vim.ArrayOfExtManagedEntityInfo;
         };
         ExtSolutionManagerInfoTabInfo: {
            (options?: vimService.vim.ExtSolutionManagerInfoTabInfo): vimService.vim.ExtSolutionManagerInfoTabInfo;
         };
         ArrayOfExtSolutionManagerInfoTabInfo: {
            (options?: vimService.vim.ArrayOfExtSolutionManagerInfoTabInfo): vimService.vim.ArrayOfExtSolutionManagerInfoTabInfo;
         };
         ExtSolutionManagerInfo: {
            (options?: vimService.vim.ExtSolutionManagerInfo): vimService.vim.ExtSolutionManagerInfo;
         };
         ActiveDirectoryFault: {
            (options?: vimService.vim.ActiveDirectoryFault): vimService.vim.ActiveDirectoryFault;
         };
         ActiveVMsBlockingEVC: {
            (options?: vimService.vim.ActiveVMsBlockingEVC): vimService.vim.ActiveVMsBlockingEVC;
         };
         AdminDisabled: {
            (options?: vimService.vim.AdminDisabled): vimService.vim.AdminDisabled;
         };
         AdminNotDisabled: {
            (options?: vimService.vim.AdminNotDisabled): vimService.vim.AdminNotDisabled;
         };
         AffinityType: {
            "memory": string;
            "cpu": string;
         };
         AffinityConfigured: {
            (options?: vimService.vim.AffinityConfigured): vimService.vim.AffinityConfigured;
         };
         AgentInstallFailedReason: {
            "NotEnoughSpaceOnDevice": string;
            "PrepareToUpgradeFailed": string;
            "AgentNotRunning": string;
            "AgentNotReachable": string;
            "InstallTimedout": string;
            "SignatureVerificationFailed": string;
            "AgentUploadFailed": string;
            "AgentUploadTimedout": string;
            "UnknownInstallerError": string;
         };
         AgentInstallFailed: {
            (options?: vimService.vim.AgentInstallFailed): vimService.vim.AgentInstallFailed;
         };
         AlreadyBeingManaged: {
            (options?: vimService.vim.AlreadyBeingManaged): vimService.vim.AlreadyBeingManaged;
         };
         AlreadyConnected: {
            (options?: vimService.vim.AlreadyConnected): vimService.vim.AlreadyConnected;
         };
         AlreadyExists: {
            (options?: vimService.vim.AlreadyExists): vimService.vim.AlreadyExists;
         };
         AlreadyUpgraded: {
            (options?: vimService.vim.AlreadyUpgraded): vimService.vim.AlreadyUpgraded;
         };
         AnswerFileUpdateFailure: {
            (options?: vimService.vim.AnswerFileUpdateFailure): vimService.vim.AnswerFileUpdateFailure;
         };
         ArrayOfAnswerFileUpdateFailure: {
            (options?: vimService.vim.ArrayOfAnswerFileUpdateFailure): vimService.vim.ArrayOfAnswerFileUpdateFailure;
         };
         AnswerFileUpdateFailed: {
            (options?: vimService.vim.AnswerFileUpdateFailed): vimService.vim.AnswerFileUpdateFailed;
         };
         ApplicationQuiesceFault: {
            (options?: vimService.vim.ApplicationQuiesceFault): vimService.vim.ApplicationQuiesceFault;
         };
         AuthMinimumAdminPermission: {
            (options?: vimService.vim.AuthMinimumAdminPermission): vimService.vim.AuthMinimumAdminPermission;
         };
         BackupBlobReadFailure: {
            (options?: vimService.vim.BackupBlobReadFailure): vimService.vim.BackupBlobReadFailure;
         };
         BackupBlobWriteFailure: {
            (options?: vimService.vim.BackupBlobWriteFailure): vimService.vim.BackupBlobWriteFailure;
         };
         BlockedByFirewall: {
            (options?: vimService.vim.BlockedByFirewall): vimService.vim.BlockedByFirewall;
         };
         CAMServerRefusedConnection: {
            (options?: vimService.vim.CAMServerRefusedConnection): vimService.vim.CAMServerRefusedConnection;
         };
         CannotAccessFile: {
            (options?: vimService.vim.CannotAccessFile): vimService.vim.CannotAccessFile;
         };
         CannotAccessLocalSource: {
            (options?: vimService.vim.CannotAccessLocalSource): vimService.vim.CannotAccessLocalSource;
         };
         CannotAccessNetwork: {
            (options?: vimService.vim.CannotAccessNetwork): vimService.vim.CannotAccessNetwork;
         };
         CannotAccessVmComponent: {
            (options?: vimService.vim.CannotAccessVmComponent): vimService.vim.CannotAccessVmComponent;
         };
         CannotAccessVmConfig: {
            (options?: vimService.vim.CannotAccessVmConfig): vimService.vim.CannotAccessVmConfig;
         };
         CannotAccessVmDevice: {
            (options?: vimService.vim.CannotAccessVmDevice): vimService.vim.CannotAccessVmDevice;
         };
         CannotAccessVmDisk: {
            (options?: vimService.vim.CannotAccessVmDisk): vimService.vim.CannotAccessVmDisk;
         };
         CannotAddHostWithFTVmAsStandalone: {
            (options?: vimService.vim.CannotAddHostWithFTVmAsStandalone): vimService.vim.CannotAddHostWithFTVmAsStandalone;
         };
         CannotAddHostWithFTVmToDifferentCluster: {
            (options?: vimService.vim.CannotAddHostWithFTVmToDifferentCluster): vimService.vim.CannotAddHostWithFTVmToDifferentCluster;
         };
         CannotAddHostWithFTVmToNonHACluster: {
            (options?: vimService.vim.CannotAddHostWithFTVmToNonHACluster): vimService.vim.CannotAddHostWithFTVmToNonHACluster;
         };
         CannotChangeDrsBehaviorForFtSecondary: {
            (options?: vimService.vim.CannotChangeDrsBehaviorForFtSecondary): vimService.vim.CannotChangeDrsBehaviorForFtSecondary;
         };
         CannotChangeHaSettingsForFtSecondary: {
            (options?: vimService.vim.CannotChangeHaSettingsForFtSecondary): vimService.vim.CannotChangeHaSettingsForFtSecondary;
         };
         CannotChangeVsanClusterUuid: {
            (options?: vimService.vim.CannotChangeVsanClusterUuid): vimService.vim.CannotChangeVsanClusterUuid;
         };
         CannotChangeVsanNodeUuid: {
            (options?: vimService.vim.CannotChangeVsanNodeUuid): vimService.vim.CannotChangeVsanNodeUuid;
         };
         CannotComputeFTCompatibleHosts: {
            (options?: vimService.vim.CannotComputeFTCompatibleHosts): vimService.vim.CannotComputeFTCompatibleHosts;
         };
         CannotCreateFile: {
            (options?: vimService.vim.CannotCreateFile): vimService.vim.CannotCreateFile;
         };
         CannotDecryptPasswords: {
            (options?: vimService.vim.CannotDecryptPasswords): vimService.vim.CannotDecryptPasswords;
         };
         CannotDeleteFile: {
            (options?: vimService.vim.CannotDeleteFile): vimService.vim.CannotDeleteFile;
         };
         CannotDisableDrsOnClustersWithVApps: {
            (options?: vimService.vim.CannotDisableDrsOnClustersWithVApps): vimService.vim.CannotDisableDrsOnClustersWithVApps;
         };
         CannotDisableSnapshot: {
            (options?: vimService.vim.CannotDisableSnapshot): vimService.vim.CannotDisableSnapshot;
         };
         CannotDisconnectHostWithFaultToleranceVm: {
            (options?: vimService.vim.CannotDisconnectHostWithFaultToleranceVm): vimService.vim.CannotDisconnectHostWithFaultToleranceVm;
         };
         CannotEnableVmcpForClusterReason: {
            "APDTimeoutDisabled": string;
            "IncompatibleHostVersion": string;
         };
         CannotEnableVmcpForCluster: {
            (options?: vimService.vim.CannotEnableVmcpForCluster): vimService.vim.CannotEnableVmcpForCluster;
         };
         CannotModifyConfigCpuRequirements: {
            (options?: vimService.vim.CannotModifyConfigCpuRequirements): vimService.vim.CannotModifyConfigCpuRequirements;
         };
         CannotMoveFaultToleranceVmMoveType: {
            "resourcePool": string;
            "cluster": string;
         };
         CannotMoveFaultToleranceVm: {
            (options?: vimService.vim.CannotMoveFaultToleranceVm): vimService.vim.CannotMoveFaultToleranceVm;
         };
         CannotMoveHostWithFaultToleranceVm: {
            (options?: vimService.vim.CannotMoveHostWithFaultToleranceVm): vimService.vim.CannotMoveHostWithFaultToleranceVm;
         };
         CannotMoveVmWithDeltaDisk: {
            (options?: vimService.vim.CannotMoveVmWithDeltaDisk): vimService.vim.CannotMoveVmWithDeltaDisk;
         };
         CannotMoveVmWithNativeDeltaDisk: {
            (options?: vimService.vim.CannotMoveVmWithNativeDeltaDisk): vimService.vim.CannotMoveVmWithNativeDeltaDisk;
         };
         CannotMoveVsanEnabledHost: {
            (options?: vimService.vim.CannotMoveVsanEnabledHost): vimService.vim.CannotMoveVsanEnabledHost;
         };
         CannotPlaceWithoutPrerequisiteMoves: {
            (options?: vimService.vim.CannotPlaceWithoutPrerequisiteMoves): vimService.vim.CannotPlaceWithoutPrerequisiteMoves;
         };
         CannotPowerOffVmInClusterOperation: {
            "suspend": string;
            "powerOff": string;
            "guestShutdown": string;
            "guestSuspend": string;
         };
         CannotPowerOffVmInCluster: {
            (options?: vimService.vim.CannotPowerOffVmInCluster): vimService.vim.CannotPowerOffVmInCluster;
         };
         CannotReconfigureVsanWhenHaEnabled: {
            (options?: vimService.vim.CannotReconfigureVsanWhenHaEnabled): vimService.vim.CannotReconfigureVsanWhenHaEnabled;
         };
         CannotUseNetworkReason: {
            "NetworkReservationNotSupported": string;
            "MismatchedNetworkPolicies": string;
            "MismatchedDvsVersionOrVendor": string;
            "VMotionToUnsupportedNetworkType": string;
         };
         CannotUseNetwork: {
            (options?: vimService.vim.CannotUseNetwork): vimService.vim.CannotUseNetwork;
         };
         ClockSkew: {
            (options?: vimService.vim.ClockSkew): vimService.vim.ClockSkew;
         };
         CloneFromSnapshotNotSupported: {
            (options?: vimService.vim.CloneFromSnapshotNotSupported): vimService.vim.CloneFromSnapshotNotSupported;
         };
         CollectorAddressUnset: {
            (options?: vimService.vim.CollectorAddressUnset): vimService.vim.CollectorAddressUnset;
         };
         ConcurrentAccess: {
            (options?: vimService.vim.ConcurrentAccess): vimService.vim.ConcurrentAccess;
         };
         ConflictingConfigurationConfig: {
            (options?: vimService.vim.ConflictingConfigurationConfig): vimService.vim.ConflictingConfigurationConfig;
         };
         ArrayOfConflictingConfigurationConfig: {
            (options?: vimService.vim.ArrayOfConflictingConfigurationConfig): vimService.vim.ArrayOfConflictingConfigurationConfig;
         };
         ConflictingConfiguration: {
            (options?: vimService.vim.ConflictingConfiguration): vimService.vim.ConflictingConfiguration;
         };
         ConflictingDatastoreFound: {
            (options?: vimService.vim.ConflictingDatastoreFound): vimService.vim.ConflictingDatastoreFound;
         };
         ConnectedIso: {
            (options?: vimService.vim.ConnectedIso): vimService.vim.ConnectedIso;
         };
         CpuCompatibilityUnknown: {
            (options?: vimService.vim.CpuCompatibilityUnknown): vimService.vim.CpuCompatibilityUnknown;
         };
         CpuHotPlugNotSupported: {
            (options?: vimService.vim.CpuHotPlugNotSupported): vimService.vim.CpuHotPlugNotSupported;
         };
         CpuIncompatible: {
            (options?: vimService.vim.CpuIncompatible): vimService.vim.CpuIncompatible;
         };
         CpuIncompatible1ECX: {
            (options?: vimService.vim.CpuIncompatible1ECX): vimService.vim.CpuIncompatible1ECX;
         };
         CpuIncompatible81EDX: {
            (options?: vimService.vim.CpuIncompatible81EDX): vimService.vim.CpuIncompatible81EDX;
         };
         CustomizationFault: {
            (options?: vimService.vim.CustomizationFault): vimService.vim.CustomizationFault;
         };
         CustomizationPending: {
            (options?: vimService.vim.CustomizationPending): vimService.vim.CustomizationPending;
         };
         DVPortNotSupported: {
            (options?: vimService.vim.DVPortNotSupported): vimService.vim.DVPortNotSupported;
         };
         DasConfigFaultDasConfigFaultReason: {
            "HostNetworkMisconfiguration": string;
            "HostMisconfiguration": string;
            "InsufficientPrivileges": string;
            "NoPrimaryAgentAvailable": string;
            "Other": string;
            "NoDatastoresConfigured": string;
            "CreateConfigVvolFailed": string;
            "VSanNotSupportedOnHost": string;
            "DasNetworkMisconfiguration": string;
         };
         DasConfigFault: {
            (options?: vimService.vim.DasConfigFault): vimService.vim.DasConfigFault;
         };
         DatabaseError: {
            (options?: vimService.vim.DatabaseError): vimService.vim.DatabaseError;
         };
         DatacenterMismatchArgument: {
            (options?: vimService.vim.DatacenterMismatchArgument): vimService.vim.DatacenterMismatchArgument;
         };
         ArrayOfDatacenterMismatchArgument: {
            (options?: vimService.vim.ArrayOfDatacenterMismatchArgument): vimService.vim.ArrayOfDatacenterMismatchArgument;
         };
         DatacenterMismatch: {
            (options?: vimService.vim.DatacenterMismatch): vimService.vim.DatacenterMismatch;
         };
         DatastoreNotWritableOnHost: {
            (options?: vimService.vim.DatastoreNotWritableOnHost): vimService.vim.DatastoreNotWritableOnHost;
         };
         DeltaDiskFormatNotSupported: {
            (options?: vimService.vim.DeltaDiskFormatNotSupported): vimService.vim.DeltaDiskFormatNotSupported;
         };
         DestinationSwitchFull: {
            (options?: vimService.vim.DestinationSwitchFull): vimService.vim.DestinationSwitchFull;
         };
         DestinationVsanDisabled: {
            (options?: vimService.vim.DestinationVsanDisabled): vimService.vim.DestinationVsanDisabled;
         };
         DeviceBackingNotSupported: {
            (options?: vimService.vim.DeviceBackingNotSupported): vimService.vim.DeviceBackingNotSupported;
         };
         DeviceControllerNotSupported: {
            (options?: vimService.vim.DeviceControllerNotSupported): vimService.vim.DeviceControllerNotSupported;
         };
         DeviceHotPlugNotSupported: {
            (options?: vimService.vim.DeviceHotPlugNotSupported): vimService.vim.DeviceHotPlugNotSupported;
         };
         DeviceNotFound: {
            (options?: vimService.vim.DeviceNotFound): vimService.vim.DeviceNotFound;
         };
         DeviceNotSupportedReason: {
            "host": string;
            "guest": string;
         };
         DeviceNotSupported: {
            (options?: vimService.vim.DeviceNotSupported): vimService.vim.DeviceNotSupported;
         };
         DeviceUnsupportedForVmPlatform: {
            (options?: vimService.vim.DeviceUnsupportedForVmPlatform): vimService.vim.DeviceUnsupportedForVmPlatform;
         };
         DeviceUnsupportedForVmVersion: {
            (options?: vimService.vim.DeviceUnsupportedForVmVersion): vimService.vim.DeviceUnsupportedForVmVersion;
         };
         DigestNotSupported: {
            (options?: vimService.vim.DigestNotSupported): vimService.vim.DigestNotSupported;
         };
         DirectoryNotEmpty: {
            (options?: vimService.vim.DirectoryNotEmpty): vimService.vim.DirectoryNotEmpty;
         };
         DisableAdminNotSupported: {
            (options?: vimService.vim.DisableAdminNotSupported): vimService.vim.DisableAdminNotSupported;
         };
         DisallowedChangeByServiceDisallowedChange: {
            "hotExtendDisk": string;
         };
         DisallowedChangeByService: {
            (options?: vimService.vim.DisallowedChangeByService): vimService.vim.DisallowedChangeByService;
         };
         DisallowedDiskModeChange: {
            (options?: vimService.vim.DisallowedDiskModeChange): vimService.vim.DisallowedDiskModeChange;
         };
         DisallowedMigrationDeviceAttached: {
            (options?: vimService.vim.DisallowedMigrationDeviceAttached): vimService.vim.DisallowedMigrationDeviceAttached;
         };
         DisallowedOperationOnFailoverHost: {
            (options?: vimService.vim.DisallowedOperationOnFailoverHost): vimService.vim.DisallowedOperationOnFailoverHost;
         };
         DisconnectedHostsBlockingEVC: {
            (options?: vimService.vim.DisconnectedHostsBlockingEVC): vimService.vim.DisconnectedHostsBlockingEVC;
         };
         DiskHasPartitions: {
            (options?: vimService.vim.DiskHasPartitions): vimService.vim.DiskHasPartitions;
         };
         DiskIsLastRemainingNonSSD: {
            (options?: vimService.vim.DiskIsLastRemainingNonSSD): vimService.vim.DiskIsLastRemainingNonSSD;
         };
         DiskIsNonLocal: {
            (options?: vimService.vim.DiskIsNonLocal): vimService.vim.DiskIsNonLocal;
         };
         DiskIsUSB: {
            (options?: vimService.vim.DiskIsUSB): vimService.vim.DiskIsUSB;
         };
         DiskMoveTypeNotSupported: {
            (options?: vimService.vim.DiskMoveTypeNotSupported): vimService.vim.DiskMoveTypeNotSupported;
         };
         DiskNotSupported: {
            (options?: vimService.vim.DiskNotSupported): vimService.vim.DiskNotSupported;
         };
         DiskTooSmall: {
            (options?: vimService.vim.DiskTooSmall): vimService.vim.DiskTooSmall;
         };
         DomainNotFound: {
            (options?: vimService.vim.DomainNotFound): vimService.vim.DomainNotFound;
         };
         DrsDisabledOnVm: {
            (options?: vimService.vim.DrsDisabledOnVm): vimService.vim.DrsDisabledOnVm;
         };
         DrsVmotionIncompatibleFault: {
            (options?: vimService.vim.DrsVmotionIncompatibleFault): vimService.vim.DrsVmotionIncompatibleFault;
         };
         DuplicateDisks: {
            (options?: vimService.vim.DuplicateDisks): vimService.vim.DuplicateDisks;
         };
         DuplicateName: {
            (options?: vimService.vim.DuplicateName): vimService.vim.DuplicateName;
         };
         DuplicateVsanNetworkInterface: {
            (options?: vimService.vim.DuplicateVsanNetworkInterface): vimService.vim.DuplicateVsanNetworkInterface;
         };
         DvsApplyOperationFaultFaultOnObject: {
            (options?: vimService.vim.DvsApplyOperationFaultFaultOnObject): vimService.vim.DvsApplyOperationFaultFaultOnObject;
         };
         ArrayOfDvsApplyOperationFaultFaultOnObject: {
            (options?: vimService.vim.ArrayOfDvsApplyOperationFaultFaultOnObject): vimService.vim.ArrayOfDvsApplyOperationFaultFaultOnObject;
         };
         DvsApplyOperationFault: {
            (options?: vimService.vim.DvsApplyOperationFault): vimService.vim.DvsApplyOperationFault;
         };
         DvsFault: {
            (options?: vimService.vim.DvsFault): vimService.vim.DvsFault;
         };
         DvsNotAuthorized: {
            (options?: vimService.vim.DvsNotAuthorized): vimService.vim.DvsNotAuthorized;
         };
         DvsOperationBulkFaultFaultOnHost: {
            (options?: vimService.vim.DvsOperationBulkFaultFaultOnHost): vimService.vim.DvsOperationBulkFaultFaultOnHost;
         };
         ArrayOfDvsOperationBulkFaultFaultOnHost: {
            (options?: vimService.vim.ArrayOfDvsOperationBulkFaultFaultOnHost): vimService.vim.ArrayOfDvsOperationBulkFaultFaultOnHost;
         };
         DvsOperationBulkFault: {
            (options?: vimService.vim.DvsOperationBulkFault): vimService.vim.DvsOperationBulkFault;
         };
         DvsScopeViolated: {
            (options?: vimService.vim.DvsScopeViolated): vimService.vim.DvsScopeViolated;
         };
         EVCAdmissionFailed: {
            (options?: vimService.vim.EVCAdmissionFailed): vimService.vim.EVCAdmissionFailed;
         };
         EVCAdmissionFailedCPUFeaturesForMode: {
            (options?: vimService.vim.EVCAdmissionFailedCPUFeaturesForMode): vimService.vim.EVCAdmissionFailedCPUFeaturesForMode;
         };
         EVCAdmissionFailedCPUModel: {
            (options?: vimService.vim.EVCAdmissionFailedCPUModel): vimService.vim.EVCAdmissionFailedCPUModel;
         };
         EVCAdmissionFailedCPUModelForMode: {
            (options?: vimService.vim.EVCAdmissionFailedCPUModelForMode): vimService.vim.EVCAdmissionFailedCPUModelForMode;
         };
         EVCAdmissionFailedCPUVendor: {
            (options?: vimService.vim.EVCAdmissionFailedCPUVendor): vimService.vim.EVCAdmissionFailedCPUVendor;
         };
         EVCAdmissionFailedCPUVendorUnknown: {
            (options?: vimService.vim.EVCAdmissionFailedCPUVendorUnknown): vimService.vim.EVCAdmissionFailedCPUVendorUnknown;
         };
         EVCAdmissionFailedHostDisconnected: {
            (options?: vimService.vim.EVCAdmissionFailedHostDisconnected): vimService.vim.EVCAdmissionFailedHostDisconnected;
         };
         EVCAdmissionFailedHostSoftware: {
            (options?: vimService.vim.EVCAdmissionFailedHostSoftware): vimService.vim.EVCAdmissionFailedHostSoftware;
         };
         EVCAdmissionFailedHostSoftwareForMode: {
            (options?: vimService.vim.EVCAdmissionFailedHostSoftwareForMode): vimService.vim.EVCAdmissionFailedHostSoftwareForMode;
         };
         EVCAdmissionFailedVmActive: {
            (options?: vimService.vim.EVCAdmissionFailedVmActive): vimService.vim.EVCAdmissionFailedVmActive;
         };
         EVCConfigFault: {
            (options?: vimService.vim.EVCConfigFault): vimService.vim.EVCConfigFault;
         };
         EVCModeIllegalByVendor: {
            (options?: vimService.vim.EVCModeIllegalByVendor): vimService.vim.EVCModeIllegalByVendor;
         };
         EVCModeUnsupportedByHosts: {
            (options?: vimService.vim.EVCModeUnsupportedByHosts): vimService.vim.EVCModeUnsupportedByHosts;
         };
         EVCUnsupportedByHostHardware: {
            (options?: vimService.vim.EVCUnsupportedByHostHardware): vimService.vim.EVCUnsupportedByHostHardware;
         };
         EVCUnsupportedByHostSoftware: {
            (options?: vimService.vim.EVCUnsupportedByHostSoftware): vimService.vim.EVCUnsupportedByHostSoftware;
         };
         EightHostLimitViolated: {
            (options?: vimService.vim.EightHostLimitViolated): vimService.vim.EightHostLimitViolated;
         };
         ExpiredAddonLicense: {
            (options?: vimService.vim.ExpiredAddonLicense): vimService.vim.ExpiredAddonLicense;
         };
         ExpiredEditionLicense: {
            (options?: vimService.vim.ExpiredEditionLicense): vimService.vim.ExpiredEditionLicense;
         };
         ExpiredFeatureLicense: {
            (options?: vimService.vim.ExpiredFeatureLicense): vimService.vim.ExpiredFeatureLicense;
         };
         ExtendedFault: {
            (options?: vimService.vim.ExtendedFault): vimService.vim.ExtendedFault;
         };
         FailToEnableSPBM: {
            (options?: vimService.vim.FailToEnableSPBM): vimService.vim.FailToEnableSPBM;
         };
         FailToLockFaultToleranceVMs: {
            (options?: vimService.vim.FailToLockFaultToleranceVMs): vimService.vim.FailToLockFaultToleranceVMs;
         };
         FaultToleranceAntiAffinityViolated: {
            (options?: vimService.vim.FaultToleranceAntiAffinityViolated): vimService.vim.FaultToleranceAntiAffinityViolated;
         };
         FaultToleranceCannotEditMem: {
            (options?: vimService.vim.FaultToleranceCannotEditMem): vimService.vim.FaultToleranceCannotEditMem;
         };
         FaultToleranceCpuIncompatible: {
            (options?: vimService.vim.FaultToleranceCpuIncompatible): vimService.vim.FaultToleranceCpuIncompatible;
         };
         FaultToleranceNeedsThickDisk: {
            (options?: vimService.vim.FaultToleranceNeedsThickDisk): vimService.vim.FaultToleranceNeedsThickDisk;
         };
         FaultToleranceNotLicensed: {
            (options?: vimService.vim.FaultToleranceNotLicensed): vimService.vim.FaultToleranceNotLicensed;
         };
         FaultToleranceNotSameBuild: {
            (options?: vimService.vim.FaultToleranceNotSameBuild): vimService.vim.FaultToleranceNotSameBuild;
         };
         FaultTolerancePrimaryPowerOnNotAttempted: {
            (options?: vimService.vim.FaultTolerancePrimaryPowerOnNotAttempted): vimService.vim.FaultTolerancePrimaryPowerOnNotAttempted;
         };
         FaultToleranceVmNotDasProtected: {
            (options?: vimService.vim.FaultToleranceVmNotDasProtected): vimService.vim.FaultToleranceVmNotDasProtected;
         };
         FcoeFault: {
            (options?: vimService.vim.FcoeFault): vimService.vim.FcoeFault;
         };
         FcoeFaultPnicHasNoPortSet: {
            (options?: vimService.vim.FcoeFaultPnicHasNoPortSet): vimService.vim.FcoeFaultPnicHasNoPortSet;
         };
         FeatureRequirementsNotMet: {
            (options?: vimService.vim.FeatureRequirementsNotMet): vimService.vim.FeatureRequirementsNotMet;
         };
         FileAlreadyExists: {
            (options?: vimService.vim.FileAlreadyExists): vimService.vim.FileAlreadyExists;
         };
         FileBackedPortNotSupported: {
            (options?: vimService.vim.FileBackedPortNotSupported): vimService.vim.FileBackedPortNotSupported;
         };
         FileFault: {
            (options?: vimService.vim.FileFault): vimService.vim.FileFault;
         };
         FileLocked: {
            (options?: vimService.vim.FileLocked): vimService.vim.FileLocked;
         };
         FileNameTooLong: {
            (options?: vimService.vim.FileNameTooLong): vimService.vim.FileNameTooLong;
         };
         FileNotFound: {
            (options?: vimService.vim.FileNotFound): vimService.vim.FileNotFound;
         };
         FileNotWritable: {
            (options?: vimService.vim.FileNotWritable): vimService.vim.FileNotWritable;
         };
         FileTooLarge: {
            (options?: vimService.vim.FileTooLarge): vimService.vim.FileTooLarge;
         };
         FilesystemQuiesceFault: {
            (options?: vimService.vim.FilesystemQuiesceFault): vimService.vim.FilesystemQuiesceFault;
         };
         FilterInUse: {
            (options?: vimService.vim.FilterInUse): vimService.vim.FilterInUse;
         };
         FtIssuesOnHostHostSelectionType: {
            "user": string;
            "vc": string;
            "drs": string;
         };
         FtIssuesOnHost: {
            (options?: vimService.vim.FtIssuesOnHost): vimService.vim.FtIssuesOnHost;
         };
         FullStorageVMotionNotSupported: {
            (options?: vimService.vim.FullStorageVMotionNotSupported): vimService.vim.FullStorageVMotionNotSupported;
         };
         GatewayConnectFault: {
            (options?: vimService.vim.GatewayConnectFault): vimService.vim.GatewayConnectFault;
         };
         GatewayHostNotReachable: {
            (options?: vimService.vim.GatewayHostNotReachable): vimService.vim.GatewayHostNotReachable;
         };
         GatewayNotFound: {
            (options?: vimService.vim.GatewayNotFound): vimService.vim.GatewayNotFound;
         };
         GatewayNotReachable: {
            (options?: vimService.vim.GatewayNotReachable): vimService.vim.GatewayNotReachable;
         };
         GatewayOperationRefused: {
            (options?: vimService.vim.GatewayOperationRefused): vimService.vim.GatewayOperationRefused;
         };
         GatewayToHostAuthFault: {
            (options?: vimService.vim.GatewayToHostAuthFault): vimService.vim.GatewayToHostAuthFault;
         };
         GatewayToHostConnectFault: {
            (options?: vimService.vim.GatewayToHostConnectFault): vimService.vim.GatewayToHostConnectFault;
         };
         GatewayToHostTrustVerifyFault: {
            (options?: vimService.vim.GatewayToHostTrustVerifyFault): vimService.vim.GatewayToHostTrustVerifyFault;
         };
         GenericDrsFault: {
            (options?: vimService.vim.GenericDrsFault): vimService.vim.GenericDrsFault;
         };
         GenericVmConfigFault: {
            (options?: vimService.vim.GenericVmConfigFault): vimService.vim.GenericVmConfigFault;
         };
         GuestAuthenticationChallenge: {
            (options?: vimService.vim.GuestAuthenticationChallenge): vimService.vim.GuestAuthenticationChallenge;
         };
         GuestComponentsOutOfDate: {
            (options?: vimService.vim.GuestComponentsOutOfDate): vimService.vim.GuestComponentsOutOfDate;
         };
         GuestMultipleMappings: {
            (options?: vimService.vim.GuestMultipleMappings): vimService.vim.GuestMultipleMappings;
         };
         GuestOperationsFault: {
            (options?: vimService.vim.GuestOperationsFault): vimService.vim.GuestOperationsFault;
         };
         GuestOperationsUnavailable: {
            (options?: vimService.vim.GuestOperationsUnavailable): vimService.vim.GuestOperationsUnavailable;
         };
         GuestPermissionDenied: {
            (options?: vimService.vim.GuestPermissionDenied): vimService.vim.GuestPermissionDenied;
         };
         GuestProcessNotFound: {
            (options?: vimService.vim.GuestProcessNotFound): vimService.vim.GuestProcessNotFound;
         };
         GuestRegistryFault: {
            (options?: vimService.vim.GuestRegistryFault): vimService.vim.GuestRegistryFault;
         };
         GuestRegistryKeyAlreadyExists: {
            (options?: vimService.vim.GuestRegistryKeyAlreadyExists): vimService.vim.GuestRegistryKeyAlreadyExists;
         };
         GuestRegistryKeyFault: {
            (options?: vimService.vim.GuestRegistryKeyFault): vimService.vim.GuestRegistryKeyFault;
         };
         GuestRegistryKeyHasSubkeys: {
            (options?: vimService.vim.GuestRegistryKeyHasSubkeys): vimService.vim.GuestRegistryKeyHasSubkeys;
         };
         GuestRegistryKeyInvalid: {
            (options?: vimService.vim.GuestRegistryKeyInvalid): vimService.vim.GuestRegistryKeyInvalid;
         };
         GuestRegistryKeyParentVolatile: {
            (options?: vimService.vim.GuestRegistryKeyParentVolatile): vimService.vim.GuestRegistryKeyParentVolatile;
         };
         GuestRegistryValueFault: {
            (options?: vimService.vim.GuestRegistryValueFault): vimService.vim.GuestRegistryValueFault;
         };
         GuestRegistryValueNotFound: {
            (options?: vimService.vim.GuestRegistryValueNotFound): vimService.vim.GuestRegistryValueNotFound;
         };
         HAErrorsAtDest: {
            (options?: vimService.vim.HAErrorsAtDest): vimService.vim.HAErrorsAtDest;
         };
         HeterogenousHostsBlockingEVC: {
            (options?: vimService.vim.HeterogenousHostsBlockingEVC): vimService.vim.HeterogenousHostsBlockingEVC;
         };
         HostAccessRestrictedToManagementServer: {
            (options?: vimService.vim.HostAccessRestrictedToManagementServer): vimService.vim.HostAccessRestrictedToManagementServer;
         };
         HostConfigFailed: {
            (options?: vimService.vim.HostConfigFailed): vimService.vim.HostConfigFailed;
         };
         HostConfigFault: {
            (options?: vimService.vim.HostConfigFault): vimService.vim.HostConfigFault;
         };
         HostConnectFault: {
            (options?: vimService.vim.HostConnectFault): vimService.vim.HostConnectFault;
         };
         HostHasComponentFailureHostComponentType: {
            "Datastore": string;
         };
         HostHasComponentFailure: {
            (options?: vimService.vim.HostHasComponentFailure): vimService.vim.HostHasComponentFailure;
         };
         HostInDomain: {
            (options?: vimService.vim.HostInDomain): vimService.vim.HostInDomain;
         };
         HostIncompatibleForFaultToleranceReason: {
            "product": string;
            "processor": string;
         };
         HostIncompatibleForFaultTolerance: {
            (options?: vimService.vim.HostIncompatibleForFaultTolerance): vimService.vim.HostIncompatibleForFaultTolerance;
         };
         HostIncompatibleForRecordReplayReason: {
            "product": string;
            "processor": string;
         };
         HostIncompatibleForRecordReplay: {
            (options?: vimService.vim.HostIncompatibleForRecordReplay): vimService.vim.HostIncompatibleForRecordReplay;
         };
         HostInventoryFull: {
            (options?: vimService.vim.HostInventoryFull): vimService.vim.HostInventoryFull;
         };
         HostPowerOpFailed: {
            (options?: vimService.vim.HostPowerOpFailed): vimService.vim.HostPowerOpFailed;
         };
         HostSpecificationOperationFailed: {
            (options?: vimService.vim.HostSpecificationOperationFailed): vimService.vim.HostSpecificationOperationFailed;
         };
         HotSnapshotMoveNotSupported: {
            (options?: vimService.vim.HotSnapshotMoveNotSupported): vimService.vim.HotSnapshotMoveNotSupported;
         };
         IDEDiskNotSupported: {
            (options?: vimService.vim.IDEDiskNotSupported): vimService.vim.IDEDiskNotSupported;
         };
         IORMNotSupportedHostOnDatastore: {
            (options?: vimService.vim.IORMNotSupportedHostOnDatastore): vimService.vim.IORMNotSupportedHostOnDatastore;
         };
         ImportHostAddFailure: {
            (options?: vimService.vim.ImportHostAddFailure): vimService.vim.ImportHostAddFailure;
         };
         ImportOperationBulkFaultFaultOnImport: {
            (options?: vimService.vim.ImportOperationBulkFaultFaultOnImport): vimService.vim.ImportOperationBulkFaultFaultOnImport;
         };
         ArrayOfImportOperationBulkFaultFaultOnImport: {
            (options?: vimService.vim.ArrayOfImportOperationBulkFaultFaultOnImport): vimService.vim.ArrayOfImportOperationBulkFaultFaultOnImport;
         };
         ImportOperationBulkFault: {
            (options?: vimService.vim.ImportOperationBulkFault): vimService.vim.ImportOperationBulkFault;
         };
         InUseFeatureManipulationDisallowed: {
            (options?: vimService.vim.InUseFeatureManipulationDisallowed): vimService.vim.InUseFeatureManipulationDisallowed;
         };
         InaccessibleDatastore: {
            (options?: vimService.vim.InaccessibleDatastore): vimService.vim.InaccessibleDatastore;
         };
         InaccessibleFTMetadataDatastore: {
            (options?: vimService.vim.InaccessibleFTMetadataDatastore): vimService.vim.InaccessibleFTMetadataDatastore;
         };
         InaccessibleVFlashSource: {
            (options?: vimService.vim.InaccessibleVFlashSource): vimService.vim.InaccessibleVFlashSource;
         };
         IncompatibleDefaultDevice: {
            (options?: vimService.vim.IncompatibleDefaultDevice): vimService.vim.IncompatibleDefaultDevice;
         };
         IncompatibleHostForFtSecondary: {
            (options?: vimService.vim.IncompatibleHostForFtSecondary): vimService.vim.IncompatibleHostForFtSecondary;
         };
         IncompatibleHostForVmReplicationIncompatibleReason: {
            "rpo": string;
            "netCompression": string;
         };
         IncompatibleHostForVmReplication: {
            (options?: vimService.vim.IncompatibleHostForVmReplication): vimService.vim.IncompatibleHostForVmReplication;
         };
         IncompatibleSetting: {
            (options?: vimService.vim.IncompatibleSetting): vimService.vim.IncompatibleSetting;
         };
         IncorrectFileType: {
            (options?: vimService.vim.IncorrectFileType): vimService.vim.IncorrectFileType;
         };
         IncorrectHostInformation: {
            (options?: vimService.vim.IncorrectHostInformation): vimService.vim.IncorrectHostInformation;
         };
         IndependentDiskVMotionNotSupported: {
            (options?: vimService.vim.IndependentDiskVMotionNotSupported): vimService.vim.IndependentDiskVMotionNotSupported;
         };
         InsufficientAgentVmsDeployed: {
            (options?: vimService.vim.InsufficientAgentVmsDeployed): vimService.vim.InsufficientAgentVmsDeployed;
         };
         InsufficientCpuResourcesFault: {
            (options?: vimService.vim.InsufficientCpuResourcesFault): vimService.vim.InsufficientCpuResourcesFault;
         };
         InsufficientDisks: {
            (options?: vimService.vim.InsufficientDisks): vimService.vim.InsufficientDisks;
         };
         InsufficientFailoverResourcesFault: {
            (options?: vimService.vim.InsufficientFailoverResourcesFault): vimService.vim.InsufficientFailoverResourcesFault;
         };
         InsufficientGraphicsResourcesFault: {
            (options?: vimService.vim.InsufficientGraphicsResourcesFault): vimService.vim.InsufficientGraphicsResourcesFault;
         };
         InsufficientHostCapacityFault: {
            (options?: vimService.vim.InsufficientHostCapacityFault): vimService.vim.InsufficientHostCapacityFault;
         };
         InsufficientHostCpuCapacityFault: {
            (options?: vimService.vim.InsufficientHostCpuCapacityFault): vimService.vim.InsufficientHostCpuCapacityFault;
         };
         InsufficientHostMemoryCapacityFault: {
            (options?: vimService.vim.InsufficientHostMemoryCapacityFault): vimService.vim.InsufficientHostMemoryCapacityFault;
         };
         InsufficientMemoryResourcesFault: {
            (options?: vimService.vim.InsufficientMemoryResourcesFault): vimService.vim.InsufficientMemoryResourcesFault;
         };
         InsufficientNetworkCapacity: {
            (options?: vimService.vim.InsufficientNetworkCapacity): vimService.vim.InsufficientNetworkCapacity;
         };
         InsufficientNetworkResourcePoolCapacity: {
            (options?: vimService.vim.InsufficientNetworkResourcePoolCapacity): vimService.vim.InsufficientNetworkResourcePoolCapacity;
         };
         InsufficientPerCpuCapacity: {
            (options?: vimService.vim.InsufficientPerCpuCapacity): vimService.vim.InsufficientPerCpuCapacity;
         };
         InsufficientResourcesFault: {
            (options?: vimService.vim.InsufficientResourcesFault): vimService.vim.InsufficientResourcesFault;
         };
         InsufficientStandbyCpuResource: {
            (options?: vimService.vim.InsufficientStandbyCpuResource): vimService.vim.InsufficientStandbyCpuResource;
         };
         InsufficientStandbyMemoryResource: {
            (options?: vimService.vim.InsufficientStandbyMemoryResource): vimService.vim.InsufficientStandbyMemoryResource;
         };
         InsufficientStandbyResource: {
            (options?: vimService.vim.InsufficientStandbyResource): vimService.vim.InsufficientStandbyResource;
         };
         InsufficientStorageIops: {
            (options?: vimService.vim.InsufficientStorageIops): vimService.vim.InsufficientStorageIops;
         };
         InsufficientStorageSpace: {
            (options?: vimService.vim.InsufficientStorageSpace): vimService.vim.InsufficientStorageSpace;
         };
         InsufficientVFlashResourcesFault: {
            (options?: vimService.vim.InsufficientVFlashResourcesFault): vimService.vim.InsufficientVFlashResourcesFault;
         };
         InvalidAffinitySettingFault: {
            (options?: vimService.vim.InvalidAffinitySettingFault): vimService.vim.InvalidAffinitySettingFault;
         };
         InvalidBmcRole: {
            (options?: vimService.vim.InvalidBmcRole): vimService.vim.InvalidBmcRole;
         };
         InvalidBundle: {
            (options?: vimService.vim.InvalidBundle): vimService.vim.InvalidBundle;
         };
         InvalidCAMCertificate: {
            (options?: vimService.vim.InvalidCAMCertificate): vimService.vim.InvalidCAMCertificate;
         };
         InvalidCAMServer: {
            (options?: vimService.vim.InvalidCAMServer): vimService.vim.InvalidCAMServer;
         };
         InvalidClientCertificate: {
            (options?: vimService.vim.InvalidClientCertificate): vimService.vim.InvalidClientCertificate;
         };
         InvalidController: {
            (options?: vimService.vim.InvalidController): vimService.vim.InvalidController;
         };
         InvalidDasConfigArgumentEntryForInvalidArgument: {
            "admissionControl": string;
            "userHeartbeatDs": string;
            "vmConfig": string;
         };
         InvalidDasConfigArgument: {
            (options?: vimService.vim.InvalidDasConfigArgument): vimService.vim.InvalidDasConfigArgument;
         };
         InvalidDasRestartPriorityForFtVm: {
            (options?: vimService.vim.InvalidDasRestartPriorityForFtVm): vimService.vim.InvalidDasRestartPriorityForFtVm;
         };
         InvalidDatastore: {
            (options?: vimService.vim.InvalidDatastore): vimService.vim.InvalidDatastore;
         };
         InvalidDatastorePath: {
            (options?: vimService.vim.InvalidDatastorePath): vimService.vim.InvalidDatastorePath;
         };
         InvalidDatastoreState: {
            (options?: vimService.vim.InvalidDatastoreState): vimService.vim.InvalidDatastoreState;
         };
         InvalidDeviceBacking: {
            (options?: vimService.vim.InvalidDeviceBacking): vimService.vim.InvalidDeviceBacking;
         };
         InvalidDeviceOperation: {
            (options?: vimService.vim.InvalidDeviceOperation): vimService.vim.InvalidDeviceOperation;
         };
         InvalidDeviceSpec: {
            (options?: vimService.vim.InvalidDeviceSpec): vimService.vim.InvalidDeviceSpec;
         };
         InvalidDiskFormat: {
            (options?: vimService.vim.InvalidDiskFormat): vimService.vim.InvalidDiskFormat;
         };
         InvalidDrsBehaviorForFtVm: {
            (options?: vimService.vim.InvalidDrsBehaviorForFtVm): vimService.vim.InvalidDrsBehaviorForFtVm;
         };
         InvalidEditionLicense: {
            (options?: vimService.vim.InvalidEditionLicense): vimService.vim.InvalidEditionLicense;
         };
         InvalidEvent: {
            (options?: vimService.vim.InvalidEvent): vimService.vim.InvalidEvent;
         };
         InvalidFolder: {
            (options?: vimService.vim.InvalidFolder): vimService.vim.InvalidFolder;
         };
         InvalidFormat: {
            (options?: vimService.vim.InvalidFormat): vimService.vim.InvalidFormat;
         };
         InvalidGuestLogin: {
            (options?: vimService.vim.InvalidGuestLogin): vimService.vim.InvalidGuestLogin;
         };
         InvalidHostConnectionState: {
            (options?: vimService.vim.InvalidHostConnectionState): vimService.vim.InvalidHostConnectionState;
         };
         InvalidHostName: {
            (options?: vimService.vim.InvalidHostName): vimService.vim.InvalidHostName;
         };
         InvalidHostState: {
            (options?: vimService.vim.InvalidHostState): vimService.vim.InvalidHostState;
         };
         InvalidIndexArgument: {
            (options?: vimService.vim.InvalidIndexArgument): vimService.vim.InvalidIndexArgument;
         };
         InvalidIpfixConfig: {
            (options?: vimService.vim.InvalidIpfixConfig): vimService.vim.InvalidIpfixConfig;
         };
         InvalidIpmiLoginInfo: {
            (options?: vimService.vim.InvalidIpmiLoginInfo): vimService.vim.InvalidIpmiLoginInfo;
         };
         InvalidIpmiMacAddress: {
            (options?: vimService.vim.InvalidIpmiMacAddress): vimService.vim.InvalidIpmiMacAddress;
         };
         InvalidLicense: {
            (options?: vimService.vim.InvalidLicense): vimService.vim.InvalidLicense;
         };
         InvalidLocale: {
            (options?: vimService.vim.InvalidLocale): vimService.vim.InvalidLocale;
         };
         InvalidLogin: {
            (options?: vimService.vim.InvalidLogin): vimService.vim.InvalidLogin;
         };
         InvalidName: {
            (options?: vimService.vim.InvalidName): vimService.vim.InvalidName;
         };
         InvalidNasCredentials: {
            (options?: vimService.vim.InvalidNasCredentials): vimService.vim.InvalidNasCredentials;
         };
         InvalidNetworkInType: {
            (options?: vimService.vim.InvalidNetworkInType): vimService.vim.InvalidNetworkInType;
         };
         InvalidNetworkResource: {
            (options?: vimService.vim.InvalidNetworkResource): vimService.vim.InvalidNetworkResource;
         };
         InvalidOperationOnSecondaryVm: {
            (options?: vimService.vim.InvalidOperationOnSecondaryVm): vimService.vim.InvalidOperationOnSecondaryVm;
         };
         InvalidPowerState: {
            (options?: vimService.vim.InvalidPowerState): vimService.vim.InvalidPowerState;
         };
         InvalidPrivilege: {
            (options?: vimService.vim.InvalidPrivilege): vimService.vim.InvalidPrivilege;
         };
         InvalidProfileReferenceHostReason: {
            "incompatibleVersion": string;
            "missingReferenceHost": string;
         };
         InvalidProfileReferenceHost: {
            (options?: vimService.vim.InvalidProfileReferenceHost): vimService.vim.InvalidProfileReferenceHost;
         };
         InvalidPropertyType: {
            (options?: vimService.vim.InvalidPropertyType): vimService.vim.InvalidPropertyType;
         };
         InvalidPropertyValue: {
            (options?: vimService.vim.InvalidPropertyValue): vimService.vim.InvalidPropertyValue;
         };
         InvalidResourcePoolStructureFault: {
            (options?: vimService.vim.InvalidResourcePoolStructureFault): vimService.vim.InvalidResourcePoolStructureFault;
         };
         InvalidSnapshotFormat: {
            (options?: vimService.vim.InvalidSnapshotFormat): vimService.vim.InvalidSnapshotFormat;
         };
         InvalidState: {
            (options?: vimService.vim.InvalidState): vimService.vim.InvalidState;
         };
         InvalidVmConfig: {
            (options?: vimService.vim.InvalidVmConfig): vimService.vim.InvalidVmConfig;
         };
         InvalidVmState: {
            (options?: vimService.vim.InvalidVmState): vimService.vim.InvalidVmState;
         };
         InventoryHasStandardAloneHosts: {
            (options?: vimService.vim.InventoryHasStandardAloneHosts): vimService.vim.InventoryHasStandardAloneHosts;
         };
         IpHostnameGeneratorError: {
            (options?: vimService.vim.IpHostnameGeneratorError): vimService.vim.IpHostnameGeneratorError;
         };
         IscsiFault: {
            (options?: vimService.vim.IscsiFault): vimService.vim.IscsiFault;
         };
         IscsiFaultInvalidVnic: {
            (options?: vimService.vim.IscsiFaultInvalidVnic): vimService.vim.IscsiFaultInvalidVnic;
         };
         IscsiFaultPnicInUse: {
            (options?: vimService.vim.IscsiFaultPnicInUse): vimService.vim.IscsiFaultPnicInUse;
         };
         IscsiFaultVnicAlreadyBound: {
            (options?: vimService.vim.IscsiFaultVnicAlreadyBound): vimService.vim.IscsiFaultVnicAlreadyBound;
         };
         IscsiFaultVnicHasActivePaths: {
            (options?: vimService.vim.IscsiFaultVnicHasActivePaths): vimService.vim.IscsiFaultVnicHasActivePaths;
         };
         IscsiFaultVnicHasMultipleUplinks: {
            (options?: vimService.vim.IscsiFaultVnicHasMultipleUplinks): vimService.vim.IscsiFaultVnicHasMultipleUplinks;
         };
         IscsiFaultVnicHasNoUplinks: {
            (options?: vimService.vim.IscsiFaultVnicHasNoUplinks): vimService.vim.IscsiFaultVnicHasNoUplinks;
         };
         IscsiFaultVnicHasWrongUplink: {
            (options?: vimService.vim.IscsiFaultVnicHasWrongUplink): vimService.vim.IscsiFaultVnicHasWrongUplink;
         };
         IscsiFaultVnicInUse: {
            (options?: vimService.vim.IscsiFaultVnicInUse): vimService.vim.IscsiFaultVnicInUse;
         };
         IscsiFaultVnicIsLastPath: {
            (options?: vimService.vim.IscsiFaultVnicIsLastPath): vimService.vim.IscsiFaultVnicIsLastPath;
         };
         IscsiFaultVnicNotBound: {
            (options?: vimService.vim.IscsiFaultVnicNotBound): vimService.vim.IscsiFaultVnicNotBound;
         };
         IscsiFaultVnicNotFound: {
            (options?: vimService.vim.IscsiFaultVnicNotFound): vimService.vim.IscsiFaultVnicNotFound;
         };
         LargeRDMConversionNotSupported: {
            (options?: vimService.vim.LargeRDMConversionNotSupported): vimService.vim.LargeRDMConversionNotSupported;
         };
         LargeRDMNotSupportedOnDatastore: {
            (options?: vimService.vim.LargeRDMNotSupportedOnDatastore): vimService.vim.LargeRDMNotSupportedOnDatastore;
         };
         LegacyNetworkInterfaceInUse: {
            (options?: vimService.vim.LegacyNetworkInterfaceInUse): vimService.vim.LegacyNetworkInterfaceInUse;
         };
         LicenseAssignmentFailedReason: {
            "keyEntityMismatch": string;
            "downgradeDisallowed": string;
            "inventoryNotManageableByVirtualCenter": string;
            "hostsUnmanageableByVirtualCenterWithoutLicenseServer": string;
         };
         LicenseAssignmentFailed: {
            (options?: vimService.vim.LicenseAssignmentFailed): vimService.vim.LicenseAssignmentFailed;
         };
         LicenseDowngradeDisallowed: {
            (options?: vimService.vim.LicenseDowngradeDisallowed): vimService.vim.LicenseDowngradeDisallowed;
         };
         LicenseEntityNotFound: {
            (options?: vimService.vim.LicenseEntityNotFound): vimService.vim.LicenseEntityNotFound;
         };
         LicenseExpired: {
            (options?: vimService.vim.LicenseExpired): vimService.vim.LicenseExpired;
         };
         LicenseKeyEntityMismatch: {
            (options?: vimService.vim.LicenseKeyEntityMismatch): vimService.vim.LicenseKeyEntityMismatch;
         };
         LicenseRestricted: {
            (options?: vimService.vim.LicenseRestricted): vimService.vim.LicenseRestricted;
         };
         LicenseServerUnavailable: {
            (options?: vimService.vim.LicenseServerUnavailable): vimService.vim.LicenseServerUnavailable;
         };
         LicenseSourceUnavailable: {
            (options?: vimService.vim.LicenseSourceUnavailable): vimService.vim.LicenseSourceUnavailable;
         };
         LimitExceeded: {
            (options?: vimService.vim.LimitExceeded): vimService.vim.LimitExceeded;
         };
         LinuxVolumeNotClean: {
            (options?: vimService.vim.LinuxVolumeNotClean): vimService.vim.LinuxVolumeNotClean;
         };
         LogBundlingFailed: {
            (options?: vimService.vim.LogBundlingFailed): vimService.vim.LogBundlingFailed;
         };
         MaintenanceModeFileMove: {
            (options?: vimService.vim.MaintenanceModeFileMove): vimService.vim.MaintenanceModeFileMove;
         };
         MemoryFileFormatNotSupportedByDatastore: {
            (options?: vimService.vim.MemoryFileFormatNotSupportedByDatastore): vimService.vim.MemoryFileFormatNotSupportedByDatastore;
         };
         MemoryHotPlugNotSupported: {
            (options?: vimService.vim.MemoryHotPlugNotSupported): vimService.vim.MemoryHotPlugNotSupported;
         };
         MemorySizeNotRecommended: {
            (options?: vimService.vim.MemorySizeNotRecommended): vimService.vim.MemorySizeNotRecommended;
         };
         MemorySizeNotSupported: {
            (options?: vimService.vim.MemorySizeNotSupported): vimService.vim.MemorySizeNotSupported;
         };
         MemorySizeNotSupportedByDatastore: {
            (options?: vimService.vim.MemorySizeNotSupportedByDatastore): vimService.vim.MemorySizeNotSupportedByDatastore;
         };
         MemorySnapshotOnIndependentDisk: {
            (options?: vimService.vim.MemorySnapshotOnIndependentDisk): vimService.vim.MemorySnapshotOnIndependentDisk;
         };
         MethodAlreadyDisabledFault: {
            (options?: vimService.vim.MethodAlreadyDisabledFault): vimService.vim.MethodAlreadyDisabledFault;
         };
         MethodDisabled: {
            (options?: vimService.vim.MethodDisabled): vimService.vim.MethodDisabled;
         };
         MigrationDisabled: {
            (options?: vimService.vim.MigrationDisabled): vimService.vim.MigrationDisabled;
         };
         MigrationFault: {
            (options?: vimService.vim.MigrationFault): vimService.vim.MigrationFault;
         };
         MigrationFeatureNotSupported: {
            (options?: vimService.vim.MigrationFeatureNotSupported): vimService.vim.MigrationFeatureNotSupported;
         };
         MigrationNotReady: {
            (options?: vimService.vim.MigrationNotReady): vimService.vim.MigrationNotReady;
         };
         MismatchedBundle: {
            (options?: vimService.vim.MismatchedBundle): vimService.vim.MismatchedBundle;
         };
         MismatchedNetworkPolicies: {
            (options?: vimService.vim.MismatchedNetworkPolicies): vimService.vim.MismatchedNetworkPolicies;
         };
         MismatchedVMotionNetworkNames: {
            (options?: vimService.vim.MismatchedVMotionNetworkNames): vimService.vim.MismatchedVMotionNetworkNames;
         };
         MissingBmcSupport: {
            (options?: vimService.vim.MissingBmcSupport): vimService.vim.MissingBmcSupport;
         };
         MissingController: {
            (options?: vimService.vim.MissingController): vimService.vim.MissingController;
         };
         MissingIpPool: {
            (options?: vimService.vim.MissingIpPool): vimService.vim.MissingIpPool;
         };
         MissingLinuxCustResources: {
            (options?: vimService.vim.MissingLinuxCustResources): vimService.vim.MissingLinuxCustResources;
         };
         MissingNetworkIpConfig: {
            (options?: vimService.vim.MissingNetworkIpConfig): vimService.vim.MissingNetworkIpConfig;
         };
         MissingPowerOffConfiguration: {
            (options?: vimService.vim.MissingPowerOffConfiguration): vimService.vim.MissingPowerOffConfiguration;
         };
         MissingPowerOnConfiguration: {
            (options?: vimService.vim.MissingPowerOnConfiguration): vimService.vim.MissingPowerOnConfiguration;
         };
         MissingWindowsCustResources: {
            (options?: vimService.vim.MissingWindowsCustResources): vimService.vim.MissingWindowsCustResources;
         };
         MksConnectionLimitReached: {
            (options?: vimService.vim.MksConnectionLimitReached): vimService.vim.MksConnectionLimitReached;
         };
         MountError: {
            (options?: vimService.vim.MountError): vimService.vim.MountError;
         };
         MultiWriterNotSupported: {
            (options?: vimService.vim.MultiWriterNotSupported): vimService.vim.MultiWriterNotSupported;
         };
         MultipleCertificatesVerifyFaultThumbprintData: {
            (options?: vimService.vim.MultipleCertificatesVerifyFaultThumbprintData): vimService.vim.MultipleCertificatesVerifyFaultThumbprintData;
         };
         ArrayOfMultipleCertificatesVerifyFaultThumbprintData: {
            (options?: vimService.vim.ArrayOfMultipleCertificatesVerifyFaultThumbprintData): vimService.vim.ArrayOfMultipleCertificatesVerifyFaultThumbprintData;
         };
         MultipleCertificatesVerifyFault: {
            (options?: vimService.vim.MultipleCertificatesVerifyFault): vimService.vim.MultipleCertificatesVerifyFault;
         };
         MultipleSnapshotsNotSupported: {
            (options?: vimService.vim.MultipleSnapshotsNotSupported): vimService.vim.MultipleSnapshotsNotSupported;
         };
         NamespaceFull: {
            (options?: vimService.vim.NamespaceFull): vimService.vim.NamespaceFull;
         };
         NamespaceLimitReached: {
            (options?: vimService.vim.NamespaceLimitReached): vimService.vim.NamespaceLimitReached;
         };
         NamespaceWriteProtected: {
            (options?: vimService.vim.NamespaceWriteProtected): vimService.vim.NamespaceWriteProtected;
         };
         NasConfigFault: {
            (options?: vimService.vim.NasConfigFault): vimService.vim.NasConfigFault;
         };
         NasConnectionLimitReached: {
            (options?: vimService.vim.NasConnectionLimitReached): vimService.vim.NasConnectionLimitReached;
         };
         NasSessionCredentialConflict: {
            (options?: vimService.vim.NasSessionCredentialConflict): vimService.vim.NasSessionCredentialConflict;
         };
         NasVolumeNotMounted: {
            (options?: vimService.vim.NasVolumeNotMounted): vimService.vim.NasVolumeNotMounted;
         };
         NetworkCopyFault: {
            (options?: vimService.vim.NetworkCopyFault): vimService.vim.NetworkCopyFault;
         };
         NetworkDisruptedAndConfigRolledBack: {
            (options?: vimService.vim.NetworkDisruptedAndConfigRolledBack): vimService.vim.NetworkDisruptedAndConfigRolledBack;
         };
         NetworkInaccessible: {
            (options?: vimService.vim.NetworkInaccessible): vimService.vim.NetworkInaccessible;
         };
         NetworksMayNotBeTheSame: {
            (options?: vimService.vim.NetworksMayNotBeTheSame): vimService.vim.NetworksMayNotBeTheSame;
         };
         NicSettingMismatch: {
            (options?: vimService.vim.NicSettingMismatch): vimService.vim.NicSettingMismatch;
         };
         NoActiveHostInCluster: {
            (options?: vimService.vim.NoActiveHostInCluster): vimService.vim.NoActiveHostInCluster;
         };
         NoAvailableIp: {
            (options?: vimService.vim.NoAvailableIp): vimService.vim.NoAvailableIp;
         };
         NoClientCertificate: {
            (options?: vimService.vim.NoClientCertificate): vimService.vim.NoClientCertificate;
         };
         NoCompatibleDatastore: {
            (options?: vimService.vim.NoCompatibleDatastore): vimService.vim.NoCompatibleDatastore;
         };
         NoCompatibleHardAffinityHost: {
            (options?: vimService.vim.NoCompatibleHardAffinityHost): vimService.vim.NoCompatibleHardAffinityHost;
         };
         NoCompatibleHost: {
            (options?: vimService.vim.NoCompatibleHost): vimService.vim.NoCompatibleHost;
         };
         NoCompatibleHostWithAccessToDevice: {
            (options?: vimService.vim.NoCompatibleHostWithAccessToDevice): vimService.vim.NoCompatibleHostWithAccessToDevice;
         };
         NoCompatibleSoftAffinityHost: {
            (options?: vimService.vim.NoCompatibleSoftAffinityHost): vimService.vim.NoCompatibleSoftAffinityHost;
         };
         NoConnectedDatastore: {
            (options?: vimService.vim.NoConnectedDatastore): vimService.vim.NoConnectedDatastore;
         };
         NoDiskFound: {
            (options?: vimService.vim.NoDiskFound): vimService.vim.NoDiskFound;
         };
         NoDiskSpace: {
            (options?: vimService.vim.NoDiskSpace): vimService.vim.NoDiskSpace;
         };
         NoDisksToCustomize: {
            (options?: vimService.vim.NoDisksToCustomize): vimService.vim.NoDisksToCustomize;
         };
         NoGateway: {
            (options?: vimService.vim.NoGateway): vimService.vim.NoGateway;
         };
         NoGuestHeartbeat: {
            (options?: vimService.vim.NoGuestHeartbeat): vimService.vim.NoGuestHeartbeat;
         };
         NoHost: {
            (options?: vimService.vim.NoHost): vimService.vim.NoHost;
         };
         NoHostSuitableForFtSecondary: {
            (options?: vimService.vim.NoHostSuitableForFtSecondary): vimService.vim.NoHostSuitableForFtSecondary;
         };
         NoLicenseServerConfigured: {
            (options?: vimService.vim.NoLicenseServerConfigured): vimService.vim.NoLicenseServerConfigured;
         };
         NoPeerHostFound: {
            (options?: vimService.vim.NoPeerHostFound): vimService.vim.NoPeerHostFound;
         };
         NoPermission: {
            (options?: vimService.vim.NoPermission): vimService.vim.NoPermission;
         };
         NoPermissionOnAD: {
            (options?: vimService.vim.NoPermissionOnAD): vimService.vim.NoPermissionOnAD;
         };
         NoPermissionOnHost: {
            (options?: vimService.vim.NoPermissionOnHost): vimService.vim.NoPermissionOnHost;
         };
         NoPermissionOnNasVolume: {
            (options?: vimService.vim.NoPermissionOnNasVolume): vimService.vim.NoPermissionOnNasVolume;
         };
         NoSubjectName: {
            (options?: vimService.vim.NoSubjectName): vimService.vim.NoSubjectName;
         };
         NoVcManagedIpConfigured: {
            (options?: vimService.vim.NoVcManagedIpConfigured): vimService.vim.NoVcManagedIpConfigured;
         };
         NoVirtualNic: {
            (options?: vimService.vim.NoVirtualNic): vimService.vim.NoVirtualNic;
         };
         NoVmInVApp: {
            (options?: vimService.vim.NoVmInVApp): vimService.vim.NoVmInVApp;
         };
         NonADUserRequired: {
            (options?: vimService.vim.NonADUserRequired): vimService.vim.NonADUserRequired;
         };
         NonHomeRDMVMotionNotSupported: {
            (options?: vimService.vim.NonHomeRDMVMotionNotSupported): vimService.vim.NonHomeRDMVMotionNotSupported;
         };
         NonPersistentDisksNotSupported: {
            (options?: vimService.vim.NonPersistentDisksNotSupported): vimService.vim.NonPersistentDisksNotSupported;
         };
         NonVmwareOuiMacNotSupportedHost: {
            (options?: vimService.vim.NonVmwareOuiMacNotSupportedHost): vimService.vim.NonVmwareOuiMacNotSupportedHost;
         };
         NotADirectory: {
            (options?: vimService.vim.NotADirectory): vimService.vim.NotADirectory;
         };
         NotAFile: {
            (options?: vimService.vim.NotAFile): vimService.vim.NotAFile;
         };
         NotAuthenticated: {
            (options?: vimService.vim.NotAuthenticated): vimService.vim.NotAuthenticated;
         };
         NotEnoughCpus: {
            (options?: vimService.vim.NotEnoughCpus): vimService.vim.NotEnoughCpus;
         };
         NotEnoughLogicalCpus: {
            (options?: vimService.vim.NotEnoughLogicalCpus): vimService.vim.NotEnoughLogicalCpus;
         };
         NotFound: {
            (options?: vimService.vim.NotFound): vimService.vim.NotFound;
         };
         NotSupportedDeviceForFTDeviceType: {
            "virtualVmxnet3": string;
            "paraVirtualSCSIController": string;
         };
         NotSupportedDeviceForFT: {
            (options?: vimService.vim.NotSupportedDeviceForFT): vimService.vim.NotSupportedDeviceForFT;
         };
         NotSupportedHost: {
            (options?: vimService.vim.NotSupportedHost): vimService.vim.NotSupportedHost;
         };
         NotSupportedHostForChecksum: {
            (options?: vimService.vim.NotSupportedHostForChecksum): vimService.vim.NotSupportedHostForChecksum;
         };
         NotSupportedHostForVFlash: {
            (options?: vimService.vim.NotSupportedHostForVFlash): vimService.vim.NotSupportedHostForVFlash;
         };
         NotSupportedHostForVmcp: {
            (options?: vimService.vim.NotSupportedHostForVmcp): vimService.vim.NotSupportedHostForVmcp;
         };
         NotSupportedHostForVmemFile: {
            (options?: vimService.vim.NotSupportedHostForVmemFile): vimService.vim.NotSupportedHostForVmemFile;
         };
         NotSupportedHostForVsan: {
            (options?: vimService.vim.NotSupportedHostForVsan): vimService.vim.NotSupportedHostForVsan;
         };
         NotSupportedHostInCluster: {
            (options?: vimService.vim.NotSupportedHostInCluster): vimService.vim.NotSupportedHostInCluster;
         };
         NotSupportedHostInDvs: {
            (options?: vimService.vim.NotSupportedHostInDvs): vimService.vim.NotSupportedHostInDvs;
         };
         NotSupportedHostInHACluster: {
            (options?: vimService.vim.NotSupportedHostInHACluster): vimService.vim.NotSupportedHostInHACluster;
         };
         NotUserConfigurableProperty: {
            (options?: vimService.vim.NotUserConfigurableProperty): vimService.vim.NotUserConfigurableProperty;
         };
         NumVirtualCoresPerSocketNotSupported: {
            (options?: vimService.vim.NumVirtualCoresPerSocketNotSupported): vimService.vim.NumVirtualCoresPerSocketNotSupported;
         };
         NumVirtualCpusExceedsLimit: {
            (options?: vimService.vim.NumVirtualCpusExceedsLimit): vimService.vim.NumVirtualCpusExceedsLimit;
         };
         NumVirtualCpusIncompatibleReason: {
            "recordReplay": string;
            "faultTolerance": string;
         };
         NumVirtualCpusIncompatible: {
            (options?: vimService.vim.NumVirtualCpusIncompatible): vimService.vim.NumVirtualCpusIncompatible;
         };
         NumVirtualCpusNotSupported: {
            (options?: vimService.vim.NumVirtualCpusNotSupported): vimService.vim.NumVirtualCpusNotSupported;
         };
         OperationDisabledByGuest: {
            (options?: vimService.vim.OperationDisabledByGuest): vimService.vim.OperationDisabledByGuest;
         };
         OperationDisallowedOnHost: {
            (options?: vimService.vim.OperationDisallowedOnHost): vimService.vim.OperationDisallowedOnHost;
         };
         OperationNotSupportedByGuest: {
            (options?: vimService.vim.OperationNotSupportedByGuest): vimService.vim.OperationNotSupportedByGuest;
         };
         OutOfBounds: {
            (options?: vimService.vim.OutOfBounds): vimService.vim.OutOfBounds;
         };
         OvfAttribute: {
            (options?: vimService.vim.OvfAttribute): vimService.vim.OvfAttribute;
         };
         OvfConnectedDevice: {
            (options?: vimService.vim.OvfConnectedDevice): vimService.vim.OvfConnectedDevice;
         };
         OvfConnectedDeviceFloppy: {
            (options?: vimService.vim.OvfConnectedDeviceFloppy): vimService.vim.OvfConnectedDeviceFloppy;
         };
         OvfConnectedDeviceIso: {
            (options?: vimService.vim.OvfConnectedDeviceIso): vimService.vim.OvfConnectedDeviceIso;
         };
         OvfConstraint: {
            (options?: vimService.vim.OvfConstraint): vimService.vim.OvfConstraint;
         };
         OvfConsumerCallbackFault: {
            (options?: vimService.vim.OvfConsumerCallbackFault): vimService.vim.OvfConsumerCallbackFault;
         };
         OvfConsumerCommunicationError: {
            (options?: vimService.vim.OvfConsumerCommunicationError): vimService.vim.OvfConsumerCommunicationError;
         };
         OvfConsumerFault: {
            (options?: vimService.vim.OvfConsumerFault): vimService.vim.OvfConsumerFault;
         };
         OvfConsumerInvalidSection: {
            (options?: vimService.vim.OvfConsumerInvalidSection): vimService.vim.OvfConsumerInvalidSection;
         };
         OvfConsumerPowerOnFault: {
            (options?: vimService.vim.OvfConsumerPowerOnFault): vimService.vim.OvfConsumerPowerOnFault;
         };
         OvfConsumerUndeclaredSection: {
            (options?: vimService.vim.OvfConsumerUndeclaredSection): vimService.vim.OvfConsumerUndeclaredSection;
         };
         OvfConsumerUndefinedPrefix: {
            (options?: vimService.vim.OvfConsumerUndefinedPrefix): vimService.vim.OvfConsumerUndefinedPrefix;
         };
         OvfConsumerValidationFault: {
            (options?: vimService.vim.OvfConsumerValidationFault): vimService.vim.OvfConsumerValidationFault;
         };
         OvfCpuCompatibility: {
            (options?: vimService.vim.OvfCpuCompatibility): vimService.vim.OvfCpuCompatibility;
         };
         OvfCpuCompatibilityCheckNotSupported: {
            (options?: vimService.vim.OvfCpuCompatibilityCheckNotSupported): vimService.vim.OvfCpuCompatibilityCheckNotSupported;
         };
         OvfDiskMappingNotFound: {
            (options?: vimService.vim.OvfDiskMappingNotFound): vimService.vim.OvfDiskMappingNotFound;
         };
         OvfDiskOrderConstraint: {
            (options?: vimService.vim.OvfDiskOrderConstraint): vimService.vim.OvfDiskOrderConstraint;
         };
         OvfDuplicateElement: {
            (options?: vimService.vim.OvfDuplicateElement): vimService.vim.OvfDuplicateElement;
         };
         OvfDuplicatedElementBoundary: {
            (options?: vimService.vim.OvfDuplicatedElementBoundary): vimService.vim.OvfDuplicatedElementBoundary;
         };
         OvfDuplicatedPropertyIdExport: {
            (options?: vimService.vim.OvfDuplicatedPropertyIdExport): vimService.vim.OvfDuplicatedPropertyIdExport;
         };
         OvfDuplicatedPropertyIdImport: {
            (options?: vimService.vim.OvfDuplicatedPropertyIdImport): vimService.vim.OvfDuplicatedPropertyIdImport;
         };
         OvfElement: {
            (options?: vimService.vim.OvfElement): vimService.vim.OvfElement;
         };
         OvfElementInvalidValue: {
            (options?: vimService.vim.OvfElementInvalidValue): vimService.vim.OvfElementInvalidValue;
         };
         OvfExport: {
            (options?: vimService.vim.OvfExport): vimService.vim.OvfExport;
         };
         OvfExportFailed: {
            (options?: vimService.vim.OvfExportFailed): vimService.vim.OvfExportFailed;
         };
         OvfFault: {
            (options?: vimService.vim.OvfFault): vimService.vim.OvfFault;
         };
         OvfHardwareCheck: {
            (options?: vimService.vim.OvfHardwareCheck): vimService.vim.OvfHardwareCheck;
         };
         OvfHardwareExport: {
            (options?: vimService.vim.OvfHardwareExport): vimService.vim.OvfHardwareExport;
         };
         OvfHostResourceConstraint: {
            (options?: vimService.vim.OvfHostResourceConstraint): vimService.vim.OvfHostResourceConstraint;
         };
         OvfHostValueNotParsed: {
            (options?: vimService.vim.OvfHostValueNotParsed): vimService.vim.OvfHostValueNotParsed;
         };
         OvfImport: {
            (options?: vimService.vim.OvfImport): vimService.vim.OvfImport;
         };
         OvfImportFailed: {
            (options?: vimService.vim.OvfImportFailed): vimService.vim.OvfImportFailed;
         };
         OvfInternalError: {
            (options?: vimService.vim.OvfInternalError): vimService.vim.OvfInternalError;
         };
         OvfInvalidPackage: {
            (options?: vimService.vim.OvfInvalidPackage): vimService.vim.OvfInvalidPackage;
         };
         OvfInvalidValue: {
            (options?: vimService.vim.OvfInvalidValue): vimService.vim.OvfInvalidValue;
         };
         OvfInvalidValueConfiguration: {
            (options?: vimService.vim.OvfInvalidValueConfiguration): vimService.vim.OvfInvalidValueConfiguration;
         };
         OvfInvalidValueEmpty: {
            (options?: vimService.vim.OvfInvalidValueEmpty): vimService.vim.OvfInvalidValueEmpty;
         };
         OvfInvalidValueFormatMalformed: {
            (options?: vimService.vim.OvfInvalidValueFormatMalformed): vimService.vim.OvfInvalidValueFormatMalformed;
         };
         OvfInvalidValueReference: {
            (options?: vimService.vim.OvfInvalidValueReference): vimService.vim.OvfInvalidValueReference;
         };
         OvfInvalidVmName: {
            (options?: vimService.vim.OvfInvalidVmName): vimService.vim.OvfInvalidVmName;
         };
         OvfMappedOsId: {
            (options?: vimService.vim.OvfMappedOsId): vimService.vim.OvfMappedOsId;
         };
         OvfMissingAttribute: {
            (options?: vimService.vim.OvfMissingAttribute): vimService.vim.OvfMissingAttribute;
         };
         OvfMissingElement: {
            (options?: vimService.vim.OvfMissingElement): vimService.vim.OvfMissingElement;
         };
         OvfMissingElementNormalBoundary: {
            (options?: vimService.vim.OvfMissingElementNormalBoundary): vimService.vim.OvfMissingElementNormalBoundary;
         };
         OvfMissingHardware: {
            (options?: vimService.vim.OvfMissingHardware): vimService.vim.OvfMissingHardware;
         };
         OvfNetworkMappingNotSupported: {
            (options?: vimService.vim.OvfNetworkMappingNotSupported): vimService.vim.OvfNetworkMappingNotSupported;
         };
         OvfNoHostNic: {
            (options?: vimService.vim.OvfNoHostNic): vimService.vim.OvfNoHostNic;
         };
         OvfNoSpaceOnController: {
            (options?: vimService.vim.OvfNoSpaceOnController): vimService.vim.OvfNoSpaceOnController;
         };
         OvfNoSupportedHardwareFamily: {
            (options?: vimService.vim.OvfNoSupportedHardwareFamily): vimService.vim.OvfNoSupportedHardwareFamily;
         };
         OvfProperty: {
            (options?: vimService.vim.OvfProperty): vimService.vim.OvfProperty;
         };
         OvfPropertyExport: {
            (options?: vimService.vim.OvfPropertyExport): vimService.vim.OvfPropertyExport;
         };
         OvfPropertyNetwork: {
            (options?: vimService.vim.OvfPropertyNetwork): vimService.vim.OvfPropertyNetwork;
         };
         OvfPropertyNetworkExport: {
            (options?: vimService.vim.OvfPropertyNetworkExport): vimService.vim.OvfPropertyNetworkExport;
         };
         OvfPropertyQualifier: {
            (options?: vimService.vim.OvfPropertyQualifier): vimService.vim.OvfPropertyQualifier;
         };
         OvfPropertyQualifierDuplicate: {
            (options?: vimService.vim.OvfPropertyQualifierDuplicate): vimService.vim.OvfPropertyQualifierDuplicate;
         };
         OvfPropertyQualifierIgnored: {
            (options?: vimService.vim.OvfPropertyQualifierIgnored): vimService.vim.OvfPropertyQualifierIgnored;
         };
         OvfPropertyType: {
            (options?: vimService.vim.OvfPropertyType): vimService.vim.OvfPropertyType;
         };
         OvfPropertyValue: {
            (options?: vimService.vim.OvfPropertyValue): vimService.vim.OvfPropertyValue;
         };
         OvfSystemFault: {
            (options?: vimService.vim.OvfSystemFault): vimService.vim.OvfSystemFault;
         };
         OvfToXmlUnsupportedElement: {
            (options?: vimService.vim.OvfToXmlUnsupportedElement): vimService.vim.OvfToXmlUnsupportedElement;
         };
         OvfUnableToExportDisk: {
            (options?: vimService.vim.OvfUnableToExportDisk): vimService.vim.OvfUnableToExportDisk;
         };
         OvfUnexpectedElement: {
            (options?: vimService.vim.OvfUnexpectedElement): vimService.vim.OvfUnexpectedElement;
         };
         OvfUnknownDevice: {
            (options?: vimService.vim.OvfUnknownDevice): vimService.vim.OvfUnknownDevice;
         };
         OvfUnknownDeviceBacking: {
            (options?: vimService.vim.OvfUnknownDeviceBacking): vimService.vim.OvfUnknownDeviceBacking;
         };
         OvfUnknownEntity: {
            (options?: vimService.vim.OvfUnknownEntity): vimService.vim.OvfUnknownEntity;
         };
         OvfUnsupportedAttribute: {
            (options?: vimService.vim.OvfUnsupportedAttribute): vimService.vim.OvfUnsupportedAttribute;
         };
         OvfUnsupportedAttributeValue: {
            (options?: vimService.vim.OvfUnsupportedAttributeValue): vimService.vim.OvfUnsupportedAttributeValue;
         };
         OvfUnsupportedDeviceBackingInfo: {
            (options?: vimService.vim.OvfUnsupportedDeviceBackingInfo): vimService.vim.OvfUnsupportedDeviceBackingInfo;
         };
         OvfUnsupportedDeviceBackingOption: {
            (options?: vimService.vim.OvfUnsupportedDeviceBackingOption): vimService.vim.OvfUnsupportedDeviceBackingOption;
         };
         OvfUnsupportedDeviceExport: {
            (options?: vimService.vim.OvfUnsupportedDeviceExport): vimService.vim.OvfUnsupportedDeviceExport;
         };
         OvfUnsupportedDiskProvisioning: {
            (options?: vimService.vim.OvfUnsupportedDiskProvisioning): vimService.vim.OvfUnsupportedDiskProvisioning;
         };
         OvfUnsupportedElement: {
            (options?: vimService.vim.OvfUnsupportedElement): vimService.vim.OvfUnsupportedElement;
         };
         OvfUnsupportedElementValue: {
            (options?: vimService.vim.OvfUnsupportedElementValue): vimService.vim.OvfUnsupportedElementValue;
         };
         OvfUnsupportedPackage: {
            (options?: vimService.vim.OvfUnsupportedPackage): vimService.vim.OvfUnsupportedPackage;
         };
         OvfUnsupportedSection: {
            (options?: vimService.vim.OvfUnsupportedSection): vimService.vim.OvfUnsupportedSection;
         };
         OvfUnsupportedSubType: {
            (options?: vimService.vim.OvfUnsupportedSubType): vimService.vim.OvfUnsupportedSubType;
         };
         OvfUnsupportedType: {
            (options?: vimService.vim.OvfUnsupportedType): vimService.vim.OvfUnsupportedType;
         };
         OvfWrongElement: {
            (options?: vimService.vim.OvfWrongElement): vimService.vim.OvfWrongElement;
         };
         OvfWrongNamespace: {
            (options?: vimService.vim.OvfWrongNamespace): vimService.vim.OvfWrongNamespace;
         };
         OvfXmlFormat: {
            (options?: vimService.vim.OvfXmlFormat): vimService.vim.OvfXmlFormat;
         };
         PatchAlreadyInstalled: {
            (options?: vimService.vim.PatchAlreadyInstalled): vimService.vim.PatchAlreadyInstalled;
         };
         PatchBinariesNotFound: {
            (options?: vimService.vim.PatchBinariesNotFound): vimService.vim.PatchBinariesNotFound;
         };
         PatchInstallFailed: {
            (options?: vimService.vim.PatchInstallFailed): vimService.vim.PatchInstallFailed;
         };
         PatchIntegrityError: {
            (options?: vimService.vim.PatchIntegrityError): vimService.vim.PatchIntegrityError;
         };
         PatchMetadataCorrupted: {
            (options?: vimService.vim.PatchMetadataCorrupted): vimService.vim.PatchMetadataCorrupted;
         };
         PatchMetadataInvalid: {
            (options?: vimService.vim.PatchMetadataInvalid): vimService.vim.PatchMetadataInvalid;
         };
         PatchMetadataNotFound: {
            (options?: vimService.vim.PatchMetadataNotFound): vimService.vim.PatchMetadataNotFound;
         };
         PatchMissingDependencies: {
            (options?: vimService.vim.PatchMissingDependencies): vimService.vim.PatchMissingDependencies;
         };
         PatchNotApplicable: {
            (options?: vimService.vim.PatchNotApplicable): vimService.vim.PatchNotApplicable;
         };
         PatchSuperseded: {
            (options?: vimService.vim.PatchSuperseded): vimService.vim.PatchSuperseded;
         };
         PhysCompatRDMNotSupported: {
            (options?: vimService.vim.PhysCompatRDMNotSupported): vimService.vim.PhysCompatRDMNotSupported;
         };
         PlatformConfigFault: {
            (options?: vimService.vim.PlatformConfigFault): vimService.vim.PlatformConfigFault;
         };
         PowerOnFtSecondaryFailed: {
            (options?: vimService.vim.PowerOnFtSecondaryFailed): vimService.vim.PowerOnFtSecondaryFailed;
         };
         PowerOnFtSecondaryTimedout: {
            (options?: vimService.vim.PowerOnFtSecondaryTimedout): vimService.vim.PowerOnFtSecondaryTimedout;
         };
         ProfileUpdateFailedUpdateFailure: {
            (options?: vimService.vim.ProfileUpdateFailedUpdateFailure): vimService.vim.ProfileUpdateFailedUpdateFailure;
         };
         ArrayOfProfileUpdateFailedUpdateFailure: {
            (options?: vimService.vim.ArrayOfProfileUpdateFailedUpdateFailure): vimService.vim.ArrayOfProfileUpdateFailedUpdateFailure;
         };
         ProfileUpdateFailed: {
            (options?: vimService.vim.ProfileUpdateFailed): vimService.vim.ProfileUpdateFailed;
         };
         QuarantineModeFaultFaultType: {
            "NoCompatibleNonQuarantinedHost": string;
            "CorrectionDisallowed": string;
            "CorrectionImpact": string;
         };
         QuarantineModeFault: {
            (options?: vimService.vim.QuarantineModeFault): vimService.vim.QuarantineModeFault;
         };
         QuestionPending: {
            (options?: vimService.vim.QuestionPending): vimService.vim.QuestionPending;
         };
         QuiesceDatastoreIOForHAFailed: {
            (options?: vimService.vim.QuiesceDatastoreIOForHAFailed): vimService.vim.QuiesceDatastoreIOForHAFailed;
         };
         RDMConversionNotSupported: {
            (options?: vimService.vim.RDMConversionNotSupported): vimService.vim.RDMConversionNotSupported;
         };
         RDMNotPreserved: {
            (options?: vimService.vim.RDMNotPreserved): vimService.vim.RDMNotPreserved;
         };
         RDMNotSupported: {
            (options?: vimService.vim.RDMNotSupported): vimService.vim.RDMNotSupported;
         };
         RDMNotSupportedOnDatastore: {
            (options?: vimService.vim.RDMNotSupportedOnDatastore): vimService.vim.RDMNotSupportedOnDatastore;
         };
         RDMPointsToInaccessibleDisk: {
            (options?: vimService.vim.RDMPointsToInaccessibleDisk): vimService.vim.RDMPointsToInaccessibleDisk;
         };
         RawDiskNotSupported: {
            (options?: vimService.vim.RawDiskNotSupported): vimService.vim.RawDiskNotSupported;
         };
         ReadHostResourcePoolTreeFailed: {
            (options?: vimService.vim.ReadHostResourcePoolTreeFailed): vimService.vim.ReadHostResourcePoolTreeFailed;
         };
         ReadOnlyDisksWithLegacyDestination: {
            (options?: vimService.vim.ReadOnlyDisksWithLegacyDestination): vimService.vim.ReadOnlyDisksWithLegacyDestination;
         };
         RebootRequired: {
            (options?: vimService.vim.RebootRequired): vimService.vim.RebootRequired;
         };
         RecordReplayDisabled: {
            (options?: vimService.vim.RecordReplayDisabled): vimService.vim.RecordReplayDisabled;
         };
         RemoteDeviceNotSupported: {
            (options?: vimService.vim.RemoteDeviceNotSupported): vimService.vim.RemoteDeviceNotSupported;
         };
         RemoveFailed: {
            (options?: vimService.vim.RemoveFailed): vimService.vim.RemoveFailed;
         };
         ReplicationConfigFault: {
            (options?: vimService.vim.ReplicationConfigFault): vimService.vim.ReplicationConfigFault;
         };
         ReplicationDiskConfigFaultReasonForFault: {
            "diskNotFound": string;
            "diskTypeNotSupported": string;
            "invalidDiskKey": string;
            "invalidDiskReplicationId": string;
            "duplicateDiskReplicationId": string;
            "invalidPersistentFilePath": string;
            "reconfigureDiskReplicationIdNotAllowed": string;
         };
         ReplicationDiskConfigFault: {
            (options?: vimService.vim.ReplicationDiskConfigFault): vimService.vim.ReplicationDiskConfigFault;
         };
         ReplicationFault: {
            (options?: vimService.vim.ReplicationFault): vimService.vim.ReplicationFault;
         };
         ReplicationIncompatibleWithFT: {
            (options?: vimService.vim.ReplicationIncompatibleWithFT): vimService.vim.ReplicationIncompatibleWithFT;
         };
         ReplicationInvalidOptions: {
            (options?: vimService.vim.ReplicationInvalidOptions): vimService.vim.ReplicationInvalidOptions;
         };
         ReplicationNotSupportedOnHost: {
            (options?: vimService.vim.ReplicationNotSupportedOnHost): vimService.vim.ReplicationNotSupportedOnHost;
         };
         ReplicationVmConfigFaultReasonForFault: {
            "incompatibleHwVersion": string;
            "invalidVmReplicationId": string;
            "invalidGenerationNumber": string;
            "outOfBoundsRpoValue": string;
            "invalidDestinationIpAddress": string;
            "invalidDestinationPort": string;
            "invalidExtraVmOptions": string;
            "staleGenerationNumber": string;
            "reconfigureVmReplicationIdNotAllowed": string;
            "cannotRetrieveVmReplicationConfiguration": string;
            "replicationAlreadyEnabled": string;
            "invalidPriorConfiguration": string;
            "replicationNotEnabled": string;
            "replicationConfigurationFailed": string;
            "encryptedVm": string;
         };
         ReplicationVmConfigFault: {
            (options?: vimService.vim.ReplicationVmConfigFault): vimService.vim.ReplicationVmConfigFault;
         };
         ReplicationVmFaultReasonForFault: {
            "notConfigured": string;
            "poweredOff": string;
            "suspended": string;
            "poweredOn": string;
            "offlineReplicating": string;
            "invalidState": string;
            "invalidInstanceId": string;
            "closeDiskError": string;
         };
         ReplicationVmFault: {
            (options?: vimService.vim.ReplicationVmFault): vimService.vim.ReplicationVmFault;
         };
         ReplicationVmInProgressFaultActivity: {
            "fullSync": string;
            "delta": string;
         };
         ReplicationVmInProgressFault: {
            (options?: vimService.vim.ReplicationVmInProgressFault): vimService.vim.ReplicationVmInProgressFault;
         };
         ResourceInUse: {
            (options?: vimService.vim.ResourceInUse): vimService.vim.ResourceInUse;
         };
         ResourceNotAvailable: {
            (options?: vimService.vim.ResourceNotAvailable): vimService.vim.ResourceNotAvailable;
         };
         RestrictedByAdministrator: {
            (options?: vimService.vim.RestrictedByAdministrator): vimService.vim.RestrictedByAdministrator;
         };
         RestrictedVersion: {
            (options?: vimService.vim.RestrictedVersion): vimService.vim.RestrictedVersion;
         };
         RollbackFailure: {
            (options?: vimService.vim.RollbackFailure): vimService.vim.RollbackFailure;
         };
         RuleViolation: {
            (options?: vimService.vim.RuleViolation): vimService.vim.RuleViolation;
         };
         SSLDisabledFault: {
            (options?: vimService.vim.SSLDisabledFault): vimService.vim.SSLDisabledFault;
         };
         SSLVerifyFault: {
            (options?: vimService.vim.SSLVerifyFault): vimService.vim.SSLVerifyFault;
         };
         SSPIChallenge: {
            (options?: vimService.vim.SSPIChallenge): vimService.vim.SSPIChallenge;
         };
         SecondaryVmAlreadyDisabled: {
            (options?: vimService.vim.SecondaryVmAlreadyDisabled): vimService.vim.SecondaryVmAlreadyDisabled;
         };
         SecondaryVmAlreadyEnabled: {
            (options?: vimService.vim.SecondaryVmAlreadyEnabled): vimService.vim.SecondaryVmAlreadyEnabled;
         };
         SecondaryVmAlreadyRegistered: {
            (options?: vimService.vim.SecondaryVmAlreadyRegistered): vimService.vim.SecondaryVmAlreadyRegistered;
         };
         SecondaryVmNotRegistered: {
            (options?: vimService.vim.SecondaryVmNotRegistered): vimService.vim.SecondaryVmNotRegistered;
         };
         SharedBusControllerNotSupported: {
            (options?: vimService.vim.SharedBusControllerNotSupported): vimService.vim.SharedBusControllerNotSupported;
         };
         ShrinkDiskFault: {
            (options?: vimService.vim.ShrinkDiskFault): vimService.vim.ShrinkDiskFault;
         };
         SnapshotCloneNotSupported: {
            (options?: vimService.vim.SnapshotCloneNotSupported): vimService.vim.SnapshotCloneNotSupported;
         };
         SnapshotCopyNotSupported: {
            (options?: vimService.vim.SnapshotCopyNotSupported): vimService.vim.SnapshotCopyNotSupported;
         };
         SnapshotDisabled: {
            (options?: vimService.vim.SnapshotDisabled): vimService.vim.SnapshotDisabled;
         };
         SnapshotFault: {
            (options?: vimService.vim.SnapshotFault): vimService.vim.SnapshotFault;
         };
         SnapshotIncompatibleDeviceInVm: {
            (options?: vimService.vim.SnapshotIncompatibleDeviceInVm): vimService.vim.SnapshotIncompatibleDeviceInVm;
         };
         SnapshotLocked: {
            (options?: vimService.vim.SnapshotLocked): vimService.vim.SnapshotLocked;
         };
         SnapshotMoveFromNonHomeNotSupported: {
            (options?: vimService.vim.SnapshotMoveFromNonHomeNotSupported): vimService.vim.SnapshotMoveFromNonHomeNotSupported;
         };
         SnapshotMoveNotSupported: {
            (options?: vimService.vim.SnapshotMoveNotSupported): vimService.vim.SnapshotMoveNotSupported;
         };
         SnapshotMoveToNonHomeNotSupported: {
            (options?: vimService.vim.SnapshotMoveToNonHomeNotSupported): vimService.vim.SnapshotMoveToNonHomeNotSupported;
         };
         SnapshotNoChange: {
            (options?: vimService.vim.SnapshotNoChange): vimService.vim.SnapshotNoChange;
         };
         SnapshotRevertIssue: {
            (options?: vimService.vim.SnapshotRevertIssue): vimService.vim.SnapshotRevertIssue;
         };
         SoftRuleVioCorrectionDisallowed: {
            (options?: vimService.vim.SoftRuleVioCorrectionDisallowed): vimService.vim.SoftRuleVioCorrectionDisallowed;
         };
         SoftRuleVioCorrectionImpact: {
            (options?: vimService.vim.SoftRuleVioCorrectionImpact): vimService.vim.SoftRuleVioCorrectionImpact;
         };
         SsdDiskNotAvailable: {
            (options?: vimService.vim.SsdDiskNotAvailable): vimService.vim.SsdDiskNotAvailable;
         };
         StorageDrsCannotMoveDiskInMultiWriterMode: {
            (options?: vimService.vim.StorageDrsCannotMoveDiskInMultiWriterMode): vimService.vim.StorageDrsCannotMoveDiskInMultiWriterMode;
         };
         StorageDrsCannotMoveFTVm: {
            (options?: vimService.vim.StorageDrsCannotMoveFTVm): vimService.vim.StorageDrsCannotMoveFTVm;
         };
         StorageDrsCannotMoveIndependentDisk: {
            (options?: vimService.vim.StorageDrsCannotMoveIndependentDisk): vimService.vim.StorageDrsCannotMoveIndependentDisk;
         };
         StorageDrsCannotMoveManuallyPlacedSwapFile: {
            (options?: vimService.vim.StorageDrsCannotMoveManuallyPlacedSwapFile): vimService.vim.StorageDrsCannotMoveManuallyPlacedSwapFile;
         };
         StorageDrsCannotMoveManuallyPlacedVm: {
            (options?: vimService.vim.StorageDrsCannotMoveManuallyPlacedVm): vimService.vim.StorageDrsCannotMoveManuallyPlacedVm;
         };
         StorageDrsCannotMoveSharedDisk: {
            (options?: vimService.vim.StorageDrsCannotMoveSharedDisk): vimService.vim.StorageDrsCannotMoveSharedDisk;
         };
         StorageDrsCannotMoveTemplate: {
            (options?: vimService.vim.StorageDrsCannotMoveTemplate): vimService.vim.StorageDrsCannotMoveTemplate;
         };
         StorageDrsCannotMoveVmInUserFolder: {
            (options?: vimService.vim.StorageDrsCannotMoveVmInUserFolder): vimService.vim.StorageDrsCannotMoveVmInUserFolder;
         };
         StorageDrsCannotMoveVmWithMountedCDROM: {
            (options?: vimService.vim.StorageDrsCannotMoveVmWithMountedCDROM): vimService.vim.StorageDrsCannotMoveVmWithMountedCDROM;
         };
         StorageDrsCannotMoveVmWithNoFilesInLayout: {
            (options?: vimService.vim.StorageDrsCannotMoveVmWithNoFilesInLayout): vimService.vim.StorageDrsCannotMoveVmWithNoFilesInLayout;
         };
         StorageDrsDatacentersCannotShareDatastore: {
            (options?: vimService.vim.StorageDrsDatacentersCannotShareDatastore): vimService.vim.StorageDrsDatacentersCannotShareDatastore;
         };
         StorageDrsDisabledOnVm: {
            (options?: vimService.vim.StorageDrsDisabledOnVm): vimService.vim.StorageDrsDisabledOnVm;
         };
         StorageDrsHbrDiskNotMovable: {
            (options?: vimService.vim.StorageDrsHbrDiskNotMovable): vimService.vim.StorageDrsHbrDiskNotMovable;
         };
         StorageDrsHmsMoveInProgress: {
            (options?: vimService.vim.StorageDrsHmsMoveInProgress): vimService.vim.StorageDrsHmsMoveInProgress;
         };
         StorageDrsHmsUnreachable: {
            (options?: vimService.vim.StorageDrsHmsUnreachable): vimService.vim.StorageDrsHmsUnreachable;
         };
         StorageDrsIolbDisabledInternally: {
            (options?: vimService.vim.StorageDrsIolbDisabledInternally): vimService.vim.StorageDrsIolbDisabledInternally;
         };
         StorageDrsRelocateDisabled: {
            (options?: vimService.vim.StorageDrsRelocateDisabled): vimService.vim.StorageDrsRelocateDisabled;
         };
         StorageDrsStaleHmsCollection: {
            (options?: vimService.vim.StorageDrsStaleHmsCollection): vimService.vim.StorageDrsStaleHmsCollection;
         };
         StorageDrsUnableToMoveFiles: {
            (options?: vimService.vim.StorageDrsUnableToMoveFiles): vimService.vim.StorageDrsUnableToMoveFiles;
         };
         StorageVMotionNotSupported: {
            (options?: vimService.vim.StorageVMotionNotSupported): vimService.vim.StorageVMotionNotSupported;
         };
         StorageVmotionIncompatible: {
            (options?: vimService.vim.StorageVmotionIncompatible): vimService.vim.StorageVmotionIncompatible;
         };
         SuspendedRelocateNotSupported: {
            (options?: vimService.vim.SuspendedRelocateNotSupported): vimService.vim.SuspendedRelocateNotSupported;
         };
         SwapDatastoreNotWritableOnHost: {
            (options?: vimService.vim.SwapDatastoreNotWritableOnHost): vimService.vim.SwapDatastoreNotWritableOnHost;
         };
         SwapDatastoreUnset: {
            (options?: vimService.vim.SwapDatastoreUnset): vimService.vim.SwapDatastoreUnset;
         };
         SwapPlacementOverrideNotSupported: {
            (options?: vimService.vim.SwapPlacementOverrideNotSupported): vimService.vim.SwapPlacementOverrideNotSupported;
         };
         SwitchIpUnset: {
            (options?: vimService.vim.SwitchIpUnset): vimService.vim.SwitchIpUnset;
         };
         SwitchNotInUpgradeMode: {
            (options?: vimService.vim.SwitchNotInUpgradeMode): vimService.vim.SwitchNotInUpgradeMode;
         };
         TaskInProgress: {
            (options?: vimService.vim.TaskInProgress): vimService.vim.TaskInProgress;
         };
         ThirdPartyLicenseAssignmentFailedReason: {
            "licenseAssignmentFailed": string;
            "moduleNotInstalled": string;
         };
         ThirdPartyLicenseAssignmentFailed: {
            (options?: vimService.vim.ThirdPartyLicenseAssignmentFailed): vimService.vim.ThirdPartyLicenseAssignmentFailed;
         };
         Timedout: {
            (options?: vimService.vim.Timedout): vimService.vim.Timedout;
         };
         TooManyConcurrentNativeClones: {
            (options?: vimService.vim.TooManyConcurrentNativeClones): vimService.vim.TooManyConcurrentNativeClones;
         };
         TooManyConsecutiveOverrides: {
            (options?: vimService.vim.TooManyConsecutiveOverrides): vimService.vim.TooManyConsecutiveOverrides;
         };
         TooManyDevices: {
            (options?: vimService.vim.TooManyDevices): vimService.vim.TooManyDevices;
         };
         TooManyDisksOnLegacyHost: {
            (options?: vimService.vim.TooManyDisksOnLegacyHost): vimService.vim.TooManyDisksOnLegacyHost;
         };
         TooManyGuestLogons: {
            (options?: vimService.vim.TooManyGuestLogons): vimService.vim.TooManyGuestLogons;
         };
         TooManyHosts: {
            (options?: vimService.vim.TooManyHosts): vimService.vim.TooManyHosts;
         };
         TooManyNativeCloneLevels: {
            (options?: vimService.vim.TooManyNativeCloneLevels): vimService.vim.TooManyNativeCloneLevels;
         };
         TooManyNativeClonesOnFile: {
            (options?: vimService.vim.TooManyNativeClonesOnFile): vimService.vim.TooManyNativeClonesOnFile;
         };
         TooManySnapshotLevels: {
            (options?: vimService.vim.TooManySnapshotLevels): vimService.vim.TooManySnapshotLevels;
         };
         ToolsAlreadyUpgraded: {
            (options?: vimService.vim.ToolsAlreadyUpgraded): vimService.vim.ToolsAlreadyUpgraded;
         };
         ToolsAutoUpgradeNotSupported: {
            (options?: vimService.vim.ToolsAutoUpgradeNotSupported): vimService.vim.ToolsAutoUpgradeNotSupported;
         };
         ToolsImageCopyFailed: {
            (options?: vimService.vim.ToolsImageCopyFailed): vimService.vim.ToolsImageCopyFailed;
         };
         ToolsImageNotAvailable: {
            (options?: vimService.vim.ToolsImageNotAvailable): vimService.vim.ToolsImageNotAvailable;
         };
         ToolsImageSignatureCheckFailed: {
            (options?: vimService.vim.ToolsImageSignatureCheckFailed): vimService.vim.ToolsImageSignatureCheckFailed;
         };
         ToolsInstallationInProgress: {
            (options?: vimService.vim.ToolsInstallationInProgress): vimService.vim.ToolsInstallationInProgress;
         };
         ToolsUnavailable: {
            (options?: vimService.vim.ToolsUnavailable): vimService.vim.ToolsUnavailable;
         };
         ToolsUpgradeCancelled: {
            (options?: vimService.vim.ToolsUpgradeCancelled): vimService.vim.ToolsUpgradeCancelled;
         };
         UnSupportedDatastoreForVFlash: {
            (options?: vimService.vim.UnSupportedDatastoreForVFlash): vimService.vim.UnSupportedDatastoreForVFlash;
         };
         UncommittedUndoableDisk: {
            (options?: vimService.vim.UncommittedUndoableDisk): vimService.vim.UncommittedUndoableDisk;
         };
         UnconfiguredPropertyValue: {
            (options?: vimService.vim.UnconfiguredPropertyValue): vimService.vim.UnconfiguredPropertyValue;
         };
         UncustomizableGuest: {
            (options?: vimService.vim.UncustomizableGuest): vimService.vim.UncustomizableGuest;
         };
         UnexpectedCustomizationFault: {
            (options?: vimService.vim.UnexpectedCustomizationFault): vimService.vim.UnexpectedCustomizationFault;
         };
         UnrecognizedHost: {
            (options?: vimService.vim.UnrecognizedHost): vimService.vim.UnrecognizedHost;
         };
         UnsharedSwapVMotionNotSupported: {
            (options?: vimService.vim.UnsharedSwapVMotionNotSupported): vimService.vim.UnsharedSwapVMotionNotSupported;
         };
         UnsupportedDatastore: {
            (options?: vimService.vim.UnsupportedDatastore): vimService.vim.UnsupportedDatastore;
         };
         UnsupportedGuest: {
            (options?: vimService.vim.UnsupportedGuest): vimService.vim.UnsupportedGuest;
         };
         UnsupportedVimApiVersion: {
            (options?: vimService.vim.UnsupportedVimApiVersion): vimService.vim.UnsupportedVimApiVersion;
         };
         UnsupportedVmxLocation: {
            (options?: vimService.vim.UnsupportedVmxLocation): vimService.vim.UnsupportedVmxLocation;
         };
         UnusedVirtualDiskBlocksNotScrubbed: {
            (options?: vimService.vim.UnusedVirtualDiskBlocksNotScrubbed): vimService.vim.UnusedVirtualDiskBlocksNotScrubbed;
         };
         UserNotFound: {
            (options?: vimService.vim.UserNotFound): vimService.vim.UserNotFound;
         };
         VAppConfigFault: {
            (options?: vimService.vim.VAppConfigFault): vimService.vim.VAppConfigFault;
         };
         VAppNotRunning: {
            (options?: vimService.vim.VAppNotRunning): vimService.vim.VAppNotRunning;
         };
         VAppOperationInProgress: {
            (options?: vimService.vim.VAppOperationInProgress): vimService.vim.VAppOperationInProgress;
         };
         VAppPropertyFault: {
            (options?: vimService.vim.VAppPropertyFault): vimService.vim.VAppPropertyFault;
         };
         VAppTaskInProgress: {
            (options?: vimService.vim.VAppTaskInProgress): vimService.vim.VAppTaskInProgress;
         };
         VFlashCacheHotConfigNotSupported: {
            (options?: vimService.vim.VFlashCacheHotConfigNotSupported): vimService.vim.VFlashCacheHotConfigNotSupported;
         };
         VFlashModuleNotSupportedReason: {
            "CacheModeNotSupported": string;
            "CacheConsistencyTypeNotSupported": string;
            "CacheBlockSizeNotSupported": string;
            "CacheReservationNotSupported": string;
            "DiskSizeNotSupported": string;
         };
         VFlashModuleNotSupported: {
            (options?: vimService.vim.VFlashModuleNotSupported): vimService.vim.VFlashModuleNotSupported;
         };
         VFlashModuleVersionIncompatible: {
            (options?: vimService.vim.VFlashModuleVersionIncompatible): vimService.vim.VFlashModuleVersionIncompatible;
         };
         VMINotSupported: {
            (options?: vimService.vim.VMINotSupported): vimService.vim.VMINotSupported;
         };
         VMOnConflictDVPort: {
            (options?: vimService.vim.VMOnConflictDVPort): vimService.vim.VMOnConflictDVPort;
         };
         VMOnVirtualIntranet: {
            (options?: vimService.vim.VMOnVirtualIntranet): vimService.vim.VMOnVirtualIntranet;
         };
         VMotionAcrossNetworkNotSupported: {
            (options?: vimService.vim.VMotionAcrossNetworkNotSupported): vimService.vim.VMotionAcrossNetworkNotSupported;
         };
         VMotionInterfaceIssue: {
            (options?: vimService.vim.VMotionInterfaceIssue): vimService.vim.VMotionInterfaceIssue;
         };
         VMotionLinkCapacityLow: {
            (options?: vimService.vim.VMotionLinkCapacityLow): vimService.vim.VMotionLinkCapacityLow;
         };
         VMotionLinkDown: {
            (options?: vimService.vim.VMotionLinkDown): vimService.vim.VMotionLinkDown;
         };
         VMotionNotConfigured: {
            (options?: vimService.vim.VMotionNotConfigured): vimService.vim.VMotionNotConfigured;
         };
         VMotionNotLicensed: {
            (options?: vimService.vim.VMotionNotLicensed): vimService.vim.VMotionNotLicensed;
         };
         VMotionNotSupported: {
            (options?: vimService.vim.VMotionNotSupported): vimService.vim.VMotionNotSupported;
         };
         VMotionProtocolIncompatible: {
            (options?: vimService.vim.VMotionProtocolIncompatible): vimService.vim.VMotionProtocolIncompatible;
         };
         VimFault: {
            (options?: vimService.vim.VimFault): vimService.vim.VimFault;
         };
         VirtualDiskBlocksNotFullyProvisioned: {
            (options?: vimService.vim.VirtualDiskBlocksNotFullyProvisioned): vimService.vim.VirtualDiskBlocksNotFullyProvisioned;
         };
         VirtualDiskModeNotSupported: {
            (options?: vimService.vim.VirtualDiskModeNotSupported): vimService.vim.VirtualDiskModeNotSupported;
         };
         VirtualEthernetCardNotSupported: {
            (options?: vimService.vim.VirtualEthernetCardNotSupported): vimService.vim.VirtualEthernetCardNotSupported;
         };
         VirtualHardwareCompatibilityIssue: {
            (options?: vimService.vim.VirtualHardwareCompatibilityIssue): vimService.vim.VirtualHardwareCompatibilityIssue;
         };
         VirtualHardwareVersionNotSupported: {
            (options?: vimService.vim.VirtualHardwareVersionNotSupported): vimService.vim.VirtualHardwareVersionNotSupported;
         };
         VmAlreadyExistsInDatacenter: {
            (options?: vimService.vim.VmAlreadyExistsInDatacenter): vimService.vim.VmAlreadyExistsInDatacenter;
         };
         VmConfigFault: {
            (options?: vimService.vim.VmConfigFault): vimService.vim.VmConfigFault;
         };
         VmConfigIncompatibleForFaultTolerance: {
            (options?: vimService.vim.VmConfigIncompatibleForFaultTolerance): vimService.vim.VmConfigIncompatibleForFaultTolerance;
         };
         VmConfigIncompatibleForRecordReplay: {
            (options?: vimService.vim.VmConfigIncompatibleForRecordReplay): vimService.vim.VmConfigIncompatibleForRecordReplay;
         };
         VmFaultToleranceConfigIssueReasonForIssue: {
            "haNotEnabled": string;
            "moreThanOneSecondary": string;
            "recordReplayNotSupported": string;
            "replayNotSupported": string;
            "templateVm": string;
            "multipleVCPU": string;
            "hostInactive": string;
            "ftUnsupportedHardware": string;
            "ftUnsupportedProduct": string;
            "missingVMotionNic": string;
            "missingFTLoggingNic": string;
            "thinDisk": string;
            "verifySSLCertificateFlagNotSet": string;
            "hasSnapshots": string;
            "noConfig": string;
            "ftSecondaryVm": string;
            "hasLocalDisk": string;
            "esxAgentVm": string;
            "video3dEnabled": string;
            "hasUnsupportedDisk": string;
            "insufficientBandwidth": string;
            "hasNestedHVConfiguration": string;
            "hasVFlashConfiguration": string;
            "unsupportedProduct": string;
            "cpuHvUnsupported": string;
            "cpuHwmmuUnsupported": string;
            "cpuHvDisabled": string;
            "hasEFIFirmware": string;
         };
         VmFaultToleranceConfigIssue: {
            (options?: vimService.vim.VmFaultToleranceConfigIssue): vimService.vim.VmFaultToleranceConfigIssue;
         };
         VmFaultToleranceConfigIssueWrapper: {
            (options?: vimService.vim.VmFaultToleranceConfigIssueWrapper): vimService.vim.VmFaultToleranceConfigIssueWrapper;
         };
         VmFaultToleranceInvalidFileBackingDeviceType: {
            "virtualFloppy": string;
            "virtualCdrom": string;
            "virtualSerialPort": string;
            "virtualParallelPort": string;
            "virtualDisk": string;
         };
         VmFaultToleranceInvalidFileBacking: {
            (options?: vimService.vim.VmFaultToleranceInvalidFileBacking): vimService.vim.VmFaultToleranceInvalidFileBacking;
         };
         VmFaultToleranceIssue: {
            (options?: vimService.vim.VmFaultToleranceIssue): vimService.vim.VmFaultToleranceIssue;
         };
         VmFaultToleranceOpIssuesList: {
            (options?: vimService.vim.VmFaultToleranceOpIssuesList): vimService.vim.VmFaultToleranceOpIssuesList;
         };
         VmFaultToleranceTooManyFtVcpusOnHost: {
            (options?: vimService.vim.VmFaultToleranceTooManyFtVcpusOnHost): vimService.vim.VmFaultToleranceTooManyFtVcpusOnHost;
         };
         VmFaultToleranceTooManyVMsOnHost: {
            (options?: vimService.vim.VmFaultToleranceTooManyVMsOnHost): vimService.vim.VmFaultToleranceTooManyVMsOnHost;
         };
         VmHostAffinityRuleViolation: {
            (options?: vimService.vim.VmHostAffinityRuleViolation): vimService.vim.VmHostAffinityRuleViolation;
         };
         VmLimitLicense: {
            (options?: vimService.vim.VmLimitLicense): vimService.vim.VmLimitLicense;
         };
         VmMetadataManagerFault: {
            (options?: vimService.vim.VmMetadataManagerFault): vimService.vim.VmMetadataManagerFault;
         };
         VmMonitorIncompatibleForFaultTolerance: {
            (options?: vimService.vim.VmMonitorIncompatibleForFaultTolerance): vimService.vim.VmMonitorIncompatibleForFaultTolerance;
         };
         VmPowerOnDisabled: {
            (options?: vimService.vim.VmPowerOnDisabled): vimService.vim.VmPowerOnDisabled;
         };
         VmSmpFaultToleranceTooManyVMsOnHost: {
            (options?: vimService.vim.VmSmpFaultToleranceTooManyVMsOnHost): vimService.vim.VmSmpFaultToleranceTooManyVMsOnHost;
         };
         VmToolsUpgradeFault: {
            (options?: vimService.vim.VmToolsUpgradeFault): vimService.vim.VmToolsUpgradeFault;
         };
         VmValidateMaxDevice: {
            (options?: vimService.vim.VmValidateMaxDevice): vimService.vim.VmValidateMaxDevice;
         };
         VmWwnConflict: {
            (options?: vimService.vim.VmWwnConflict): vimService.vim.VmWwnConflict;
         };
         VmfsAlreadyMounted: {
            (options?: vimService.vim.VmfsAlreadyMounted): vimService.vim.VmfsAlreadyMounted;
         };
         VmfsAmbiguousMount: {
            (options?: vimService.vim.VmfsAmbiguousMount): vimService.vim.VmfsAmbiguousMount;
         };
         VmfsMountFault: {
            (options?: vimService.vim.VmfsMountFault): vimService.vim.VmfsMountFault;
         };
         VmotionInterfaceNotEnabled: {
            (options?: vimService.vim.VmotionInterfaceNotEnabled): vimService.vim.VmotionInterfaceNotEnabled;
         };
         VolumeEditorError: {
            (options?: vimService.vim.VolumeEditorError): vimService.vim.VolumeEditorError;
         };
         VramLimitLicense: {
            (options?: vimService.vim.VramLimitLicense): vimService.vim.VramLimitLicense;
         };
         VsanClusterUuidMismatch: {
            (options?: vimService.vim.VsanClusterUuidMismatch): vimService.vim.VsanClusterUuidMismatch;
         };
         VsanDiskFault: {
            (options?: vimService.vim.VsanDiskFault): vimService.vim.VsanDiskFault;
         };
         VsanFault: {
            (options?: vimService.vim.VsanFault): vimService.vim.VsanFault;
         };
         VsanIncompatibleDiskMapping: {
            (options?: vimService.vim.VsanIncompatibleDiskMapping): vimService.vim.VsanIncompatibleDiskMapping;
         };
         VspanDestPortConflict: {
            (options?: vimService.vim.VspanDestPortConflict): vimService.vim.VspanDestPortConflict;
         };
         VspanPortConflict: {
            (options?: vimService.vim.VspanPortConflict): vimService.vim.VspanPortConflict;
         };
         VspanPortMoveFault: {
            (options?: vimService.vim.VspanPortMoveFault): vimService.vim.VspanPortMoveFault;
         };
         VspanPortPromiscChangeFault: {
            (options?: vimService.vim.VspanPortPromiscChangeFault): vimService.vim.VspanPortPromiscChangeFault;
         };
         VspanPortgroupPromiscChangeFault: {
            (options?: vimService.vim.VspanPortgroupPromiscChangeFault): vimService.vim.VspanPortgroupPromiscChangeFault;
         };
         VspanPortgroupTypeChangeFault: {
            (options?: vimService.vim.VspanPortgroupTypeChangeFault): vimService.vim.VspanPortgroupTypeChangeFault;
         };
         VspanPromiscuousPortNotSupported: {
            (options?: vimService.vim.VspanPromiscuousPortNotSupported): vimService.vim.VspanPromiscuousPortNotSupported;
         };
         VspanSameSessionPortConflict: {
            (options?: vimService.vim.VspanSameSessionPortConflict): vimService.vim.VspanSameSessionPortConflict;
         };
         WakeOnLanNotSupported: {
            (options?: vimService.vim.WakeOnLanNotSupported): vimService.vim.WakeOnLanNotSupported;
         };
         WakeOnLanNotSupportedByVmotionNIC: {
            (options?: vimService.vim.WakeOnLanNotSupportedByVmotionNIC): vimService.vim.WakeOnLanNotSupportedByVmotionNIC;
         };
         WillLoseHAProtectionResolution: {
            "svmotion": string;
            "relocate": string;
         };
         WillLoseHAProtection: {
            (options?: vimService.vim.WillLoseHAProtection): vimService.vim.WillLoseHAProtection;
         };
         WillModifyConfigCpuRequirements: {
            (options?: vimService.vim.WillModifyConfigCpuRequirements): vimService.vim.WillModifyConfigCpuRequirements;
         };
         WillResetSnapshotDirectory: {
            (options?: vimService.vim.WillResetSnapshotDirectory): vimService.vim.WillResetSnapshotDirectory;
         };
         WipeDiskFault: {
            (options?: vimService.vim.WipeDiskFault): vimService.vim.WipeDiskFault;
         };
         HostActiveDirectoryAuthenticationCertificateDigest: {
            "SHA1": string;
         };
         HostActiveDirectoryInfoDomainMembershipStatus: {
            "unknown": string;
            "ok": string;
            "noServers": string;
            "clientTrustBroken": string;
            "serverTrustBroken": string;
            "inconsistentTrust": string;
            "otherProblem": string;
         };
         HostActiveDirectoryInfo: {
            (options?: vimService.vim.HostActiveDirectoryInfo): vimService.vim.HostActiveDirectoryInfo;
         };
         HostActiveDirectorySpec: {
            (options?: vimService.vim.HostActiveDirectorySpec): vimService.vim.HostActiveDirectorySpec;
         };
         HostActiveDirectory: {
            (options?: vimService.vim.HostActiveDirectory): vimService.vim.HostActiveDirectory;
         };
         ArrayOfHostActiveDirectory: {
            (options?: vimService.vim.ArrayOfHostActiveDirectory): vimService.vim.ArrayOfHostActiveDirectory;
         };
         HostAuthenticationManagerInfo: {
            (options?: vimService.vim.HostAuthenticationManagerInfo): vimService.vim.HostAuthenticationManagerInfo;
         };
         HostAuthenticationStoreInfo: {
            (options?: vimService.vim.HostAuthenticationStoreInfo): vimService.vim.HostAuthenticationStoreInfo;
         };
         ArrayOfHostAuthenticationStoreInfo: {
            (options?: vimService.vim.ArrayOfHostAuthenticationStoreInfo): vimService.vim.ArrayOfHostAuthenticationStoreInfo;
         };
         AutoStartAction: {
            "none": string;
            "systemDefault": string;
            "powerOn": string;
            "powerOff": string;
            "guestShutdown": string;
            "suspend": string;
         };
         AutoStartDefaults: {
            (options?: vimService.vim.AutoStartDefaults): vimService.vim.AutoStartDefaults;
         };
         AutoStartWaitHeartbeatSetting: {
            "yes": string;
            "no": string;
            "systemDefault": string;
         };
         AutoStartPowerInfo: {
            (options?: vimService.vim.AutoStartPowerInfo): vimService.vim.AutoStartPowerInfo;
         };
         ArrayOfAutoStartPowerInfo: {
            (options?: vimService.vim.ArrayOfAutoStartPowerInfo): vimService.vim.ArrayOfAutoStartPowerInfo;
         };
         HostAutoStartManagerConfig: {
            (options?: vimService.vim.HostAutoStartManagerConfig): vimService.vim.HostAutoStartManagerConfig;
         };
         HostBootDeviceInfo: {
            (options?: vimService.vim.HostBootDeviceInfo): vimService.vim.HostBootDeviceInfo;
         };
         HostBootDevice: {
            (options?: vimService.vim.HostBootDevice): vimService.vim.HostBootDevice;
         };
         ArrayOfHostBootDevice: {
            (options?: vimService.vim.ArrayOfHostBootDevice): vimService.vim.ArrayOfHostBootDevice;
         };
         HostCacheConfigurationSpec: {
            (options?: vimService.vim.HostCacheConfigurationSpec): vimService.vim.HostCacheConfigurationSpec;
         };
         HostCacheConfigurationInfo: {
            (options?: vimService.vim.HostCacheConfigurationInfo): vimService.vim.HostCacheConfigurationInfo;
         };
         ArrayOfHostCacheConfigurationInfo: {
            (options?: vimService.vim.ArrayOfHostCacheConfigurationInfo): vimService.vim.ArrayOfHostCacheConfigurationInfo;
         };
         HostReplayUnsupportedReason: {
            "incompatibleProduct": string;
            "incompatibleCpu": string;
            "hvDisabled": string;
            "cpuidLimitSet": string;
            "oldBIOS": string;
            "unknown": string;
         };
         HostCapabilityFtUnsupportedReason: {
            "vMotionNotLicensed": string;
            "missingVMotionNic": string;
            "missingFTLoggingNic": string;
            "ftNotLicensed": string;
            "haAgentIssue": string;
            "unsupportedProduct": string;
            "cpuHvUnsupported": string;
            "cpuHwmmuUnsupported": string;
            "cpuHvDisabled": string;
         };
         HostCapabilityVmDirectPathGen2UnsupportedReason: {
            "hostNptIncompatibleProduct": string;
            "hostNptIncompatibleHardware": string;
            "hostNptDisabled": string;
         };
         HostCapability: {
            (options?: vimService.vim.HostCapability): vimService.vim.HostCapability;
         };
         HostCertificateManagerCertificateInfoCertificateStatus: {
            "unknown": string;
            "expired": string;
            "expiring": string;
            "expiringShortly": string;
            "expirationImminent": string;
            "good": string;
         };
         HostCertificateManagerCertificateInfo: {
            (options?: vimService.vim.HostCertificateManagerCertificateInfo): vimService.vim.HostCertificateManagerCertificateInfo;
         };
         HostConfigChangeMode: {
            "modify": string;
            "replace": string;
         };
         HostConfigChangeOperation: {
            "add": string;
            "remove": string;
            "edit": string;
            "ignore": string;
         };
         HostConfigChange: {
            (options?: vimService.vim.HostConfigChange): vimService.vim.HostConfigChange;
         };
         HostConfigInfo: {
            (options?: vimService.vim.HostConfigInfo): vimService.vim.HostConfigInfo;
         };
         HostConfigManager: {
            (options?: vimService.vim.HostConfigManager): vimService.vim.HostConfigManager;
         };
         HostConfigSpec: {
            (options?: vimService.vim.HostConfigSpec): vimService.vim.HostConfigSpec;
         };
         HostConnectInfoNetworkInfo: {
            (options?: vimService.vim.HostConnectInfoNetworkInfo): vimService.vim.HostConnectInfoNetworkInfo;
         };
         ArrayOfHostConnectInfoNetworkInfo: {
            (options?: vimService.vim.ArrayOfHostConnectInfoNetworkInfo): vimService.vim.ArrayOfHostConnectInfoNetworkInfo;
         };
         HostNewNetworkConnectInfo: {
            (options?: vimService.vim.HostNewNetworkConnectInfo): vimService.vim.HostNewNetworkConnectInfo;
         };
         HostDatastoreConnectInfo: {
            (options?: vimService.vim.HostDatastoreConnectInfo): vimService.vim.HostDatastoreConnectInfo;
         };
         ArrayOfHostDatastoreConnectInfo: {
            (options?: vimService.vim.ArrayOfHostDatastoreConnectInfo): vimService.vim.ArrayOfHostDatastoreConnectInfo;
         };
         HostDatastoreExistsConnectInfo: {
            (options?: vimService.vim.HostDatastoreExistsConnectInfo): vimService.vim.HostDatastoreExistsConnectInfo;
         };
         HostDatastoreNameConflictConnectInfo: {
            (options?: vimService.vim.HostDatastoreNameConflictConnectInfo): vimService.vim.HostDatastoreNameConflictConnectInfo;
         };
         HostLicenseConnectInfo: {
            (options?: vimService.vim.HostLicenseConnectInfo): vimService.vim.HostLicenseConnectInfo;
         };
         HostConnectInfo: {
            (options?: vimService.vim.HostConnectInfo): vimService.vim.HostConnectInfo;
         };
         HostConnectSpec: {
            (options?: vimService.vim.HostConnectSpec): vimService.vim.HostConnectSpec;
         };
         HostCpuIdInfo: {
            (options?: vimService.vim.HostCpuIdInfo): vimService.vim.HostCpuIdInfo;
         };
         ArrayOfHostCpuIdInfo: {
            (options?: vimService.vim.ArrayOfHostCpuIdInfo): vimService.vim.ArrayOfHostCpuIdInfo;
         };
         HostHyperThreadScheduleInfo: {
            (options?: vimService.vim.HostHyperThreadScheduleInfo): vimService.vim.HostHyperThreadScheduleInfo;
         };
         FileQueryFlags: {
            (options?: vimService.vim.FileQueryFlags): vimService.vim.FileQueryFlags;
         };
         FileInfo: {
            (options?: vimService.vim.FileInfo): vimService.vim.FileInfo;
         };
         ArrayOfFileInfo: {
            (options?: vimService.vim.ArrayOfFileInfo): vimService.vim.ArrayOfFileInfo;
         };
         FileQuery: {
            (options?: vimService.vim.FileQuery): vimService.vim.FileQuery;
         };
         ArrayOfFileQuery: {
            (options?: vimService.vim.ArrayOfFileQuery): vimService.vim.ArrayOfFileQuery;
         };
         VmConfigFileQueryFilter: {
            (options?: vimService.vim.VmConfigFileQueryFilter): vimService.vim.VmConfigFileQueryFilter;
         };
         VmConfigFileQueryFlags: {
            (options?: vimService.vim.VmConfigFileQueryFlags): vimService.vim.VmConfigFileQueryFlags;
         };
         VmConfigFileQuery: {
            (options?: vimService.vim.VmConfigFileQuery): vimService.vim.VmConfigFileQuery;
         };
         TemplateConfigFileQuery: {
            (options?: vimService.vim.TemplateConfigFileQuery): vimService.vim.TemplateConfigFileQuery;
         };
         VmDiskFileQueryFilter: {
            (options?: vimService.vim.VmDiskFileQueryFilter): vimService.vim.VmDiskFileQueryFilter;
         };
         VmDiskFileQueryFlags: {
            (options?: vimService.vim.VmDiskFileQueryFlags): vimService.vim.VmDiskFileQueryFlags;
         };
         VmDiskFileQuery: {
            (options?: vimService.vim.VmDiskFileQuery): vimService.vim.VmDiskFileQuery;
         };
         FolderFileQuery: {
            (options?: vimService.vim.FolderFileQuery): vimService.vim.FolderFileQuery;
         };
         VmSnapshotFileQuery: {
            (options?: vimService.vim.VmSnapshotFileQuery): vimService.vim.VmSnapshotFileQuery;
         };
         IsoImageFileQuery: {
            (options?: vimService.vim.IsoImageFileQuery): vimService.vim.IsoImageFileQuery;
         };
         FloppyImageFileQuery: {
            (options?: vimService.vim.FloppyImageFileQuery): vimService.vim.FloppyImageFileQuery;
         };
         VmNvramFileQuery: {
            (options?: vimService.vim.VmNvramFileQuery): vimService.vim.VmNvramFileQuery;
         };
         VmLogFileQuery: {
            (options?: vimService.vim.VmLogFileQuery): vimService.vim.VmLogFileQuery;
         };
         VmConfigFileEncryptionInfo: {
            (options?: vimService.vim.VmConfigFileEncryptionInfo): vimService.vim.VmConfigFileEncryptionInfo;
         };
         VmConfigFileInfo: {
            (options?: vimService.vim.VmConfigFileInfo): vimService.vim.VmConfigFileInfo;
         };
         TemplateConfigFileInfo: {
            (options?: vimService.vim.TemplateConfigFileInfo): vimService.vim.TemplateConfigFileInfo;
         };
         VmDiskFileEncryptionInfo: {
            (options?: vimService.vim.VmDiskFileEncryptionInfo): vimService.vim.VmDiskFileEncryptionInfo;
         };
         VmDiskFileInfo: {
            (options?: vimService.vim.VmDiskFileInfo): vimService.vim.VmDiskFileInfo;
         };
         FolderFileInfo: {
            (options?: vimService.vim.FolderFileInfo): vimService.vim.FolderFileInfo;
         };
         VmSnapshotFileInfo: {
            (options?: vimService.vim.VmSnapshotFileInfo): vimService.vim.VmSnapshotFileInfo;
         };
         IsoImageFileInfo: {
            (options?: vimService.vim.IsoImageFileInfo): vimService.vim.IsoImageFileInfo;
         };
         FloppyImageFileInfo: {
            (options?: vimService.vim.FloppyImageFileInfo): vimService.vim.FloppyImageFileInfo;
         };
         VmNvramFileInfo: {
            (options?: vimService.vim.VmNvramFileInfo): vimService.vim.VmNvramFileInfo;
         };
         VmLogFileInfo: {
            (options?: vimService.vim.VmLogFileInfo): vimService.vim.VmLogFileInfo;
         };
         HostDatastoreBrowserSearchSpec: {
            (options?: vimService.vim.HostDatastoreBrowserSearchSpec): vimService.vim.HostDatastoreBrowserSearchSpec;
         };
         HostDatastoreBrowserSearchResults: {
            (options?: vimService.vim.HostDatastoreBrowserSearchResults): vimService.vim.HostDatastoreBrowserSearchResults;
         };
         ArrayOfHostDatastoreBrowserSearchResults: {
            (options?: vimService.vim.ArrayOfHostDatastoreBrowserSearchResults): vimService.vim.ArrayOfHostDatastoreBrowserSearchResults;
         };
         HostDatastoreSystemCapabilities: {
            (options?: vimService.vim.HostDatastoreSystemCapabilities): vimService.vim.HostDatastoreSystemCapabilities;
         };
         HostDatastoreSystemVvolDatastoreSpec: {
            (options?: vimService.vim.HostDatastoreSystemVvolDatastoreSpec): vimService.vim.HostDatastoreSystemVvolDatastoreSpec;
         };
         HostDatastoreSystemDatastoreResult: {
            (options?: vimService.vim.HostDatastoreSystemDatastoreResult): vimService.vim.HostDatastoreSystemDatastoreResult;
         };
         ArrayOfHostDatastoreSystemDatastoreResult: {
            (options?: vimService.vim.ArrayOfHostDatastoreSystemDatastoreResult): vimService.vim.ArrayOfHostDatastoreSystemDatastoreResult;
         };
         VmfsDatastoreInfo: {
            (options?: vimService.vim.VmfsDatastoreInfo): vimService.vim.VmfsDatastoreInfo;
         };
         NasDatastoreInfo: {
            (options?: vimService.vim.NasDatastoreInfo): vimService.vim.NasDatastoreInfo;
         };
         LocalDatastoreInfo: {
            (options?: vimService.vim.LocalDatastoreInfo): vimService.vim.LocalDatastoreInfo;
         };
         VmfsDatastoreSpec: {
            (options?: vimService.vim.VmfsDatastoreSpec): vimService.vim.VmfsDatastoreSpec;
         };
         VmfsDatastoreCreateSpec: {
            (options?: vimService.vim.VmfsDatastoreCreateSpec): vimService.vim.VmfsDatastoreCreateSpec;
         };
         VmfsDatastoreExtendSpec: {
            (options?: vimService.vim.VmfsDatastoreExtendSpec): vimService.vim.VmfsDatastoreExtendSpec;
         };
         VmfsDatastoreExpandSpec: {
            (options?: vimService.vim.VmfsDatastoreExpandSpec): vimService.vim.VmfsDatastoreExpandSpec;
         };
         VmfsDatastoreBaseOption: {
            (options?: vimService.vim.VmfsDatastoreBaseOption): vimService.vim.VmfsDatastoreBaseOption;
         };
         VmfsDatastoreSingleExtentOption: {
            (options?: vimService.vim.VmfsDatastoreSingleExtentOption): vimService.vim.VmfsDatastoreSingleExtentOption;
         };
         VmfsDatastoreAllExtentOption: {
            (options?: vimService.vim.VmfsDatastoreAllExtentOption): vimService.vim.VmfsDatastoreAllExtentOption;
         };
         VmfsDatastoreMultipleExtentOption: {
            (options?: vimService.vim.VmfsDatastoreMultipleExtentOption): vimService.vim.VmfsDatastoreMultipleExtentOption;
         };
         VmfsDatastoreOption: {
            (options?: vimService.vim.VmfsDatastoreOption): vimService.vim.VmfsDatastoreOption;
         };
         ArrayOfVmfsDatastoreOption: {
            (options?: vimService.vim.ArrayOfVmfsDatastoreOption): vimService.vim.ArrayOfVmfsDatastoreOption;
         };
         VvolDatastoreInfo: {
            (options?: vimService.vim.VvolDatastoreInfo): vimService.vim.VvolDatastoreInfo;
         };
         HostDateTimeConfig: {
            (options?: vimService.vim.HostDateTimeConfig): vimService.vim.HostDateTimeConfig;
         };
         HostDateTimeInfo: {
            (options?: vimService.vim.HostDateTimeInfo): vimService.vim.HostDateTimeInfo;
         };
         HostDateTimeSystemTimeZone: {
            (options?: vimService.vim.HostDateTimeSystemTimeZone): vimService.vim.HostDateTimeSystemTimeZone;
         };
         ArrayOfHostDateTimeSystemTimeZone: {
            (options?: vimService.vim.ArrayOfHostDateTimeSystemTimeZone): vimService.vim.ArrayOfHostDateTimeSystemTimeZone;
         };
         HostDeploymentInfo: {
            (options?: vimService.vim.HostDeploymentInfo): vimService.vim.HostDeploymentInfo;
         };
         HostDevice: {
            (options?: vimService.vim.HostDevice): vimService.vim.HostDevice;
         };
         HostDhcpServiceSpec: {
            (options?: vimService.vim.HostDhcpServiceSpec): vimService.vim.HostDhcpServiceSpec;
         };
         HostDhcpServiceConfig: {
            (options?: vimService.vim.HostDhcpServiceConfig): vimService.vim.HostDhcpServiceConfig;
         };
         ArrayOfHostDhcpServiceConfig: {
            (options?: vimService.vim.ArrayOfHostDhcpServiceConfig): vimService.vim.ArrayOfHostDhcpServiceConfig;
         };
         HostDhcpService: {
            (options?: vimService.vim.HostDhcpService): vimService.vim.HostDhcpService;
         };
         ArrayOfHostDhcpService: {
            (options?: vimService.vim.ArrayOfHostDhcpService): vimService.vim.ArrayOfHostDhcpService;
         };
         DiagnosticPartitionStorageType: {
            "directAttached": string;
            "networkAttached": string;
         };
         DiagnosticPartitionType: {
            "singleHost": string;
            "multiHost": string;
         };
         HostDiagnosticPartitionCreateOption: {
            (options?: vimService.vim.HostDiagnosticPartitionCreateOption): vimService.vim.HostDiagnosticPartitionCreateOption;
         };
         ArrayOfHostDiagnosticPartitionCreateOption: {
            (options?: vimService.vim.ArrayOfHostDiagnosticPartitionCreateOption): vimService.vim.ArrayOfHostDiagnosticPartitionCreateOption;
         };
         HostDiagnosticPartitionCreateSpec: {
            (options?: vimService.vim.HostDiagnosticPartitionCreateSpec): vimService.vim.HostDiagnosticPartitionCreateSpec;
         };
         HostDiagnosticPartitionCreateDescription: {
            (options?: vimService.vim.HostDiagnosticPartitionCreateDescription): vimService.vim.HostDiagnosticPartitionCreateDescription;
         };
         HostDiagnosticPartition: {
            (options?: vimService.vim.HostDiagnosticPartition): vimService.vim.HostDiagnosticPartition;
         };
         ArrayOfHostDiagnosticPartition: {
            (options?: vimService.vim.ArrayOfHostDiagnosticPartition): vimService.vim.ArrayOfHostDiagnosticPartition;
         };
         HostDirectoryStoreInfo: {
            (options?: vimService.vim.HostDirectoryStoreInfo): vimService.vim.HostDirectoryStoreInfo;
         };
         HostDiskConfigurationResult: {
            (options?: vimService.vim.HostDiskConfigurationResult): vimService.vim.HostDiskConfigurationResult;
         };
         ArrayOfHostDiskConfigurationResult: {
            (options?: vimService.vim.ArrayOfHostDiskConfigurationResult): vimService.vim.ArrayOfHostDiskConfigurationResult;
         };
         HostDiskDimensionsChs: {
            (options?: vimService.vim.HostDiskDimensionsChs): vimService.vim.HostDiskDimensionsChs;
         };
         HostDiskDimensionsLba: {
            (options?: vimService.vim.HostDiskDimensionsLba): vimService.vim.HostDiskDimensionsLba;
         };
         HostDiskDimensions: {
            (options?: vimService.vim.HostDiskDimensions): vimService.vim.HostDiskDimensions;
         };
         HostDiskPartitionInfoPartitionFormat: {
            "gpt": string;
            "mbr": string;
            "unknown": string;
         };
         HostDiskPartitionInfoType: {
            "none": string;
            "vmfs": string;
            "linuxNative": string;
            "linuxSwap": string;
            "extended": string;
            "ntfs": string;
            "vmkDiagnostic": string;
            "vffs": string;
         };
         HostDiskPartitionAttributes: {
            (options?: vimService.vim.HostDiskPartitionAttributes): vimService.vim.HostDiskPartitionAttributes;
         };
         ArrayOfHostDiskPartitionAttributes: {
            (options?: vimService.vim.ArrayOfHostDiskPartitionAttributes): vimService.vim.ArrayOfHostDiskPartitionAttributes;
         };
         HostDiskPartitionBlockRange: {
            (options?: vimService.vim.HostDiskPartitionBlockRange): vimService.vim.HostDiskPartitionBlockRange;
         };
         ArrayOfHostDiskPartitionBlockRange: {
            (options?: vimService.vim.ArrayOfHostDiskPartitionBlockRange): vimService.vim.ArrayOfHostDiskPartitionBlockRange;
         };
         HostDiskPartitionSpec: {
            (options?: vimService.vim.HostDiskPartitionSpec): vimService.vim.HostDiskPartitionSpec;
         };
         HostDiskPartitionLayout: {
            (options?: vimService.vim.HostDiskPartitionLayout): vimService.vim.HostDiskPartitionLayout;
         };
         HostDiskPartitionInfo: {
            (options?: vimService.vim.HostDiskPartitionInfo): vimService.vim.HostDiskPartitionInfo;
         };
         ArrayOfHostDiskPartitionInfo: {
            (options?: vimService.vim.ArrayOfHostDiskPartitionInfo): vimService.vim.ArrayOfHostDiskPartitionInfo;
         };
         HostDnsConfig: {
            (options?: vimService.vim.HostDnsConfig): vimService.vim.HostDnsConfig;
         };
         HostDnsConfigSpec: {
            (options?: vimService.vim.HostDnsConfigSpec): vimService.vim.HostDnsConfigSpec;
         };
         HostEsxAgentHostManagerConfigInfo: {
            (options?: vimService.vim.HostEsxAgentHostManagerConfigInfo): vimService.vim.HostEsxAgentHostManagerConfigInfo;
         };
         HostFaultToleranceManagerComponentHealthInfo: {
            (options?: vimService.vim.HostFaultToleranceManagerComponentHealthInfo): vimService.vim.HostFaultToleranceManagerComponentHealthInfo;
         };
         FcoeConfigVlanRange: {
            (options?: vimService.vim.FcoeConfigVlanRange): vimService.vim.FcoeConfigVlanRange;
         };
         ArrayOfFcoeConfigVlanRange: {
            (options?: vimService.vim.ArrayOfFcoeConfigVlanRange): vimService.vim.ArrayOfFcoeConfigVlanRange;
         };
         FcoeConfigFcoeCapabilities: {
            (options?: vimService.vim.FcoeConfigFcoeCapabilities): vimService.vim.FcoeConfigFcoeCapabilities;
         };
         FcoeConfigFcoeSpecification: {
            (options?: vimService.vim.FcoeConfigFcoeSpecification): vimService.vim.FcoeConfigFcoeSpecification;
         };
         FcoeConfig: {
            (options?: vimService.vim.FcoeConfig): vimService.vim.FcoeConfig;
         };
         HostFeatureCapability: {
            (options?: vimService.vim.HostFeatureCapability): vimService.vim.HostFeatureCapability;
         };
         ArrayOfHostFeatureCapability: {
            (options?: vimService.vim.ArrayOfHostFeatureCapability): vimService.vim.ArrayOfHostFeatureCapability;
         };
         HostFeatureMask: {
            (options?: vimService.vim.HostFeatureMask): vimService.vim.HostFeatureMask;
         };
         ArrayOfHostFeatureMask: {
            (options?: vimService.vim.ArrayOfHostFeatureMask): vimService.vim.ArrayOfHostFeatureMask;
         };
         HostFeatureVersionKey: {
            "faultTolerance": string;
         };
         HostFeatureVersionInfo: {
            (options?: vimService.vim.HostFeatureVersionInfo): vimService.vim.HostFeatureVersionInfo;
         };
         ArrayOfHostFeatureVersionInfo: {
            (options?: vimService.vim.ArrayOfHostFeatureVersionInfo): vimService.vim.ArrayOfHostFeatureVersionInfo;
         };
         ModeInfo: {
            (options?: vimService.vim.ModeInfo): vimService.vim.ModeInfo;
         };
         HostFileAccess: {
            (options?: vimService.vim.HostFileAccess): vimService.vim.HostFileAccess;
         };
         HostFileSystemVolumeInfo: {
            (options?: vimService.vim.HostFileSystemVolumeInfo): vimService.vim.HostFileSystemVolumeInfo;
         };
         FileSystemMountInfoVStorageSupportStatus: {
            "vStorageSupported": string;
            "vStorageUnsupported": string;
            "vStorageUnknown": string;
         };
         HostFileSystemMountInfo: {
            (options?: vimService.vim.HostFileSystemMountInfo): vimService.vim.HostFileSystemMountInfo;
         };
         ArrayOfHostFileSystemMountInfo: {
            (options?: vimService.vim.ArrayOfHostFileSystemMountInfo): vimService.vim.ArrayOfHostFileSystemMountInfo;
         };
         HostFileSystemVolumeFileSystemType: {
            "VMFS": string;
            "NFS": string;
            "NFS41": string;
            "CIFS": string;
            "vsan": string;
            "VFFS": string;
            "VVOL": string;
            "OTHER": string;
         };
         HostFileSystemVolume: {
            (options?: vimService.vim.HostFileSystemVolume): vimService.vim.HostFileSystemVolume;
         };
         HostNasVolumeUserInfo: {
            (options?: vimService.vim.HostNasVolumeUserInfo): vimService.vim.HostNasVolumeUserInfo;
         };
         HostNasVolumeSecurityType: {
            "AUTH_SYS": string;
            "SEC_KRB5": string;
            "SEC_KRB5I": string;
         };
         HostNasVolumeSpec: {
            (options?: vimService.vim.HostNasVolumeSpec): vimService.vim.HostNasVolumeSpec;
         };
         HostNasVolumeConfig: {
            (options?: vimService.vim.HostNasVolumeConfig): vimService.vim.HostNasVolumeConfig;
         };
         ArrayOfHostNasVolumeConfig: {
            (options?: vimService.vim.ArrayOfHostNasVolumeConfig): vimService.vim.ArrayOfHostNasVolumeConfig;
         };
         HostNasVolume: {
            (options?: vimService.vim.HostNasVolume): vimService.vim.HostNasVolume;
         };
         HostLocalFileSystemVolumeSpec: {
            (options?: vimService.vim.HostLocalFileSystemVolumeSpec): vimService.vim.HostLocalFileSystemVolumeSpec;
         };
         HostLocalFileSystemVolume: {
            (options?: vimService.vim.HostLocalFileSystemVolume): vimService.vim.HostLocalFileSystemVolume;
         };
         HostVfatVolume: {
            (options?: vimService.vim.HostVfatVolume): vimService.vim.HostVfatVolume;
         };
         HostFirewallConfigRuleSetConfig: {
            (options?: vimService.vim.HostFirewallConfigRuleSetConfig): vimService.vim.HostFirewallConfigRuleSetConfig;
         };
         ArrayOfHostFirewallConfigRuleSetConfig: {
            (options?: vimService.vim.ArrayOfHostFirewallConfigRuleSetConfig): vimService.vim.ArrayOfHostFirewallConfigRuleSetConfig;
         };
         HostFirewallConfig: {
            (options?: vimService.vim.HostFirewallConfig): vimService.vim.HostFirewallConfig;
         };
         HostFirewallDefaultPolicy: {
            (options?: vimService.vim.HostFirewallDefaultPolicy): vimService.vim.HostFirewallDefaultPolicy;
         };
         HostFirewallInfo: {
            (options?: vimService.vim.HostFirewallInfo): vimService.vim.HostFirewallInfo;
         };
         HostFlagInfo: {
            (options?: vimService.vim.HostFlagInfo): vimService.vim.HostFlagInfo;
         };
         HostForceMountedInfo: {
            (options?: vimService.vim.HostForceMountedInfo): vimService.vim.HostForceMountedInfo;
         };
         HostGatewaySpec: {
            (options?: vimService.vim.HostGatewaySpec): vimService.vim.HostGatewaySpec;
         };
         HostGraphicsConfigGraphicsType: {
            "shared": string;
            "sharedDirect": string;
         };
         HostGraphicsConfigSharedPassthruAssignmentPolicy: {
            "performance": string;
            "consolidation": string;
         };
         HostGraphicsConfigDeviceType: {
            (options?: vimService.vim.HostGraphicsConfigDeviceType): vimService.vim.HostGraphicsConfigDeviceType;
         };
         ArrayOfHostGraphicsConfigDeviceType: {
            (options?: vimService.vim.ArrayOfHostGraphicsConfigDeviceType): vimService.vim.ArrayOfHostGraphicsConfigDeviceType;
         };
         HostGraphicsConfig: {
            (options?: vimService.vim.HostGraphicsConfig): vimService.vim.HostGraphicsConfig;
         };
         HostGraphicsInfoGraphicsType: {
            "basic": string;
            "shared": string;
            "direct": string;
            "sharedDirect": string;
         };
         HostGraphicsInfo: {
            (options?: vimService.vim.HostGraphicsInfo): vimService.vim.HostGraphicsInfo;
         };
         ArrayOfHostGraphicsInfo: {
            (options?: vimService.vim.ArrayOfHostGraphicsInfo): vimService.vim.ArrayOfHostGraphicsInfo;
         };
         HostHardwareInfo: {
            (options?: vimService.vim.HostHardwareInfo): vimService.vim.HostHardwareInfo;
         };
         HostSystemInfo: {
            (options?: vimService.vim.HostSystemInfo): vimService.vim.HostSystemInfo;
         };
         HostCpuPowerManagementInfoPolicyType: {
            "off": string;
            "staticPolicy": string;
            "dynamicPolicy": string;
         };
         HostCpuPowerManagementInfo: {
            (options?: vimService.vim.HostCpuPowerManagementInfo): vimService.vim.HostCpuPowerManagementInfo;
         };
         HostCpuInfo: {
            (options?: vimService.vim.HostCpuInfo): vimService.vim.HostCpuInfo;
         };
         HostCpuPackageVendor: {
            "unknown": string;
            "intel": string;
            "amd": string;
         };
         HostCpuPackage: {
            (options?: vimService.vim.HostCpuPackage): vimService.vim.HostCpuPackage;
         };
         ArrayOfHostCpuPackage: {
            (options?: vimService.vim.ArrayOfHostCpuPackage): vimService.vim.ArrayOfHostCpuPackage;
         };
         HostNumaInfo: {
            (options?: vimService.vim.HostNumaInfo): vimService.vim.HostNumaInfo;
         };
         HostNumaNode: {
            (options?: vimService.vim.HostNumaNode): vimService.vim.HostNumaNode;
         };
         ArrayOfHostNumaNode: {
            (options?: vimService.vim.ArrayOfHostNumaNode): vimService.vim.ArrayOfHostNumaNode;
         };
         HostBIOSInfo: {
            (options?: vimService.vim.HostBIOSInfo): vimService.vim.HostBIOSInfo;
         };
         HostReliableMemoryInfo: {
            (options?: vimService.vim.HostReliableMemoryInfo): vimService.vim.HostReliableMemoryInfo;
         };
         HostHardwareElementStatus: {
            "Unknown": string;
            "Green": string;
            "Yellow": string;
            "Red": string;
         };
         HostHardwareElementInfo: {
            (options?: vimService.vim.HostHardwareElementInfo): vimService.vim.HostHardwareElementInfo;
         };
         ArrayOfHostHardwareElementInfo: {
            (options?: vimService.vim.ArrayOfHostHardwareElementInfo): vimService.vim.ArrayOfHostHardwareElementInfo;
         };
         HostStorageOperationalInfo: {
            (options?: vimService.vim.HostStorageOperationalInfo): vimService.vim.HostStorageOperationalInfo;
         };
         ArrayOfHostStorageOperationalInfo: {
            (options?: vimService.vim.ArrayOfHostStorageOperationalInfo): vimService.vim.ArrayOfHostStorageOperationalInfo;
         };
         HostStorageElementInfo: {
            (options?: vimService.vim.HostStorageElementInfo): vimService.vim.HostStorageElementInfo;
         };
         ArrayOfHostStorageElementInfo: {
            (options?: vimService.vim.ArrayOfHostStorageElementInfo): vimService.vim.ArrayOfHostStorageElementInfo;
         };
         HostHardwareStatusInfo: {
            (options?: vimService.vim.HostHardwareStatusInfo): vimService.vim.HostHardwareStatusInfo;
         };
         HealthSystemRuntime: {
            (options?: vimService.vim.HealthSystemRuntime): vimService.vim.HealthSystemRuntime;
         };
         HostAccessMode: {
            "accessNone": string;
            "accessAdmin": string;
            "accessNoAccess": string;
            "accessReadOnly": string;
            "accessOther": string;
         };
         HostAccessControlEntry: {
            (options?: vimService.vim.HostAccessControlEntry): vimService.vim.HostAccessControlEntry;
         };
         ArrayOfHostAccessControlEntry: {
            (options?: vimService.vim.ArrayOfHostAccessControlEntry): vimService.vim.ArrayOfHostAccessControlEntry;
         };
         HostLockdownMode: {
            "lockdownDisabled": string;
            "lockdownNormal": string;
            "lockdownStrict": string;
         };
         HostHostBusAdapter: {
            (options?: vimService.vim.HostHostBusAdapter): vimService.vim.HostHostBusAdapter;
         };
         ArrayOfHostHostBusAdapter: {
            (options?: vimService.vim.ArrayOfHostHostBusAdapter): vimService.vim.ArrayOfHostHostBusAdapter;
         };
         HostParallelScsiHba: {
            (options?: vimService.vim.HostParallelScsiHba): vimService.vim.HostParallelScsiHba;
         };
         HostSerialAttachedHba: {
            (options?: vimService.vim.HostSerialAttachedHba): vimService.vim.HostSerialAttachedHba;
         };
         HostBlockHba: {
            (options?: vimService.vim.HostBlockHba): vimService.vim.HostBlockHba;
         };
         FibreChannelPortType: {
            "fabric": string;
            "loop": string;
            "pointToPoint": string;
            "unknown": string;
         };
         HostFibreChannelHba: {
            (options?: vimService.vim.HostFibreChannelHba): vimService.vim.HostFibreChannelHba;
         };
         HostInternetScsiHbaParamValue: {
            (options?: vimService.vim.HostInternetScsiHbaParamValue): vimService.vim.HostInternetScsiHbaParamValue;
         };
         ArrayOfHostInternetScsiHbaParamValue: {
            (options?: vimService.vim.ArrayOfHostInternetScsiHbaParamValue): vimService.vim.ArrayOfHostInternetScsiHbaParamValue;
         };
         HostInternetScsiHbaDiscoveryCapabilities: {
            (options?: vimService.vim.HostInternetScsiHbaDiscoveryCapabilities): vimService.vim.HostInternetScsiHbaDiscoveryCapabilities;
         };
         InternetScsiSnsDiscoveryMethod: {
            "isnsStatic": string;
            "isnsDhcp": string;
            "isnsSlp": string;
         };
         SlpDiscoveryMethod: {
            "slpDhcp": string;
            "slpAutoUnicast": string;
            "slpAutoMulticast": string;
            "slpManual": string;
         };
         HostInternetScsiHbaDiscoveryProperties: {
            (options?: vimService.vim.HostInternetScsiHbaDiscoveryProperties): vimService.vim.HostInternetScsiHbaDiscoveryProperties;
         };
         HostInternetScsiHbaChapAuthenticationType: {
            "chapProhibited": string;
            "chapDiscouraged": string;
            "chapPreferred": string;
            "chapRequired": string;
         };
         HostInternetScsiHbaAuthenticationCapabilities: {
            (options?: vimService.vim.HostInternetScsiHbaAuthenticationCapabilities): vimService.vim.HostInternetScsiHbaAuthenticationCapabilities;
         };
         HostInternetScsiHbaAuthenticationProperties: {
            (options?: vimService.vim.HostInternetScsiHbaAuthenticationProperties): vimService.vim.HostInternetScsiHbaAuthenticationProperties;
         };
         HostInternetScsiHbaDigestType: {
            "digestProhibited": string;
            "digestDiscouraged": string;
            "digestPreferred": string;
            "digestRequired": string;
         };
         HostInternetScsiHbaDigestCapabilities: {
            (options?: vimService.vim.HostInternetScsiHbaDigestCapabilities): vimService.vim.HostInternetScsiHbaDigestCapabilities;
         };
         HostInternetScsiHbaDigestProperties: {
            (options?: vimService.vim.HostInternetScsiHbaDigestProperties): vimService.vim.HostInternetScsiHbaDigestProperties;
         };
         HostInternetScsiHbaIPCapabilities: {
            (options?: vimService.vim.HostInternetScsiHbaIPCapabilities): vimService.vim.HostInternetScsiHbaIPCapabilities;
         };
         HostInternetScsiHbaIscsiIpv6AddressAddressConfigurationType: {
            "DHCP": string;
            "AutoConfigured": string;
            "Static": string;
            "Other": string;
         };
         HostInternetScsiHbaIscsiIpv6AddressIPv6AddressOperation: {
            "add": string;
            "remove": string;
         };
         HostInternetScsiHbaIscsiIpv6Address: {
            (options?: vimService.vim.HostInternetScsiHbaIscsiIpv6Address): vimService.vim.HostInternetScsiHbaIscsiIpv6Address;
         };
         ArrayOfHostInternetScsiHbaIscsiIpv6Address: {
            (options?: vimService.vim.ArrayOfHostInternetScsiHbaIscsiIpv6Address): vimService.vim.ArrayOfHostInternetScsiHbaIscsiIpv6Address;
         };
         HostInternetScsiHbaIPv6Properties: {
            (options?: vimService.vim.HostInternetScsiHbaIPv6Properties): vimService.vim.HostInternetScsiHbaIPv6Properties;
         };
         HostInternetScsiHbaIPProperties: {
            (options?: vimService.vim.HostInternetScsiHbaIPProperties): vimService.vim.HostInternetScsiHbaIPProperties;
         };
         HostInternetScsiHbaSendTarget: {
            (options?: vimService.vim.HostInternetScsiHbaSendTarget): vimService.vim.HostInternetScsiHbaSendTarget;
         };
         ArrayOfHostInternetScsiHbaSendTarget: {
            (options?: vimService.vim.ArrayOfHostInternetScsiHbaSendTarget): vimService.vim.ArrayOfHostInternetScsiHbaSendTarget;
         };
         HostInternetScsiHbaStaticTargetTargetDiscoveryMethod: {
            "staticMethod": string;
            "sendTargetMethod": string;
            "slpMethod": string;
            "isnsMethod": string;
            "unknownMethod": string;
         };
         HostInternetScsiHbaStaticTarget: {
            (options?: vimService.vim.HostInternetScsiHbaStaticTarget): vimService.vim.HostInternetScsiHbaStaticTarget;
         };
         ArrayOfHostInternetScsiHbaStaticTarget: {
            (options?: vimService.vim.ArrayOfHostInternetScsiHbaStaticTarget): vimService.vim.ArrayOfHostInternetScsiHbaStaticTarget;
         };
         HostInternetScsiHbaTargetSet: {
            (options?: vimService.vim.HostInternetScsiHbaTargetSet): vimService.vim.HostInternetScsiHbaTargetSet;
         };
         HostInternetScsiHbaNetworkBindingSupportType: {
            "notsupported": string;
            "optional": string;
            "required": string;
         };
         HostInternetScsiHba: {
            (options?: vimService.vim.HostInternetScsiHba): vimService.vim.HostInternetScsiHba;
         };
         HostFibreChannelOverEthernetHbaLinkInfo: {
            (options?: vimService.vim.HostFibreChannelOverEthernetHbaLinkInfo): vimService.vim.HostFibreChannelOverEthernetHbaLinkInfo;
         };
         HostFibreChannelOverEthernetHba: {
            (options?: vimService.vim.HostFibreChannelOverEthernetHba): vimService.vim.HostFibreChannelOverEthernetHba;
         };
         HostProxySwitchSpec: {
            (options?: vimService.vim.HostProxySwitchSpec): vimService.vim.HostProxySwitchSpec;
         };
         HostProxySwitchConfig: {
            (options?: vimService.vim.HostProxySwitchConfig): vimService.vim.HostProxySwitchConfig;
         };
         ArrayOfHostProxySwitchConfig: {
            (options?: vimService.vim.ArrayOfHostProxySwitchConfig): vimService.vim.ArrayOfHostProxySwitchConfig;
         };
         HostProxySwitchHostLagConfig: {
            (options?: vimService.vim.HostProxySwitchHostLagConfig): vimService.vim.HostProxySwitchHostLagConfig;
         };
         ArrayOfHostProxySwitchHostLagConfig: {
            (options?: vimService.vim.ArrayOfHostProxySwitchHostLagConfig): vimService.vim.ArrayOfHostProxySwitchHostLagConfig;
         };
         HostProxySwitch: {
            (options?: vimService.vim.HostProxySwitch): vimService.vim.HostProxySwitch;
         };
         ArrayOfHostProxySwitch: {
            (options?: vimService.vim.ArrayOfHostProxySwitch): vimService.vim.ArrayOfHostProxySwitch;
         };
         HostImageAcceptanceLevel: {
            "vmware_certified": string;
            "vmware_accepted": string;
            "partner": string;
            "community": string;
         };
         HostImageProfileSummary: {
            (options?: vimService.vim.HostImageProfileSummary): vimService.vim.HostImageProfileSummary;
         };
         HostIpConfigIpV6AddressConfigType: {
            "other": string;
            "manual": string;
            "dhcp": string;
            "linklayer": string;
            "random": string;
         };
         HostIpConfigIpV6AddressStatus: {
            "preferred": string;
            "deprecated": string;
            "invalid": string;
            "inaccessible": string;
            "unknown": string;
            "tentative": string;
            "duplicate": string;
         };
         HostIpConfigIpV6Address: {
            (options?: vimService.vim.HostIpConfigIpV6Address): vimService.vim.HostIpConfigIpV6Address;
         };
         ArrayOfHostIpConfigIpV6Address: {
            (options?: vimService.vim.ArrayOfHostIpConfigIpV6Address): vimService.vim.ArrayOfHostIpConfigIpV6Address;
         };
         HostIpConfigIpV6AddressConfiguration: {
            (options?: vimService.vim.HostIpConfigIpV6AddressConfiguration): vimService.vim.HostIpConfigIpV6AddressConfiguration;
         };
         HostIpConfig: {
            (options?: vimService.vim.HostIpConfig): vimService.vim.HostIpConfig;
         };
         HostIpRouteConfig: {
            (options?: vimService.vim.HostIpRouteConfig): vimService.vim.HostIpRouteConfig;
         };
         HostIpRouteConfigSpec: {
            (options?: vimService.vim.HostIpRouteConfigSpec): vimService.vim.HostIpRouteConfigSpec;
         };
         HostIpRouteEntry: {
            (options?: vimService.vim.HostIpRouteEntry): vimService.vim.HostIpRouteEntry;
         };
         ArrayOfHostIpRouteEntry: {
            (options?: vimService.vim.ArrayOfHostIpRouteEntry): vimService.vim.ArrayOfHostIpRouteEntry;
         };
         HostIpRouteOp: {
            (options?: vimService.vim.HostIpRouteOp): vimService.vim.HostIpRouteOp;
         };
         ArrayOfHostIpRouteOp: {
            (options?: vimService.vim.ArrayOfHostIpRouteOp): vimService.vim.ArrayOfHostIpRouteOp;
         };
         HostIpRouteTableConfig: {
            (options?: vimService.vim.HostIpRouteTableConfig): vimService.vim.HostIpRouteTableConfig;
         };
         HostIpRouteTableInfo: {
            (options?: vimService.vim.HostIpRouteTableInfo): vimService.vim.HostIpRouteTableInfo;
         };
         HostIpmiInfo: {
            (options?: vimService.vim.HostIpmiInfo): vimService.vim.HostIpmiInfo;
         };
         IscsiStatus: {
            (options?: vimService.vim.IscsiStatus): vimService.vim.IscsiStatus;
         };
         IscsiPortInfoPathStatus: {
            "notUsed": string;
            "active": string;
            "standBy": string;
            "lastActive": string;
         };
         IscsiPortInfo: {
            (options?: vimService.vim.IscsiPortInfo): vimService.vim.IscsiPortInfo;
         };
         ArrayOfIscsiPortInfo: {
            (options?: vimService.vim.ArrayOfIscsiPortInfo): vimService.vim.ArrayOfIscsiPortInfo;
         };
         IscsiDependencyEntity: {
            (options?: vimService.vim.IscsiDependencyEntity): vimService.vim.IscsiDependencyEntity;
         };
         ArrayOfIscsiDependencyEntity: {
            (options?: vimService.vim.ArrayOfIscsiDependencyEntity): vimService.vim.ArrayOfIscsiDependencyEntity;
         };
         IscsiMigrationDependency: {
            (options?: vimService.vim.IscsiMigrationDependency): vimService.vim.IscsiMigrationDependency;
         };
         KernelModuleSectionInfo: {
            (options?: vimService.vim.KernelModuleSectionInfo): vimService.vim.KernelModuleSectionInfo;
         };
         KernelModuleInfo: {
            (options?: vimService.vim.KernelModuleInfo): vimService.vim.KernelModuleInfo;
         };
         ArrayOfKernelModuleInfo: {
            (options?: vimService.vim.ArrayOfKernelModuleInfo): vimService.vim.ArrayOfKernelModuleInfo;
         };
         HostLicenseSpec: {
            (options?: vimService.vim.HostLicenseSpec): vimService.vim.HostLicenseSpec;
         };
         LinkDiscoveryProtocolConfigProtocolType: {
            "cdp": string;
            "lldp": string;
         };
         LinkDiscoveryProtocolConfigOperationType: {
            "none": string;
            "listen": string;
            "advertise": string;
            "both": string;
         };
         LinkDiscoveryProtocolConfig: {
            (options?: vimService.vim.LinkDiscoveryProtocolConfig): vimService.vim.LinkDiscoveryProtocolConfig;
         };
         HostAccountSpec: {
            (options?: vimService.vim.HostAccountSpec): vimService.vim.HostAccountSpec;
         };
         ArrayOfHostAccountSpec: {
            (options?: vimService.vim.ArrayOfHostAccountSpec): vimService.vim.ArrayOfHostAccountSpec;
         };
         HostPosixAccountSpec: {
            (options?: vimService.vim.HostPosixAccountSpec): vimService.vim.HostPosixAccountSpec;
         };
         HostLocalAuthenticationInfo: {
            (options?: vimService.vim.HostLocalAuthenticationInfo): vimService.vim.HostLocalAuthenticationInfo;
         };
         HostLowLevelProvisioningManagerVmRecoveryInfo: {
            (options?: vimService.vim.HostLowLevelProvisioningManagerVmRecoveryInfo): vimService.vim.HostLowLevelProvisioningManagerVmRecoveryInfo;
         };
         HostLowLevelProvisioningManagerVmMigrationStatus: {
            (options?: vimService.vim.HostLowLevelProvisioningManagerVmMigrationStatus): vimService.vim.HostLowLevelProvisioningManagerVmMigrationStatus;
         };
         HostLowLevelProvisioningManagerReloadTarget: {
            "currentConfig": string;
            "snapshotConfig": string;
         };
         HostLowLevelProvisioningManagerDiskLayoutSpec: {
            (options?: vimService.vim.HostLowLevelProvisioningManagerDiskLayoutSpec): vimService.vim.HostLowLevelProvisioningManagerDiskLayoutSpec;
         };
         ArrayOfHostLowLevelProvisioningManagerDiskLayoutSpec: {
            (options?: vimService.vim.ArrayOfHostLowLevelProvisioningManagerDiskLayoutSpec): vimService.vim.ArrayOfHostLowLevelProvisioningManagerDiskLayoutSpec;
         };
         HostLowLevelProvisioningManagerSnapshotLayoutSpec: {
            (options?: vimService.vim.HostLowLevelProvisioningManagerSnapshotLayoutSpec): vimService.vim.HostLowLevelProvisioningManagerSnapshotLayoutSpec;
         };
         ArrayOfHostLowLevelProvisioningManagerSnapshotLayoutSpec: {
            (options?: vimService.vim.ArrayOfHostLowLevelProvisioningManagerSnapshotLayoutSpec): vimService.vim.ArrayOfHostLowLevelProvisioningManagerSnapshotLayoutSpec;
         };
         HostLowLevelProvisioningManagerFileType: {
            "File": string;
            "VirtualDisk": string;
            "Directory": string;
         };
         HostLowLevelProvisioningManagerFileReserveSpec: {
            (options?: vimService.vim.HostLowLevelProvisioningManagerFileReserveSpec): vimService.vim.HostLowLevelProvisioningManagerFileReserveSpec;
         };
         ArrayOfHostLowLevelProvisioningManagerFileReserveSpec: {
            (options?: vimService.vim.ArrayOfHostLowLevelProvisioningManagerFileReserveSpec): vimService.vim.ArrayOfHostLowLevelProvisioningManagerFileReserveSpec;
         };
         HostLowLevelProvisioningManagerFileReserveResult: {
            (options?: vimService.vim.HostLowLevelProvisioningManagerFileReserveResult): vimService.vim.HostLowLevelProvisioningManagerFileReserveResult;
         };
         ArrayOfHostLowLevelProvisioningManagerFileReserveResult: {
            (options?: vimService.vim.ArrayOfHostLowLevelProvisioningManagerFileReserveResult): vimService.vim.ArrayOfHostLowLevelProvisioningManagerFileReserveResult;
         };
         HostLowLevelProvisioningManagerFileDeleteSpec: {
            (options?: vimService.vim.HostLowLevelProvisioningManagerFileDeleteSpec): vimService.vim.HostLowLevelProvisioningManagerFileDeleteSpec;
         };
         ArrayOfHostLowLevelProvisioningManagerFileDeleteSpec: {
            (options?: vimService.vim.ArrayOfHostLowLevelProvisioningManagerFileDeleteSpec): vimService.vim.ArrayOfHostLowLevelProvisioningManagerFileDeleteSpec;
         };
         HostLowLevelProvisioningManagerFileDeleteResult: {
            (options?: vimService.vim.HostLowLevelProvisioningManagerFileDeleteResult): vimService.vim.HostLowLevelProvisioningManagerFileDeleteResult;
         };
         ArrayOfHostLowLevelProvisioningManagerFileDeleteResult: {
            (options?: vimService.vim.ArrayOfHostLowLevelProvisioningManagerFileDeleteResult): vimService.vim.ArrayOfHostLowLevelProvisioningManagerFileDeleteResult;
         };
         HostMaintenanceSpec: {
            (options?: vimService.vim.HostMaintenanceSpec): vimService.vim.HostMaintenanceSpec;
         };
         ServiceConsoleReservationInfo: {
            (options?: vimService.vim.ServiceConsoleReservationInfo): vimService.vim.ServiceConsoleReservationInfo;
         };
         VirtualMachineMemoryAllocationPolicy: {
            "swapNone": string;
            "swapSome": string;
            "swapMost": string;
         };
         VirtualMachineMemoryReservationInfo: {
            (options?: vimService.vim.VirtualMachineMemoryReservationInfo): vimService.vim.VirtualMachineMemoryReservationInfo;
         };
         VirtualMachineMemoryReservationSpec: {
            (options?: vimService.vim.VirtualMachineMemoryReservationSpec): vimService.vim.VirtualMachineMemoryReservationSpec;
         };
         HostMemorySpec: {
            (options?: vimService.vim.HostMemorySpec): vimService.vim.HostMemorySpec;
         };
         HostMountMode: {
            "readWrite": string;
            "readOnly": string;
         };
         HostMountInfoInaccessibleReason: {
            "AllPathsDown_Start": string;
            "AllPathsDown_Timeout": string;
            "PermanentDeviceLoss": string;
         };
         HostMountInfo: {
            (options?: vimService.vim.HostMountInfo): vimService.vim.HostMountInfo;
         };
         MultipathState: {
            "standby": string;
            "active": string;
            "disabled": string;
            "dead": string;
            "unknown": string;
         };
         HostMultipathInfoLogicalUnitPolicy: {
            (options?: vimService.vim.HostMultipathInfoLogicalUnitPolicy): vimService.vim.HostMultipathInfoLogicalUnitPolicy;
         };
         HostMultipathInfoLogicalUnitStorageArrayTypePolicy: {
            (options?: vimService.vim.HostMultipathInfoLogicalUnitStorageArrayTypePolicy): vimService.vim.HostMultipathInfoLogicalUnitStorageArrayTypePolicy;
         };
         HostMultipathInfoFixedLogicalUnitPolicy: {
            (options?: vimService.vim.HostMultipathInfoFixedLogicalUnitPolicy): vimService.vim.HostMultipathInfoFixedLogicalUnitPolicy;
         };
         HostMultipathInfoLogicalUnit: {
            (options?: vimService.vim.HostMultipathInfoLogicalUnit): vimService.vim.HostMultipathInfoLogicalUnit;
         };
         ArrayOfHostMultipathInfoLogicalUnit: {
            (options?: vimService.vim.ArrayOfHostMultipathInfoLogicalUnit): vimService.vim.ArrayOfHostMultipathInfoLogicalUnit;
         };
         HostMultipathInfoPath: {
            (options?: vimService.vim.HostMultipathInfoPath): vimService.vim.HostMultipathInfoPath;
         };
         ArrayOfHostMultipathInfoPath: {
            (options?: vimService.vim.ArrayOfHostMultipathInfoPath): vimService.vim.ArrayOfHostMultipathInfoPath;
         };
         HostMultipathInfo: {
            (options?: vimService.vim.HostMultipathInfo): vimService.vim.HostMultipathInfo;
         };
         HostMultipathStateInfoPath: {
            (options?: vimService.vim.HostMultipathStateInfoPath): vimService.vim.HostMultipathStateInfoPath;
         };
         ArrayOfHostMultipathStateInfoPath: {
            (options?: vimService.vim.ArrayOfHostMultipathStateInfoPath): vimService.vim.ArrayOfHostMultipathStateInfoPath;
         };
         HostMultipathStateInfo: {
            (options?: vimService.vim.HostMultipathStateInfo): vimService.vim.HostMultipathStateInfo;
         };
         HostNatServicePortForwardSpec: {
            (options?: vimService.vim.HostNatServicePortForwardSpec): vimService.vim.HostNatServicePortForwardSpec;
         };
         ArrayOfHostNatServicePortForwardSpec: {
            (options?: vimService.vim.ArrayOfHostNatServicePortForwardSpec): vimService.vim.ArrayOfHostNatServicePortForwardSpec;
         };
         HostNatServiceNameServiceSpec: {
            (options?: vimService.vim.HostNatServiceNameServiceSpec): vimService.vim.HostNatServiceNameServiceSpec;
         };
         HostNatServiceSpec: {
            (options?: vimService.vim.HostNatServiceSpec): vimService.vim.HostNatServiceSpec;
         };
         HostNatServiceConfig: {
            (options?: vimService.vim.HostNatServiceConfig): vimService.vim.HostNatServiceConfig;
         };
         ArrayOfHostNatServiceConfig: {
            (options?: vimService.vim.ArrayOfHostNatServiceConfig): vimService.vim.ArrayOfHostNatServiceConfig;
         };
         HostNatService: {
            (options?: vimService.vim.HostNatService): vimService.vim.HostNatService;
         };
         ArrayOfHostNatService: {
            (options?: vimService.vim.ArrayOfHostNatService): vimService.vim.ArrayOfHostNatService;
         };
         HostNetCapabilities: {
            (options?: vimService.vim.HostNetCapabilities): vimService.vim.HostNetCapabilities;
         };
         HostNetOffloadCapabilities: {
            (options?: vimService.vim.HostNetOffloadCapabilities): vimService.vim.HostNetOffloadCapabilities;
         };
         HostNetStackInstanceSystemStackKey: {
            "defaultTcpipStack": string;
            "vmotion": string;
            "vSphereProvisioning": string;
         };
         HostNetStackInstanceCongestionControlAlgorithmType: {
            "newreno": string;
            "cubic": string;
         };
         HostNetStackInstance: {
            (options?: vimService.vim.HostNetStackInstance): vimService.vim.HostNetStackInstance;
         };
         ArrayOfHostNetStackInstance: {
            (options?: vimService.vim.ArrayOfHostNetStackInstance): vimService.vim.ArrayOfHostNetStackInstance;
         };
         HostNetworkConfigResult: {
            (options?: vimService.vim.HostNetworkConfigResult): vimService.vim.HostNetworkConfigResult;
         };
         HostNetworkConfigNetStackSpec: {
            (options?: vimService.vim.HostNetworkConfigNetStackSpec): vimService.vim.HostNetworkConfigNetStackSpec;
         };
         ArrayOfHostNetworkConfigNetStackSpec: {
            (options?: vimService.vim.ArrayOfHostNetworkConfigNetStackSpec): vimService.vim.ArrayOfHostNetworkConfigNetStackSpec;
         };
         HostNetworkConfig: {
            (options?: vimService.vim.HostNetworkConfig): vimService.vim.HostNetworkConfig;
         };
         HostNetworkInfo: {
            (options?: vimService.vim.HostNetworkInfo): vimService.vim.HostNetworkInfo;
         };
         HostNetworkSecurityPolicy: {
            (options?: vimService.vim.HostNetworkSecurityPolicy): vimService.vim.HostNetworkSecurityPolicy;
         };
         HostNetworkTrafficShapingPolicy: {
            (options?: vimService.vim.HostNetworkTrafficShapingPolicy): vimService.vim.HostNetworkTrafficShapingPolicy;
         };
         HostNicFailureCriteria: {
            (options?: vimService.vim.HostNicFailureCriteria): vimService.vim.HostNicFailureCriteria;
         };
         HostNicOrderPolicy: {
            (options?: vimService.vim.HostNicOrderPolicy): vimService.vim.HostNicOrderPolicy;
         };
         HostNicTeamingPolicy: {
            (options?: vimService.vim.HostNicTeamingPolicy): vimService.vim.HostNicTeamingPolicy;
         };
         HostNetworkPolicy: {
            (options?: vimService.vim.HostNetworkPolicy): vimService.vim.HostNetworkPolicy;
         };
         HostNtpConfig: {
            (options?: vimService.vim.HostNtpConfig): vimService.vim.HostNtpConfig;
         };
         HostNumericSensorHealthState: {
            "unknown": string;
            "green": string;
            "yellow": string;
            "red": string;
         };
         HostNumericSensorType: {
            "fan": string;
            "power": string;
            "temperature": string;
            "voltage": string;
            "other": string;
            "processor": string;
            "memory": string;
            "storage": string;
            "systemBoard": string;
            "battery": string;
            "bios": string;
            "cable": string;
            "watchdog": string;
         };
         HostNumericSensorInfo: {
            (options?: vimService.vim.HostNumericSensorInfo): vimService.vim.HostNumericSensorInfo;
         };
         ArrayOfHostNumericSensorInfo: {
            (options?: vimService.vim.ArrayOfHostNumericSensorInfo): vimService.vim.ArrayOfHostNumericSensorInfo;
         };
         HostOpaqueNetworkInfo: {
            (options?: vimService.vim.HostOpaqueNetworkInfo): vimService.vim.HostOpaqueNetworkInfo;
         };
         ArrayOfHostOpaqueNetworkInfo: {
            (options?: vimService.vim.ArrayOfHostOpaqueNetworkInfo): vimService.vim.ArrayOfHostOpaqueNetworkInfo;
         };
         HostOpaqueSwitchOpaqueSwitchState: {
            "up": string;
            "warning": string;
            "down": string;
         };
         HostOpaqueSwitchPhysicalNicZone: {
            (options?: vimService.vim.HostOpaqueSwitchPhysicalNicZone): vimService.vim.HostOpaqueSwitchPhysicalNicZone;
         };
         ArrayOfHostOpaqueSwitchPhysicalNicZone: {
            (options?: vimService.vim.ArrayOfHostOpaqueSwitchPhysicalNicZone): vimService.vim.ArrayOfHostOpaqueSwitchPhysicalNicZone;
         };
         HostOpaqueSwitch: {
            (options?: vimService.vim.HostOpaqueSwitch): vimService.vim.HostOpaqueSwitch;
         };
         ArrayOfHostOpaqueSwitch: {
            (options?: vimService.vim.ArrayOfHostOpaqueSwitch): vimService.vim.ArrayOfHostOpaqueSwitch;
         };
         HostPatchManagerResult: {
            (options?: vimService.vim.HostPatchManagerResult): vimService.vim.HostPatchManagerResult;
         };
         HostPatchManagerReason: {
            "obsoleted": string;
            "missingPatch": string;
            "missingLib": string;
            "hasDependentPatch": string;
            "conflictPatch": string;
            "conflictLib": string;
         };
         HostPatchManagerIntegrityStatus: {
            "validated": string;
            "keyNotFound": string;
            "keyRevoked": string;
            "keyExpired": string;
            "digestMismatch": string;
            "notEnoughSignatures": string;
            "validationError": string;
         };
         HostPatchManagerInstallState: {
            "hostRestarted": string;
            "imageActive": string;
         };
         HostPatchManagerStatusPrerequisitePatch: {
            (options?: vimService.vim.HostPatchManagerStatusPrerequisitePatch): vimService.vim.HostPatchManagerStatusPrerequisitePatch;
         };
         ArrayOfHostPatchManagerStatusPrerequisitePatch: {
            (options?: vimService.vim.ArrayOfHostPatchManagerStatusPrerequisitePatch): vimService.vim.ArrayOfHostPatchManagerStatusPrerequisitePatch;
         };
         HostPatchManagerStatus: {
            (options?: vimService.vim.HostPatchManagerStatus): vimService.vim.HostPatchManagerStatus;
         };
         ArrayOfHostPatchManagerStatus: {
            (options?: vimService.vim.ArrayOfHostPatchManagerStatus): vimService.vim.ArrayOfHostPatchManagerStatus;
         };
         HostPatchManagerLocator: {
            (options?: vimService.vim.HostPatchManagerLocator): vimService.vim.HostPatchManagerLocator;
         };
         HostPatchManagerPatchManagerOperationSpec: {
            (options?: vimService.vim.HostPatchManagerPatchManagerOperationSpec): vimService.vim.HostPatchManagerPatchManagerOperationSpec;
         };
         HostPathSelectionPolicyOption: {
            (options?: vimService.vim.HostPathSelectionPolicyOption): vimService.vim.HostPathSelectionPolicyOption;
         };
         ArrayOfHostPathSelectionPolicyOption: {
            (options?: vimService.vim.ArrayOfHostPathSelectionPolicyOption): vimService.vim.ArrayOfHostPathSelectionPolicyOption;
         };
         HostPciDevice: {
            (options?: vimService.vim.HostPciDevice): vimService.vim.HostPciDevice;
         };
         ArrayOfHostPciDevice: {
            (options?: vimService.vim.ArrayOfHostPciDevice): vimService.vim.ArrayOfHostPciDevice;
         };
         HostPciPassthruConfig: {
            (options?: vimService.vim.HostPciPassthruConfig): vimService.vim.HostPciPassthruConfig;
         };
         ArrayOfHostPciPassthruConfig: {
            (options?: vimService.vim.ArrayOfHostPciPassthruConfig): vimService.vim.ArrayOfHostPciPassthruConfig;
         };
         HostPciPassthruInfo: {
            (options?: vimService.vim.HostPciPassthruInfo): vimService.vim.HostPciPassthruInfo;
         };
         ArrayOfHostPciPassthruInfo: {
            (options?: vimService.vim.ArrayOfHostPciPassthruInfo): vimService.vim.ArrayOfHostPciPassthruInfo;
         };
         PhysicalNicSpec: {
            (options?: vimService.vim.PhysicalNicSpec): vimService.vim.PhysicalNicSpec;
         };
         PhysicalNicConfig: {
            (options?: vimService.vim.PhysicalNicConfig): vimService.vim.PhysicalNicConfig;
         };
         ArrayOfPhysicalNicConfig: {
            (options?: vimService.vim.ArrayOfPhysicalNicConfig): vimService.vim.ArrayOfPhysicalNicConfig;
         };
         PhysicalNicLinkInfo: {
            (options?: vimService.vim.PhysicalNicLinkInfo): vimService.vim.PhysicalNicLinkInfo;
         };
         ArrayOfPhysicalNicLinkInfo: {
            (options?: vimService.vim.ArrayOfPhysicalNicLinkInfo): vimService.vim.ArrayOfPhysicalNicLinkInfo;
         };
         PhysicalNicHint: {
            (options?: vimService.vim.PhysicalNicHint): vimService.vim.PhysicalNicHint;
         };
         PhysicalNicIpHint: {
            (options?: vimService.vim.PhysicalNicIpHint): vimService.vim.PhysicalNicIpHint;
         };
         ArrayOfPhysicalNicIpHint: {
            (options?: vimService.vim.ArrayOfPhysicalNicIpHint): vimService.vim.ArrayOfPhysicalNicIpHint;
         };
         PhysicalNicNameHint: {
            (options?: vimService.vim.PhysicalNicNameHint): vimService.vim.PhysicalNicNameHint;
         };
         ArrayOfPhysicalNicNameHint: {
            (options?: vimService.vim.ArrayOfPhysicalNicNameHint): vimService.vim.ArrayOfPhysicalNicNameHint;
         };
         PhysicalNicHintInfo: {
            (options?: vimService.vim.PhysicalNicHintInfo): vimService.vim.PhysicalNicHintInfo;
         };
         ArrayOfPhysicalNicHintInfo: {
            (options?: vimService.vim.ArrayOfPhysicalNicHintInfo): vimService.vim.ArrayOfPhysicalNicHintInfo;
         };
         PhysicalNicCdpDeviceCapability: {
            (options?: vimService.vim.PhysicalNicCdpDeviceCapability): vimService.vim.PhysicalNicCdpDeviceCapability;
         };
         PhysicalNicCdpInfo: {
            (options?: vimService.vim.PhysicalNicCdpInfo): vimService.vim.PhysicalNicCdpInfo;
         };
         LinkLayerDiscoveryProtocolInfo: {
            (options?: vimService.vim.LinkLayerDiscoveryProtocolInfo): vimService.vim.LinkLayerDiscoveryProtocolInfo;
         };
         PhysicalNicVmDirectPathGen2SupportedMode: {
            "upt": string;
         };
         PhysicalNicResourcePoolSchedulerDisallowedReason: {
            "userOptOut": string;
            "hardwareUnsupported": string;
         };
         PhysicalNic: {
            (options?: vimService.vim.PhysicalNic): vimService.vim.PhysicalNic;
         };
         ArrayOfPhysicalNic: {
            (options?: vimService.vim.ArrayOfPhysicalNic): vimService.vim.ArrayOfPhysicalNic;
         };
         HostPlugStoreTopologyAdapter: {
            (options?: vimService.vim.HostPlugStoreTopologyAdapter): vimService.vim.HostPlugStoreTopologyAdapter;
         };
         ArrayOfHostPlugStoreTopologyAdapter: {
            (options?: vimService.vim.ArrayOfHostPlugStoreTopologyAdapter): vimService.vim.ArrayOfHostPlugStoreTopologyAdapter;
         };
         HostPlugStoreTopologyPath: {
            (options?: vimService.vim.HostPlugStoreTopologyPath): vimService.vim.HostPlugStoreTopologyPath;
         };
         ArrayOfHostPlugStoreTopologyPath: {
            (options?: vimService.vim.ArrayOfHostPlugStoreTopologyPath): vimService.vim.ArrayOfHostPlugStoreTopologyPath;
         };
         HostPlugStoreTopologyDevice: {
            (options?: vimService.vim.HostPlugStoreTopologyDevice): vimService.vim.HostPlugStoreTopologyDevice;
         };
         ArrayOfHostPlugStoreTopologyDevice: {
            (options?: vimService.vim.ArrayOfHostPlugStoreTopologyDevice): vimService.vim.ArrayOfHostPlugStoreTopologyDevice;
         };
         HostPlugStoreTopologyPlugin: {
            (options?: vimService.vim.HostPlugStoreTopologyPlugin): vimService.vim.HostPlugStoreTopologyPlugin;
         };
         ArrayOfHostPlugStoreTopologyPlugin: {
            (options?: vimService.vim.ArrayOfHostPlugStoreTopologyPlugin): vimService.vim.ArrayOfHostPlugStoreTopologyPlugin;
         };
         HostPlugStoreTopologyTarget: {
            (options?: vimService.vim.HostPlugStoreTopologyTarget): vimService.vim.HostPlugStoreTopologyTarget;
         };
         ArrayOfHostPlugStoreTopologyTarget: {
            (options?: vimService.vim.ArrayOfHostPlugStoreTopologyTarget): vimService.vim.ArrayOfHostPlugStoreTopologyTarget;
         };
         HostPlugStoreTopology: {
            (options?: vimService.vim.HostPlugStoreTopology): vimService.vim.HostPlugStoreTopology;
         };
         PortGroupConnecteeType: {
            "virtualMachine": string;
            "systemManagement": string;
            "host": string;
            "unknown": string;
         };
         HostPortGroupSpec: {
            (options?: vimService.vim.HostPortGroupSpec): vimService.vim.HostPortGroupSpec;
         };
         HostPortGroupConfig: {
            (options?: vimService.vim.HostPortGroupConfig): vimService.vim.HostPortGroupConfig;
         };
         ArrayOfHostPortGroupConfig: {
            (options?: vimService.vim.ArrayOfHostPortGroupConfig): vimService.vim.ArrayOfHostPortGroupConfig;
         };
         HostPortGroupPort: {
            (options?: vimService.vim.HostPortGroupPort): vimService.vim.HostPortGroupPort;
         };
         ArrayOfHostPortGroupPort: {
            (options?: vimService.vim.ArrayOfHostPortGroupPort): vimService.vim.ArrayOfHostPortGroupPort;
         };
         HostPortGroup: {
            (options?: vimService.vim.HostPortGroup): vimService.vim.HostPortGroup;
         };
         ArrayOfHostPortGroup: {
            (options?: vimService.vim.ArrayOfHostPortGroup): vimService.vim.ArrayOfHostPortGroup;
         };
         HostPowerPolicy: {
            (options?: vimService.vim.HostPowerPolicy): vimService.vim.HostPowerPolicy;
         };
         ArrayOfHostPowerPolicy: {
            (options?: vimService.vim.ArrayOfHostPowerPolicy): vimService.vim.ArrayOfHostPowerPolicy;
         };
         PowerSystemCapability: {
            (options?: vimService.vim.PowerSystemCapability): vimService.vim.PowerSystemCapability;
         };
         PowerSystemInfo: {
            (options?: vimService.vim.PowerSystemInfo): vimService.vim.PowerSystemInfo;
         };
         HostProtocolEndpointPEType: {
            "block": string;
            "nas": string;
         };
         HostProtocolEndpointProtocolEndpointType: {
            "scsi": string;
            "nfs": string;
            "nfs4x": string;
         };
         HostProtocolEndpoint: {
            (options?: vimService.vim.HostProtocolEndpoint): vimService.vim.HostProtocolEndpoint;
         };
         ArrayOfHostProtocolEndpoint: {
            (options?: vimService.vim.ArrayOfHostProtocolEndpoint): vimService.vim.ArrayOfHostProtocolEndpoint;
         };
         HostResignatureRescanResult: {
            (options?: vimService.vim.HostResignatureRescanResult): vimService.vim.HostResignatureRescanResult;
         };
         HostFirewallRulesetIpNetwork: {
            (options?: vimService.vim.HostFirewallRulesetIpNetwork): vimService.vim.HostFirewallRulesetIpNetwork;
         };
         ArrayOfHostFirewallRulesetIpNetwork: {
            (options?: vimService.vim.ArrayOfHostFirewallRulesetIpNetwork): vimService.vim.ArrayOfHostFirewallRulesetIpNetwork;
         };
         HostFirewallRulesetIpList: {
            (options?: vimService.vim.HostFirewallRulesetIpList): vimService.vim.HostFirewallRulesetIpList;
         };
         HostFirewallRulesetRulesetSpec: {
            (options?: vimService.vim.HostFirewallRulesetRulesetSpec): vimService.vim.HostFirewallRulesetRulesetSpec;
         };
         HostFirewallRuleDirection: {
            "inbound": string;
            "outbound": string;
         };
         HostFirewallRulePortType: {
            "src": string;
            "dst": string;
         };
         HostFirewallRuleProtocol: {
            "tcp": string;
            "udp": string;
         };
         HostFirewallRule: {
            (options?: vimService.vim.HostFirewallRule): vimService.vim.HostFirewallRule;
         };
         ArrayOfHostFirewallRule: {
            (options?: vimService.vim.ArrayOfHostFirewallRule): vimService.vim.ArrayOfHostFirewallRule;
         };
         HostFirewallRuleset: {
            (options?: vimService.vim.HostFirewallRuleset): vimService.vim.HostFirewallRuleset;
         };
         ArrayOfHostFirewallRuleset: {
            (options?: vimService.vim.ArrayOfHostFirewallRuleset): vimService.vim.ArrayOfHostFirewallRuleset;
         };
         HostRuntimeInfoNetStackInstanceRuntimeInfoState: {
            "inactive": string;
            "active": string;
            "deactivating": string;
            "activating": string;
         };
         HostRuntimeInfoNetStackInstanceRuntimeInfo: {
            (options?: vimService.vim.HostRuntimeInfoNetStackInstanceRuntimeInfo): vimService.vim.HostRuntimeInfoNetStackInstanceRuntimeInfo;
         };
         ArrayOfHostRuntimeInfoNetStackInstanceRuntimeInfo: {
            (options?: vimService.vim.ArrayOfHostRuntimeInfoNetStackInstanceRuntimeInfo): vimService.vim.ArrayOfHostRuntimeInfoNetStackInstanceRuntimeInfo;
         };
         HostPlacedVirtualNicIdentifier: {
            (options?: vimService.vim.HostPlacedVirtualNicIdentifier): vimService.vim.HostPlacedVirtualNicIdentifier;
         };
         ArrayOfHostPlacedVirtualNicIdentifier: {
            (options?: vimService.vim.ArrayOfHostPlacedVirtualNicIdentifier): vimService.vim.ArrayOfHostPlacedVirtualNicIdentifier;
         };
         HostPnicNetworkResourceInfo: {
            (options?: vimService.vim.HostPnicNetworkResourceInfo): vimService.vim.HostPnicNetworkResourceInfo;
         };
         ArrayOfHostPnicNetworkResourceInfo: {
            (options?: vimService.vim.ArrayOfHostPnicNetworkResourceInfo): vimService.vim.ArrayOfHostPnicNetworkResourceInfo;
         };
         HostNetworkResourceRuntime: {
            (options?: vimService.vim.HostNetworkResourceRuntime): vimService.vim.HostNetworkResourceRuntime;
         };
         HostRuntimeInfoNetworkRuntimeInfo: {
            (options?: vimService.vim.HostRuntimeInfoNetworkRuntimeInfo): vimService.vim.HostRuntimeInfoNetworkRuntimeInfo;
         };
         HostRuntimeInfo: {
            (options?: vimService.vim.HostRuntimeInfo): vimService.vim.HostRuntimeInfo;
         };
         HostScsiDiskPartition: {
            (options?: vimService.vim.HostScsiDiskPartition): vimService.vim.HostScsiDiskPartition;
         };
         ArrayOfHostScsiDiskPartition: {
            (options?: vimService.vim.ArrayOfHostScsiDiskPartition): vimService.vim.ArrayOfHostScsiDiskPartition;
         };
         ScsiDiskType: {
            "native512": string;
            "emulated512": string;
            "native4k": string;
            "unknown": string;
         };
         HostScsiDisk: {
            (options?: vimService.vim.HostScsiDisk): vimService.vim.HostScsiDisk;
         };
         ArrayOfHostScsiDisk: {
            (options?: vimService.vim.ArrayOfHostScsiDisk): vimService.vim.ArrayOfHostScsiDisk;
         };
         ScsiLunType: {
            "disk": string;
            "tape": string;
            "printer": string;
            "processor": string;
            "worm": string;
            "cdrom": string;
            "scanner": string;
            "opticalDevice": string;
            "mediaChanger": string;
            "communications": string;
            "storageArrayController": string;
            "enclosure": string;
            "unknown": string;
         };
         ScsiLunCapabilities: {
            (options?: vimService.vim.ScsiLunCapabilities): vimService.vim.ScsiLunCapabilities;
         };
         ScsiLunDurableName: {
            (options?: vimService.vim.ScsiLunDurableName): vimService.vim.ScsiLunDurableName;
         };
         ArrayOfScsiLunDurableName: {
            (options?: vimService.vim.ArrayOfScsiLunDurableName): vimService.vim.ArrayOfScsiLunDurableName;
         };
         ScsiLunState: {
            "unknownState": string;
            "ok": string;
            "error": string;
            "off": string;
            "quiesced": string;
            "degraded": string;
            "lostCommunication": string;
            "timeout": string;
         };
         ScsiLunDescriptorQuality: {
            "highQuality": string;
            "mediumQuality": string;
            "lowQuality": string;
            "unknownQuality": string;
         };
         ScsiLunDescriptor: {
            (options?: vimService.vim.ScsiLunDescriptor): vimService.vim.ScsiLunDescriptor;
         };
         ArrayOfScsiLunDescriptor: {
            (options?: vimService.vim.ArrayOfScsiLunDescriptor): vimService.vim.ArrayOfScsiLunDescriptor;
         };
         ScsiLunVStorageSupportStatus: {
            "vStorageSupported": string;
            "vStorageUnsupported": string;
            "vStorageUnknown": string;
         };
         ScsiLun: {
            (options?: vimService.vim.ScsiLun): vimService.vim.ScsiLun;
         };
         ArrayOfScsiLun: {
            (options?: vimService.vim.ArrayOfScsiLun): vimService.vim.ArrayOfScsiLun;
         };
         HostScsiTopologyInterface: {
            (options?: vimService.vim.HostScsiTopologyInterface): vimService.vim.HostScsiTopologyInterface;
         };
         ArrayOfHostScsiTopologyInterface: {
            (options?: vimService.vim.ArrayOfHostScsiTopologyInterface): vimService.vim.ArrayOfHostScsiTopologyInterface;
         };
         HostScsiTopologyTarget: {
            (options?: vimService.vim.HostScsiTopologyTarget): vimService.vim.HostScsiTopologyTarget;
         };
         ArrayOfHostScsiTopologyTarget: {
            (options?: vimService.vim.ArrayOfHostScsiTopologyTarget): vimService.vim.ArrayOfHostScsiTopologyTarget;
         };
         HostScsiTopologyLun: {
            (options?: vimService.vim.HostScsiTopologyLun): vimService.vim.HostScsiTopologyLun;
         };
         ArrayOfHostScsiTopologyLun: {
            (options?: vimService.vim.ArrayOfHostScsiTopologyLun): vimService.vim.ArrayOfHostScsiTopologyLun;
         };
         HostScsiTopology: {
            (options?: vimService.vim.HostScsiTopology): vimService.vim.HostScsiTopology;
         };
         HostSecuritySpec: {
            (options?: vimService.vim.HostSecuritySpec): vimService.vim.HostSecuritySpec;
         };
         HostServicePolicy: {
            "on": string;
            "automatic": string;
            "off": string;
         };
         HostServiceSourcePackage: {
            (options?: vimService.vim.HostServiceSourcePackage): vimService.vim.HostServiceSourcePackage;
         };
         HostService: {
            (options?: vimService.vim.HostService): vimService.vim.HostService;
         };
         ArrayOfHostService: {
            (options?: vimService.vim.ArrayOfHostService): vimService.vim.ArrayOfHostService;
         };
         HostServiceConfig: {
            (options?: vimService.vim.HostServiceConfig): vimService.vim.HostServiceConfig;
         };
         ArrayOfHostServiceConfig: {
            (options?: vimService.vim.ArrayOfHostServiceConfig): vimService.vim.ArrayOfHostServiceConfig;
         };
         HostServiceInfo: {
            (options?: vimService.vim.HostServiceInfo): vimService.vim.HostServiceInfo;
         };
         HostSnmpDestination: {
            (options?: vimService.vim.HostSnmpDestination): vimService.vim.HostSnmpDestination;
         };
         ArrayOfHostSnmpDestination: {
            (options?: vimService.vim.ArrayOfHostSnmpDestination): vimService.vim.ArrayOfHostSnmpDestination;
         };
         HostSnmpConfigSpec: {
            (options?: vimService.vim.HostSnmpConfigSpec): vimService.vim.HostSnmpConfigSpec;
         };
         HostSnmpAgentCapability: {
            "COMPLETE": string;
            "DIAGNOSTICS": string;
            "CONFIGURATION": string;
         };
         HostSnmpSystemAgentLimits: {
            (options?: vimService.vim.HostSnmpSystemAgentLimits): vimService.vim.HostSnmpSystemAgentLimits;
         };
         SoftwarePackageVibType: {
            "bootbank": string;
            "tools": string;
            "meta": string;
         };
         SoftwarePackageCapability: {
            (options?: vimService.vim.SoftwarePackageCapability): vimService.vim.SoftwarePackageCapability;
         };
         SoftwarePackageConstraint: {
            "equals": string;
            "lessThan": string;
            "lessThanEqual": string;
            "greaterThanEqual": string;
            "greaterThan": string;
         };
         Relation: {
            (options?: vimService.vim.Relation): vimService.vim.Relation;
         };
         ArrayOfRelation: {
            (options?: vimService.vim.ArrayOfRelation): vimService.vim.ArrayOfRelation;
         };
         SoftwarePackage: {
            (options?: vimService.vim.SoftwarePackage): vimService.vim.SoftwarePackage;
         };
         ArrayOfSoftwarePackage: {
            (options?: vimService.vim.ArrayOfSoftwarePackage): vimService.vim.ArrayOfSoftwarePackage;
         };
         HostSriovConfig: {
            (options?: vimService.vim.HostSriovConfig): vimService.vim.HostSriovConfig;
         };
         HostSriovDevicePoolInfo: {
            (options?: vimService.vim.HostSriovDevicePoolInfo): vimService.vim.HostSriovDevicePoolInfo;
         };
         ArrayOfHostSriovDevicePoolInfo: {
            (options?: vimService.vim.ArrayOfHostSriovDevicePoolInfo): vimService.vim.ArrayOfHostSriovDevicePoolInfo;
         };
         HostSriovInfo: {
            (options?: vimService.vim.HostSriovInfo): vimService.vim.HostSriovInfo;
         };
         HostSriovNetworkDevicePoolInfo: {
            (options?: vimService.vim.HostSriovNetworkDevicePoolInfo): vimService.vim.HostSriovNetworkDevicePoolInfo;
         };
         HostSslThumbprintInfo: {
            (options?: vimService.vim.HostSslThumbprintInfo): vimService.vim.HostSslThumbprintInfo;
         };
         ArrayOfHostSslThumbprintInfo: {
            (options?: vimService.vim.ArrayOfHostSslThumbprintInfo): vimService.vim.ArrayOfHostSslThumbprintInfo;
         };
         HostStorageArrayTypePolicyOption: {
            (options?: vimService.vim.HostStorageArrayTypePolicyOption): vimService.vim.HostStorageArrayTypePolicyOption;
         };
         ArrayOfHostStorageArrayTypePolicyOption: {
            (options?: vimService.vim.ArrayOfHostStorageArrayTypePolicyOption): vimService.vim.ArrayOfHostStorageArrayTypePolicyOption;
         };
         HostStorageDeviceInfo: {
            (options?: vimService.vim.HostStorageDeviceInfo): vimService.vim.HostStorageDeviceInfo;
         };
         HostStorageSystemVmfsVolumeResult: {
            (options?: vimService.vim.HostStorageSystemVmfsVolumeResult): vimService.vim.HostStorageSystemVmfsVolumeResult;
         };
         ArrayOfHostStorageSystemVmfsVolumeResult: {
            (options?: vimService.vim.ArrayOfHostStorageSystemVmfsVolumeResult): vimService.vim.ArrayOfHostStorageSystemVmfsVolumeResult;
         };
         HostStorageSystemScsiLunResult: {
            (options?: vimService.vim.HostStorageSystemScsiLunResult): vimService.vim.HostStorageSystemScsiLunResult;
         };
         ArrayOfHostStorageSystemScsiLunResult: {
            (options?: vimService.vim.ArrayOfHostStorageSystemScsiLunResult): vimService.vim.ArrayOfHostStorageSystemScsiLunResult;
         };
         HostStorageSystemDiskLocatorLedResult: {
            (options?: vimService.vim.HostStorageSystemDiskLocatorLedResult): vimService.vim.HostStorageSystemDiskLocatorLedResult;
         };
         ArrayOfHostStorageSystemDiskLocatorLedResult: {
            (options?: vimService.vim.ArrayOfHostStorageSystemDiskLocatorLedResult): vimService.vim.ArrayOfHostStorageSystemDiskLocatorLedResult;
         };
         HostHardwareSummary: {
            (options?: vimService.vim.HostHardwareSummary): vimService.vim.HostHardwareSummary;
         };
         HostListSummaryQuickStats: {
            (options?: vimService.vim.HostListSummaryQuickStats): vimService.vim.HostListSummaryQuickStats;
         };
         HostConfigSummary: {
            (options?: vimService.vim.HostConfigSummary): vimService.vim.HostConfigSummary;
         };
         HostListSummaryGatewaySummary: {
            (options?: vimService.vim.HostListSummaryGatewaySummary): vimService.vim.HostListSummaryGatewaySummary;
         };
         HostListSummary: {
            (options?: vimService.vim.HostListSummary): vimService.vim.HostListSummary;
         };
         SystemEventInfo: {
            (options?: vimService.vim.SystemEventInfo): vimService.vim.SystemEventInfo;
         };
         ArrayOfSystemEventInfo: {
            (options?: vimService.vim.ArrayOfSystemEventInfo): vimService.vim.ArrayOfSystemEventInfo;
         };
         HostSystemHealthInfo: {
            (options?: vimService.vim.HostSystemHealthInfo): vimService.vim.HostSystemHealthInfo;
         };
         HostSystemIdentificationInfoIdentifier: {
            "AssetTag": string;
            "ServiceTag": string;
            "OemSpecificString": string;
         };
         HostSystemIdentificationInfo: {
            (options?: vimService.vim.HostSystemIdentificationInfo): vimService.vim.HostSystemIdentificationInfo;
         };
         ArrayOfHostSystemIdentificationInfo: {
            (options?: vimService.vim.ArrayOfHostSystemIdentificationInfo): vimService.vim.ArrayOfHostSystemIdentificationInfo;
         };
         HostSystemResourceInfo: {
            (options?: vimService.vim.HostSystemResourceInfo): vimService.vim.HostSystemResourceInfo;
         };
         ArrayOfHostSystemResourceInfo: {
            (options?: vimService.vim.ArrayOfHostSystemResourceInfo): vimService.vim.ArrayOfHostSystemResourceInfo;
         };
         HostSystemSwapConfigurationSystemSwapOption: {
            (options?: vimService.vim.HostSystemSwapConfigurationSystemSwapOption): vimService.vim.HostSystemSwapConfigurationSystemSwapOption;
         };
         ArrayOfHostSystemSwapConfigurationSystemSwapOption: {
            (options?: vimService.vim.ArrayOfHostSystemSwapConfigurationSystemSwapOption): vimService.vim.ArrayOfHostSystemSwapConfigurationSystemSwapOption;
         };
         HostSystemSwapConfigurationDisabledOption: {
            (options?: vimService.vim.HostSystemSwapConfigurationDisabledOption): vimService.vim.HostSystemSwapConfigurationDisabledOption;
         };
         HostSystemSwapConfigurationHostCacheOption: {
            (options?: vimService.vim.HostSystemSwapConfigurationHostCacheOption): vimService.vim.HostSystemSwapConfigurationHostCacheOption;
         };
         HostSystemSwapConfigurationHostLocalSwapOption: {
            (options?: vimService.vim.HostSystemSwapConfigurationHostLocalSwapOption): vimService.vim.HostSystemSwapConfigurationHostLocalSwapOption;
         };
         HostSystemSwapConfigurationDatastoreOption: {
            (options?: vimService.vim.HostSystemSwapConfigurationDatastoreOption): vimService.vim.HostSystemSwapConfigurationDatastoreOption;
         };
         HostSystemSwapConfiguration: {
            (options?: vimService.vim.HostSystemSwapConfiguration): vimService.vim.HostSystemSwapConfiguration;
         };
         HostTargetTransport: {
            (options?: vimService.vim.HostTargetTransport): vimService.vim.HostTargetTransport;
         };
         HostParallelScsiTargetTransport: {
            (options?: vimService.vim.HostParallelScsiTargetTransport): vimService.vim.HostParallelScsiTargetTransport;
         };
         HostBlockAdapterTargetTransport: {
            (options?: vimService.vim.HostBlockAdapterTargetTransport): vimService.vim.HostBlockAdapterTargetTransport;
         };
         HostSerialAttachedTargetTransport: {
            (options?: vimService.vim.HostSerialAttachedTargetTransport): vimService.vim.HostSerialAttachedTargetTransport;
         };
         HostFibreChannelTargetTransport: {
            (options?: vimService.vim.HostFibreChannelTargetTransport): vimService.vim.HostFibreChannelTargetTransport;
         };
         HostInternetScsiTargetTransport: {
            (options?: vimService.vim.HostInternetScsiTargetTransport): vimService.vim.HostInternetScsiTargetTransport;
         };
         HostFibreChannelOverEthernetTargetTransport: {
            (options?: vimService.vim.HostFibreChannelOverEthernetTargetTransport): vimService.vim.HostFibreChannelOverEthernetTargetTransport;
         };
         HostTpmAttestationReport: {
            (options?: vimService.vim.HostTpmAttestationReport): vimService.vim.HostTpmAttestationReport;
         };
         HostTpmBootSecurityOptionEventDetails: {
            (options?: vimService.vim.HostTpmBootSecurityOptionEventDetails): vimService.vim.HostTpmBootSecurityOptionEventDetails;
         };
         HostTpmCommandEventDetails: {
            (options?: vimService.vim.HostTpmCommandEventDetails): vimService.vim.HostTpmCommandEventDetails;
         };
         HostDigestInfoDigestMethodType: {
            "SHA1": string;
            "MD5": string;
         };
         HostDigestInfo: {
            (options?: vimService.vim.HostDigestInfo): vimService.vim.HostDigestInfo;
         };
         HostTpmDigestInfo: {
            (options?: vimService.vim.HostTpmDigestInfo): vimService.vim.HostTpmDigestInfo;
         };
         ArrayOfHostTpmDigestInfo: {
            (options?: vimService.vim.ArrayOfHostTpmDigestInfo): vimService.vim.ArrayOfHostTpmDigestInfo;
         };
         HostTpmEventDetails: {
            (options?: vimService.vim.HostTpmEventDetails): vimService.vim.HostTpmEventDetails;
         };
         HostTpmEventLogEntry: {
            (options?: vimService.vim.HostTpmEventLogEntry): vimService.vim.HostTpmEventLogEntry;
         };
         ArrayOfHostTpmEventLogEntry: {
            (options?: vimService.vim.ArrayOfHostTpmEventLogEntry): vimService.vim.ArrayOfHostTpmEventLogEntry;
         };
         HostTpmOptionEventDetails: {
            (options?: vimService.vim.HostTpmOptionEventDetails): vimService.vim.HostTpmOptionEventDetails;
         };
         HostTpmSoftwareComponentEventDetails: {
            (options?: vimService.vim.HostTpmSoftwareComponentEventDetails): vimService.vim.HostTpmSoftwareComponentEventDetails;
         };
         HostUnresolvedVmfsExtentUnresolvedReason: {
            "diskIdMismatch": string;
            "uuidConflict": string;
         };
         HostUnresolvedVmfsExtent: {
            (options?: vimService.vim.HostUnresolvedVmfsExtent): vimService.vim.HostUnresolvedVmfsExtent;
         };
         ArrayOfHostUnresolvedVmfsExtent: {
            (options?: vimService.vim.ArrayOfHostUnresolvedVmfsExtent): vimService.vim.ArrayOfHostUnresolvedVmfsExtent;
         };
         HostUnresolvedVmfsResignatureSpec: {
            (options?: vimService.vim.HostUnresolvedVmfsResignatureSpec): vimService.vim.HostUnresolvedVmfsResignatureSpec;
         };
         HostUnresolvedVmfsResolutionResult: {
            (options?: vimService.vim.HostUnresolvedVmfsResolutionResult): vimService.vim.HostUnresolvedVmfsResolutionResult;
         };
         ArrayOfHostUnresolvedVmfsResolutionResult: {
            (options?: vimService.vim.ArrayOfHostUnresolvedVmfsResolutionResult): vimService.vim.ArrayOfHostUnresolvedVmfsResolutionResult;
         };
         HostUnresolvedVmfsResolutionSpecVmfsUuidResolution: {
            "resignature": string;
            "forceMount": string;
         };
         HostUnresolvedVmfsResolutionSpec: {
            (options?: vimService.vim.HostUnresolvedVmfsResolutionSpec): vimService.vim.HostUnresolvedVmfsResolutionSpec;
         };
         ArrayOfHostUnresolvedVmfsResolutionSpec: {
            (options?: vimService.vim.ArrayOfHostUnresolvedVmfsResolutionSpec): vimService.vim.ArrayOfHostUnresolvedVmfsResolutionSpec;
         };
         HostUnresolvedVmfsVolumeResolveStatus: {
            (options?: vimService.vim.HostUnresolvedVmfsVolumeResolveStatus): vimService.vim.HostUnresolvedVmfsVolumeResolveStatus;
         };
         HostUnresolvedVmfsVolume: {
            (options?: vimService.vim.HostUnresolvedVmfsVolume): vimService.vim.HostUnresolvedVmfsVolume;
         };
         ArrayOfHostUnresolvedVmfsVolume: {
            (options?: vimService.vim.ArrayOfHostUnresolvedVmfsVolume): vimService.vim.ArrayOfHostUnresolvedVmfsVolume;
         };
         HostVFlashManagerVFlashResourceConfigSpec: {
            (options?: vimService.vim.HostVFlashManagerVFlashResourceConfigSpec): vimService.vim.HostVFlashManagerVFlashResourceConfigSpec;
         };
         HostVFlashManagerVFlashResourceConfigInfo: {
            (options?: vimService.vim.HostVFlashManagerVFlashResourceConfigInfo): vimService.vim.HostVFlashManagerVFlashResourceConfigInfo;
         };
         HostVFlashManagerVFlashResourceRunTimeInfo: {
            (options?: vimService.vim.HostVFlashManagerVFlashResourceRunTimeInfo): vimService.vim.HostVFlashManagerVFlashResourceRunTimeInfo;
         };
         HostVFlashManagerVFlashCacheConfigSpec: {
            (options?: vimService.vim.HostVFlashManagerVFlashCacheConfigSpec): vimService.vim.HostVFlashManagerVFlashCacheConfigSpec;
         };
         HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption: {
            (options?: vimService.vim.HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption): vimService.vim.HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption;
         };
         ArrayOfHostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption: {
            (options?: vimService.vim.ArrayOfHostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption): vimService.vim.ArrayOfHostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption;
         };
         HostVFlashManagerVFlashCacheConfigInfo: {
            (options?: vimService.vim.HostVFlashManagerVFlashCacheConfigInfo): vimService.vim.HostVFlashManagerVFlashCacheConfigInfo;
         };
         HostVFlashManagerVFlashConfigInfo: {
            (options?: vimService.vim.HostVFlashManagerVFlashConfigInfo): vimService.vim.HostVFlashManagerVFlashConfigInfo;
         };
         HostVFlashResourceConfigurationResult: {
            (options?: vimService.vim.HostVFlashResourceConfigurationResult): vimService.vim.HostVFlashResourceConfigurationResult;
         };
         HostVMotionConfig: {
            (options?: vimService.vim.HostVMotionConfig): vimService.vim.HostVMotionConfig;
         };
         HostVMotionInfo: {
            (options?: vimService.vim.HostVMotionInfo): vimService.vim.HostVMotionInfo;
         };
         HostVMotionNetConfig: {
            (options?: vimService.vim.HostVMotionNetConfig): vimService.vim.HostVMotionNetConfig;
         };
         HostVffsSpec: {
            (options?: vimService.vim.HostVffsSpec): vimService.vim.HostVffsSpec;
         };
         HostVffsVolume: {
            (options?: vimService.vim.HostVffsVolume): vimService.vim.HostVffsVolume;
         };
         HostVirtualNicSpec: {
            (options?: vimService.vim.HostVirtualNicSpec): vimService.vim.HostVirtualNicSpec;
         };
         HostVirtualNicConfig: {
            (options?: vimService.vim.HostVirtualNicConfig): vimService.vim.HostVirtualNicConfig;
         };
         ArrayOfHostVirtualNicConfig: {
            (options?: vimService.vim.ArrayOfHostVirtualNicConfig): vimService.vim.ArrayOfHostVirtualNicConfig;
         };
         HostVirtualNicOpaqueNetworkSpec: {
            (options?: vimService.vim.HostVirtualNicOpaqueNetworkSpec): vimService.vim.HostVirtualNicOpaqueNetworkSpec;
         };
         HostVirtualNicIpRouteSpec: {
            (options?: vimService.vim.HostVirtualNicIpRouteSpec): vimService.vim.HostVirtualNicIpRouteSpec;
         };
         HostVirtualNic: {
            (options?: vimService.vim.HostVirtualNic): vimService.vim.HostVirtualNic;
         };
         ArrayOfHostVirtualNic: {
            (options?: vimService.vim.ArrayOfHostVirtualNic): vimService.vim.ArrayOfHostVirtualNic;
         };
         HostVirtualNicConnection: {
            (options?: vimService.vim.HostVirtualNicConnection): vimService.vim.HostVirtualNicConnection;
         };
         HostVirtualNicManagerNicType: {
            "vmotion": string;
            "faultToleranceLogging": string;
            "vSphereReplication": string;
            "vSphereReplicationNFC": string;
            "management": string;
            "vsan": string;
            "vSphereProvisioning": string;
            "vsanWitness": string;
         };
         HostVirtualNicManagerNicTypeSelection: {
            (options?: vimService.vim.HostVirtualNicManagerNicTypeSelection): vimService.vim.HostVirtualNicManagerNicTypeSelection;
         };
         ArrayOfHostVirtualNicManagerNicTypeSelection: {
            (options?: vimService.vim.ArrayOfHostVirtualNicManagerNicTypeSelection): vimService.vim.ArrayOfHostVirtualNicManagerNicTypeSelection;
         };
         VirtualNicManagerNetConfig: {
            (options?: vimService.vim.VirtualNicManagerNetConfig): vimService.vim.VirtualNicManagerNetConfig;
         };
         ArrayOfVirtualNicManagerNetConfig: {
            (options?: vimService.vim.ArrayOfVirtualNicManagerNetConfig): vimService.vim.ArrayOfVirtualNicManagerNetConfig;
         };
         HostVirtualNicManagerInfo: {
            (options?: vimService.vim.HostVirtualNicManagerInfo): vimService.vim.HostVirtualNicManagerInfo;
         };
         HostVirtualSwitchBridge: {
            (options?: vimService.vim.HostVirtualSwitchBridge): vimService.vim.HostVirtualSwitchBridge;
         };
         HostVirtualSwitchAutoBridge: {
            (options?: vimService.vim.HostVirtualSwitchAutoBridge): vimService.vim.HostVirtualSwitchAutoBridge;
         };
         HostVirtualSwitchSimpleBridge: {
            (options?: vimService.vim.HostVirtualSwitchSimpleBridge): vimService.vim.HostVirtualSwitchSimpleBridge;
         };
         HostVirtualSwitchBondBridge: {
            (options?: vimService.vim.HostVirtualSwitchBondBridge): vimService.vim.HostVirtualSwitchBondBridge;
         };
         HostVirtualSwitchBeaconConfig: {
            (options?: vimService.vim.HostVirtualSwitchBeaconConfig): vimService.vim.HostVirtualSwitchBeaconConfig;
         };
         HostVirtualSwitchSpec: {
            (options?: vimService.vim.HostVirtualSwitchSpec): vimService.vim.HostVirtualSwitchSpec;
         };
         HostVirtualSwitchConfig: {
            (options?: vimService.vim.HostVirtualSwitchConfig): vimService.vim.HostVirtualSwitchConfig;
         };
         ArrayOfHostVirtualSwitchConfig: {
            (options?: vimService.vim.ArrayOfHostVirtualSwitchConfig): vimService.vim.ArrayOfHostVirtualSwitchConfig;
         };
         HostVirtualSwitch: {
            (options?: vimService.vim.HostVirtualSwitch): vimService.vim.HostVirtualSwitch;
         };
         ArrayOfHostVirtualSwitch: {
            (options?: vimService.vim.ArrayOfHostVirtualSwitch): vimService.vim.ArrayOfHostVirtualSwitch;
         };
         HostVmciAccessManagerMode: {
            "grant": string;
            "replace": string;
            "revoke": string;
         };
         HostVmciAccessManagerAccessSpec: {
            (options?: vimService.vim.HostVmciAccessManagerAccessSpec): vimService.vim.HostVmciAccessManagerAccessSpec;
         };
         ArrayOfHostVmciAccessManagerAccessSpec: {
            (options?: vimService.vim.ArrayOfHostVmciAccessManagerAccessSpec): vimService.vim.ArrayOfHostVmciAccessManagerAccessSpec;
         };
         HostVmfsRescanResult: {
            (options?: vimService.vim.HostVmfsRescanResult): vimService.vim.HostVmfsRescanResult;
         };
         ArrayOfHostVmfsRescanResult: {
            (options?: vimService.vim.ArrayOfHostVmfsRescanResult): vimService.vim.ArrayOfHostVmfsRescanResult;
         };
         HostVmfsSpec: {
            (options?: vimService.vim.HostVmfsSpec): vimService.vim.HostVmfsSpec;
         };
         HostVmfsVolumeUnmapPriority: {
            "none": string;
            "low": string;
         };
         VmfsConfigOption: {
            (options?: vimService.vim.VmfsConfigOption): vimService.vim.VmfsConfigOption;
         };
         ArrayOfVmfsConfigOption: {
            (options?: vimService.vim.ArrayOfVmfsConfigOption): vimService.vim.ArrayOfVmfsConfigOption;
         };
         HostVmfsVolume: {
            (options?: vimService.vim.HostVmfsVolume): vimService.vim.HostVmfsVolume;
         };
         HostVsanInternalSystemCmmdsQuery: {
            (options?: vimService.vim.HostVsanInternalSystemCmmdsQuery): vimService.vim.HostVsanInternalSystemCmmdsQuery;
         };
         ArrayOfHostVsanInternalSystemCmmdsQuery: {
            (options?: vimService.vim.ArrayOfHostVsanInternalSystemCmmdsQuery): vimService.vim.ArrayOfHostVsanInternalSystemCmmdsQuery;
         };
         VsanPolicyCost: {
            (options?: vimService.vim.VsanPolicyCost): vimService.vim.VsanPolicyCost;
         };
         VsanPolicySatisfiability: {
            (options?: vimService.vim.VsanPolicySatisfiability): vimService.vim.VsanPolicySatisfiability;
         };
         ArrayOfVsanPolicySatisfiability: {
            (options?: vimService.vim.ArrayOfVsanPolicySatisfiability): vimService.vim.ArrayOfVsanPolicySatisfiability;
         };
         VsanPolicyChangeBatch: {
            (options?: vimService.vim.VsanPolicyChangeBatch): vimService.vim.VsanPolicyChangeBatch;
         };
         ArrayOfVsanPolicyChangeBatch: {
            (options?: vimService.vim.ArrayOfVsanPolicyChangeBatch): vimService.vim.ArrayOfVsanPolicyChangeBatch;
         };
         VsanNewPolicyBatch: {
            (options?: vimService.vim.VsanNewPolicyBatch): vimService.vim.VsanNewPolicyBatch;
         };
         ArrayOfVsanNewPolicyBatch: {
            (options?: vimService.vim.ArrayOfVsanNewPolicyBatch): vimService.vim.ArrayOfVsanNewPolicyBatch;
         };
         HostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult: {
            (options?: vimService.vim.HostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult): vimService.vim.HostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult;
         };
         ArrayOfHostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult: {
            (options?: vimService.vim.ArrayOfHostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult): vimService.vim.ArrayOfHostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult;
         };
         HostVsanInternalSystemDeleteVsanObjectsResult: {
            (options?: vimService.vim.HostVsanInternalSystemDeleteVsanObjectsResult): vimService.vim.HostVsanInternalSystemDeleteVsanObjectsResult;
         };
         ArrayOfHostVsanInternalSystemDeleteVsanObjectsResult: {
            (options?: vimService.vim.ArrayOfHostVsanInternalSystemDeleteVsanObjectsResult): vimService.vim.ArrayOfHostVsanInternalSystemDeleteVsanObjectsResult;
         };
         HostVsanInternalSystemVsanObjectOperationResult: {
            (options?: vimService.vim.HostVsanInternalSystemVsanObjectOperationResult): vimService.vim.HostVsanInternalSystemVsanObjectOperationResult;
         };
         ArrayOfHostVsanInternalSystemVsanObjectOperationResult: {
            (options?: vimService.vim.ArrayOfHostVsanInternalSystemVsanObjectOperationResult): vimService.vim.ArrayOfHostVsanInternalSystemVsanObjectOperationResult;
         };
         HostVvolVolumeSpecification: {
            (options?: vimService.vim.HostVvolVolumeSpecification): vimService.vim.HostVvolVolumeSpecification;
         };
         VVolHostPE: {
            (options?: vimService.vim.VVolHostPE): vimService.vim.VVolHostPE;
         };
         ArrayOfVVolHostPE: {
            (options?: vimService.vim.ArrayOfVVolHostPE): vimService.vim.ArrayOfVVolHostPE;
         };
         HostVvolVolume: {
            (options?: vimService.vim.HostVvolVolume): vimService.vim.HostVvolVolume;
         };
         NetDhcpConfigInfoDhcpOptions: {
            (options?: vimService.vim.NetDhcpConfigInfoDhcpOptions): vimService.vim.NetDhcpConfigInfoDhcpOptions;
         };
         NetDhcpConfigInfo: {
            (options?: vimService.vim.NetDhcpConfigInfo): vimService.vim.NetDhcpConfigInfo;
         };
         NetDhcpConfigSpecDhcpOptionsSpec: {
            (options?: vimService.vim.NetDhcpConfigSpecDhcpOptionsSpec): vimService.vim.NetDhcpConfigSpecDhcpOptionsSpec;
         };
         NetDhcpConfigSpec: {
            (options?: vimService.vim.NetDhcpConfigSpec): vimService.vim.NetDhcpConfigSpec;
         };
         NetDnsConfigInfo: {
            (options?: vimService.vim.NetDnsConfigInfo): vimService.vim.NetDnsConfigInfo;
         };
         NetDnsConfigSpec: {
            (options?: vimService.vim.NetDnsConfigSpec): vimService.vim.NetDnsConfigSpec;
         };
         NetIpConfigInfoIpAddressOrigin: {
            "other": string;
            "manual": string;
            "dhcp": string;
            "linklayer": string;
            "random": string;
         };
         NetIpConfigInfoIpAddressStatus: {
            "preferred": string;
            "deprecated": string;
            "invalid": string;
            "inaccessible": string;
            "unknown": string;
            "tentative": string;
            "duplicate": string;
         };
         NetIpConfigInfoIpAddress: {
            (options?: vimService.vim.NetIpConfigInfoIpAddress): vimService.vim.NetIpConfigInfoIpAddress;
         };
         ArrayOfNetIpConfigInfoIpAddress: {
            (options?: vimService.vim.ArrayOfNetIpConfigInfoIpAddress): vimService.vim.ArrayOfNetIpConfigInfoIpAddress;
         };
         NetIpConfigInfo: {
            (options?: vimService.vim.NetIpConfigInfo): vimService.vim.NetIpConfigInfo;
         };
         NetIpConfigSpecIpAddressSpec: {
            (options?: vimService.vim.NetIpConfigSpecIpAddressSpec): vimService.vim.NetIpConfigSpecIpAddressSpec;
         };
         ArrayOfNetIpConfigSpecIpAddressSpec: {
            (options?: vimService.vim.ArrayOfNetIpConfigSpecIpAddressSpec): vimService.vim.ArrayOfNetIpConfigSpecIpAddressSpec;
         };
         NetIpConfigSpec: {
            (options?: vimService.vim.NetIpConfigSpec): vimService.vim.NetIpConfigSpec;
         };
         NetIpRouteConfigInfoGateway: {
            (options?: vimService.vim.NetIpRouteConfigInfoGateway): vimService.vim.NetIpRouteConfigInfoGateway;
         };
         NetIpRouteConfigInfoIpRoute: {
            (options?: vimService.vim.NetIpRouteConfigInfoIpRoute): vimService.vim.NetIpRouteConfigInfoIpRoute;
         };
         ArrayOfNetIpRouteConfigInfoIpRoute: {
            (options?: vimService.vim.ArrayOfNetIpRouteConfigInfoIpRoute): vimService.vim.ArrayOfNetIpRouteConfigInfoIpRoute;
         };
         NetIpRouteConfigInfo: {
            (options?: vimService.vim.NetIpRouteConfigInfo): vimService.vim.NetIpRouteConfigInfo;
         };
         NetIpRouteConfigSpecGatewaySpec: {
            (options?: vimService.vim.NetIpRouteConfigSpecGatewaySpec): vimService.vim.NetIpRouteConfigSpecGatewaySpec;
         };
         NetIpRouteConfigSpecIpRouteSpec: {
            (options?: vimService.vim.NetIpRouteConfigSpecIpRouteSpec): vimService.vim.NetIpRouteConfigSpecIpRouteSpec;
         };
         ArrayOfNetIpRouteConfigSpecIpRouteSpec: {
            (options?: vimService.vim.ArrayOfNetIpRouteConfigSpecIpRouteSpec): vimService.vim.ArrayOfNetIpRouteConfigSpecIpRouteSpec;
         };
         NetIpRouteConfigSpec: {
            (options?: vimService.vim.NetIpRouteConfigSpec): vimService.vim.NetIpRouteConfigSpec;
         };
         NetIpStackInfoEntryType: {
            "other": string;
            "invalid": string;
            "dynamic": string;
            "manual": string;
         };
         NetIpStackInfoPreference: {
            "reserved": string;
            "low": string;
            "medium": string;
            "high": string;
         };
         NetIpStackInfoNetToMedia: {
            (options?: vimService.vim.NetIpStackInfoNetToMedia): vimService.vim.NetIpStackInfoNetToMedia;
         };
         ArrayOfNetIpStackInfoNetToMedia: {
            (options?: vimService.vim.ArrayOfNetIpStackInfoNetToMedia): vimService.vim.ArrayOfNetIpStackInfoNetToMedia;
         };
         NetIpStackInfoDefaultRouter: {
            (options?: vimService.vim.NetIpStackInfoDefaultRouter): vimService.vim.NetIpStackInfoDefaultRouter;
         };
         ArrayOfNetIpStackInfoDefaultRouter: {
            (options?: vimService.vim.ArrayOfNetIpStackInfoDefaultRouter): vimService.vim.ArrayOfNetIpStackInfoDefaultRouter;
         };
         NetIpStackInfo: {
            (options?: vimService.vim.NetIpStackInfo): vimService.vim.NetIpStackInfo;
         };
         NetBIOSConfigInfoMode: {
            "unknown": string;
            "enabled": string;
            "disabled": string;
            "enabledViaDHCP": string;
         };
         NetBIOSConfigInfo: {
            (options?: vimService.vim.NetBIOSConfigInfo): vimService.vim.NetBIOSConfigInfo;
         };
         WinNetBIOSConfigInfo: {
            (options?: vimService.vim.WinNetBIOSConfigInfo): vimService.vim.WinNetBIOSConfigInfo;
         };
         ArrayUpdateOperation: {
            "add": string;
            "remove": string;
            "edit": string;
         };
         ArrayUpdateSpec: {
            (options?: vimService.vim.ArrayUpdateSpec): vimService.vim.ArrayUpdateSpec;
         };
         BoolOption: {
            (options?: vimService.vim.BoolOption): vimService.vim.BoolOption;
         };
         ChoiceOption: {
            (options?: vimService.vim.ChoiceOption): vimService.vim.ChoiceOption;
         };
         FloatOption: {
            (options?: vimService.vim.FloatOption): vimService.vim.FloatOption;
         };
         IntOption: {
            (options?: vimService.vim.IntOption): vimService.vim.IntOption;
         };
         LongOption: {
            (options?: vimService.vim.LongOption): vimService.vim.LongOption;
         };
         OptionDef: {
            (options?: vimService.vim.OptionDef): vimService.vim.OptionDef;
         };
         ArrayOfOptionDef: {
            (options?: vimService.vim.ArrayOfOptionDef): vimService.vim.ArrayOfOptionDef;
         };
         OptionType: {
            (options?: vimService.vim.OptionType): vimService.vim.OptionType;
         };
         OptionValue: {
            (options?: vimService.vim.OptionValue): vimService.vim.OptionValue;
         };
         ArrayOfOptionValue: {
            (options?: vimService.vim.ArrayOfOptionValue): vimService.vim.ArrayOfOptionValue;
         };
         StringOption: {
            (options?: vimService.vim.StringOption): vimService.vim.StringOption;
         };
         ApplyProfile: {
            (options?: vimService.vim.ApplyProfile): vimService.vim.ApplyProfile;
         };
         ArrayOfApplyProfile: {
            (options?: vimService.vim.ArrayOfApplyProfile): vimService.vim.ArrayOfApplyProfile;
         };
         ProfileApplyProfileElement: {
            (options?: vimService.vim.ProfileApplyProfileElement): vimService.vim.ProfileApplyProfileElement;
         };
         ProfileApplyProfileProperty: {
            (options?: vimService.vim.ProfileApplyProfileProperty): vimService.vim.ProfileApplyProfileProperty;
         };
         ArrayOfProfileApplyProfileProperty: {
            (options?: vimService.vim.ArrayOfProfileApplyProfileProperty): vimService.vim.ArrayOfProfileApplyProfileProperty;
         };
         ComplianceLocator: {
            (options?: vimService.vim.ComplianceLocator): vimService.vim.ComplianceLocator;
         };
         ArrayOfComplianceLocator: {
            (options?: vimService.vim.ArrayOfComplianceLocator): vimService.vim.ArrayOfComplianceLocator;
         };
         ComplianceProfile: {
            (options?: vimService.vim.ComplianceProfile): vimService.vim.ComplianceProfile;
         };
         ComplianceResultStatus: {
            "compliant": string;
            "nonCompliant": string;
            "unknown": string;
         };
         ComplianceFailureComplianceFailureValues: {
            (options?: vimService.vim.ComplianceFailureComplianceFailureValues): vimService.vim.ComplianceFailureComplianceFailureValues;
         };
         ArrayOfComplianceFailureComplianceFailureValues: {
            (options?: vimService.vim.ArrayOfComplianceFailureComplianceFailureValues): vimService.vim.ArrayOfComplianceFailureComplianceFailureValues;
         };
         ComplianceFailure: {
            (options?: vimService.vim.ComplianceFailure): vimService.vim.ComplianceFailure;
         };
         ArrayOfComplianceFailure: {
            (options?: vimService.vim.ArrayOfComplianceFailure): vimService.vim.ArrayOfComplianceFailure;
         };
         ComplianceResult: {
            (options?: vimService.vim.ComplianceResult): vimService.vim.ComplianceResult;
         };
         ArrayOfComplianceResult: {
            (options?: vimService.vim.ArrayOfComplianceResult): vimService.vim.ArrayOfComplianceResult;
         };
         ProfileDeferredPolicyOptionParameter: {
            (options?: vimService.vim.ProfileDeferredPolicyOptionParameter): vimService.vim.ProfileDeferredPolicyOptionParameter;
         };
         ArrayOfProfileDeferredPolicyOptionParameter: {
            (options?: vimService.vim.ArrayOfProfileDeferredPolicyOptionParameter): vimService.vim.ArrayOfProfileDeferredPolicyOptionParameter;
         };
         ProfileExpression: {
            (options?: vimService.vim.ProfileExpression): vimService.vim.ProfileExpression;
         };
         ArrayOfProfileExpression: {
            (options?: vimService.vim.ArrayOfProfileExpression): vimService.vim.ArrayOfProfileExpression;
         };
         ProfileSimpleExpression: {
            (options?: vimService.vim.ProfileSimpleExpression): vimService.vim.ProfileSimpleExpression;
         };
         ProfileCompositeExpression: {
            (options?: vimService.vim.ProfileCompositeExpression): vimService.vim.ProfileCompositeExpression;
         };
         ProfileExpressionMetadata: {
            (options?: vimService.vim.ProfileExpressionMetadata): vimService.vim.ProfileExpressionMetadata;
         };
         ArrayOfProfileExpressionMetadata: {
            (options?: vimService.vim.ArrayOfProfileExpressionMetadata): vimService.vim.ArrayOfProfileExpressionMetadata;
         };
         ProfileNumericComparator: {
            "lessThan": string;
            "lessThanEqual": string;
            "equal": string;
            "notEqual": string;
            "greaterThanEqual": string;
            "greaterThan": string;
         };
         ProfileParameterMetadata: {
            (options?: vimService.vim.ProfileParameterMetadata): vimService.vim.ProfileParameterMetadata;
         };
         ArrayOfProfileParameterMetadata: {
            (options?: vimService.vim.ArrayOfProfileParameterMetadata): vimService.vim.ArrayOfProfileParameterMetadata;
         };
         ProfilePolicy: {
            (options?: vimService.vim.ProfilePolicy): vimService.vim.ProfilePolicy;
         };
         ArrayOfProfilePolicy: {
            (options?: vimService.vim.ArrayOfProfilePolicy): vimService.vim.ArrayOfProfilePolicy;
         };
         ProfilePolicyOptionMetadata: {
            (options?: vimService.vim.ProfilePolicyOptionMetadata): vimService.vim.ProfilePolicyOptionMetadata;
         };
         ArrayOfProfilePolicyOptionMetadata: {
            (options?: vimService.vim.ArrayOfProfilePolicyOptionMetadata): vimService.vim.ArrayOfProfilePolicyOptionMetadata;
         };
         ProfileCompositePolicyOptionMetadata: {
            (options?: vimService.vim.ProfileCompositePolicyOptionMetadata): vimService.vim.ProfileCompositePolicyOptionMetadata;
         };
         UserInputRequiredParameterMetadata: {
            (options?: vimService.vim.UserInputRequiredParameterMetadata): vimService.vim.UserInputRequiredParameterMetadata;
         };
         ProfilePolicyMetadata: {
            (options?: vimService.vim.ProfilePolicyMetadata): vimService.vim.ProfilePolicyMetadata;
         };
         ArrayOfProfilePolicyMetadata: {
            (options?: vimService.vim.ArrayOfProfilePolicyMetadata): vimService.vim.ArrayOfProfilePolicyMetadata;
         };
         PolicyOption: {
            (options?: vimService.vim.PolicyOption): vimService.vim.PolicyOption;
         };
         ArrayOfPolicyOption: {
            (options?: vimService.vim.ArrayOfPolicyOption): vimService.vim.ArrayOfPolicyOption;
         };
         CompositePolicyOption: {
            (options?: vimService.vim.CompositePolicyOption): vimService.vim.CompositePolicyOption;
         };
         ProfileCreateSpec: {
            (options?: vimService.vim.ProfileCreateSpec): vimService.vim.ProfileCreateSpec;
         };
         ProfileSerializedCreateSpec: {
            (options?: vimService.vim.ProfileSerializedCreateSpec): vimService.vim.ProfileSerializedCreateSpec;
         };
         ProfileConfigInfo: {
            (options?: vimService.vim.ProfileConfigInfo): vimService.vim.ProfileConfigInfo;
         };
         ProfileDescriptionSection: {
            (options?: vimService.vim.ProfileDescriptionSection): vimService.vim.ProfileDescriptionSection;
         };
         ArrayOfProfileDescriptionSection: {
            (options?: vimService.vim.ArrayOfProfileDescriptionSection): vimService.vim.ArrayOfProfileDescriptionSection;
         };
         ProfileDescription: {
            (options?: vimService.vim.ProfileDescription): vimService.vim.ProfileDescription;
         };
         ProfileMetadataProfileSortSpec: {
            (options?: vimService.vim.ProfileMetadataProfileSortSpec): vimService.vim.ProfileMetadataProfileSortSpec;
         };
         ArrayOfProfileMetadataProfileSortSpec: {
            (options?: vimService.vim.ArrayOfProfileMetadataProfileSortSpec): vimService.vim.ArrayOfProfileMetadataProfileSortSpec;
         };
         ProfileMetadata: {
            (options?: vimService.vim.ProfileMetadata): vimService.vim.ProfileMetadata;
         };
         ArrayOfProfileMetadata: {
            (options?: vimService.vim.ArrayOfProfileMetadata): vimService.vim.ArrayOfProfileMetadata;
         };
         ProfilePropertyPath: {
            (options?: vimService.vim.ProfilePropertyPath): vimService.vim.ProfilePropertyPath;
         };
         ArrayOfProfilePropertyPath: {
            (options?: vimService.vim.ArrayOfProfilePropertyPath): vimService.vim.ArrayOfProfilePropertyPath;
         };
         ProfileProfileStructure: {
            (options?: vimService.vim.ProfileProfileStructure): vimService.vim.ProfileProfileStructure;
         };
         ProfileProfileStructureProperty: {
            (options?: vimService.vim.ProfileProfileStructureProperty): vimService.vim.ProfileProfileStructureProperty;
         };
         ArrayOfProfileProfileStructureProperty: {
            (options?: vimService.vim.ArrayOfProfileProfileStructureProperty): vimService.vim.ArrayOfProfileProfileStructureProperty;
         };
         ClusterProfileConfigInfo: {
            (options?: vimService.vim.ClusterProfileConfigInfo): vimService.vim.ClusterProfileConfigInfo;
         };
         ClusterProfileCreateSpec: {
            (options?: vimService.vim.ClusterProfileCreateSpec): vimService.vim.ClusterProfileCreateSpec;
         };
         ClusterProfileConfigSpec: {
            (options?: vimService.vim.ClusterProfileConfigSpec): vimService.vim.ClusterProfileConfigSpec;
         };
         ClusterProfileCompleteConfigSpec: {
            (options?: vimService.vim.ClusterProfileCompleteConfigSpec): vimService.vim.ClusterProfileCompleteConfigSpec;
         };
         ClusterProfileServiceType: {
            "DRS": string;
            "HA": string;
            "DPM": string;
            "FT": string;
         };
         ClusterProfileConfigServiceCreateSpec: {
            (options?: vimService.vim.ClusterProfileConfigServiceCreateSpec): vimService.vim.ClusterProfileConfigServiceCreateSpec;
         };
         AnswerFile: {
            (options?: vimService.vim.AnswerFile): vimService.vim.AnswerFile;
         };
         AnswerFileStatusError: {
            (options?: vimService.vim.AnswerFileStatusError): vimService.vim.AnswerFileStatusError;
         };
         ArrayOfAnswerFileStatusError: {
            (options?: vimService.vim.ArrayOfAnswerFileStatusError): vimService.vim.ArrayOfAnswerFileStatusError;
         };
         AnswerFileStatusResult: {
            (options?: vimService.vim.AnswerFileStatusResult): vimService.vim.AnswerFileStatusResult;
         };
         ArrayOfAnswerFileStatusResult: {
            (options?: vimService.vim.ArrayOfAnswerFileStatusResult): vimService.vim.ArrayOfAnswerFileStatusResult;
         };
         ProfileExecuteResultStatus: {
            "success": string;
            "needInput": string;
            "error": string;
         };
         ProfileExecuteError: {
            (options?: vimService.vim.ProfileExecuteError): vimService.vim.ProfileExecuteError;
         };
         ArrayOfProfileExecuteError: {
            (options?: vimService.vim.ArrayOfProfileExecuteError): vimService.vim.ArrayOfProfileExecuteError;
         };
         ProfileExecuteResult: {
            (options?: vimService.vim.ProfileExecuteResult): vimService.vim.ProfileExecuteResult;
         };
         HostApplyProfile: {
            (options?: vimService.vim.HostApplyProfile): vimService.vim.HostApplyProfile;
         };
         PhysicalNicProfile: {
            (options?: vimService.vim.PhysicalNicProfile): vimService.vim.PhysicalNicProfile;
         };
         ArrayOfPhysicalNicProfile: {
            (options?: vimService.vim.ArrayOfPhysicalNicProfile): vimService.vim.ArrayOfPhysicalNicProfile;
         };
         HostMemoryProfile: {
            (options?: vimService.vim.HostMemoryProfile): vimService.vim.HostMemoryProfile;
         };
         UserProfile: {
            (options?: vimService.vim.UserProfile): vimService.vim.UserProfile;
         };
         ArrayOfUserProfile: {
            (options?: vimService.vim.ArrayOfUserProfile): vimService.vim.ArrayOfUserProfile;
         };
         UserGroupProfile: {
            (options?: vimService.vim.UserGroupProfile): vimService.vim.UserGroupProfile;
         };
         ArrayOfUserGroupProfile: {
            (options?: vimService.vim.ArrayOfUserGroupProfile): vimService.vim.ArrayOfUserGroupProfile;
         };
         SecurityProfile: {
            (options?: vimService.vim.SecurityProfile): vimService.vim.SecurityProfile;
         };
         OptionProfile: {
            (options?: vimService.vim.OptionProfile): vimService.vim.OptionProfile;
         };
         ArrayOfOptionProfile: {
            (options?: vimService.vim.ArrayOfOptionProfile): vimService.vim.ArrayOfOptionProfile;
         };
         DateTimeProfile: {
            (options?: vimService.vim.DateTimeProfile): vimService.vim.DateTimeProfile;
         };
         ServiceProfile: {
            (options?: vimService.vim.ServiceProfile): vimService.vim.ServiceProfile;
         };
         ArrayOfServiceProfile: {
            (options?: vimService.vim.ArrayOfServiceProfile): vimService.vim.ArrayOfServiceProfile;
         };
         FirewallProfileRulesetProfile: {
            (options?: vimService.vim.FirewallProfileRulesetProfile): vimService.vim.FirewallProfileRulesetProfile;
         };
         ArrayOfFirewallProfileRulesetProfile: {
            (options?: vimService.vim.ArrayOfFirewallProfileRulesetProfile): vimService.vim.ArrayOfFirewallProfileRulesetProfile;
         };
         FirewallProfile: {
            (options?: vimService.vim.FirewallProfile): vimService.vim.FirewallProfile;
         };
         NasStorageProfile: {
            (options?: vimService.vim.NasStorageProfile): vimService.vim.NasStorageProfile;
         };
         ArrayOfNasStorageProfile: {
            (options?: vimService.vim.ArrayOfNasStorageProfile): vimService.vim.ArrayOfNasStorageProfile;
         };
         StorageProfile: {
            (options?: vimService.vim.StorageProfile): vimService.vim.StorageProfile;
         };
         NetworkProfileDnsConfigProfile: {
            (options?: vimService.vim.NetworkProfileDnsConfigProfile): vimService.vim.NetworkProfileDnsConfigProfile;
         };
         NetworkProfile: {
            (options?: vimService.vim.NetworkProfile): vimService.vim.NetworkProfile;
         };
         DvsVNicProfile: {
            (options?: vimService.vim.DvsVNicProfile): vimService.vim.DvsVNicProfile;
         };
         DvsServiceConsoleVNicProfile: {
            (options?: vimService.vim.DvsServiceConsoleVNicProfile): vimService.vim.DvsServiceConsoleVNicProfile;
         };
         ArrayOfDvsServiceConsoleVNicProfile: {
            (options?: vimService.vim.ArrayOfDvsServiceConsoleVNicProfile): vimService.vim.ArrayOfDvsServiceConsoleVNicProfile;
         };
         DvsHostVNicProfile: {
            (options?: vimService.vim.DvsHostVNicProfile): vimService.vim.DvsHostVNicProfile;
         };
         ArrayOfDvsHostVNicProfile: {
            (options?: vimService.vim.ArrayOfDvsHostVNicProfile): vimService.vim.ArrayOfDvsHostVNicProfile;
         };
         DvsProfile: {
            (options?: vimService.vim.DvsProfile): vimService.vim.DvsProfile;
         };
         ArrayOfDvsProfile: {
            (options?: vimService.vim.ArrayOfDvsProfile): vimService.vim.ArrayOfDvsProfile;
         };
         PnicUplinkProfile: {
            (options?: vimService.vim.PnicUplinkProfile): vimService.vim.PnicUplinkProfile;
         };
         ArrayOfPnicUplinkProfile: {
            (options?: vimService.vim.ArrayOfPnicUplinkProfile): vimService.vim.ArrayOfPnicUplinkProfile;
         };
         IpRouteProfile: {
            (options?: vimService.vim.IpRouteProfile): vimService.vim.IpRouteProfile;
         };
         StaticRouteProfile: {
            (options?: vimService.vim.StaticRouteProfile): vimService.vim.StaticRouteProfile;
         };
         ArrayOfStaticRouteProfile: {
            (options?: vimService.vim.ArrayOfStaticRouteProfile): vimService.vim.ArrayOfStaticRouteProfile;
         };
         LinkProfile: {
            (options?: vimService.vim.LinkProfile): vimService.vim.LinkProfile;
         };
         NumPortsProfile: {
            (options?: vimService.vim.NumPortsProfile): vimService.vim.NumPortsProfile;
         };
         VirtualSwitchProfile: {
            (options?: vimService.vim.VirtualSwitchProfile): vimService.vim.VirtualSwitchProfile;
         };
         ArrayOfVirtualSwitchProfile: {
            (options?: vimService.vim.ArrayOfVirtualSwitchProfile): vimService.vim.ArrayOfVirtualSwitchProfile;
         };
         NetStackInstanceProfile: {
            (options?: vimService.vim.NetStackInstanceProfile): vimService.vim.NetStackInstanceProfile;
         };
         ArrayOfNetStackInstanceProfile: {
            (options?: vimService.vim.ArrayOfNetStackInstanceProfile): vimService.vim.ArrayOfNetStackInstanceProfile;
         };
         VlanProfile: {
            (options?: vimService.vim.VlanProfile): vimService.vim.VlanProfile;
         };
         VirtualSwitchSelectionProfile: {
            (options?: vimService.vim.VirtualSwitchSelectionProfile): vimService.vim.VirtualSwitchSelectionProfile;
         };
         PortGroupProfile: {
            (options?: vimService.vim.PortGroupProfile): vimService.vim.PortGroupProfile;
         };
         VmPortGroupProfile: {
            (options?: vimService.vim.VmPortGroupProfile): vimService.vim.VmPortGroupProfile;
         };
         ArrayOfVmPortGroupProfile: {
            (options?: vimService.vim.ArrayOfVmPortGroupProfile): vimService.vim.ArrayOfVmPortGroupProfile;
         };
         HostPortGroupProfile: {
            (options?: vimService.vim.HostPortGroupProfile): vimService.vim.HostPortGroupProfile;
         };
         ArrayOfHostPortGroupProfile: {
            (options?: vimService.vim.ArrayOfHostPortGroupProfile): vimService.vim.ArrayOfHostPortGroupProfile;
         };
         ServiceConsolePortGroupProfile: {
            (options?: vimService.vim.ServiceConsolePortGroupProfile): vimService.vim.ServiceConsolePortGroupProfile;
         };
         ArrayOfServiceConsolePortGroupProfile: {
            (options?: vimService.vim.ArrayOfServiceConsolePortGroupProfile): vimService.vim.ArrayOfServiceConsolePortGroupProfile;
         };
         NetworkPolicyProfile: {
            (options?: vimService.vim.NetworkPolicyProfile): vimService.vim.NetworkPolicyProfile;
         };
         IpAddressProfile: {
            (options?: vimService.vim.IpAddressProfile): vimService.vim.IpAddressProfile;
         };
         AuthenticationProfile: {
            (options?: vimService.vim.AuthenticationProfile): vimService.vim.AuthenticationProfile;
         };
         ActiveDirectoryProfile: {
            (options?: vimService.vim.ActiveDirectoryProfile): vimService.vim.ActiveDirectoryProfile;
         };
         PermissionProfile: {
            (options?: vimService.vim.PermissionProfile): vimService.vim.PermissionProfile;
         };
         ArrayOfPermissionProfile: {
            (options?: vimService.vim.ArrayOfPermissionProfile): vimService.vim.ArrayOfPermissionProfile;
         };
         HostProfileConfigInfo: {
            (options?: vimService.vim.HostProfileConfigInfo): vimService.vim.HostProfileConfigInfo;
         };
         HostProfileConfigSpec: {
            (options?: vimService.vim.HostProfileConfigSpec): vimService.vim.HostProfileConfigSpec;
         };
         HostProfileSerializedHostProfileSpec: {
            (options?: vimService.vim.HostProfileSerializedHostProfileSpec): vimService.vim.HostProfileSerializedHostProfileSpec;
         };
         HostProfileCompleteConfigSpec: {
            (options?: vimService.vim.HostProfileCompleteConfigSpec): vimService.vim.HostProfileCompleteConfigSpec;
         };
         HostProfileHostBasedConfigSpec: {
            (options?: vimService.vim.HostProfileHostBasedConfigSpec): vimService.vim.HostProfileHostBasedConfigSpec;
         };
         HostSpecification: {
            (options?: vimService.vim.HostSpecification): vimService.vim.HostSpecification;
         };
         HostSubSpecification: {
            (options?: vimService.vim.HostSubSpecification): vimService.vim.HostSubSpecification;
         };
         ArrayOfHostSubSpecification: {
            (options?: vimService.vim.ArrayOfHostSubSpecification): vimService.vim.ArrayOfHostSubSpecification;
         };
         HostProfileManagerTaskListRequirement: {
            "maintenanceModeRequired": string;
            "rebootRequired": string;
         };
         HostProfileManagerConfigTaskList: {
            (options?: vimService.vim.HostProfileManagerConfigTaskList): vimService.vim.HostProfileManagerConfigTaskList;
         };
         AnswerFileCreateSpec: {
            (options?: vimService.vim.AnswerFileCreateSpec): vimService.vim.AnswerFileCreateSpec;
         };
         AnswerFileOptionsCreateSpec: {
            (options?: vimService.vim.AnswerFileOptionsCreateSpec): vimService.vim.AnswerFileOptionsCreateSpec;
         };
         AnswerFileSerializedCreateSpec: {
            (options?: vimService.vim.AnswerFileSerializedCreateSpec): vimService.vim.AnswerFileSerializedCreateSpec;
         };
         HostProfileManagerAnswerFileStatus: {
            "valid": string;
            "invalid": string;
            "unknown": string;
         };
         HostProfilesEntityCustomizations: {
            (options?: vimService.vim.HostProfilesEntityCustomizations): vimService.vim.HostProfilesEntityCustomizations;
         };
         ArrayOfHostProfilesEntityCustomizations: {
            (options?: vimService.vim.ArrayOfHostProfilesEntityCustomizations): vimService.vim.ArrayOfHostProfilesEntityCustomizations;
         };
         StructuredCustomizations: {
            (options?: vimService.vim.StructuredCustomizations): vimService.vim.StructuredCustomizations;
         };
         ArrayOfStructuredCustomizations: {
            (options?: vimService.vim.ArrayOfStructuredCustomizations): vimService.vim.ArrayOfStructuredCustomizations;
         };
         HostProfileManagerHostToConfigSpecMap: {
            (options?: vimService.vim.HostProfileManagerHostToConfigSpecMap): vimService.vim.HostProfileManagerHostToConfigSpecMap;
         };
         ArrayOfHostProfileManagerHostToConfigSpecMap: {
            (options?: vimService.vim.ArrayOfHostProfileManagerHostToConfigSpecMap): vimService.vim.ArrayOfHostProfileManagerHostToConfigSpecMap;
         };
         ApplyHostProfileConfigurationSpec: {
            (options?: vimService.vim.ApplyHostProfileConfigurationSpec): vimService.vim.ApplyHostProfileConfigurationSpec;
         };
         ArrayOfApplyHostProfileConfigurationSpec: {
            (options?: vimService.vim.ArrayOfApplyHostProfileConfigurationSpec): vimService.vim.ArrayOfApplyHostProfileConfigurationSpec;
         };
         HostProfileManagerCompositionValidationResultResultElement: {
            (options?: vimService.vim.HostProfileManagerCompositionValidationResultResultElement): vimService.vim.HostProfileManagerCompositionValidationResultResultElement;
         };
         ArrayOfHostProfileManagerCompositionValidationResultResultElement: {
            (options?: vimService.vim.ArrayOfHostProfileManagerCompositionValidationResultResultElement): vimService.vim.ArrayOfHostProfileManagerCompositionValidationResultResultElement;
         };
         ScheduledTaskDetail: {
            (options?: vimService.vim.ScheduledTaskDetail): vimService.vim.ScheduledTaskDetail;
         };
         ArrayOfScheduledTaskDetail: {
            (options?: vimService.vim.ArrayOfScheduledTaskDetail): vimService.vim.ArrayOfScheduledTaskDetail;
         };
         ScheduledTaskDescription: {
            (options?: vimService.vim.ScheduledTaskDescription): vimService.vim.ScheduledTaskDescription;
         };
         ScheduledTaskInfo: {
            (options?: vimService.vim.ScheduledTaskInfo): vimService.vim.ScheduledTaskInfo;
         };
         TaskScheduler: {
            (options?: vimService.vim.TaskScheduler): vimService.vim.TaskScheduler;
         };
         AfterStartupTaskScheduler: {
            (options?: vimService.vim.AfterStartupTaskScheduler): vimService.vim.AfterStartupTaskScheduler;
         };
         OnceTaskScheduler: {
            (options?: vimService.vim.OnceTaskScheduler): vimService.vim.OnceTaskScheduler;
         };
         RecurrentTaskScheduler: {
            (options?: vimService.vim.RecurrentTaskScheduler): vimService.vim.RecurrentTaskScheduler;
         };
         HourlyTaskScheduler: {
            (options?: vimService.vim.HourlyTaskScheduler): vimService.vim.HourlyTaskScheduler;
         };
         DailyTaskScheduler: {
            (options?: vimService.vim.DailyTaskScheduler): vimService.vim.DailyTaskScheduler;
         };
         WeeklyTaskScheduler: {
            (options?: vimService.vim.WeeklyTaskScheduler): vimService.vim.WeeklyTaskScheduler;
         };
         MonthlyTaskScheduler: {
            (options?: vimService.vim.MonthlyTaskScheduler): vimService.vim.MonthlyTaskScheduler;
         };
         MonthlyByDayTaskScheduler: {
            (options?: vimService.vim.MonthlyByDayTaskScheduler): vimService.vim.MonthlyByDayTaskScheduler;
         };
         DayOfWeek: {
            "sunday": string;
            "monday": string;
            "tuesday": string;
            "wednesday": string;
            "thursday": string;
            "friday": string;
            "saturday": string;
         };
         WeekOfMonth: {
            "first": string;
            "second": string;
            "third": string;
            "fourth": string;
            "last": string;
         };
         MonthlyByWeekdayTaskScheduler: {
            (options?: vimService.vim.MonthlyByWeekdayTaskScheduler): vimService.vim.MonthlyByWeekdayTaskScheduler;
         };
         ScheduledTaskSpec: {
            (options?: vimService.vim.ScheduledTaskSpec): vimService.vim.ScheduledTaskSpec;
         };
         ApplyStorageRecommendationResult: {
            (options?: vimService.vim.ApplyStorageRecommendationResult): vimService.vim.ApplyStorageRecommendationResult;
         };
         StorageDrsConfigInfo: {
            (options?: vimService.vim.StorageDrsConfigInfo): vimService.vim.StorageDrsConfigInfo;
         };
         StorageDrsConfigSpec: {
            (options?: vimService.vim.StorageDrsConfigSpec): vimService.vim.StorageDrsConfigSpec;
         };
         StorageDrsVmConfigSpec: {
            (options?: vimService.vim.StorageDrsVmConfigSpec): vimService.vim.StorageDrsVmConfigSpec;
         };
         ArrayOfStorageDrsVmConfigSpec: {
            (options?: vimService.vim.ArrayOfStorageDrsVmConfigSpec): vimService.vim.ArrayOfStorageDrsVmConfigSpec;
         };
         HbrDiskMigrationAction: {
            (options?: vimService.vim.HbrDiskMigrationAction): vimService.vim.HbrDiskMigrationAction;
         };
         PlacementAffinityRuleRuleType: {
            "affinity": string;
            "antiAffinity": string;
            "softAffinity": string;
            "softAntiAffinity": string;
         };
         PlacementAffinityRuleRuleScope: {
            "cluster": string;
            "host": string;
            "storagePod": string;
            "datastore": string;
         };
         PlacementAffinityRule: {
            (options?: vimService.vim.PlacementAffinityRule): vimService.vim.PlacementAffinityRule;
         };
         ArrayOfPlacementAffinityRule: {
            (options?: vimService.vim.ArrayOfPlacementAffinityRule): vimService.vim.ArrayOfPlacementAffinityRule;
         };
         PlacementRankResult: {
            (options?: vimService.vim.PlacementRankResult): vimService.vim.PlacementRankResult;
         };
         PlacementRankSpec: {
            (options?: vimService.vim.PlacementRankSpec): vimService.vim.PlacementRankSpec;
         };
         StorageDrsPlacementRankVmSpec: {
            (options?: vimService.vim.StorageDrsPlacementRankVmSpec): vimService.vim.StorageDrsPlacementRankVmSpec;
         };
         ArrayOfStorageDrsPlacementRankVmSpec: {
            (options?: vimService.vim.ArrayOfStorageDrsPlacementRankVmSpec): vimService.vim.ArrayOfStorageDrsPlacementRankVmSpec;
         };
         StorageDrsPodConfigInfoBehavior: {
            "manual": string;
            "automated": string;
         };
         StorageDrsPodConfigInfo: {
            (options?: vimService.vim.StorageDrsPodConfigInfo): vimService.vim.StorageDrsPodConfigInfo;
         };
         StorageDrsSpaceLoadBalanceConfigSpaceThresholdMode: {
            "utilization": string;
            "freeSpace": string;
         };
         StorageDrsSpaceLoadBalanceConfig: {
            (options?: vimService.vim.StorageDrsSpaceLoadBalanceConfig): vimService.vim.StorageDrsSpaceLoadBalanceConfig;
         };
         StorageDrsIoLoadBalanceConfig: {
            (options?: vimService.vim.StorageDrsIoLoadBalanceConfig): vimService.vim.StorageDrsIoLoadBalanceConfig;
         };
         StorageDrsAutomationConfig: {
            (options?: vimService.vim.StorageDrsAutomationConfig): vimService.vim.StorageDrsAutomationConfig;
         };
         StorageDrsPodConfigSpec: {
            (options?: vimService.vim.StorageDrsPodConfigSpec): vimService.vim.StorageDrsPodConfigSpec;
         };
         StorageDrsOptionSpec: {
            (options?: vimService.vim.StorageDrsOptionSpec): vimService.vim.StorageDrsOptionSpec;
         };
         ArrayOfStorageDrsOptionSpec: {
            (options?: vimService.vim.ArrayOfStorageDrsOptionSpec): vimService.vim.ArrayOfStorageDrsOptionSpec;
         };
         VmPodConfigForPlacement: {
            (options?: vimService.vim.VmPodConfigForPlacement): vimService.vim.VmPodConfigForPlacement;
         };
         ArrayOfVmPodConfigForPlacement: {
            (options?: vimService.vim.ArrayOfVmPodConfigForPlacement): vimService.vim.ArrayOfVmPodConfigForPlacement;
         };
         PodDiskLocator: {
            (options?: vimService.vim.PodDiskLocator): vimService.vim.PodDiskLocator;
         };
         ArrayOfPodDiskLocator: {
            (options?: vimService.vim.ArrayOfPodDiskLocator): vimService.vim.ArrayOfPodDiskLocator;
         };
         StorageDrsPodSelectionSpec: {
            (options?: vimService.vim.StorageDrsPodSelectionSpec): vimService.vim.StorageDrsPodSelectionSpec;
         };
         StorageMigrationAction: {
            (options?: vimService.vim.StorageMigrationAction): vimService.vim.StorageMigrationAction;
         };
         StoragePlacementAction: {
            (options?: vimService.vim.StoragePlacementAction): vimService.vim.StoragePlacementAction;
         };
         StoragePlacementResult: {
            (options?: vimService.vim.StoragePlacementResult): vimService.vim.StoragePlacementResult;
         };
         StoragePlacementSpecPlacementType: {
            "create": string;
            "reconfigure": string;
            "relocate": string;
            "clone": string;
         };
         StoragePlacementSpec: {
            (options?: vimService.vim.StoragePlacementSpec): vimService.vim.StoragePlacementSpec;
         };
         VirtualDiskAntiAffinityRuleSpec: {
            (options?: vimService.vim.VirtualDiskAntiAffinityRuleSpec): vimService.vim.VirtualDiskAntiAffinityRuleSpec;
         };
         StorageDrsVmConfigInfo: {
            (options?: vimService.vim.StorageDrsVmConfigInfo): vimService.vim.StorageDrsVmConfigInfo;
         };
         ArrayOfStorageDrsVmConfigInfo: {
            (options?: vimService.vim.ArrayOfStorageDrsVmConfigInfo): vimService.vim.ArrayOfStorageDrsVmConfigInfo;
         };
         VAppCloneSpecNetworkMappingPair: {
            (options?: vimService.vim.VAppCloneSpecNetworkMappingPair): vimService.vim.VAppCloneSpecNetworkMappingPair;
         };
         ArrayOfVAppCloneSpecNetworkMappingPair: {
            (options?: vimService.vim.ArrayOfVAppCloneSpecNetworkMappingPair): vimService.vim.ArrayOfVAppCloneSpecNetworkMappingPair;
         };
         VAppCloneSpecResourceMap: {
            (options?: vimService.vim.VAppCloneSpecResourceMap): vimService.vim.VAppCloneSpecResourceMap;
         };
         ArrayOfVAppCloneSpecResourceMap: {
            (options?: vimService.vim.ArrayOfVAppCloneSpecResourceMap): vimService.vim.ArrayOfVAppCloneSpecResourceMap;
         };
         VAppCloneSpecProvisioningType: {
            "sameAsSource": string;
            "thin": string;
            "thick": string;
         };
         VAppCloneSpec: {
            (options?: vimService.vim.VAppCloneSpec): vimService.vim.VAppCloneSpec;
         };
         VAppAutoStartAction: {
            "none": string;
            "powerOn": string;
            "powerOff": string;
            "guestShutdown": string;
            "suspend": string;
         };
         VAppEntityConfigInfo: {
            (options?: vimService.vim.VAppEntityConfigInfo): vimService.vim.VAppEntityConfigInfo;
         };
         ArrayOfVAppEntityConfigInfo: {
            (options?: vimService.vim.ArrayOfVAppEntityConfigInfo): vimService.vim.ArrayOfVAppEntityConfigInfo;
         };
         VAppIPAssignmentInfoIpAllocationPolicy: {
            "dhcpPolicy": string;
            "transientPolicy": string;
            "fixedPolicy": string;
            "fixedAllocatedPolicy": string;
         };
         VAppIPAssignmentInfoAllocationSchemes: {
            "dhcp": string;
            "ovfenv": string;
         };
         VAppIPAssignmentInfoProtocols: {
            "IPv4": string;
            "IPv6": string;
         };
         VAppIPAssignmentInfo: {
            (options?: vimService.vim.VAppIPAssignmentInfo): vimService.vim.VAppIPAssignmentInfo;
         };
         IpPoolIpPoolConfigInfo: {
            (options?: vimService.vim.IpPoolIpPoolConfigInfo): vimService.vim.IpPoolIpPoolConfigInfo;
         };
         IpPoolAssociation: {
            (options?: vimService.vim.IpPoolAssociation): vimService.vim.IpPoolAssociation;
         };
         ArrayOfIpPoolAssociation: {
            (options?: vimService.vim.ArrayOfIpPoolAssociation): vimService.vim.ArrayOfIpPoolAssociation;
         };
         IpPool: {
            (options?: vimService.vim.IpPool): vimService.vim.IpPool;
         };
         ArrayOfIpPool: {
            (options?: vimService.vim.ArrayOfIpPool): vimService.vim.ArrayOfIpPool;
         };
         VAppOvfSectionInfo: {
            (options?: vimService.vim.VAppOvfSectionInfo): vimService.vim.VAppOvfSectionInfo;
         };
         ArrayOfVAppOvfSectionInfo: {
            (options?: vimService.vim.ArrayOfVAppOvfSectionInfo): vimService.vim.ArrayOfVAppOvfSectionInfo;
         };
         VAppProductInfo: {
            (options?: vimService.vim.VAppProductInfo): vimService.vim.VAppProductInfo;
         };
         ArrayOfVAppProductInfo: {
            (options?: vimService.vim.ArrayOfVAppProductInfo): vimService.vim.ArrayOfVAppProductInfo;
         };
         VAppPropertyInfo: {
            (options?: vimService.vim.VAppPropertyInfo): vimService.vim.VAppPropertyInfo;
         };
         ArrayOfVAppPropertyInfo: {
            (options?: vimService.vim.ArrayOfVAppPropertyInfo): vimService.vim.ArrayOfVAppPropertyInfo;
         };
         VAppConfigInfo: {
            (options?: vimService.vim.VAppConfigInfo): vimService.vim.VAppConfigInfo;
         };
         VAppConfigSpec: {
            (options?: vimService.vim.VAppConfigSpec): vimService.vim.VAppConfigSpec;
         };
         VirtualAppImportSpec: {
            (options?: vimService.vim.VirtualAppImportSpec): vimService.vim.VirtualAppImportSpec;
         };
         VmConfigInfo: {
            (options?: vimService.vim.VmConfigInfo): vimService.vim.VmConfigInfo;
         };
         VmConfigSpec: {
            (options?: vimService.vim.VmConfigSpec): vimService.vim.VmConfigSpec;
         };
         VAppProductSpec: {
            (options?: vimService.vim.VAppProductSpec): vimService.vim.VAppProductSpec;
         };
         ArrayOfVAppProductSpec: {
            (options?: vimService.vim.ArrayOfVAppProductSpec): vimService.vim.ArrayOfVAppProductSpec;
         };
         VAppPropertySpec: {
            (options?: vimService.vim.VAppPropertySpec): vimService.vim.VAppPropertySpec;
         };
         ArrayOfVAppPropertySpec: {
            (options?: vimService.vim.ArrayOfVAppPropertySpec): vimService.vim.ArrayOfVAppPropertySpec;
         };
         VAppOvfSectionSpec: {
            (options?: vimService.vim.VAppOvfSectionSpec): vimService.vim.VAppOvfSectionSpec;
         };
         ArrayOfVAppOvfSectionSpec: {
            (options?: vimService.vim.ArrayOfVAppOvfSectionSpec): vimService.vim.ArrayOfVAppOvfSectionSpec;
         };
         ClusterNetworkConfigSpec: {
            (options?: vimService.vim.ClusterNetworkConfigSpec): vimService.vim.ClusterNetworkConfigSpec;
         };
         SourceNodeSpec: {
            (options?: vimService.vim.SourceNodeSpec): vimService.vim.SourceNodeSpec;
         };
         NodeNetworkSpec: {
            (options?: vimService.vim.NodeNetworkSpec): vimService.vim.NodeNetworkSpec;
         };
         PassiveNodeNetworkSpec: {
            (options?: vimService.vim.PassiveNodeNetworkSpec): vimService.vim.PassiveNodeNetworkSpec;
         };
         VchaClusterNetworkSpec: {
            (options?: vimService.vim.VchaClusterNetworkSpec): vimService.vim.VchaClusterNetworkSpec;
         };
         NodeDeploymentSpec: {
            (options?: vimService.vim.NodeDeploymentSpec): vimService.vim.NodeDeploymentSpec;
         };
         PassiveNodeDeploymentSpec: {
            (options?: vimService.vim.PassiveNodeDeploymentSpec): vimService.vim.PassiveNodeDeploymentSpec;
         };
         VchaClusterConfigSpec: {
            (options?: vimService.vim.VchaClusterConfigSpec): vimService.vim.VchaClusterConfigSpec;
         };
         VchaClusterDeploymentSpec: {
            (options?: vimService.vim.VchaClusterDeploymentSpec): vimService.vim.VchaClusterDeploymentSpec;
         };
         FailoverNodeInfo: {
            (options?: vimService.vim.FailoverNodeInfo): vimService.vim.FailoverNodeInfo;
         };
         WitnessNodeInfo: {
            (options?: vimService.vim.WitnessNodeInfo): vimService.vim.WitnessNodeInfo;
         };
         VchaState: {
            "configured": string;
            "notConfigured": string;
            "invalid": string;
            "prepared": string;
         };
         VchaClusterConfigInfo: {
            (options?: vimService.vim.VchaClusterConfigInfo): vimService.vim.VchaClusterConfigInfo;
         };
         VchaNodeRole: {
            "active": string;
            "passive": string;
            "witness": string;
         };
         VchaClusterMode: {
            "enabled": string;
            "disabled": string;
            "maintenance": string;
         };
         VchaClusterState: {
            "healthy": string;
            "degraded": string;
            "isolated": string;
         };
         VchaNodeState: {
            "up": string;
            "down": string;
         };
         VchaNodeRuntimeInfo: {
            (options?: vimService.vim.VchaNodeRuntimeInfo): vimService.vim.VchaNodeRuntimeInfo;
         };
         ArrayOfVchaNodeRuntimeInfo: {
            (options?: vimService.vim.ArrayOfVchaNodeRuntimeInfo): vimService.vim.ArrayOfVchaNodeRuntimeInfo;
         };
         VchaClusterRuntimeInfo: {
            (options?: vimService.vim.VchaClusterRuntimeInfo): vimService.vim.VchaClusterRuntimeInfo;
         };
         VchaClusterHealth: {
            (options?: vimService.vim.VchaClusterHealth): vimService.vim.VchaClusterHealth;
         };
         VirtualMachineAffinityInfo: {
            (options?: vimService.vim.VirtualMachineAffinityInfo): vimService.vim.VirtualMachineAffinityInfo;
         };
         VirtualMachineBootOptionsNetworkBootProtocolType: {
            "ipv4": string;
            "ipv6": string;
         };
         VirtualMachineBootOptionsBootableDevice: {
            (options?: vimService.vim.VirtualMachineBootOptionsBootableDevice): vimService.vim.VirtualMachineBootOptionsBootableDevice;
         };
         ArrayOfVirtualMachineBootOptionsBootableDevice: {
            (options?: vimService.vim.ArrayOfVirtualMachineBootOptionsBootableDevice): vimService.vim.ArrayOfVirtualMachineBootOptionsBootableDevice;
         };
         VirtualMachineBootOptionsBootableDiskDevice: {
            (options?: vimService.vim.VirtualMachineBootOptionsBootableDiskDevice): vimService.vim.VirtualMachineBootOptionsBootableDiskDevice;
         };
         VirtualMachineBootOptionsBootableEthernetDevice: {
            (options?: vimService.vim.VirtualMachineBootOptionsBootableEthernetDevice): vimService.vim.VirtualMachineBootOptionsBootableEthernetDevice;
         };
         VirtualMachineBootOptionsBootableFloppyDevice: {
            (options?: vimService.vim.VirtualMachineBootOptionsBootableFloppyDevice): vimService.vim.VirtualMachineBootOptionsBootableFloppyDevice;
         };
         VirtualMachineBootOptionsBootableCdromDevice: {
            (options?: vimService.vim.VirtualMachineBootOptionsBootableCdromDevice): vimService.vim.VirtualMachineBootOptionsBootableCdromDevice;
         };
         VirtualMachineBootOptions: {
            (options?: vimService.vim.VirtualMachineBootOptions): vimService.vim.VirtualMachineBootOptions;
         };
         VirtualMachineCapability: {
            (options?: vimService.vim.VirtualMachineCapability): vimService.vim.VirtualMachineCapability;
         };
         VirtualMachineCdromInfo: {
            (options?: vimService.vim.VirtualMachineCdromInfo): vimService.vim.VirtualMachineCdromInfo;
         };
         ArrayOfVirtualMachineCdromInfo: {
            (options?: vimService.vim.ArrayOfVirtualMachineCdromInfo): vimService.vim.ArrayOfVirtualMachineCdromInfo;
         };
         VirtualMachineCloneSpec: {
            (options?: vimService.vim.VirtualMachineCloneSpec): vimService.vim.VirtualMachineCloneSpec;
         };
         VirtualMachineConfigInfoNpivWwnType: {
            "vc": string;
            "host": string;
            "external": string;
         };
         VirtualMachineConfigInfoSwapPlacementType: {
            "inherit": string;
            "vmDirectory": string;
            "hostLocal": string;
         };
         VirtualMachineConfigInfoDatastoreUrlPair: {
            (options?: vimService.vim.VirtualMachineConfigInfoDatastoreUrlPair): vimService.vim.VirtualMachineConfigInfoDatastoreUrlPair;
         };
         ArrayOfVirtualMachineConfigInfoDatastoreUrlPair: {
            (options?: vimService.vim.ArrayOfVirtualMachineConfigInfoDatastoreUrlPair): vimService.vim.ArrayOfVirtualMachineConfigInfoDatastoreUrlPair;
         };
         VirtualMachineConfigInfoOverheadInfo: {
            (options?: vimService.vim.VirtualMachineConfigInfoOverheadInfo): vimService.vim.VirtualMachineConfigInfoOverheadInfo;
         };
         VirtualMachineConfigInfo: {
            (options?: vimService.vim.VirtualMachineConfigInfo): vimService.vim.VirtualMachineConfigInfo;
         };
         VirtualMachineConfigOption: {
            (options?: vimService.vim.VirtualMachineConfigOption): vimService.vim.VirtualMachineConfigOption;
         };
         VirtualMachineConfigOptionDescriptor: {
            (options?: vimService.vim.VirtualMachineConfigOptionDescriptor): vimService.vim.VirtualMachineConfigOptionDescriptor;
         };
         ArrayOfVirtualMachineConfigOptionDescriptor: {
            (options?: vimService.vim.ArrayOfVirtualMachineConfigOptionDescriptor): vimService.vim.ArrayOfVirtualMachineConfigOptionDescriptor;
         };
         VirtualMachineConfigSpecNpivWwnOp: {
            "generate": string;
            "set": string;
            "remove": string;
            "extend": string;
         };
         VirtualMachineConfigSpecEncryptedVMotionModes: {
            "disabled": string;
            "opportunistic": string;
            "required": string;
         };
         VirtualMachineCpuIdInfoSpec: {
            (options?: vimService.vim.VirtualMachineCpuIdInfoSpec): vimService.vim.VirtualMachineCpuIdInfoSpec;
         };
         ArrayOfVirtualMachineCpuIdInfoSpec: {
            (options?: vimService.vim.ArrayOfVirtualMachineCpuIdInfoSpec): vimService.vim.ArrayOfVirtualMachineCpuIdInfoSpec;
         };
         VirtualMachineConfigSpec: {
            (options?: vimService.vim.VirtualMachineConfigSpec): vimService.vim.VirtualMachineConfigSpec;
         };
         ConfigTarget: {
            (options?: vimService.vim.ConfigTarget): vimService.vim.ConfigTarget;
         };
         VirtualMachineConsolePreferences: {
            (options?: vimService.vim.VirtualMachineConsolePreferences): vimService.vim.VirtualMachineConsolePreferences;
         };
         VirtualMachineDatastoreInfo: {
            (options?: vimService.vim.VirtualMachineDatastoreInfo): vimService.vim.VirtualMachineDatastoreInfo;
         };
         ArrayOfVirtualMachineDatastoreInfo: {
            (options?: vimService.vim.ArrayOfVirtualMachineDatastoreInfo): vimService.vim.ArrayOfVirtualMachineDatastoreInfo;
         };
         VirtualMachineDatastoreVolumeOption: {
            (options?: vimService.vim.VirtualMachineDatastoreVolumeOption): vimService.vim.VirtualMachineDatastoreVolumeOption;
         };
         ArrayOfVirtualMachineDatastoreVolumeOption: {
            (options?: vimService.vim.ArrayOfVirtualMachineDatastoreVolumeOption): vimService.vim.ArrayOfVirtualMachineDatastoreVolumeOption;
         };
         DatastoreOption: {
            (options?: vimService.vim.DatastoreOption): vimService.vim.DatastoreOption;
         };
         VirtualMachinePowerOpType: {
            "soft": string;
            "hard": string;
            "preset": string;
         };
         VirtualMachineStandbyActionType: {
            "checkpoint": string;
            "powerOnSuspend": string;
         };
         VirtualMachineDefaultPowerOpInfo: {
            (options?: vimService.vim.VirtualMachineDefaultPowerOpInfo): vimService.vim.VirtualMachineDefaultPowerOpInfo;
         };
         VirtualMachineDefaultProfileSpec: {
            (options?: vimService.vim.VirtualMachineDefaultProfileSpec): vimService.vim.VirtualMachineDefaultProfileSpec;
         };
         VirtualMachineDefinedProfileSpec: {
            (options?: vimService.vim.VirtualMachineDefinedProfileSpec): vimService.vim.VirtualMachineDefinedProfileSpec;
         };
         VirtualMachineDeviceRuntimeInfoDeviceRuntimeState: {
            (options?: vimService.vim.VirtualMachineDeviceRuntimeInfoDeviceRuntimeState): vimService.vim.VirtualMachineDeviceRuntimeInfoDeviceRuntimeState;
         };
         VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm: {
            "vmNptIncompatibleGuest": string;
            "vmNptIncompatibleGuestDriver": string;
            "vmNptIncompatibleAdapterType": string;
            "vmNptDisabledOrDisconnectedAdapter": string;
            "vmNptIncompatibleAdapterFeatures": string;
            "vmNptIncompatibleBackingType": string;
            "vmNptInsufficientMemoryReservation": string;
            "vmNptFaultToleranceOrRecordReplayConfigured": string;
            "vmNptConflictingIOChainConfigured": string;
            "vmNptMonitorBlocks": string;
            "vmNptConflictingOperationInProgress": string;
            "vmNptRuntimeError": string;
            "vmNptOutOfIntrVector": string;
            "vmNptVMCIActive": string;
         };
         VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOther: {
            "vmNptIncompatibleHost": string;
            "vmNptIncompatibleNetwork": string;
         };
         VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState: {
            (options?: vimService.vim.VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState): vimService.vim.VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState;
         };
         VirtualMachineDeviceRuntimeInfo: {
            (options?: vimService.vim.VirtualMachineDeviceRuntimeInfo): vimService.vim.VirtualMachineDeviceRuntimeInfo;
         };
         ArrayOfVirtualMachineDeviceRuntimeInfo: {
            (options?: vimService.vim.ArrayOfVirtualMachineDeviceRuntimeInfo): vimService.vim.ArrayOfVirtualMachineDeviceRuntimeInfo;
         };
         VirtualMachineDiskDeviceInfo: {
            (options?: vimService.vim.VirtualMachineDiskDeviceInfo): vimService.vim.VirtualMachineDiskDeviceInfo;
         };
         VirtualMachineEmptyProfileSpec: {
            (options?: vimService.vim.VirtualMachineEmptyProfileSpec): vimService.vim.VirtualMachineEmptyProfileSpec;
         };
         FaultToleranceConfigInfo: {
            (options?: vimService.vim.FaultToleranceConfigInfo): vimService.vim.FaultToleranceConfigInfo;
         };
         FaultTolerancePrimaryConfigInfo: {
            (options?: vimService.vim.FaultTolerancePrimaryConfigInfo): vimService.vim.FaultTolerancePrimaryConfigInfo;
         };
         FaultToleranceSecondaryConfigInfo: {
            (options?: vimService.vim.FaultToleranceSecondaryConfigInfo): vimService.vim.FaultToleranceSecondaryConfigInfo;
         };
         FaultToleranceConfigSpec: {
            (options?: vimService.vim.FaultToleranceConfigSpec): vimService.vim.FaultToleranceConfigSpec;
         };
         FaultToleranceMetaSpec: {
            (options?: vimService.vim.FaultToleranceMetaSpec): vimService.vim.FaultToleranceMetaSpec;
         };
         FaultToleranceSecondaryOpResult: {
            (options?: vimService.vim.FaultToleranceSecondaryOpResult): vimService.vim.FaultToleranceSecondaryOpResult;
         };
         FaultToleranceDiskSpec: {
            (options?: vimService.vim.FaultToleranceDiskSpec): vimService.vim.FaultToleranceDiskSpec;
         };
         ArrayOfFaultToleranceDiskSpec: {
            (options?: vimService.vim.ArrayOfFaultToleranceDiskSpec): vimService.vim.ArrayOfFaultToleranceDiskSpec;
         };
         FaultToleranceVMConfigSpec: {
            (options?: vimService.vim.FaultToleranceVMConfigSpec): vimService.vim.FaultToleranceVMConfigSpec;
         };
         VirtualMachineFeatureRequirement: {
            (options?: vimService.vim.VirtualMachineFeatureRequirement): vimService.vim.VirtualMachineFeatureRequirement;
         };
         ArrayOfVirtualMachineFeatureRequirement: {
            (options?: vimService.vim.ArrayOfVirtualMachineFeatureRequirement): vimService.vim.ArrayOfVirtualMachineFeatureRequirement;
         };
         VirtualMachineFileInfo: {
            (options?: vimService.vim.VirtualMachineFileInfo): vimService.vim.VirtualMachineFileInfo;
         };
         VirtualMachineFileLayoutDiskLayout: {
            (options?: vimService.vim.VirtualMachineFileLayoutDiskLayout): vimService.vim.VirtualMachineFileLayoutDiskLayout;
         };
         ArrayOfVirtualMachineFileLayoutDiskLayout: {
            (options?: vimService.vim.ArrayOfVirtualMachineFileLayoutDiskLayout): vimService.vim.ArrayOfVirtualMachineFileLayoutDiskLayout;
         };
         VirtualMachineFileLayoutSnapshotLayout: {
            (options?: vimService.vim.VirtualMachineFileLayoutSnapshotLayout): vimService.vim.VirtualMachineFileLayoutSnapshotLayout;
         };
         ArrayOfVirtualMachineFileLayoutSnapshotLayout: {
            (options?: vimService.vim.ArrayOfVirtualMachineFileLayoutSnapshotLayout): vimService.vim.ArrayOfVirtualMachineFileLayoutSnapshotLayout;
         };
         VirtualMachineFileLayout: {
            (options?: vimService.vim.VirtualMachineFileLayout): vimService.vim.VirtualMachineFileLayout;
         };
         VirtualMachineFileLayoutExFileType: {
            "config": string;
            "extendedConfig": string;
            "diskDescriptor": string;
            "diskExtent": string;
            "digestDescriptor": string;
            "digestExtent": string;
            "diskReplicationState": string;
            "log": string;
            "stat": string;
            "namespaceData": string;
            "nvram": string;
            "snapshotData": string;
            "snapshotMemory": string;
            "snapshotList": string;
            "snapshotManifestList": string;
            "suspend": string;
            "suspendMemory": string;
            "swap": string;
            "uwswap": string;
            "core": string;
            "screenshot": string;
            "ftMetadata": string;
            "guestCustomization": string;
         };
         VirtualMachineFileLayoutExFileInfo: {
            (options?: vimService.vim.VirtualMachineFileLayoutExFileInfo): vimService.vim.VirtualMachineFileLayoutExFileInfo;
         };
         ArrayOfVirtualMachineFileLayoutExFileInfo: {
            (options?: vimService.vim.ArrayOfVirtualMachineFileLayoutExFileInfo): vimService.vim.ArrayOfVirtualMachineFileLayoutExFileInfo;
         };
         VirtualMachineFileLayoutExDiskUnit: {
            (options?: vimService.vim.VirtualMachineFileLayoutExDiskUnit): vimService.vim.VirtualMachineFileLayoutExDiskUnit;
         };
         ArrayOfVirtualMachineFileLayoutExDiskUnit: {
            (options?: vimService.vim.ArrayOfVirtualMachineFileLayoutExDiskUnit): vimService.vim.ArrayOfVirtualMachineFileLayoutExDiskUnit;
         };
         VirtualMachineFileLayoutExDiskLayout: {
            (options?: vimService.vim.VirtualMachineFileLayoutExDiskLayout): vimService.vim.VirtualMachineFileLayoutExDiskLayout;
         };
         ArrayOfVirtualMachineFileLayoutExDiskLayout: {
            (options?: vimService.vim.ArrayOfVirtualMachineFileLayoutExDiskLayout): vimService.vim.ArrayOfVirtualMachineFileLayoutExDiskLayout;
         };
         VirtualMachineFileLayoutExSnapshotLayout: {
            (options?: vimService.vim.VirtualMachineFileLayoutExSnapshotLayout): vimService.vim.VirtualMachineFileLayoutExSnapshotLayout;
         };
         ArrayOfVirtualMachineFileLayoutExSnapshotLayout: {
            (options?: vimService.vim.ArrayOfVirtualMachineFileLayoutExSnapshotLayout): vimService.vim.ArrayOfVirtualMachineFileLayoutExSnapshotLayout;
         };
         VirtualMachineFileLayoutEx: {
            (options?: vimService.vim.VirtualMachineFileLayoutEx): vimService.vim.VirtualMachineFileLayoutEx;
         };
         VirtualMachineHtSharing: {
            "any": string;
            "none": string;
            "internal": string;
         };
         VirtualMachinePowerOffBehavior: {
            "powerOff": string;
            "revert": string;
            "prompt": string;
            "take": string;
         };
         VirtualMachineFlagInfoMonitorType: {
            "release": string;
            "debug": string;
            "stats": string;
         };
         VirtualMachineFlagInfoVirtualMmuUsage: {
            "automatic": string;
            "on": string;
            "off": string;
         };
         VirtualMachineFlagInfoVirtualExecUsage: {
            "hvAuto": string;
            "hvOn": string;
            "hvOff": string;
         };
         VirtualMachineFlagInfo: {
            (options?: vimService.vim.VirtualMachineFlagInfo): vimService.vim.VirtualMachineFlagInfo;
         };
         VirtualMachineFloppyInfo: {
            (options?: vimService.vim.VirtualMachineFloppyInfo): vimService.vim.VirtualMachineFloppyInfo;
         };
         ArrayOfVirtualMachineFloppyInfo: {
            (options?: vimService.vim.ArrayOfVirtualMachineFloppyInfo): vimService.vim.ArrayOfVirtualMachineFloppyInfo;
         };
         VirtualMachineForkConfigInfoChildType: {
            "none": string;
            "persistent": string;
            "nonpersistent": string;
         };
         VirtualMachineForkConfigInfo: {
            (options?: vimService.vim.VirtualMachineForkConfigInfo): vimService.vim.VirtualMachineForkConfigInfo;
         };
         VirtualMachineToolsStatus: {
            "toolsNotInstalled": string;
            "toolsNotRunning": string;
            "toolsOld": string;
            "toolsOk": string;
         };
         VirtualMachineToolsVersionStatus: {
            "guestToolsNotInstalled": string;
            "guestToolsNeedUpgrade": string;
            "guestToolsCurrent": string;
            "guestToolsUnmanaged": string;
            "guestToolsTooOld": string;
            "guestToolsSupportedOld": string;
            "guestToolsSupportedNew": string;
            "guestToolsTooNew": string;
            "guestToolsBlacklisted": string;
         };
         VirtualMachineToolsRunningStatus: {
            "guestToolsNotRunning": string;
            "guestToolsRunning": string;
            "guestToolsExecutingScripts": string;
         };
         VirtualMachineToolsInstallType: {
            "guestToolsTypeUnknown": string;
            "guestToolsTypeMSI": string;
            "guestToolsTypeTar": string;
            "guestToolsTypeOSP": string;
            "guestToolsTypeOpenVMTools": string;
         };
         GuestDiskInfo: {
            (options?: vimService.vim.GuestDiskInfo): vimService.vim.GuestDiskInfo;
         };
         ArrayOfGuestDiskInfo: {
            (options?: vimService.vim.ArrayOfGuestDiskInfo): vimService.vim.ArrayOfGuestDiskInfo;
         };
         GuestNicInfo: {
            (options?: vimService.vim.GuestNicInfo): vimService.vim.GuestNicInfo;
         };
         ArrayOfGuestNicInfo: {
            (options?: vimService.vim.ArrayOfGuestNicInfo): vimService.vim.ArrayOfGuestNicInfo;
         };
         GuestStackInfo: {
            (options?: vimService.vim.GuestStackInfo): vimService.vim.GuestStackInfo;
         };
         ArrayOfGuestStackInfo: {
            (options?: vimService.vim.ArrayOfGuestStackInfo): vimService.vim.ArrayOfGuestStackInfo;
         };
         GuestScreenInfo: {
            (options?: vimService.vim.GuestScreenInfo): vimService.vim.GuestScreenInfo;
         };
         VirtualMachineGuestState: {
            "running": string;
            "shuttingDown": string;
            "resetting": string;
            "standby": string;
            "notRunning": string;
            "unknown": string;
         };
         GuestInfoAppStateType: {
            "none": string;
            "appStateOk": string;
            "appStateNeedReset": string;
         };
         GuestInfoNamespaceGenerationInfo: {
            (options?: vimService.vim.GuestInfoNamespaceGenerationInfo): vimService.vim.GuestInfoNamespaceGenerationInfo;
         };
         ArrayOfGuestInfoNamespaceGenerationInfo: {
            (options?: vimService.vim.ArrayOfGuestInfoNamespaceGenerationInfo): vimService.vim.ArrayOfGuestInfoNamespaceGenerationInfo;
         };
         GuestInfo: {
            (options?: vimService.vim.GuestInfo): vimService.vim.GuestInfo;
         };
         VirtualMachineGuestIntegrityInfo: {
            (options?: vimService.vim.VirtualMachineGuestIntegrityInfo): vimService.vim.VirtualMachineGuestIntegrityInfo;
         };
         VirtualMachineGuestOsFamily: {
            "windowsGuest": string;
            "linuxGuest": string;
            "netwareGuest": string;
            "solarisGuest": string;
            "darwinGuestFamily": string;
            "otherGuestFamily": string;
         };
         VirtualMachineGuestOsIdentifier: {
            "dosGuest": string;
            "win31Guest": string;
            "win95Guest": string;
            "win98Guest": string;
            "winMeGuest": string;
            "winNTGuest": string;
            "win2000ProGuest": string;
            "win2000ServGuest": string;
            "win2000AdvServGuest": string;
            "winXPHomeGuest": string;
            "winXPProGuest": string;
            "winXPPro64Guest": string;
            "winNetWebGuest": string;
            "winNetStandardGuest": string;
            "winNetEnterpriseGuest": string;
            "winNetDatacenterGuest": string;
            "winNetBusinessGuest": string;
            "winNetStandard64Guest": string;
            "winNetEnterprise64Guest": string;
            "winLonghornGuest": string;
            "winLonghorn64Guest": string;
            "winNetDatacenter64Guest": string;
            "winVistaGuest": string;
            "winVista64Guest": string;
            "windows7Guest": string;
            "windows7_64Guest": string;
            "windows7Server64Guest": string;
            "windows8Guest": string;
            "windows8_64Guest": string;
            "windows8Server64Guest": string;
            "windows9Guest": string;
            "windows9_64Guest": string;
            "windows9Server64Guest": string;
            "windowsHyperVGuest": string;
            "freebsdGuest": string;
            "freebsd64Guest": string;
            "redhatGuest": string;
            "rhel2Guest": string;
            "rhel3Guest": string;
            "rhel3_64Guest": string;
            "rhel4Guest": string;
            "rhel4_64Guest": string;
            "rhel5Guest": string;
            "rhel5_64Guest": string;
            "rhel6Guest": string;
            "rhel6_64Guest": string;
            "rhel7Guest": string;
            "rhel7_64Guest": string;
            "centosGuest": string;
            "centos64Guest": string;
            "centos6Guest": string;
            "centos6_64Guest": string;
            "centos7Guest": string;
            "centos7_64Guest": string;
            "oracleLinuxGuest": string;
            "oracleLinux64Guest": string;
            "oracleLinux6Guest": string;
            "oracleLinux6_64Guest": string;
            "oracleLinux7Guest": string;
            "oracleLinux7_64Guest": string;
            "suseGuest": string;
            "suse64Guest": string;
            "slesGuest": string;
            "sles64Guest": string;
            "sles10Guest": string;
            "sles10_64Guest": string;
            "sles11Guest": string;
            "sles11_64Guest": string;
            "sles12Guest": string;
            "sles12_64Guest": string;
            "nld9Guest": string;
            "oesGuest": string;
            "sjdsGuest": string;
            "mandrakeGuest": string;
            "mandrivaGuest": string;
            "mandriva64Guest": string;
            "turboLinuxGuest": string;
            "turboLinux64Guest": string;
            "ubuntuGuest": string;
            "ubuntu64Guest": string;
            "debian4Guest": string;
            "debian4_64Guest": string;
            "debian5Guest": string;
            "debian5_64Guest": string;
            "debian6Guest": string;
            "debian6_64Guest": string;
            "debian7Guest": string;
            "debian7_64Guest": string;
            "debian8Guest": string;
            "debian8_64Guest": string;
            "debian9Guest": string;
            "debian9_64Guest": string;
            "debian10Guest": string;
            "debian10_64Guest": string;
            "asianux3Guest": string;
            "asianux3_64Guest": string;
            "asianux4Guest": string;
            "asianux4_64Guest": string;
            "asianux5_64Guest": string;
            "asianux7_64Guest": string;
            "opensuseGuest": string;
            "opensuse64Guest": string;
            "fedoraGuest": string;
            "fedora64Guest": string;
            "coreos64Guest": string;
            "vmwarePhoton64Guest": string;
            "other24xLinuxGuest": string;
            "other26xLinuxGuest": string;
            "otherLinuxGuest": string;
            "other3xLinuxGuest": string;
            "genericLinuxGuest": string;
            "other24xLinux64Guest": string;
            "other26xLinux64Guest": string;
            "other3xLinux64Guest": string;
            "otherLinux64Guest": string;
            "solaris6Guest": string;
            "solaris7Guest": string;
            "solaris8Guest": string;
            "solaris9Guest": string;
            "solaris10Guest": string;
            "solaris10_64Guest": string;
            "solaris11_64Guest": string;
            "os2Guest": string;
            "eComStationGuest": string;
            "eComStation2Guest": string;
            "netware4Guest": string;
            "netware5Guest": string;
            "netware6Guest": string;
            "openServer5Guest": string;
            "openServer6Guest": string;
            "unixWare7Guest": string;
            "darwinGuest": string;
            "darwin64Guest": string;
            "darwin10Guest": string;
            "darwin10_64Guest": string;
            "darwin11Guest": string;
            "darwin11_64Guest": string;
            "darwin12_64Guest": string;
            "darwin13_64Guest": string;
            "darwin14_64Guest": string;
            "darwin15_64Guest": string;
            "darwin16_64Guest": string;
            "vmkernelGuest": string;
            "vmkernel5Guest": string;
            "vmkernel6Guest": string;
            "vmkernel65Guest": string;
            "otherGuest": string;
            "otherGuest64": string;
         };
         GuestOsDescriptorFirmwareType: {
            "bios": string;
            "efi": string;
         };
         GuestOsDescriptorSupportLevel: {
            "experimental": string;
            "legacy": string;
            "terminated": string;
            "supported": string;
            "unsupported": string;
            "deprecated": string;
            "techPreview": string;
         };
         GuestOsDescriptor: {
            (options?: vimService.vim.GuestOsDescriptor): vimService.vim.GuestOsDescriptor;
         };
         ArrayOfGuestOsDescriptor: {
            (options?: vimService.vim.ArrayOfGuestOsDescriptor): vimService.vim.ArrayOfGuestOsDescriptor;
         };
         VirtualMachineGuestQuiesceSpec: {
            (options?: vimService.vim.VirtualMachineGuestQuiesceSpec): vimService.vim.VirtualMachineGuestQuiesceSpec;
         };
         VirtualMachineIdeDiskDevicePartitionInfo: {
            (options?: vimService.vim.VirtualMachineIdeDiskDevicePartitionInfo): vimService.vim.VirtualMachineIdeDiskDevicePartitionInfo;
         };
         ArrayOfVirtualMachineIdeDiskDevicePartitionInfo: {
            (options?: vimService.vim.ArrayOfVirtualMachineIdeDiskDevicePartitionInfo): vimService.vim.ArrayOfVirtualMachineIdeDiskDevicePartitionInfo;
         };
         VirtualMachineIdeDiskDeviceInfo: {
            (options?: vimService.vim.VirtualMachineIdeDiskDeviceInfo): vimService.vim.VirtualMachineIdeDiskDeviceInfo;
         };
         ArrayOfVirtualMachineIdeDiskDeviceInfo: {
            (options?: vimService.vim.ArrayOfVirtualMachineIdeDiskDeviceInfo): vimService.vim.ArrayOfVirtualMachineIdeDiskDeviceInfo;
         };
         VirtualMachineLegacyNetworkSwitchInfo: {
            (options?: vimService.vim.VirtualMachineLegacyNetworkSwitchInfo): vimService.vim.VirtualMachineLegacyNetworkSwitchInfo;
         };
         ArrayOfVirtualMachineLegacyNetworkSwitchInfo: {
            (options?: vimService.vim.ArrayOfVirtualMachineLegacyNetworkSwitchInfo): vimService.vim.ArrayOfVirtualMachineLegacyNetworkSwitchInfo;
         };
         VirtualMachineMessage: {
            (options?: vimService.vim.VirtualMachineMessage): vimService.vim.VirtualMachineMessage;
         };
         ArrayOfVirtualMachineMessage: {
            (options?: vimService.vim.ArrayOfVirtualMachineMessage): vimService.vim.ArrayOfVirtualMachineMessage;
         };
         VirtualMachineMetadataManagerVmMetadataOwnerOwner: {
            "ComVmwareVsphereHA": string;
         };
         VirtualMachineMetadataManagerVmMetadataOwner: {
            (options?: vimService.vim.VirtualMachineMetadataManagerVmMetadataOwner): vimService.vim.VirtualMachineMetadataManagerVmMetadataOwner;
         };
         VirtualMachineMetadataManagerVmMetadataOp: {
            "Update": string;
            "Remove": string;
         };
         VirtualMachineMetadataManagerVmMetadata: {
            (options?: vimService.vim.VirtualMachineMetadataManagerVmMetadata): vimService.vim.VirtualMachineMetadataManagerVmMetadata;
         };
         VirtualMachineMetadataManagerVmMetadataInput: {
            (options?: vimService.vim.VirtualMachineMetadataManagerVmMetadataInput): vimService.vim.VirtualMachineMetadataManagerVmMetadataInput;
         };
         ArrayOfVirtualMachineMetadataManagerVmMetadataInput: {
            (options?: vimService.vim.ArrayOfVirtualMachineMetadataManagerVmMetadataInput): vimService.vim.ArrayOfVirtualMachineMetadataManagerVmMetadataInput;
         };
         VirtualMachineMetadataManagerVmMetadataResult: {
            (options?: vimService.vim.VirtualMachineMetadataManagerVmMetadataResult): vimService.vim.VirtualMachineMetadataManagerVmMetadataResult;
         };
         ArrayOfVirtualMachineMetadataManagerVmMetadataResult: {
            (options?: vimService.vim.ArrayOfVirtualMachineMetadataManagerVmMetadataResult): vimService.vim.ArrayOfVirtualMachineMetadataManagerVmMetadataResult;
         };
         VirtualMachineNetworkInfo: {
            (options?: vimService.vim.VirtualMachineNetworkInfo): vimService.vim.VirtualMachineNetworkInfo;
         };
         ArrayOfVirtualMachineNetworkInfo: {
            (options?: vimService.vim.ArrayOfVirtualMachineNetworkInfo): vimService.vim.ArrayOfVirtualMachineNetworkInfo;
         };
         VirtualMachineNetworkShaperInfo: {
            (options?: vimService.vim.VirtualMachineNetworkShaperInfo): vimService.vim.VirtualMachineNetworkShaperInfo;
         };
         OpaqueNetworkTargetInfo: {
            (options?: vimService.vim.OpaqueNetworkTargetInfo): vimService.vim.OpaqueNetworkTargetInfo;
         };
         ArrayOfOpaqueNetworkTargetInfo: {
            (options?: vimService.vim.ArrayOfOpaqueNetworkTargetInfo): vimService.vim.ArrayOfOpaqueNetworkTargetInfo;
         };
         VirtualMachineParallelInfo: {
            (options?: vimService.vim.VirtualMachineParallelInfo): vimService.vim.VirtualMachineParallelInfo;
         };
         ArrayOfVirtualMachineParallelInfo: {
            (options?: vimService.vim.ArrayOfVirtualMachineParallelInfo): vimService.vim.ArrayOfVirtualMachineParallelInfo;
         };
         VirtualMachinePciPassthroughInfo: {
            (options?: vimService.vim.VirtualMachinePciPassthroughInfo): vimService.vim.VirtualMachinePciPassthroughInfo;
         };
         ArrayOfVirtualMachinePciPassthroughInfo: {
            (options?: vimService.vim.ArrayOfVirtualMachinePciPassthroughInfo): vimService.vim.ArrayOfVirtualMachinePciPassthroughInfo;
         };
         VirtualMachinePciSharedGpuPassthroughInfo: {
            (options?: vimService.vim.VirtualMachinePciSharedGpuPassthroughInfo): vimService.vim.VirtualMachinePciSharedGpuPassthroughInfo;
         };
         ArrayOfVirtualMachinePciSharedGpuPassthroughInfo: {
            (options?: vimService.vim.ArrayOfVirtualMachinePciSharedGpuPassthroughInfo): vimService.vim.ArrayOfVirtualMachinePciSharedGpuPassthroughInfo;
         };
         VirtualMachineProfileRawData: {
            (options?: vimService.vim.VirtualMachineProfileRawData): vimService.vim.VirtualMachineProfileRawData;
         };
         VirtualMachineProfileSpec: {
            (options?: vimService.vim.VirtualMachineProfileSpec): vimService.vim.VirtualMachineProfileSpec;
         };
         ArrayOfVirtualMachineProfileSpec: {
            (options?: vimService.vim.ArrayOfVirtualMachineProfileSpec): vimService.vim.ArrayOfVirtualMachineProfileSpec;
         };
         VirtualMachineQuestionInfo: {
            (options?: vimService.vim.VirtualMachineQuestionInfo): vimService.vim.VirtualMachineQuestionInfo;
         };
         VirtualMachineRelocateTransformation: {
            "flat": string;
            "sparse": string;
         };
         VirtualMachineRelocateSpecDiskLocator: {
            (options?: vimService.vim.VirtualMachineRelocateSpecDiskLocator): vimService.vim.VirtualMachineRelocateSpecDiskLocator;
         };
         ArrayOfVirtualMachineRelocateSpecDiskLocator: {
            (options?: vimService.vim.ArrayOfVirtualMachineRelocateSpecDiskLocator): vimService.vim.ArrayOfVirtualMachineRelocateSpecDiskLocator;
         };
         VirtualMachineRelocateDiskMoveOptions: {
            "moveAllDiskBackingsAndAllowSharing": string;
            "moveAllDiskBackingsAndDisallowSharing": string;
            "moveChildMostDiskBacking": string;
            "createNewChildDiskBacking": string;
            "moveAllDiskBackingsAndConsolidate": string;
         };
         VirtualMachineRelocateSpec: {
            (options?: vimService.vim.VirtualMachineRelocateSpec): vimService.vim.VirtualMachineRelocateSpec;
         };
         ReplicationInfoDiskSettings: {
            (options?: vimService.vim.ReplicationInfoDiskSettings): vimService.vim.ReplicationInfoDiskSettings;
         };
         ArrayOfReplicationInfoDiskSettings: {
            (options?: vimService.vim.ArrayOfReplicationInfoDiskSettings): vimService.vim.ArrayOfReplicationInfoDiskSettings;
         };
         ReplicationConfigSpec: {
            (options?: vimService.vim.ReplicationConfigSpec): vimService.vim.ReplicationConfigSpec;
         };
         VirtualMachineRuntimeInfoDasProtectionState: {
            (options?: vimService.vim.VirtualMachineRuntimeInfoDasProtectionState): vimService.vim.VirtualMachineRuntimeInfoDasProtectionState;
         };
         VirtualMachineRuntimeInfo: {
            (options?: vimService.vim.VirtualMachineRuntimeInfo): vimService.vim.VirtualMachineRuntimeInfo;
         };
         ScheduledHardwareUpgradeInfoHardwareUpgradePolicy: {
            "never": string;
            "onSoftPowerOff": string;
            "always": string;
         };
         ScheduledHardwareUpgradeInfoHardwareUpgradeStatus: {
            "none": string;
            "pending": string;
            "success": string;
            "failed": string;
         };
         ScheduledHardwareUpgradeInfo: {
            (options?: vimService.vim.ScheduledHardwareUpgradeInfo): vimService.vim.ScheduledHardwareUpgradeInfo;
         };
         VirtualMachineScsiDiskDeviceInfo: {
            (options?: vimService.vim.VirtualMachineScsiDiskDeviceInfo): vimService.vim.VirtualMachineScsiDiskDeviceInfo;
         };
         ArrayOfVirtualMachineScsiDiskDeviceInfo: {
            (options?: vimService.vim.ArrayOfVirtualMachineScsiDiskDeviceInfo): vimService.vim.ArrayOfVirtualMachineScsiDiskDeviceInfo;
         };
         VirtualMachineScsiPassthroughType: {
            "disk": string;
            "tape": string;
            "printer": string;
            "processor": string;
            "worm": string;
            "cdrom": string;
            "scanner": string;
            "optical": string;
            "media": string;
            "com": string;
            "raid": string;
            "unknown": string;
         };
         VirtualMachineScsiPassthroughInfo: {
            (options?: vimService.vim.VirtualMachineScsiPassthroughInfo): vimService.vim.VirtualMachineScsiPassthroughInfo;
         };
         ArrayOfVirtualMachineScsiPassthroughInfo: {
            (options?: vimService.vim.ArrayOfVirtualMachineScsiPassthroughInfo): vimService.vim.ArrayOfVirtualMachineScsiPassthroughInfo;
         };
         VirtualMachineSerialInfo: {
            (options?: vimService.vim.VirtualMachineSerialInfo): vimService.vim.VirtualMachineSerialInfo;
         };
         ArrayOfVirtualMachineSerialInfo: {
            (options?: vimService.vim.ArrayOfVirtualMachineSerialInfo): vimService.vim.ArrayOfVirtualMachineSerialInfo;
         };
         VirtualMachineSnapshotInfo: {
            (options?: vimService.vim.VirtualMachineSnapshotInfo): vimService.vim.VirtualMachineSnapshotInfo;
         };
         VirtualMachineSnapshotTree: {
            (options?: vimService.vim.VirtualMachineSnapshotTree): vimService.vim.VirtualMachineSnapshotTree;
         };
         ArrayOfVirtualMachineSnapshotTree: {
            (options?: vimService.vim.ArrayOfVirtualMachineSnapshotTree): vimService.vim.ArrayOfVirtualMachineSnapshotTree;
         };
         VirtualMachineSoundInfo: {
            (options?: vimService.vim.VirtualMachineSoundInfo): vimService.vim.VirtualMachineSoundInfo;
         };
         ArrayOfVirtualMachineSoundInfo: {
            (options?: vimService.vim.ArrayOfVirtualMachineSoundInfo): vimService.vim.ArrayOfVirtualMachineSoundInfo;
         };
         VirtualMachineSriovDevicePoolInfo: {
            (options?: vimService.vim.VirtualMachineSriovDevicePoolInfo): vimService.vim.VirtualMachineSriovDevicePoolInfo;
         };
         VirtualMachineSriovInfo: {
            (options?: vimService.vim.VirtualMachineSriovInfo): vimService.vim.VirtualMachineSriovInfo;
         };
         ArrayOfVirtualMachineSriovInfo: {
            (options?: vimService.vim.ArrayOfVirtualMachineSriovInfo): vimService.vim.ArrayOfVirtualMachineSriovInfo;
         };
         VirtualMachineSriovNetworkDevicePoolInfo: {
            (options?: vimService.vim.VirtualMachineSriovNetworkDevicePoolInfo): vimService.vim.VirtualMachineSriovNetworkDevicePoolInfo;
         };
         VirtualMachineUsageOnDatastore: {
            (options?: vimService.vim.VirtualMachineUsageOnDatastore): vimService.vim.VirtualMachineUsageOnDatastore;
         };
         ArrayOfVirtualMachineUsageOnDatastore: {
            (options?: vimService.vim.ArrayOfVirtualMachineUsageOnDatastore): vimService.vim.ArrayOfVirtualMachineUsageOnDatastore;
         };
         VirtualMachineStorageInfo: {
            (options?: vimService.vim.VirtualMachineStorageInfo): vimService.vim.VirtualMachineStorageInfo;
         };
         VirtualMachineConfigSummary: {
            (options?: vimService.vim.VirtualMachineConfigSummary): vimService.vim.VirtualMachineConfigSummary;
         };
         VirtualMachineQuickStats: {
            (options?: vimService.vim.VirtualMachineQuickStats): vimService.vim.VirtualMachineQuickStats;
         };
         VirtualMachineGuestSummary: {
            (options?: vimService.vim.VirtualMachineGuestSummary): vimService.vim.VirtualMachineGuestSummary;
         };
         VirtualMachineStorageSummary: {
            (options?: vimService.vim.VirtualMachineStorageSummary): vimService.vim.VirtualMachineStorageSummary;
         };
         VirtualMachineSummary: {
            (options?: vimService.vim.VirtualMachineSummary): vimService.vim.VirtualMachineSummary;
         };
         ArrayOfVirtualMachineSummary: {
            (options?: vimService.vim.ArrayOfVirtualMachineSummary): vimService.vim.ArrayOfVirtualMachineSummary;
         };
         VirtualMachineTargetInfoConfigurationTag: {
            "compliant": string;
            "clusterWide": string;
         };
         VirtualMachineTargetInfo: {
            (options?: vimService.vim.VirtualMachineTargetInfo): vimService.vim.VirtualMachineTargetInfo;
         };
         UpgradePolicy: {
            "manual": string;
            "upgradeAtPowerCycle": string;
         };
         ToolsConfigInfoToolsLastInstallInfo: {
            (options?: vimService.vim.ToolsConfigInfoToolsLastInstallInfo): vimService.vim.ToolsConfigInfoToolsLastInstallInfo;
         };
         ToolsConfigInfo: {
            (options?: vimService.vim.ToolsConfigInfo): vimService.vim.ToolsConfigInfo;
         };
         VirtualMachineUsbInfoSpeed: {
            "low": string;
            "full": string;
            "high": string;
            "superSpeed": string;
            "unknownSpeed": string;
         };
         VirtualMachineUsbInfoFamily: {
            "audio": string;
            "hid": string;
            "hid_bootable": string;
            "physical": string;
            "communication": string;
            "imaging": string;
            "printer": string;
            "storage": string;
            "hub": string;
            "smart_card": string;
            "security": string;
            "video": string;
            "wireless": string;
            "bluetooth": string;
            "wusb": string;
            "pda": string;
            "vendor_specific": string;
            "other": string;
            "unknownFamily": string;
         };
         VirtualMachineUsbInfo: {
            (options?: vimService.vim.VirtualMachineUsbInfo): vimService.vim.VirtualMachineUsbInfo;
         };
         ArrayOfVirtualMachineUsbInfo: {
            (options?: vimService.vim.ArrayOfVirtualMachineUsbInfo): vimService.vim.ArrayOfVirtualMachineUsbInfo;
         };
         UsbScanCodeSpecModifierType: {
            (options?: vimService.vim.UsbScanCodeSpecModifierType): vimService.vim.UsbScanCodeSpecModifierType;
         };
         UsbScanCodeSpecKeyEvent: {
            (options?: vimService.vim.UsbScanCodeSpecKeyEvent): vimService.vim.UsbScanCodeSpecKeyEvent;
         };
         ArrayOfUsbScanCodeSpecKeyEvent: {
            (options?: vimService.vim.ArrayOfUsbScanCodeSpecKeyEvent): vimService.vim.ArrayOfUsbScanCodeSpecKeyEvent;
         };
         UsbScanCodeSpec: {
            (options?: vimService.vim.UsbScanCodeSpec): vimService.vim.UsbScanCodeSpec;
         };
         VirtualMachineVFlashModuleInfo: {
            (options?: vimService.vim.VirtualMachineVFlashModuleInfo): vimService.vim.VirtualMachineVFlashModuleInfo;
         };
         ArrayOfVirtualMachineVFlashModuleInfo: {
            (options?: vimService.vim.ArrayOfVirtualMachineVFlashModuleInfo): vimService.vim.ArrayOfVirtualMachineVFlashModuleInfo;
         };
         VirtualHardware: {
            (options?: vimService.vim.VirtualHardware): vimService.vim.VirtualHardware;
         };
         VirtualHardwareOption: {
            (options?: vimService.vim.VirtualHardwareOption): vimService.vim.VirtualHardwareOption;
         };
         VirtualMachineImportSpec: {
            (options?: vimService.vim.VirtualMachineImportSpec): vimService.vim.VirtualMachineImportSpec;
         };
         VirtualMachineWindowsQuiesceSpecVssBackupContext: {
            "ctx_auto": string;
            "ctx_backup": string;
            "ctx_file_share_backup": string;
         };
         VirtualMachineWindowsQuiesceSpec: {
            (options?: vimService.vim.VirtualMachineWindowsQuiesceSpec): vimService.vim.VirtualMachineWindowsQuiesceSpec;
         };
         CheckResult: {
            (options?: vimService.vim.CheckResult): vimService.vim.CheckResult;
         };
         ArrayOfCheckResult: {
            (options?: vimService.vim.ArrayOfCheckResult): vimService.vim.ArrayOfCheckResult;
         };
         CheckTestType: {
            "sourceTests": string;
            "hostTests": string;
            "resourcePoolTests": string;
            "datastoreTests": string;
            "networkTests": string;
         };
         CustomizationIPSettingsIpV6AddressSpec: {
            (options?: vimService.vim.CustomizationIPSettingsIpV6AddressSpec): vimService.vim.CustomizationIPSettingsIpV6AddressSpec;
         };
         CustomizationNetBIOSMode: {
            "enableNetBIOSViaDhcp": string;
            "enableNetBIOS": string;
            "disableNetBIOS": string;
         };
         CustomizationIPSettings: {
            (options?: vimService.vim.CustomizationIPSettings): vimService.vim.CustomizationIPSettings;
         };
         CustomizationSpec: {
            (options?: vimService.vim.CustomizationSpec): vimService.vim.CustomizationSpec;
         };
         CustomizationName: {
            (options?: vimService.vim.CustomizationName): vimService.vim.CustomizationName;
         };
         CustomizationFixedName: {
            (options?: vimService.vim.CustomizationFixedName): vimService.vim.CustomizationFixedName;
         };
         CustomizationPrefixName: {
            (options?: vimService.vim.CustomizationPrefixName): vimService.vim.CustomizationPrefixName;
         };
         CustomizationVirtualMachineName: {
            (options?: vimService.vim.CustomizationVirtualMachineName): vimService.vim.CustomizationVirtualMachineName;
         };
         CustomizationUnknownName: {
            (options?: vimService.vim.CustomizationUnknownName): vimService.vim.CustomizationUnknownName;
         };
         CustomizationCustomName: {
            (options?: vimService.vim.CustomizationCustomName): vimService.vim.CustomizationCustomName;
         };
         CustomizationPassword: {
            (options?: vimService.vim.CustomizationPassword): vimService.vim.CustomizationPassword;
         };
         CustomizationOptions: {
            (options?: vimService.vim.CustomizationOptions): vimService.vim.CustomizationOptions;
         };
         CustomizationSysprepRebootOption: {
            "reboot": string;
            "noreboot": string;
            "shutdown": string;
         };
         CustomizationWinOptions: {
            (options?: vimService.vim.CustomizationWinOptions): vimService.vim.CustomizationWinOptions;
         };
         CustomizationLinuxOptions: {
            (options?: vimService.vim.CustomizationLinuxOptions): vimService.vim.CustomizationLinuxOptions;
         };
         CustomizationGuiUnattended: {
            (options?: vimService.vim.CustomizationGuiUnattended): vimService.vim.CustomizationGuiUnattended;
         };
         CustomizationUserData: {
            (options?: vimService.vim.CustomizationUserData): vimService.vim.CustomizationUserData;
         };
         CustomizationGuiRunOnce: {
            (options?: vimService.vim.CustomizationGuiRunOnce): vimService.vim.CustomizationGuiRunOnce;
         };
         CustomizationIdentification: {
            (options?: vimService.vim.CustomizationIdentification): vimService.vim.CustomizationIdentification;
         };
         CustomizationLicenseDataMode: {
            "perServer": string;
            "perSeat": string;
         };
         CustomizationLicenseFilePrintData: {
            (options?: vimService.vim.CustomizationLicenseFilePrintData): vimService.vim.CustomizationLicenseFilePrintData;
         };
         CustomizationIdentitySettings: {
            (options?: vimService.vim.CustomizationIdentitySettings): vimService.vim.CustomizationIdentitySettings;
         };
         CustomizationSysprepText: {
            (options?: vimService.vim.CustomizationSysprepText): vimService.vim.CustomizationSysprepText;
         };
         CustomizationSysprep: {
            (options?: vimService.vim.CustomizationSysprep): vimService.vim.CustomizationSysprep;
         };
         CustomizationLinuxPrep: {
            (options?: vimService.vim.CustomizationLinuxPrep): vimService.vim.CustomizationLinuxPrep;
         };
         CustomizationGlobalIPSettings: {
            (options?: vimService.vim.CustomizationGlobalIPSettings): vimService.vim.CustomizationGlobalIPSettings;
         };
         CustomizationIpGenerator: {
            (options?: vimService.vim.CustomizationIpGenerator): vimService.vim.CustomizationIpGenerator;
         };
         CustomizationDhcpIpGenerator: {
            (options?: vimService.vim.CustomizationDhcpIpGenerator): vimService.vim.CustomizationDhcpIpGenerator;
         };
         CustomizationFixedIp: {
            (options?: vimService.vim.CustomizationFixedIp): vimService.vim.CustomizationFixedIp;
         };
         CustomizationUnknownIpGenerator: {
            (options?: vimService.vim.CustomizationUnknownIpGenerator): vimService.vim.CustomizationUnknownIpGenerator;
         };
         CustomizationCustomIpGenerator: {
            (options?: vimService.vim.CustomizationCustomIpGenerator): vimService.vim.CustomizationCustomIpGenerator;
         };
         CustomizationIpV6Generator: {
            (options?: vimService.vim.CustomizationIpV6Generator): vimService.vim.CustomizationIpV6Generator;
         };
         ArrayOfCustomizationIpV6Generator: {
            (options?: vimService.vim.ArrayOfCustomizationIpV6Generator): vimService.vim.ArrayOfCustomizationIpV6Generator;
         };
         CustomizationDhcpIpV6Generator: {
            (options?: vimService.vim.CustomizationDhcpIpV6Generator): vimService.vim.CustomizationDhcpIpV6Generator;
         };
         CustomizationStatelessIpV6Generator: {
            (options?: vimService.vim.CustomizationStatelessIpV6Generator): vimService.vim.CustomizationStatelessIpV6Generator;
         };
         CustomizationFixedIpV6: {
            (options?: vimService.vim.CustomizationFixedIpV6): vimService.vim.CustomizationFixedIpV6;
         };
         CustomizationAutoIpV6Generator: {
            (options?: vimService.vim.CustomizationAutoIpV6Generator): vimService.vim.CustomizationAutoIpV6Generator;
         };
         CustomizationUnknownIpV6Generator: {
            (options?: vimService.vim.CustomizationUnknownIpV6Generator): vimService.vim.CustomizationUnknownIpV6Generator;
         };
         CustomizationCustomIpV6Generator: {
            (options?: vimService.vim.CustomizationCustomIpV6Generator): vimService.vim.CustomizationCustomIpV6Generator;
         };
         CustomizationAdapterMapping: {
            (options?: vimService.vim.CustomizationAdapterMapping): vimService.vim.CustomizationAdapterMapping;
         };
         ArrayOfCustomizationAdapterMapping: {
            (options?: vimService.vim.ArrayOfCustomizationAdapterMapping): vimService.vim.ArrayOfCustomizationAdapterMapping;
         };
         HostDiskMappingPartitionInfo: {
            (options?: vimService.vim.HostDiskMappingPartitionInfo): vimService.vim.HostDiskMappingPartitionInfo;
         };
         HostDiskMappingInfo: {
            (options?: vimService.vim.HostDiskMappingInfo): vimService.vim.HostDiskMappingInfo;
         };
         HostDiskMappingPartitionOption: {
            (options?: vimService.vim.HostDiskMappingPartitionOption): vimService.vim.HostDiskMappingPartitionOption;
         };
         ArrayOfHostDiskMappingPartitionOption: {
            (options?: vimService.vim.ArrayOfHostDiskMappingPartitionOption): vimService.vim.ArrayOfHostDiskMappingPartitionOption;
         };
         HostDiskMappingOption: {
            (options?: vimService.vim.HostDiskMappingOption): vimService.vim.HostDiskMappingOption;
         };
         ParaVirtualSCSIController: {
            (options?: vimService.vim.ParaVirtualSCSIController): vimService.vim.ParaVirtualSCSIController;
         };
         ParaVirtualSCSIControllerOption: {
            (options?: vimService.vim.ParaVirtualSCSIControllerOption): vimService.vim.ParaVirtualSCSIControllerOption;
         };
         VirtualAHCIController: {
            (options?: vimService.vim.VirtualAHCIController): vimService.vim.VirtualAHCIController;
         };
         VirtualAHCIControllerOption: {
            (options?: vimService.vim.VirtualAHCIControllerOption): vimService.vim.VirtualAHCIControllerOption;
         };
         VirtualBusLogicController: {
            (options?: vimService.vim.VirtualBusLogicController): vimService.vim.VirtualBusLogicController;
         };
         VirtualBusLogicControllerOption: {
            (options?: vimService.vim.VirtualBusLogicControllerOption): vimService.vim.VirtualBusLogicControllerOption;
         };
         VirtualCdromIsoBackingInfo: {
            (options?: vimService.vim.VirtualCdromIsoBackingInfo): vimService.vim.VirtualCdromIsoBackingInfo;
         };
         VirtualCdromPassthroughBackingInfo: {
            (options?: vimService.vim.VirtualCdromPassthroughBackingInfo): vimService.vim.VirtualCdromPassthroughBackingInfo;
         };
         VirtualCdromRemotePassthroughBackingInfo: {
            (options?: vimService.vim.VirtualCdromRemotePassthroughBackingInfo): vimService.vim.VirtualCdromRemotePassthroughBackingInfo;
         };
         VirtualCdromAtapiBackingInfo: {
            (options?: vimService.vim.VirtualCdromAtapiBackingInfo): vimService.vim.VirtualCdromAtapiBackingInfo;
         };
         VirtualCdromRemoteAtapiBackingInfo: {
            (options?: vimService.vim.VirtualCdromRemoteAtapiBackingInfo): vimService.vim.VirtualCdromRemoteAtapiBackingInfo;
         };
         VirtualCdrom: {
            (options?: vimService.vim.VirtualCdrom): vimService.vim.VirtualCdrom;
         };
         VirtualCdromIsoBackingOption: {
            (options?: vimService.vim.VirtualCdromIsoBackingOption): vimService.vim.VirtualCdromIsoBackingOption;
         };
         VirtualCdromPassthroughBackingOption: {
            (options?: vimService.vim.VirtualCdromPassthroughBackingOption): vimService.vim.VirtualCdromPassthroughBackingOption;
         };
         VirtualCdromRemotePassthroughBackingOption: {
            (options?: vimService.vim.VirtualCdromRemotePassthroughBackingOption): vimService.vim.VirtualCdromRemotePassthroughBackingOption;
         };
         VirtualCdromAtapiBackingOption: {
            (options?: vimService.vim.VirtualCdromAtapiBackingOption): vimService.vim.VirtualCdromAtapiBackingOption;
         };
         VirtualCdromRemoteAtapiBackingOption: {
            (options?: vimService.vim.VirtualCdromRemoteAtapiBackingOption): vimService.vim.VirtualCdromRemoteAtapiBackingOption;
         };
         VirtualCdromOption: {
            (options?: vimService.vim.VirtualCdromOption): vimService.vim.VirtualCdromOption;
         };
         VirtualController: {
            (options?: vimService.vim.VirtualController): vimService.vim.VirtualController;
         };
         VirtualControllerOption: {
            (options?: vimService.vim.VirtualControllerOption): vimService.vim.VirtualControllerOption;
         };
         VirtualDeviceBackingInfo: {
            (options?: vimService.vim.VirtualDeviceBackingInfo): vimService.vim.VirtualDeviceBackingInfo;
         };
         VirtualDeviceFileBackingInfo: {
            (options?: vimService.vim.VirtualDeviceFileBackingInfo): vimService.vim.VirtualDeviceFileBackingInfo;
         };
         VirtualDeviceDeviceBackingInfo: {
            (options?: vimService.vim.VirtualDeviceDeviceBackingInfo): vimService.vim.VirtualDeviceDeviceBackingInfo;
         };
         VirtualDeviceRemoteDeviceBackingInfo: {
            (options?: vimService.vim.VirtualDeviceRemoteDeviceBackingInfo): vimService.vim.VirtualDeviceRemoteDeviceBackingInfo;
         };
         VirtualDevicePipeBackingInfo: {
            (options?: vimService.vim.VirtualDevicePipeBackingInfo): vimService.vim.VirtualDevicePipeBackingInfo;
         };
         VirtualDeviceURIBackingInfo: {
            (options?: vimService.vim.VirtualDeviceURIBackingInfo): vimService.vim.VirtualDeviceURIBackingInfo;
         };
         VirtualDeviceConnectInfoStatus: {
            "ok": string;
            "recoverableError": string;
            "unrecoverableError": string;
            "untried": string;
         };
         VirtualDeviceConnectInfo: {
            (options?: vimService.vim.VirtualDeviceConnectInfo): vimService.vim.VirtualDeviceConnectInfo;
         };
         VirtualDeviceBusSlotInfo: {
            (options?: vimService.vim.VirtualDeviceBusSlotInfo): vimService.vim.VirtualDeviceBusSlotInfo;
         };
         VirtualDevicePciBusSlotInfo: {
            (options?: vimService.vim.VirtualDevicePciBusSlotInfo): vimService.vim.VirtualDevicePciBusSlotInfo;
         };
         VirtualDevice: {
            (options?: vimService.vim.VirtualDevice): vimService.vim.VirtualDevice;
         };
         ArrayOfVirtualDevice: {
            (options?: vimService.vim.ArrayOfVirtualDevice): vimService.vim.ArrayOfVirtualDevice;
         };
         VirtualDeviceBackingOption: {
            (options?: vimService.vim.VirtualDeviceBackingOption): vimService.vim.VirtualDeviceBackingOption;
         };
         ArrayOfVirtualDeviceBackingOption: {
            (options?: vimService.vim.ArrayOfVirtualDeviceBackingOption): vimService.vim.ArrayOfVirtualDeviceBackingOption;
         };
         VirtualDeviceFileExtension: {
            "iso": string;
            "flp": string;
            "vmdk": string;
            "dsk": string;
            "rdm": string;
         };
         VirtualDeviceFileBackingOption: {
            (options?: vimService.vim.VirtualDeviceFileBackingOption): vimService.vim.VirtualDeviceFileBackingOption;
         };
         VirtualDeviceDeviceBackingOption: {
            (options?: vimService.vim.VirtualDeviceDeviceBackingOption): vimService.vim.VirtualDeviceDeviceBackingOption;
         };
         VirtualDeviceRemoteDeviceBackingOption: {
            (options?: vimService.vim.VirtualDeviceRemoteDeviceBackingOption): vimService.vim.VirtualDeviceRemoteDeviceBackingOption;
         };
         VirtualDevicePipeBackingOption: {
            (options?: vimService.vim.VirtualDevicePipeBackingOption): vimService.vim.VirtualDevicePipeBackingOption;
         };
         VirtualDeviceURIBackingOptionDirection: {
            "server": string;
            "client": string;
         };
         VirtualDeviceURIBackingOption: {
            (options?: vimService.vim.VirtualDeviceURIBackingOption): vimService.vim.VirtualDeviceURIBackingOption;
         };
         VirtualDeviceConnectOption: {
            (options?: vimService.vim.VirtualDeviceConnectOption): vimService.vim.VirtualDeviceConnectOption;
         };
         VirtualDeviceBusSlotOption: {
            (options?: vimService.vim.VirtualDeviceBusSlotOption): vimService.vim.VirtualDeviceBusSlotOption;
         };
         VirtualDeviceOption: {
            (options?: vimService.vim.VirtualDeviceOption): vimService.vim.VirtualDeviceOption;
         };
         ArrayOfVirtualDeviceOption: {
            (options?: vimService.vim.ArrayOfVirtualDeviceOption): vimService.vim.ArrayOfVirtualDeviceOption;
         };
         VirtualDeviceConfigSpecOperation: {
            "add": string;
            "remove": string;
            "edit": string;
         };
         VirtualDeviceConfigSpecFileOperation: {
            "create": string;
            "destroy": string;
            "replace": string;
         };
         VirtualDeviceConfigSpecBackingSpec: {
            (options?: vimService.vim.VirtualDeviceConfigSpecBackingSpec): vimService.vim.VirtualDeviceConfigSpecBackingSpec;
         };
         VirtualDeviceConfigSpec: {
            (options?: vimService.vim.VirtualDeviceConfigSpec): vimService.vim.VirtualDeviceConfigSpec;
         };
         ArrayOfVirtualDeviceConfigSpec: {
            (options?: vimService.vim.ArrayOfVirtualDeviceConfigSpec): vimService.vim.ArrayOfVirtualDeviceConfigSpec;
         };
         VirtualDiskDeltaDiskFormat: {
            "redoLogFormat": string;
            "nativeFormat": string;
            "seSparseFormat": string;
         };
         VirtualDiskDeltaDiskFormatVariant: {
            "vmfsSparseVariant": string;
            "vsanSparseVariant": string;
         };
         VirtualDiskSharing: {
            "sharingNone": string;
            "sharingMultiWriter": string;
         };
         VirtualDiskSparseVer1BackingInfo: {
            (options?: vimService.vim.VirtualDiskSparseVer1BackingInfo): vimService.vim.VirtualDiskSparseVer1BackingInfo;
         };
         VirtualDiskSparseVer2BackingInfo: {
            (options?: vimService.vim.VirtualDiskSparseVer2BackingInfo): vimService.vim.VirtualDiskSparseVer2BackingInfo;
         };
         VirtualDiskFlatVer1BackingInfo: {
            (options?: vimService.vim.VirtualDiskFlatVer1BackingInfo): vimService.vim.VirtualDiskFlatVer1BackingInfo;
         };
         VirtualDiskFlatVer2BackingInfo: {
            (options?: vimService.vim.VirtualDiskFlatVer2BackingInfo): vimService.vim.VirtualDiskFlatVer2BackingInfo;
         };
         VirtualDiskSeSparseBackingInfo: {
            (options?: vimService.vim.VirtualDiskSeSparseBackingInfo): vimService.vim.VirtualDiskSeSparseBackingInfo;
         };
         VirtualDiskRawDiskVer2BackingInfo: {
            (options?: vimService.vim.VirtualDiskRawDiskVer2BackingInfo): vimService.vim.VirtualDiskRawDiskVer2BackingInfo;
         };
         VirtualDiskPartitionedRawDiskVer2BackingInfo: {
            (options?: vimService.vim.VirtualDiskPartitionedRawDiskVer2BackingInfo): vimService.vim.VirtualDiskPartitionedRawDiskVer2BackingInfo;
         };
         VirtualDiskRawDiskMappingVer1BackingInfo: {
            (options?: vimService.vim.VirtualDiskRawDiskMappingVer1BackingInfo): vimService.vim.VirtualDiskRawDiskMappingVer1BackingInfo;
         };
         VirtualDiskVFlashCacheConfigInfoCacheConsistencyType: {
            "strong": string;
            "weak": string;
         };
         VirtualDiskVFlashCacheConfigInfoCacheMode: {
            "write_thru": string;
            "write_back": string;
         };
         VirtualDiskVFlashCacheConfigInfo: {
            (options?: vimService.vim.VirtualDiskVFlashCacheConfigInfo): vimService.vim.VirtualDiskVFlashCacheConfigInfo;
         };
         VirtualDisk: {
            (options?: vimService.vim.VirtualDisk): vimService.vim.VirtualDisk;
         };
         ArrayOfVirtualDisk: {
            (options?: vimService.vim.ArrayOfVirtualDisk): vimService.vim.ArrayOfVirtualDisk;
         };
         VirtualDiskId: {
            (options?: vimService.vim.VirtualDiskId): vimService.vim.VirtualDiskId;
         };
         ArrayOfVirtualDiskId: {
            (options?: vimService.vim.ArrayOfVirtualDiskId): vimService.vim.ArrayOfVirtualDiskId;
         };
         VirtualDiskMode: {
            "persistent": string;
            "nonpersistent": string;
            "undoable": string;
            "independent_persistent": string;
            "independent_nonpersistent": string;
            "append": string;
         };
         VirtualDiskCompatibilityMode: {
            "virtualMode": string;
            "physicalMode": string;
         };
         VirtualDiskSparseVer1BackingOption: {
            (options?: vimService.vim.VirtualDiskSparseVer1BackingOption): vimService.vim.VirtualDiskSparseVer1BackingOption;
         };
         VirtualDiskSparseVer2BackingOption: {
            (options?: vimService.vim.VirtualDiskSparseVer2BackingOption): vimService.vim.VirtualDiskSparseVer2BackingOption;
         };
         VirtualDiskFlatVer1BackingOption: {
            (options?: vimService.vim.VirtualDiskFlatVer1BackingOption): vimService.vim.VirtualDiskFlatVer1BackingOption;
         };
         VirtualDiskDeltaDiskFormatsSupported: {
            (options?: vimService.vim.VirtualDiskDeltaDiskFormatsSupported): vimService.vim.VirtualDiskDeltaDiskFormatsSupported;
         };
         ArrayOfVirtualDiskDeltaDiskFormatsSupported: {
            (options?: vimService.vim.ArrayOfVirtualDiskDeltaDiskFormatsSupported): vimService.vim.ArrayOfVirtualDiskDeltaDiskFormatsSupported;
         };
         VirtualDiskFlatVer2BackingOption: {
            (options?: vimService.vim.VirtualDiskFlatVer2BackingOption): vimService.vim.VirtualDiskFlatVer2BackingOption;
         };
         VirtualDiskSeSparseBackingOption: {
            (options?: vimService.vim.VirtualDiskSeSparseBackingOption): vimService.vim.VirtualDiskSeSparseBackingOption;
         };
         VirtualDiskRawDiskVer2BackingOption: {
            (options?: vimService.vim.VirtualDiskRawDiskVer2BackingOption): vimService.vim.VirtualDiskRawDiskVer2BackingOption;
         };
         VirtualDiskPartitionedRawDiskVer2BackingOption: {
            (options?: vimService.vim.VirtualDiskPartitionedRawDiskVer2BackingOption): vimService.vim.VirtualDiskPartitionedRawDiskVer2BackingOption;
         };
         VirtualDiskRawDiskMappingVer1BackingOption: {
            (options?: vimService.vim.VirtualDiskRawDiskMappingVer1BackingOption): vimService.vim.VirtualDiskRawDiskMappingVer1BackingOption;
         };
         VirtualDiskOptionVFlashCacheConfigOption: {
            (options?: vimService.vim.VirtualDiskOptionVFlashCacheConfigOption): vimService.vim.VirtualDiskOptionVFlashCacheConfigOption;
         };
         VirtualDiskOption: {
            (options?: vimService.vim.VirtualDiskOption): vimService.vim.VirtualDiskOption;
         };
         VirtualDiskConfigSpec: {
            (options?: vimService.vim.VirtualDiskConfigSpec): vimService.vim.VirtualDiskConfigSpec;
         };
         VirtualE1000: {
            (options?: vimService.vim.VirtualE1000): vimService.vim.VirtualE1000;
         };
         VirtualE1000Option: {
            (options?: vimService.vim.VirtualE1000Option): vimService.vim.VirtualE1000Option;
         };
         VirtualE1000e: {
            (options?: vimService.vim.VirtualE1000e): vimService.vim.VirtualE1000e;
         };
         VirtualE1000eOption: {
            (options?: vimService.vim.VirtualE1000eOption): vimService.vim.VirtualE1000eOption;
         };
         VirtualEnsoniq1371: {
            (options?: vimService.vim.VirtualEnsoniq1371): vimService.vim.VirtualEnsoniq1371;
         };
         VirtualEnsoniq1371Option: {
            (options?: vimService.vim.VirtualEnsoniq1371Option): vimService.vim.VirtualEnsoniq1371Option;
         };
         VirtualEthernetCardNetworkBackingInfo: {
            (options?: vimService.vim.VirtualEthernetCardNetworkBackingInfo): vimService.vim.VirtualEthernetCardNetworkBackingInfo;
         };
         VirtualEthernetCardLegacyNetworkBackingInfo: {
            (options?: vimService.vim.VirtualEthernetCardLegacyNetworkBackingInfo): vimService.vim.VirtualEthernetCardLegacyNetworkBackingInfo;
         };
         VirtualEthernetCardDistributedVirtualPortBackingInfo: {
            (options?: vimService.vim.VirtualEthernetCardDistributedVirtualPortBackingInfo): vimService.vim.VirtualEthernetCardDistributedVirtualPortBackingInfo;
         };
         VirtualEthernetCardOpaqueNetworkBackingInfo: {
            (options?: vimService.vim.VirtualEthernetCardOpaqueNetworkBackingInfo): vimService.vim.VirtualEthernetCardOpaqueNetworkBackingInfo;
         };
         VirtualEthernetCardResourceAllocation: {
            (options?: vimService.vim.VirtualEthernetCardResourceAllocation): vimService.vim.VirtualEthernetCardResourceAllocation;
         };
         VirtualEthernetCard: {
            (options?: vimService.vim.VirtualEthernetCard): vimService.vim.VirtualEthernetCard;
         };
         VirtualEthernetCardNetworkBackingOption: {
            (options?: vimService.vim.VirtualEthernetCardNetworkBackingOption): vimService.vim.VirtualEthernetCardNetworkBackingOption;
         };
         VirtualEthernetCardOpaqueNetworkBackingOption: {
            (options?: vimService.vim.VirtualEthernetCardOpaqueNetworkBackingOption): vimService.vim.VirtualEthernetCardOpaqueNetworkBackingOption;
         };
         VirtualEthernetCardLegacyNetworkDeviceName: {
            "bridged": string;
            "nat": string;
            "hostonly": string;
         };
         VirtualEthernetCardLegacyNetworkBackingOption: {
            (options?: vimService.vim.VirtualEthernetCardLegacyNetworkBackingOption): vimService.vim.VirtualEthernetCardLegacyNetworkBackingOption;
         };
         VirtualEthernetCardDVPortBackingOption: {
            (options?: vimService.vim.VirtualEthernetCardDVPortBackingOption): vimService.vim.VirtualEthernetCardDVPortBackingOption;
         };
         VirtualEthernetCardMacType: {
            "manual": string;
            "generated": string;
            "assigned": string;
         };
         VirtualEthernetCardOption: {
            (options?: vimService.vim.VirtualEthernetCardOption): vimService.vim.VirtualEthernetCardOption;
         };
         VirtualFloppyImageBackingInfo: {
            (options?: vimService.vim.VirtualFloppyImageBackingInfo): vimService.vim.VirtualFloppyImageBackingInfo;
         };
         VirtualFloppyDeviceBackingInfo: {
            (options?: vimService.vim.VirtualFloppyDeviceBackingInfo): vimService.vim.VirtualFloppyDeviceBackingInfo;
         };
         VirtualFloppyRemoteDeviceBackingInfo: {
            (options?: vimService.vim.VirtualFloppyRemoteDeviceBackingInfo): vimService.vim.VirtualFloppyRemoteDeviceBackingInfo;
         };
         VirtualFloppy: {
            (options?: vimService.vim.VirtualFloppy): vimService.vim.VirtualFloppy;
         };
         VirtualFloppyImageBackingOption: {
            (options?: vimService.vim.VirtualFloppyImageBackingOption): vimService.vim.VirtualFloppyImageBackingOption;
         };
         VirtualFloppyDeviceBackingOption: {
            (options?: vimService.vim.VirtualFloppyDeviceBackingOption): vimService.vim.VirtualFloppyDeviceBackingOption;
         };
         VirtualFloppyRemoteDeviceBackingOption: {
            (options?: vimService.vim.VirtualFloppyRemoteDeviceBackingOption): vimService.vim.VirtualFloppyRemoteDeviceBackingOption;
         };
         VirtualFloppyOption: {
            (options?: vimService.vim.VirtualFloppyOption): vimService.vim.VirtualFloppyOption;
         };
         VirtualHdAudioCard: {
            (options?: vimService.vim.VirtualHdAudioCard): vimService.vim.VirtualHdAudioCard;
         };
         VirtualHdAudioCardOption: {
            (options?: vimService.vim.VirtualHdAudioCardOption): vimService.vim.VirtualHdAudioCardOption;
         };
         VirtualIDEController: {
            (options?: vimService.vim.VirtualIDEController): vimService.vim.VirtualIDEController;
         };
         VirtualIDEControllerOption: {
            (options?: vimService.vim.VirtualIDEControllerOption): vimService.vim.VirtualIDEControllerOption;
         };
         VirtualKeyboard: {
            (options?: vimService.vim.VirtualKeyboard): vimService.vim.VirtualKeyboard;
         };
         VirtualKeyboardOption: {
            (options?: vimService.vim.VirtualKeyboardOption): vimService.vim.VirtualKeyboardOption;
         };
         VirtualLsiLogicController: {
            (options?: vimService.vim.VirtualLsiLogicController): vimService.vim.VirtualLsiLogicController;
         };
         VirtualLsiLogicControllerOption: {
            (options?: vimService.vim.VirtualLsiLogicControllerOption): vimService.vim.VirtualLsiLogicControllerOption;
         };
         VirtualLsiLogicSASController: {
            (options?: vimService.vim.VirtualLsiLogicSASController): vimService.vim.VirtualLsiLogicSASController;
         };
         VirtualLsiLogicSASControllerOption: {
            (options?: vimService.vim.VirtualLsiLogicSASControllerOption): vimService.vim.VirtualLsiLogicSASControllerOption;
         };
         VirtualNVMEController: {
            (options?: vimService.vim.VirtualNVMEController): vimService.vim.VirtualNVMEController;
         };
         VirtualNVMEControllerOption: {
            (options?: vimService.vim.VirtualNVMEControllerOption): vimService.vim.VirtualNVMEControllerOption;
         };
         VirtualPCIController: {
            (options?: vimService.vim.VirtualPCIController): vimService.vim.VirtualPCIController;
         };
         VirtualPCIControllerOption: {
            (options?: vimService.vim.VirtualPCIControllerOption): vimService.vim.VirtualPCIControllerOption;
         };
         VirtualPCIPassthroughDeviceBackingInfo: {
            (options?: vimService.vim.VirtualPCIPassthroughDeviceBackingInfo): vimService.vim.VirtualPCIPassthroughDeviceBackingInfo;
         };
         VirtualPCIPassthroughPluginBackingInfo: {
            (options?: vimService.vim.VirtualPCIPassthroughPluginBackingInfo): vimService.vim.VirtualPCIPassthroughPluginBackingInfo;
         };
         VirtualPCIPassthroughVmiopBackingInfo: {
            (options?: vimService.vim.VirtualPCIPassthroughVmiopBackingInfo): vimService.vim.VirtualPCIPassthroughVmiopBackingInfo;
         };
         VirtualPCIPassthrough: {
            (options?: vimService.vim.VirtualPCIPassthrough): vimService.vim.VirtualPCIPassthrough;
         };
         VirtualPCIPassthroughDeviceBackingOption: {
            (options?: vimService.vim.VirtualPCIPassthroughDeviceBackingOption): vimService.vim.VirtualPCIPassthroughDeviceBackingOption;
         };
         VirtualPCIPassthroughPluginBackingOption: {
            (options?: vimService.vim.VirtualPCIPassthroughPluginBackingOption): vimService.vim.VirtualPCIPassthroughPluginBackingOption;
         };
         VirtualPCIPassthroughVmiopBackingOption: {
            (options?: vimService.vim.VirtualPCIPassthroughVmiopBackingOption): vimService.vim.VirtualPCIPassthroughVmiopBackingOption;
         };
         VirtualPCIPassthroughOption: {
            (options?: vimService.vim.VirtualPCIPassthroughOption): vimService.vim.VirtualPCIPassthroughOption;
         };
         VirtualPCNet32: {
            (options?: vimService.vim.VirtualPCNet32): vimService.vim.VirtualPCNet32;
         };
         VirtualPCNet32Option: {
            (options?: vimService.vim.VirtualPCNet32Option): vimService.vim.VirtualPCNet32Option;
         };
         VirtualPS2Controller: {
            (options?: vimService.vim.VirtualPS2Controller): vimService.vim.VirtualPS2Controller;
         };
         VirtualPS2ControllerOption: {
            (options?: vimService.vim.VirtualPS2ControllerOption): vimService.vim.VirtualPS2ControllerOption;
         };
         VirtualParallelPortFileBackingInfo: {
            (options?: vimService.vim.VirtualParallelPortFileBackingInfo): vimService.vim.VirtualParallelPortFileBackingInfo;
         };
         VirtualParallelPortDeviceBackingInfo: {
            (options?: vimService.vim.VirtualParallelPortDeviceBackingInfo): vimService.vim.VirtualParallelPortDeviceBackingInfo;
         };
         VirtualParallelPort: {
            (options?: vimService.vim.VirtualParallelPort): vimService.vim.VirtualParallelPort;
         };
         VirtualParallelPortFileBackingOption: {
            (options?: vimService.vim.VirtualParallelPortFileBackingOption): vimService.vim.VirtualParallelPortFileBackingOption;
         };
         VirtualParallelPortDeviceBackingOption: {
            (options?: vimService.vim.VirtualParallelPortDeviceBackingOption): vimService.vim.VirtualParallelPortDeviceBackingOption;
         };
         VirtualParallelPortOption: {
            (options?: vimService.vim.VirtualParallelPortOption): vimService.vim.VirtualParallelPortOption;
         };
         VirtualPointingDeviceDeviceBackingInfo: {
            (options?: vimService.vim.VirtualPointingDeviceDeviceBackingInfo): vimService.vim.VirtualPointingDeviceDeviceBackingInfo;
         };
         VirtualPointingDevice: {
            (options?: vimService.vim.VirtualPointingDevice): vimService.vim.VirtualPointingDevice;
         };
         VirtualPointingDeviceHostChoice: {
            "autodetect": string;
            "intellimouseExplorer": string;
            "intellimousePs2": string;
            "logitechMouseman": string;
            "microsoft_serial": string;
            "mouseSystems": string;
            "mousemanSerial": string;
            "ps2": string;
         };
         VirtualPointingDeviceBackingOption: {
            (options?: vimService.vim.VirtualPointingDeviceBackingOption): vimService.vim.VirtualPointingDeviceBackingOption;
         };
         VirtualPointingDeviceOption: {
            (options?: vimService.vim.VirtualPointingDeviceOption): vimService.vim.VirtualPointingDeviceOption;
         };
         VirtualSATAController: {
            (options?: vimService.vim.VirtualSATAController): vimService.vim.VirtualSATAController;
         };
         VirtualSATAControllerOption: {
            (options?: vimService.vim.VirtualSATAControllerOption): vimService.vim.VirtualSATAControllerOption;
         };
         VirtualSCSISharing: {
            "noSharing": string;
            "virtualSharing": string;
            "physicalSharing": string;
         };
         ArrayOfVirtualSCSISharing: {
            (options?: vimService.vim.ArrayOfVirtualSCSISharing): vimService.vim.ArrayOfVirtualSCSISharing;
         };
         VirtualSCSIController: {
            (options?: vimService.vim.VirtualSCSIController): vimService.vim.VirtualSCSIController;
         };
         VirtualSCSIControllerOption: {
            (options?: vimService.vim.VirtualSCSIControllerOption): vimService.vim.VirtualSCSIControllerOption;
         };
         VirtualSCSIPassthroughDeviceBackingInfo: {
            (options?: vimService.vim.VirtualSCSIPassthroughDeviceBackingInfo): vimService.vim.VirtualSCSIPassthroughDeviceBackingInfo;
         };
         VirtualSCSIPassthrough: {
            (options?: vimService.vim.VirtualSCSIPassthrough): vimService.vim.VirtualSCSIPassthrough;
         };
         VirtualSCSIPassthroughDeviceBackingOption: {
            (options?: vimService.vim.VirtualSCSIPassthroughDeviceBackingOption): vimService.vim.VirtualSCSIPassthroughDeviceBackingOption;
         };
         VirtualSCSIPassthroughOption: {
            (options?: vimService.vim.VirtualSCSIPassthroughOption): vimService.vim.VirtualSCSIPassthroughOption;
         };
         VirtualSIOController: {
            (options?: vimService.vim.VirtualSIOController): vimService.vim.VirtualSIOController;
         };
         VirtualSIOControllerOption: {
            (options?: vimService.vim.VirtualSIOControllerOption): vimService.vim.VirtualSIOControllerOption;
         };
         VirtualSerialPortFileBackingInfo: {
            (options?: vimService.vim.VirtualSerialPortFileBackingInfo): vimService.vim.VirtualSerialPortFileBackingInfo;
         };
         VirtualSerialPortDeviceBackingInfo: {
            (options?: vimService.vim.VirtualSerialPortDeviceBackingInfo): vimService.vim.VirtualSerialPortDeviceBackingInfo;
         };
         VirtualSerialPortPipeBackingInfo: {
            (options?: vimService.vim.VirtualSerialPortPipeBackingInfo): vimService.vim.VirtualSerialPortPipeBackingInfo;
         };
         VirtualSerialPortURIBackingInfo: {
            (options?: vimService.vim.VirtualSerialPortURIBackingInfo): vimService.vim.VirtualSerialPortURIBackingInfo;
         };
         VirtualSerialPortThinPrintBackingInfo: {
            (options?: vimService.vim.VirtualSerialPortThinPrintBackingInfo): vimService.vim.VirtualSerialPortThinPrintBackingInfo;
         };
         VirtualSerialPort: {
            (options?: vimService.vim.VirtualSerialPort): vimService.vim.VirtualSerialPort;
         };
         VirtualSerialPortEndPoint: {
            "client": string;
            "server": string;
         };
         VirtualSerialPortFileBackingOption: {
            (options?: vimService.vim.VirtualSerialPortFileBackingOption): vimService.vim.VirtualSerialPortFileBackingOption;
         };
         VirtualSerialPortDeviceBackingOption: {
            (options?: vimService.vim.VirtualSerialPortDeviceBackingOption): vimService.vim.VirtualSerialPortDeviceBackingOption;
         };
         VirtualSerialPortPipeBackingOption: {
            (options?: vimService.vim.VirtualSerialPortPipeBackingOption): vimService.vim.VirtualSerialPortPipeBackingOption;
         };
         VirtualSerialPortURIBackingOption: {
            (options?: vimService.vim.VirtualSerialPortURIBackingOption): vimService.vim.VirtualSerialPortURIBackingOption;
         };
         VirtualSerialPortThinPrintBackingOption: {
            (options?: vimService.vim.VirtualSerialPortThinPrintBackingOption): vimService.vim.VirtualSerialPortThinPrintBackingOption;
         };
         VirtualSerialPortOption: {
            (options?: vimService.vim.VirtualSerialPortOption): vimService.vim.VirtualSerialPortOption;
         };
         VirtualSoundBlaster16: {
            (options?: vimService.vim.VirtualSoundBlaster16): vimService.vim.VirtualSoundBlaster16;
         };
         VirtualSoundBlaster16Option: {
            (options?: vimService.vim.VirtualSoundBlaster16Option): vimService.vim.VirtualSoundBlaster16Option;
         };
         VirtualSoundCardDeviceBackingInfo: {
            (options?: vimService.vim.VirtualSoundCardDeviceBackingInfo): vimService.vim.VirtualSoundCardDeviceBackingInfo;
         };
         VirtualSoundCard: {
            (options?: vimService.vim.VirtualSoundCard): vimService.vim.VirtualSoundCard;
         };
         VirtualSoundCardDeviceBackingOption: {
            (options?: vimService.vim.VirtualSoundCardDeviceBackingOption): vimService.vim.VirtualSoundCardDeviceBackingOption;
         };
         VirtualSoundCardOption: {
            (options?: vimService.vim.VirtualSoundCardOption): vimService.vim.VirtualSoundCardOption;
         };
         VirtualSriovEthernetCardSriovBackingInfo: {
            (options?: vimService.vim.VirtualSriovEthernetCardSriovBackingInfo): vimService.vim.VirtualSriovEthernetCardSriovBackingInfo;
         };
         VirtualSriovEthernetCard: {
            (options?: vimService.vim.VirtualSriovEthernetCard): vimService.vim.VirtualSriovEthernetCard;
         };
         VirtualSriovEthernetCardSriovBackingOption: {
            (options?: vimService.vim.VirtualSriovEthernetCardSriovBackingOption): vimService.vim.VirtualSriovEthernetCardSriovBackingOption;
         };
         VirtualSriovEthernetCardOption: {
            (options?: vimService.vim.VirtualSriovEthernetCardOption): vimService.vim.VirtualSriovEthernetCardOption;
         };
         VirtualUSBUSBBackingInfo: {
            (options?: vimService.vim.VirtualUSBUSBBackingInfo): vimService.vim.VirtualUSBUSBBackingInfo;
         };
         VirtualUSBRemoteHostBackingInfo: {
            (options?: vimService.vim.VirtualUSBRemoteHostBackingInfo): vimService.vim.VirtualUSBRemoteHostBackingInfo;
         };
         VirtualUSBRemoteClientBackingInfo: {
            (options?: vimService.vim.VirtualUSBRemoteClientBackingInfo): vimService.vim.VirtualUSBRemoteClientBackingInfo;
         };
         VirtualUSB: {
            (options?: vimService.vim.VirtualUSB): vimService.vim.VirtualUSB;
         };
         VirtualUSBControllerPciBusSlotInfo: {
            (options?: vimService.vim.VirtualUSBControllerPciBusSlotInfo): vimService.vim.VirtualUSBControllerPciBusSlotInfo;
         };
         VirtualUSBController: {
            (options?: vimService.vim.VirtualUSBController): vimService.vim.VirtualUSBController;
         };
         VirtualUSBControllerOption: {
            (options?: vimService.vim.VirtualUSBControllerOption): vimService.vim.VirtualUSBControllerOption;
         };
         VirtualUSBUSBBackingOption: {
            (options?: vimService.vim.VirtualUSBUSBBackingOption): vimService.vim.VirtualUSBUSBBackingOption;
         };
         VirtualUSBRemoteHostBackingOption: {
            (options?: vimService.vim.VirtualUSBRemoteHostBackingOption): vimService.vim.VirtualUSBRemoteHostBackingOption;
         };
         VirtualUSBRemoteClientBackingOption: {
            (options?: vimService.vim.VirtualUSBRemoteClientBackingOption): vimService.vim.VirtualUSBRemoteClientBackingOption;
         };
         VirtualUSBOption: {
            (options?: vimService.vim.VirtualUSBOption): vimService.vim.VirtualUSBOption;
         };
         VirtualUSBXHCIController: {
            (options?: vimService.vim.VirtualUSBXHCIController): vimService.vim.VirtualUSBXHCIController;
         };
         VirtualUSBXHCIControllerOption: {
            (options?: vimService.vim.VirtualUSBXHCIControllerOption): vimService.vim.VirtualUSBXHCIControllerOption;
         };
         VirtualMachineVMCIDeviceAction: {
            "allow": string;
            "deny": string;
         };
         VirtualMachineVMCIDeviceProtocol: {
            "hypervisor": string;
            "doorbell": string;
            "queuepair": string;
            "datagram": string;
            "stream": string;
            "anyProtocol": string;
         };
         VirtualMachineVMCIDeviceDirection: {
            "guest": string;
            "host": string;
            "anyDirection": string;
         };
         VirtualMachineVMCIDeviceFilterSpec: {
            (options?: vimService.vim.VirtualMachineVMCIDeviceFilterSpec): vimService.vim.VirtualMachineVMCIDeviceFilterSpec;
         };
         ArrayOfVirtualMachineVMCIDeviceFilterSpec: {
            (options?: vimService.vim.ArrayOfVirtualMachineVMCIDeviceFilterSpec): vimService.vim.ArrayOfVirtualMachineVMCIDeviceFilterSpec;
         };
         VirtualMachineVMCIDeviceFilterInfo: {
            (options?: vimService.vim.VirtualMachineVMCIDeviceFilterInfo): vimService.vim.VirtualMachineVMCIDeviceFilterInfo;
         };
         VirtualMachineVMCIDevice: {
            (options?: vimService.vim.VirtualMachineVMCIDevice): vimService.vim.VirtualMachineVMCIDevice;
         };
         VirtualMachineVMCIDeviceOptionFilterSpecOption: {
            (options?: vimService.vim.VirtualMachineVMCIDeviceOptionFilterSpecOption): vimService.vim.VirtualMachineVMCIDeviceOptionFilterSpecOption;
         };
         VirtualMachineVMCIDeviceOption: {
            (options?: vimService.vim.VirtualMachineVMCIDeviceOption): vimService.vim.VirtualMachineVMCIDeviceOption;
         };
         VirtualMachineVMIROM: {
            (options?: vimService.vim.VirtualMachineVMIROM): vimService.vim.VirtualMachineVMIROM;
         };
         VirtualVMIROMOption: {
            (options?: vimService.vim.VirtualVMIROMOption): vimService.vim.VirtualVMIROMOption;
         };
         VirtualMachineVideoCardUse3dRenderer: {
            "automatic": string;
            "software": string;
            "hardware": string;
         };
         VirtualMachineVideoCard: {
            (options?: vimService.vim.VirtualMachineVideoCard): vimService.vim.VirtualMachineVideoCard;
         };
         VirtualVideoCardOption: {
            (options?: vimService.vim.VirtualVideoCardOption): vimService.vim.VirtualVideoCardOption;
         };
         VirtualVmxnet: {
            (options?: vimService.vim.VirtualVmxnet): vimService.vim.VirtualVmxnet;
         };
         VirtualVmxnet2: {
            (options?: vimService.vim.VirtualVmxnet2): vimService.vim.VirtualVmxnet2;
         };
         VirtualVmxnet2Option: {
            (options?: vimService.vim.VirtualVmxnet2Option): vimService.vim.VirtualVmxnet2Option;
         };
         VirtualVmxnet3: {
            (options?: vimService.vim.VirtualVmxnet3): vimService.vim.VirtualVmxnet3;
         };
         VirtualVmxnet3Option: {
            (options?: vimService.vim.VirtualVmxnet3Option): vimService.vim.VirtualVmxnet3Option;
         };
         VirtualVmxnet3Vrdma: {
            (options?: vimService.vim.VirtualVmxnet3Vrdma): vimService.vim.VirtualVmxnet3Vrdma;
         };
         VirtualVmxnet3VrdmaOption: {
            (options?: vimService.vim.VirtualVmxnet3VrdmaOption): vimService.vim.VirtualVmxnet3VrdmaOption;
         };
         VirtualVmxnetOption: {
            (options?: vimService.vim.VirtualVmxnetOption): vimService.vim.VirtualVmxnetOption;
         };
         GuestAuthSubject: {
            (options?: vimService.vim.GuestAuthSubject): vimService.vim.GuestAuthSubject;
         };
         ArrayOfGuestAuthSubject: {
            (options?: vimService.vim.ArrayOfGuestAuthSubject): vimService.vim.ArrayOfGuestAuthSubject;
         };
         GuestAuthAnySubject: {
            (options?: vimService.vim.GuestAuthAnySubject): vimService.vim.GuestAuthAnySubject;
         };
         GuestAuthNamedSubject: {
            (options?: vimService.vim.GuestAuthNamedSubject): vimService.vim.GuestAuthNamedSubject;
         };
         GuestAuthAliasInfo: {
            (options?: vimService.vim.GuestAuthAliasInfo): vimService.vim.GuestAuthAliasInfo;
         };
         ArrayOfGuestAuthAliasInfo: {
            (options?: vimService.vim.ArrayOfGuestAuthAliasInfo): vimService.vim.ArrayOfGuestAuthAliasInfo;
         };
         GuestAliases: {
            (options?: vimService.vim.GuestAliases): vimService.vim.GuestAliases;
         };
         ArrayOfGuestAliases: {
            (options?: vimService.vim.ArrayOfGuestAliases): vimService.vim.ArrayOfGuestAliases;
         };
         GuestMappedAliases: {
            (options?: vimService.vim.GuestMappedAliases): vimService.vim.GuestMappedAliases;
         };
         ArrayOfGuestMappedAliases: {
            (options?: vimService.vim.ArrayOfGuestMappedAliases): vimService.vim.ArrayOfGuestMappedAliases;
         };
         GuestFileAttributes: {
            (options?: vimService.vim.GuestFileAttributes): vimService.vim.GuestFileAttributes;
         };
         GuestPosixFileAttributes: {
            (options?: vimService.vim.GuestPosixFileAttributes): vimService.vim.GuestPosixFileAttributes;
         };
         GuestWindowsFileAttributes: {
            (options?: vimService.vim.GuestWindowsFileAttributes): vimService.vim.GuestWindowsFileAttributes;
         };
         GuestFileType: {
            "file": string;
            "directory": string;
            "symlink": string;
         };
         GuestFileInfo: {
            (options?: vimService.vim.GuestFileInfo): vimService.vim.GuestFileInfo;
         };
         ArrayOfGuestFileInfo: {
            (options?: vimService.vim.ArrayOfGuestFileInfo): vimService.vim.ArrayOfGuestFileInfo;
         };
         GuestListFileInfo: {
            (options?: vimService.vim.GuestListFileInfo): vimService.vim.GuestListFileInfo;
         };
         FileTransferInformation: {
            (options?: vimService.vim.FileTransferInformation): vimService.vim.FileTransferInformation;
         };
         GuestAuthentication: {
            (options?: vimService.vim.GuestAuthentication): vimService.vim.GuestAuthentication;
         };
         NamePasswordAuthentication: {
            (options?: vimService.vim.NamePasswordAuthentication): vimService.vim.NamePasswordAuthentication;
         };
         GuestProgramSpec: {
            (options?: vimService.vim.GuestProgramSpec): vimService.vim.GuestProgramSpec;
         };
         GuestWindowsProgramSpec: {
            (options?: vimService.vim.GuestWindowsProgramSpec): vimService.vim.GuestWindowsProgramSpec;
         };
         GuestProcessInfo: {
            (options?: vimService.vim.GuestProcessInfo): vimService.vim.GuestProcessInfo;
         };
         ArrayOfGuestProcessInfo: {
            (options?: vimService.vim.ArrayOfGuestProcessInfo): vimService.vim.ArrayOfGuestProcessInfo;
         };
         SAMLTokenAuthentication: {
            (options?: vimService.vim.SAMLTokenAuthentication): vimService.vim.SAMLTokenAuthentication;
         };
         SSPIAuthentication: {
            (options?: vimService.vim.SSPIAuthentication): vimService.vim.SSPIAuthentication;
         };
         TicketedSessionAuthentication: {
            (options?: vimService.vim.TicketedSessionAuthentication): vimService.vim.TicketedSessionAuthentication;
         };
         GuestRegKeyWowSpec: {
            "WOWNative": string;
            "WOW32": string;
            "WOW64": string;
         };
         GuestRegKeyNameSpec: {
            (options?: vimService.vim.GuestRegKeyNameSpec): vimService.vim.GuestRegKeyNameSpec;
         };
         GuestRegKeySpec: {
            (options?: vimService.vim.GuestRegKeySpec): vimService.vim.GuestRegKeySpec;
         };
         GuestRegKeyRecordSpec: {
            (options?: vimService.vim.GuestRegKeyRecordSpec): vimService.vim.GuestRegKeyRecordSpec;
         };
         ArrayOfGuestRegKeyRecordSpec: {
            (options?: vimService.vim.ArrayOfGuestRegKeyRecordSpec): vimService.vim.ArrayOfGuestRegKeyRecordSpec;
         };
         GuestRegValueNameSpec: {
            (options?: vimService.vim.GuestRegValueNameSpec): vimService.vim.GuestRegValueNameSpec;
         };
         GuestRegValueDataSpec: {
            (options?: vimService.vim.GuestRegValueDataSpec): vimService.vim.GuestRegValueDataSpec;
         };
         GuestRegValueDwordSpec: {
            (options?: vimService.vim.GuestRegValueDwordSpec): vimService.vim.GuestRegValueDwordSpec;
         };
         GuestRegValueQwordSpec: {
            (options?: vimService.vim.GuestRegValueQwordSpec): vimService.vim.GuestRegValueQwordSpec;
         };
         GuestRegValueStringSpec: {
            (options?: vimService.vim.GuestRegValueStringSpec): vimService.vim.GuestRegValueStringSpec;
         };
         GuestRegValueExpandStringSpec: {
            (options?: vimService.vim.GuestRegValueExpandStringSpec): vimService.vim.GuestRegValueExpandStringSpec;
         };
         GuestRegValueMultiStringSpec: {
            (options?: vimService.vim.GuestRegValueMultiStringSpec): vimService.vim.GuestRegValueMultiStringSpec;
         };
         GuestRegValueBinarySpec: {
            (options?: vimService.vim.GuestRegValueBinarySpec): vimService.vim.GuestRegValueBinarySpec;
         };
         GuestRegValueSpec: {
            (options?: vimService.vim.GuestRegValueSpec): vimService.vim.GuestRegValueSpec;
         };
         ArrayOfGuestRegValueSpec: {
            (options?: vimService.vim.ArrayOfGuestRegValueSpec): vimService.vim.ArrayOfGuestRegValueSpec;
         };
         DeviceGroupId: {
            (options?: vimService.vim.DeviceGroupId): vimService.vim.DeviceGroupId;
         };
         FaultDomainId: {
            (options?: vimService.vim.FaultDomainId): vimService.vim.FaultDomainId;
         };
         ReplicationGroupId: {
            (options?: vimService.vim.ReplicationGroupId): vimService.vim.ReplicationGroupId;
         };
         ReplicationSpec: {
            (options?: vimService.vim.ReplicationSpec): vimService.vim.ReplicationSpec;
         };
         VsanClusterConfigInfoHostDefaultInfo: {
            (options?: vimService.vim.VsanClusterConfigInfoHostDefaultInfo): vimService.vim.VsanClusterConfigInfoHostDefaultInfo;
         };
         VsanClusterConfigInfo: {
            (options?: vimService.vim.VsanClusterConfigInfo): vimService.vim.VsanClusterConfigInfo;
         };
         VsanHostClusterStatusStateCompletionEstimate: {
            (options?: vimService.vim.VsanHostClusterStatusStateCompletionEstimate): vimService.vim.VsanHostClusterStatusStateCompletionEstimate;
         };
         VsanHostClusterStatusState: {
            (options?: vimService.vim.VsanHostClusterStatusState): vimService.vim.VsanHostClusterStatusState;
         };
         VsanHostClusterStatus: {
            (options?: vimService.vim.VsanHostClusterStatus): vimService.vim.VsanHostClusterStatus;
         };
         VsanHostConfigInfoStorageInfo: {
            (options?: vimService.vim.VsanHostConfigInfoStorageInfo): vimService.vim.VsanHostConfigInfoStorageInfo;
         };
         VsanHostConfigInfoClusterInfo: {
            (options?: vimService.vim.VsanHostConfigInfoClusterInfo): vimService.vim.VsanHostConfigInfoClusterInfo;
         };
         VsanHostConfigInfoNetworkInfoPortConfig: {
            (options?: vimService.vim.VsanHostConfigInfoNetworkInfoPortConfig): vimService.vim.VsanHostConfigInfoNetworkInfoPortConfig;
         };
         ArrayOfVsanHostConfigInfoNetworkInfoPortConfig: {
            (options?: vimService.vim.ArrayOfVsanHostConfigInfoNetworkInfoPortConfig): vimService.vim.ArrayOfVsanHostConfigInfoNetworkInfoPortConfig;
         };
         VsanHostConfigInfoNetworkInfo: {
            (options?: vimService.vim.VsanHostConfigInfoNetworkInfo): vimService.vim.VsanHostConfigInfoNetworkInfo;
         };
         VsanHostFaultDomainInfo: {
            (options?: vimService.vim.VsanHostFaultDomainInfo): vimService.vim.VsanHostFaultDomainInfo;
         };
         VsanHostConfigInfo: {
            (options?: vimService.vim.VsanHostConfigInfo): vimService.vim.VsanHostConfigInfo;
         };
         ArrayOfVsanHostConfigInfo: {
            (options?: vimService.vim.ArrayOfVsanHostConfigInfo): vimService.vim.ArrayOfVsanHostConfigInfo;
         };
         VsanHostDecommissionModeObjectAction: {
            "noAction": string;
            "ensureObjectAccessibility": string;
            "evacuateAllData": string;
         };
         VsanHostDecommissionMode: {
            (options?: vimService.vim.VsanHostDecommissionMode): vimService.vim.VsanHostDecommissionMode;
         };
         VsanHostDiskMapInfo: {
            (options?: vimService.vim.VsanHostDiskMapInfo): vimService.vim.VsanHostDiskMapInfo;
         };
         ArrayOfVsanHostDiskMapInfo: {
            (options?: vimService.vim.ArrayOfVsanHostDiskMapInfo): vimService.vim.ArrayOfVsanHostDiskMapInfo;
         };
         VsanHostDiskMapResult: {
            (options?: vimService.vim.VsanHostDiskMapResult): vimService.vim.VsanHostDiskMapResult;
         };
         ArrayOfVsanHostDiskMapResult: {
            (options?: vimService.vim.ArrayOfVsanHostDiskMapResult): vimService.vim.ArrayOfVsanHostDiskMapResult;
         };
         VsanHostDiskMapping: {
            (options?: vimService.vim.VsanHostDiskMapping): vimService.vim.VsanHostDiskMapping;
         };
         ArrayOfVsanHostDiskMapping: {
            (options?: vimService.vim.ArrayOfVsanHostDiskMapping): vimService.vim.ArrayOfVsanHostDiskMapping;
         };
         VsanHostDiskResultState: {
            "inUse": string;
            "eligible": string;
            "ineligible": string;
         };
         VsanHostDiskResult: {
            (options?: vimService.vim.VsanHostDiskResult): vimService.vim.VsanHostDiskResult;
         };
         ArrayOfVsanHostDiskResult: {
            (options?: vimService.vim.ArrayOfVsanHostDiskResult): vimService.vim.ArrayOfVsanHostDiskResult;
         };
         VsanHostHealthState: {
            "unknown": string;
            "healthy": string;
            "unhealthy": string;
         };
         VsanHostIpConfig: {
            (options?: vimService.vim.VsanHostIpConfig): vimService.vim.VsanHostIpConfig;
         };
         VsanHostMembershipInfo: {
            (options?: vimService.vim.VsanHostMembershipInfo): vimService.vim.VsanHostMembershipInfo;
         };
         ArrayOfVsanHostMembershipInfo: {
            (options?: vimService.vim.ArrayOfVsanHostMembershipInfo): vimService.vim.ArrayOfVsanHostMembershipInfo;
         };
         VsanHostNodeState: {
            "error": string;
            "disabled": string;
            "agent": string;
            "master": string;
            "backup": string;
            "starting": string;
            "stopping": string;
            "enteringMaintenanceMode": string;
            "exitingMaintenanceMode": string;
            "decommissioning": string;
         };
         VsanHostVsanDiskInfo: {
            (options?: vimService.vim.VsanHostVsanDiskInfo): vimService.vim.VsanHostVsanDiskInfo;
         };
         VsanDiskIssueType: {
            "nonExist": string;
            "stampMismatch": string;
            "unknown": string;
         };
         VsanHostRuntimeInfoDiskIssue: {
            (options?: vimService.vim.VsanHostRuntimeInfoDiskIssue): vimService.vim.VsanHostRuntimeInfoDiskIssue;
         };
         ArrayOfVsanHostRuntimeInfoDiskIssue: {
            (options?: vimService.vim.ArrayOfVsanHostRuntimeInfoDiskIssue): vimService.vim.ArrayOfVsanHostRuntimeInfoDiskIssue;
         };
         VsanHostRuntimeInfo: {
            (options?: vimService.vim.VsanHostRuntimeInfo): vimService.vim.VsanHostRuntimeInfo;
         };
         BaseConfigInfoBackingInfo: {
            (options?: vimService.vim.BaseConfigInfoBackingInfo): vimService.vim.BaseConfigInfoBackingInfo;
         };
         BaseConfigInfoFileBackingInfo: {
            (options?: vimService.vim.BaseConfigInfoFileBackingInfo): vimService.vim.BaseConfigInfoFileBackingInfo;
         };
         BaseConfigInfoDiskFileBackingInfoProvisioningType: {
            "thin": string;
            "eagerZeroedThick": string;
            "lazyZeroedThick": string;
         };
         BaseConfigInfoDiskFileBackingInfo: {
            (options?: vimService.vim.BaseConfigInfoDiskFileBackingInfo): vimService.vim.BaseConfigInfoDiskFileBackingInfo;
         };
         BaseConfigInfoRawDiskMappingBackingInfo: {
            (options?: vimService.vim.BaseConfigInfoRawDiskMappingBackingInfo): vimService.vim.BaseConfigInfoRawDiskMappingBackingInfo;
         };
         BaseConfigInfo: {
            (options?: vimService.vim.BaseConfigInfo): vimService.vim.BaseConfigInfo;
         };
         VslmCloneSpec: {
            (options?: vimService.vim.VslmCloneSpec): vimService.vim.VslmCloneSpec;
         };
         VslmCreateSpecBackingSpec: {
            (options?: vimService.vim.VslmCreateSpecBackingSpec): vimService.vim.VslmCreateSpecBackingSpec;
         };
         VslmCreateSpecDiskFileBackingSpec: {
            (options?: vimService.vim.VslmCreateSpecDiskFileBackingSpec): vimService.vim.VslmCreateSpecDiskFileBackingSpec;
         };
         VslmCreateSpecRawDiskMappingBackingSpec: {
            (options?: vimService.vim.VslmCreateSpecRawDiskMappingBackingSpec): vimService.vim.VslmCreateSpecRawDiskMappingBackingSpec;
         };
         VslmCreateSpec: {
            (options?: vimService.vim.VslmCreateSpec): vimService.vim.VslmCreateSpec;
         };
         ID: {
            (options?: vimService.vim.ID): vimService.vim.ID;
         };
         ArrayOfID: {
            (options?: vimService.vim.ArrayOfID): vimService.vim.ArrayOfID;
         };
         VslmMigrateSpec: {
            (options?: vimService.vim.VslmMigrateSpec): vimService.vim.VslmMigrateSpec;
         };
         VslmRelocateSpec: {
            (options?: vimService.vim.VslmRelocateSpec): vimService.vim.VslmRelocateSpec;
         };
         VStorageObjectStateInfo: {
            (options?: vimService.vim.VStorageObjectStateInfo): vimService.vim.VStorageObjectStateInfo;
         };
         VslmTagEntry: {
            (options?: vimService.vim.VslmTagEntry): vimService.vim.VslmTagEntry;
         };
         ArrayOfVslmTagEntry: {
            (options?: vimService.vim.ArrayOfVslmTagEntry): vimService.vim.ArrayOfVslmTagEntry;
         };
         VStorageObjectConsumptionType: {
            "disk": string;
         };
         VStorageObjectConfigInfo: {
            (options?: vimService.vim.VStorageObjectConfigInfo): vimService.vim.VStorageObjectConfigInfo;
         };
         VStorageObject: {
            (options?: vimService.vim.VStorageObject): vimService.vim.VStorageObject;
         };
      }
      vimPort: {
         addAuthorizationRole(_this: vimService.vim.ManagedObjectReference, name: string, privIds: Array<string>): Promise<number>;
         removeAuthorizationRole(_this: vimService.vim.ManagedObjectReference, roleId: number, failIfUsed: boolean): Promise<void>;
         updateAuthorizationRole(_this: vimService.vim.ManagedObjectReference, roleId: number, newName: string, privIds: Array<string>): Promise<void>;
         mergePermissions(_this: vimService.vim.ManagedObjectReference, srcRoleId: number, dstRoleId: number): Promise<void>;
         retrieveRolePermissions(_this: vimService.vim.ManagedObjectReference, roleId: number): Promise<Array<vimService.vim.Permission>>;
         retrieveEntityPermissions(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, inherited: boolean): Promise<Array<vimService.vim.Permission>>;
         retrieveAllPermissions(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.Permission>>;
         setEntityPermissions(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, permission: Array<vimService.vim.Permission>): Promise<void>;
         resetEntityPermissions(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, permission: Array<vimService.vim.Permission>): Promise<void>;
         removeEntityPermission(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, user: string, isGroup: boolean): Promise<void>;
         hasPrivilegeOnEntity(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, sessionId: string, privId: Array<string>): Promise<Array<boolean>>;
         hasPrivilegeOnEntities(_this: vimService.vim.ManagedObjectReference, entity: Array<vimService.vim.ManagedObjectReference>, sessionId: string, privId: Array<string>): Promise<Array<vimService.vim.EntityPrivilege>>;
         hasUserPrivilegeOnEntities(_this: vimService.vim.ManagedObjectReference, entities: Array<vimService.vim.ManagedObjectReference>, userName: string, privId: Array<string>): Promise<Array<vimService.vim.EntityPrivilege>>;
         fetchUserPrivilegeOnEntities(_this: vimService.vim.ManagedObjectReference, entities: Array<vimService.vim.ManagedObjectReference>, userName: string): Promise<Array<vimService.vim.UserPrivilegeResult>>;
         certMgrRefreshCACertificatesAndCRLsTask(_this: vimService.vim.ManagedObjectReference, host: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         certMgrRefreshCertificatesTask(_this: vimService.vim.ManagedObjectReference, host: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         certMgrRevokeCertificatesTask(_this: vimService.vim.ManagedObjectReference, host: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         reconfigureClusterTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.ClusterConfigSpec, modify: boolean): Promise<vimService.vim.ManagedObjectReference>;
         applyRecommendation(_this: vimService.vim.ManagedObjectReference, key: string): Promise<void>;
         cancelRecommendation(_this: vimService.vim.ManagedObjectReference, key: string): Promise<void>;
         recommendHostsForVm(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, pool: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ClusterHostRecommendation>>;
         addHostTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostConnectSpec, asConnected: boolean, resourcePool: vimService.vim.ManagedObjectReference, license: string): Promise<vimService.vim.ManagedObjectReference>;
         moveIntoTask(_this: vimService.vim.ManagedObjectReference, host: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         moveHostIntoTask(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, resourcePool: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         refreshRecommendation(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         evcManager(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         retrieveDasAdvancedRuntimeInfo(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ClusterDasAdvancedRuntimeInfo>;
         clusterEnterMaintenanceMode(_this: vimService.vim.ManagedObjectReference, host: Array<vimService.vim.ManagedObjectReference>, option: Array<vimService.vim.OptionValue>): Promise<vimService.vim.ClusterEnterMaintenanceResult>;
         placeVm(_this: vimService.vim.ManagedObjectReference, placementSpec: vimService.vim.PlacementSpec): Promise<vimService.vim.PlacementResult>;
         findRulesForVm(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ClusterRuleInfo>>;
         stampAllRulesWithUuidTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         getResourceUsage(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ClusterResourceUsageSummary>;
         reconfigureComputeResourceTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.ComputeResourceConfigSpec, modify: boolean): Promise<vimService.vim.ManagedObjectReference>;
         addCustomFieldDef(_this: vimService.vim.ManagedObjectReference, name: string, moType: string, fieldDefPolicy: vimService.vim.PrivilegePolicyDef, fieldPolicy: vimService.vim.PrivilegePolicyDef): Promise<vimService.vim.CustomFieldDef>;
         removeCustomFieldDef(_this: vimService.vim.ManagedObjectReference, key: number): Promise<void>;
         renameCustomFieldDef(_this: vimService.vim.ManagedObjectReference, key: number, name: string): Promise<void>;
         setField(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, key: number, value: string): Promise<void>;
         doesCustomizationSpecExist(_this: vimService.vim.ManagedObjectReference, name: string): Promise<boolean>;
         getCustomizationSpec(_this: vimService.vim.ManagedObjectReference, name: string): Promise<vimService.vim.CustomizationSpecItem>;
         createCustomizationSpec(_this: vimService.vim.ManagedObjectReference, item: vimService.vim.CustomizationSpecItem): Promise<void>;
         overwriteCustomizationSpec(_this: vimService.vim.ManagedObjectReference, item: vimService.vim.CustomizationSpecItem): Promise<void>;
         deleteCustomizationSpec(_this: vimService.vim.ManagedObjectReference, name: string): Promise<void>;
         duplicateCustomizationSpec(_this: vimService.vim.ManagedObjectReference, name: string, newName: string): Promise<void>;
         renameCustomizationSpec(_this: vimService.vim.ManagedObjectReference, name: string, newName: string): Promise<void>;
         customizationSpecItemToXml(_this: vimService.vim.ManagedObjectReference, item: vimService.vim.CustomizationSpecItem): Promise<string>;
         xmlToCustomizationSpecItem(_this: vimService.vim.ManagedObjectReference, specItemXml: string): Promise<vimService.vim.CustomizationSpecItem>;
         checkCustomizationResources(_this: vimService.vim.ManagedObjectReference, guestOs: string): Promise<void>;
         queryConnectionInfo(_this: vimService.vim.ManagedObjectReference, hostname: string, port: number, username: string, password: string, sslThumbprint: string): Promise<vimService.vim.HostConnectInfo>;
         queryConnectionInfoViaSpec(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostConnectSpec): Promise<vimService.vim.HostConnectInfo>;
         powerOnMultiVMTask(_this: vimService.vim.ManagedObjectReference, vm: Array<vimService.vim.ManagedObjectReference>, option: Array<vimService.vim.OptionValue>): Promise<vimService.vim.ManagedObjectReference>;
         queryDatacenterConfigOptionDescriptor(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.VirtualMachineConfigOptionDescriptor>>;
         reconfigureDatacenterTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.DatacenterConfigSpec, modify: boolean): Promise<vimService.vim.ManagedObjectReference>;
         refreshDatastore(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         refreshDatastoreStorageInfo(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         updateVirtualMachineFilesTask(_this: vimService.vim.ManagedObjectReference, mountPathDatastoreMapping: Array<vimService.vim.DatastoreMountPathDatastorePair>): Promise<vimService.vim.ManagedObjectReference>;
         renameDatastore(_this: vimService.vim.ManagedObjectReference, newName: string): Promise<void>;
         destroyDatastore(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         datastoreEnterMaintenanceMode(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.StoragePlacementResult>;
         datastoreExitMaintenanceModeTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         updateVVolVirtualMachineFilesTask(_this: vimService.vim.ManagedObjectReference, failoverPair: Array<vimService.vim.DatastoreVVolContainerFailoverPair>): Promise<vimService.vim.ManagedObjectReference>;
         createDirectory(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference, displayName: string, policy: string): Promise<string>;
         deleteDirectory(_this: vimService.vim.ManagedObjectReference, datacenter: vimService.vim.ManagedObjectReference, datastorePath: string): Promise<void>;
         convertNamespacePathToUuidPath(_this: vimService.vim.ManagedObjectReference, datacenter: vimService.vim.ManagedObjectReference, namespaceUrl: string): Promise<string>;
         queryDescriptions(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.DiagnosticManagerLogDescriptor>>;
         browseDiagnosticLog(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, key: string, start: number, lines: number): Promise<vimService.vim.DiagnosticManagerLogHeader>;
         generateLogBundlesTask(_this: vimService.vim.ManagedObjectReference, includeDefault: boolean, host: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         fetchDVPortKeys(_this: vimService.vim.ManagedObjectReference, criteria: vimService.vim.DistributedVirtualSwitchPortCriteria): Promise<Array<string>>;
         fetchDVPorts(_this: vimService.vim.ManagedObjectReference, criteria: vimService.vim.DistributedVirtualSwitchPortCriteria): Promise<Array<vimService.vim.DistributedVirtualPort>>;
         queryUsedVlanIdInDvs(_this: vimService.vim.ManagedObjectReference): Promise<Array<number>>;
         reconfigureDvsTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.DVSConfigSpec): Promise<vimService.vim.ManagedObjectReference>;
         performDvsProductSpecOperationTask(_this: vimService.vim.ManagedObjectReference, operation: string, productSpec: vimService.vim.DistributedVirtualSwitchProductSpec): Promise<vimService.vim.ManagedObjectReference>;
         mergeDvsTask(_this: vimService.vim.ManagedObjectReference, dvs: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         addDVPortgroupTask(_this: vimService.vim.ManagedObjectReference, spec: Array<vimService.vim.DVPortgroupConfigSpec>): Promise<vimService.vim.ManagedObjectReference>;
         moveDVPortTask(_this: vimService.vim.ManagedObjectReference, portKey: Array<string>, destinationPortgroupKey: string): Promise<vimService.vim.ManagedObjectReference>;
         updateDvsCapability(_this: vimService.vim.ManagedObjectReference, capability: vimService.vim.DVSCapability): Promise<void>;
         reconfigureDVPortTask(_this: vimService.vim.ManagedObjectReference, port: Array<vimService.vim.DVPortConfigSpec>): Promise<vimService.vim.ManagedObjectReference>;
         refreshDVPortState(_this: vimService.vim.ManagedObjectReference, portKeys: Array<string>): Promise<void>;
         rectifyDvsHostTask(_this: vimService.vim.ManagedObjectReference, hosts: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         updateNetworkResourcePool(_this: vimService.vim.ManagedObjectReference, configSpec: Array<vimService.vim.DVSNetworkResourcePoolConfigSpec>): Promise<void>;
         addNetworkResourcePool(_this: vimService.vim.ManagedObjectReference, configSpec: Array<vimService.vim.DVSNetworkResourcePoolConfigSpec>): Promise<void>;
         removeNetworkResourcePool(_this: vimService.vim.ManagedObjectReference, key: Array<string>): Promise<void>;
         dvsReconfigureVmVnicNetworkResourcePoolTask(_this: vimService.vim.ManagedObjectReference, configSpec: Array<vimService.vim.DvsVmVnicResourcePoolConfigSpec>): Promise<vimService.vim.ManagedObjectReference>;
         enableNetworkResourceManagement(_this: vimService.vim.ManagedObjectReference, enable: boolean): Promise<void>;
         dVSRollbackTask(_this: vimService.vim.ManagedObjectReference, entityBackup: vimService.vim.EntityBackupConfig): Promise<vimService.vim.ManagedObjectReference>;
         createDVPortgroupTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.DVPortgroupConfigSpec): Promise<vimService.vim.ManagedObjectReference>;
         updateDVSHealthCheckConfigTask(_this: vimService.vim.ManagedObjectReference, healthCheckConfig: Array<vimService.vim.DVSHealthCheckConfig>): Promise<vimService.vim.ManagedObjectReference>;
         lookupDvPortGroup(_this: vimService.vim.ManagedObjectReference, portgroupKey: string): Promise<vimService.vim.ManagedObjectReference>;
         queryConfigOptionDescriptor(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.VirtualMachineConfigOptionDescriptor>>;
         queryConfigOption(_this: vimService.vim.ManagedObjectReference, key: string, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.VirtualMachineConfigOption>;
         queryConfigOptionEx(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.EnvironmentBrowserConfigOptionQuerySpec): Promise<vimService.vim.VirtualMachineConfigOption>;
         queryConfigTarget(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ConfigTarget>;
         queryTargetCapabilities(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.HostCapability>;
         setCustomValue(_this: vimService.vim.ManagedObjectReference, key: string, value: string): Promise<void>;
         unregisterExtension(_this: vimService.vim.ManagedObjectReference, extensionKey: string): Promise<void>;
         findExtension(_this: vimService.vim.ManagedObjectReference, extensionKey: string): Promise<vimService.vim.Extension>;
         registerExtension(_this: vimService.vim.ManagedObjectReference, extension: vimService.vim.Extension): Promise<void>;
         updateExtension(_this: vimService.vim.ManagedObjectReference, extension: vimService.vim.Extension): Promise<void>;
         getPublicKey(_this: vimService.vim.ManagedObjectReference): Promise<string>;
         setPublicKey(_this: vimService.vim.ManagedObjectReference, extensionKey: string, publicKey: string): Promise<void>;
         setExtensionCertificate(_this: vimService.vim.ManagedObjectReference, extensionKey: string, certificatePem: string): Promise<void>;
         queryManagedBy(_this: vimService.vim.ManagedObjectReference, extensionKey: string): Promise<Array<vimService.vim.ManagedObjectReference>>;
         queryExtensionIpAllocationUsage(_this: vimService.vim.ManagedObjectReference, extensionKeys: Array<string>): Promise<Array<vimService.vim.ExtensionManagerIpAllocationUsage>>;
         moveDatastoreFileTask(_this: vimService.vim.ManagedObjectReference, sourceName: string, sourceDatacenter: vimService.vim.ManagedObjectReference, destinationName: string, destinationDatacenter: vimService.vim.ManagedObjectReference, force: boolean): Promise<vimService.vim.ManagedObjectReference>;
         copyDatastoreFileTask(_this: vimService.vim.ManagedObjectReference, sourceName: string, sourceDatacenter: vimService.vim.ManagedObjectReference, destinationName: string, destinationDatacenter: vimService.vim.ManagedObjectReference, force: boolean): Promise<vimService.vim.ManagedObjectReference>;
         deleteDatastoreFileTask(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         makeDirectory(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference, createParentDirectories: boolean): Promise<void>;
         changeOwner(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference, owner: string): Promise<void>;
         createFolder(_this: vimService.vim.ManagedObjectReference, name: string): Promise<vimService.vim.ManagedObjectReference>;
         moveIntoFolderTask(_this: vimService.vim.ManagedObjectReference, list: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         createVMTask(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.VirtualMachineConfigSpec, pool: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         registerVMTask(_this: vimService.vim.ManagedObjectReference, path: string, name: string, asTemplate: boolean, pool: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         createCluster(_this: vimService.vim.ManagedObjectReference, name: string, spec: vimService.vim.ClusterConfigSpec): Promise<vimService.vim.ManagedObjectReference>;
         createClusterEx(_this: vimService.vim.ManagedObjectReference, name: string, spec: vimService.vim.ClusterConfigSpecEx): Promise<vimService.vim.ManagedObjectReference>;
         addStandaloneHostTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostConnectSpec, compResSpec: vimService.vim.ComputeResourceConfigSpec, addConnected: boolean, license: string): Promise<vimService.vim.ManagedObjectReference>;
         createDatacenter(_this: vimService.vim.ManagedObjectReference, name: string): Promise<vimService.vim.ManagedObjectReference>;
         unregisterAndDestroyTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         createDVSTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.DVSCreateSpec): Promise<vimService.vim.ManagedObjectReference>;
         createStoragePod(_this: vimService.vim.ManagedObjectReference, name: string): Promise<vimService.vim.ManagedObjectReference>;
         registerHealthUpdateProvider(_this: vimService.vim.ManagedObjectReference, name: string, healthUpdateInfo: Array<vimService.vim.HealthUpdateInfo>): Promise<string>;
         unregisterHealthUpdateProvider(_this: vimService.vim.ManagedObjectReference, providerId: string): Promise<void>;
         queryProviderList(_this: vimService.vim.ManagedObjectReference): Promise<Array<string>>;
         hasProvider(_this: vimService.vim.ManagedObjectReference, id: string): Promise<boolean>;
         queryProviderName(_this: vimService.vim.ManagedObjectReference, id: string): Promise<string>;
         queryHealthUpdateInfos(_this: vimService.vim.ManagedObjectReference, providerId: string): Promise<Array<vimService.vim.HealthUpdateInfo>>;
         addMonitoredEntities(_this: vimService.vim.ManagedObjectReference, providerId: string, entities: Array<vimService.vim.ManagedObjectReference>): Promise<void>;
         removeMonitoredEntities(_this: vimService.vim.ManagedObjectReference, providerId: string, entities: Array<vimService.vim.ManagedObjectReference>): Promise<void>;
         queryMonitoredEntities(_this: vimService.vim.ManagedObjectReference, providerId: string): Promise<Array<vimService.vim.ManagedObjectReference>>;
         hasMonitoredEntity(_this: vimService.vim.ManagedObjectReference, providerId: string, entity: vimService.vim.ManagedObjectReference): Promise<boolean>;
         queryUnmonitoredHosts(_this: vimService.vim.ManagedObjectReference, providerId: string, cluster: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ManagedObjectReference>>;
         postHealthUpdates(_this: vimService.vim.ManagedObjectReference, providerId: string, updates: Array<vimService.vim.HealthUpdate>): Promise<void>;
         queryHealthUpdates(_this: vimService.vim.ManagedObjectReference, providerId: string): Promise<Array<vimService.vim.HealthUpdate>>;
         addFilter(_this: vimService.vim.ManagedObjectReference, providerId: string, filterName: string, infoIds: Array<string>): Promise<string>;
         queryFilterList(_this: vimService.vim.ManagedObjectReference, providerId: string): Promise<Array<string>>;
         queryFilterName(_this: vimService.vim.ManagedObjectReference, filterId: string): Promise<string>;
         queryFilterInfoIds(_this: vimService.vim.ManagedObjectReference, filterId: string): Promise<Array<string>>;
         queryFilterEntities(_this: vimService.vim.ManagedObjectReference, filterId: string): Promise<Array<vimService.vim.ManagedObjectReference>>;
         addFilterEntities(_this: vimService.vim.ManagedObjectReference, filterId: string, entities: Array<vimService.vim.ManagedObjectReference>): Promise<void>;
         removeFilterEntities(_this: vimService.vim.ManagedObjectReference, filterId: string, entities: Array<vimService.vim.ManagedObjectReference>): Promise<void>;
         removeFilter(_this: vimService.vim.ManagedObjectReference, filterId: string): Promise<void>;
         setCollectorPageSize(_this: vimService.vim.ManagedObjectReference, maxCount: number): Promise<void>;
         rewindCollector(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         resetCollector(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         destroyCollector(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         queryTpmAttestationReport(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.HostTpmAttestationReport>;
         queryHostConnectionInfo(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.HostConnectInfo>;
         updateSystemResources(_this: vimService.vim.ManagedObjectReference, resourceInfo: vimService.vim.HostSystemResourceInfo): Promise<void>;
         updateSystemSwapConfiguration(_this: vimService.vim.ManagedObjectReference, sysSwapConfig: vimService.vim.HostSystemSwapConfiguration): Promise<void>;
         reconnectHostTask(_this: vimService.vim.ManagedObjectReference, cnxSpec: vimService.vim.HostConnectSpec, reconnectSpec: vimService.vim.HostSystemReconnectSpec): Promise<vimService.vim.ManagedObjectReference>;
         disconnectHostTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         enterMaintenanceModeTask(_this: vimService.vim.ManagedObjectReference, timeout: number, evacuatePoweredOffVms: boolean, maintenanceSpec: vimService.vim.HostMaintenanceSpec): Promise<vimService.vim.ManagedObjectReference>;
         exitMaintenanceModeTask(_this: vimService.vim.ManagedObjectReference, timeout: number): Promise<vimService.vim.ManagedObjectReference>;
         rebootHostTask(_this: vimService.vim.ManagedObjectReference, force: boolean): Promise<vimService.vim.ManagedObjectReference>;
         shutdownHostTask(_this: vimService.vim.ManagedObjectReference, force: boolean): Promise<vimService.vim.ManagedObjectReference>;
         powerDownHostToStandByTask(_this: vimService.vim.ManagedObjectReference, timeoutSec: number, evacuatePoweredOffVms: boolean): Promise<vimService.vim.ManagedObjectReference>;
         powerUpHostFromStandByTask(_this: vimService.vim.ManagedObjectReference, timeoutSec: number): Promise<vimService.vim.ManagedObjectReference>;
         queryMemoryOverhead(_this: vimService.vim.ManagedObjectReference, memorySize: number, videoRamSize: number, numVcpus: number): Promise<number>;
         queryMemoryOverheadEx(_this: vimService.vim.ManagedObjectReference, vmConfigInfo: vimService.vim.VirtualMachineConfigInfo): Promise<number>;
         reconfigureHostForDASTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         updateFlags(_this: vimService.vim.ManagedObjectReference, flagInfo: vimService.vim.HostFlagInfo): Promise<void>;
         enterLockdownMode(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         exitLockdownMode(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         acquireCimServicesTicket(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.HostServiceTicket>;
         updateIpmi(_this: vimService.vim.ManagedObjectReference, ipmiInfo: vimService.vim.HostIpmiInfo): Promise<void>;
         retrieveHardwareUptime(_this: vimService.vim.ManagedObjectReference): Promise<number>;
         prepareCrypto(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         enableCrypto(_this: vimService.vim.ManagedObjectReference, keyPlain: vimService.vim.CryptoKeyPlain): Promise<void>;
         configureCryptoKey(_this: vimService.vim.ManagedObjectReference, keyId: vimService.vim.CryptoKeyId): Promise<void>;
         httpNfcLeaseGetManifest(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.HttpNfcLeaseManifestEntry>>;
         httpNfcLeaseComplete(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         httpNfcLeaseAbort(_this: vimService.vim.ManagedObjectReference, fault: vimService.vim.LocalizedMethodFault): Promise<void>;
         httpNfcLeaseProgress(_this: vimService.vim.ManagedObjectReference, percent: number): Promise<void>;
         installIoFilterTask(_this: vimService.vim.ManagedObjectReference, vibUrl: string, compRes: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         uninstallIoFilterTask(_this: vimService.vim.ManagedObjectReference, filterId: string, compRes: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         upgradeIoFilterTask(_this: vimService.vim.ManagedObjectReference, filterId: string, compRes: vimService.vim.ManagedObjectReference, vibUrl: string): Promise<vimService.vim.ManagedObjectReference>;
         queryIoFilterIssues(_this: vimService.vim.ManagedObjectReference, filterId: string, compRes: vimService.vim.ManagedObjectReference): Promise<vimService.vim.IoFilterQueryIssueResult>;
         queryIoFilterInfo(_this: vimService.vim.ManagedObjectReference, compRes: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ClusterIoFilterInfo>>;
         resolveInstallationErrorsOnHostTask(_this: vimService.vim.ManagedObjectReference, filterId: string, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         resolveInstallationErrorsOnClusterTask(_this: vimService.vim.ManagedObjectReference, filterId: string, cluster: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         queryDisksUsingFilter(_this: vimService.vim.ManagedObjectReference, filterId: string, compRes: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.VirtualDiskId>>;
         queryIpPools(_this: vimService.vim.ManagedObjectReference, dc: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.IpPool>>;
         createIpPool(_this: vimService.vim.ManagedObjectReference, dc: vimService.vim.ManagedObjectReference, pool: vimService.vim.IpPool): Promise<number>;
         updateIpPool(_this: vimService.vim.ManagedObjectReference, dc: vimService.vim.ManagedObjectReference, pool: vimService.vim.IpPool): Promise<void>;
         destroyIpPool(_this: vimService.vim.ManagedObjectReference, dc: vimService.vim.ManagedObjectReference, id: number, force: boolean): Promise<void>;
         allocateIpv4Address(_this: vimService.vim.ManagedObjectReference, dc: vimService.vim.ManagedObjectReference, poolId: number, allocationId: string): Promise<string>;
         allocateIpv6Address(_this: vimService.vim.ManagedObjectReference, dc: vimService.vim.ManagedObjectReference, poolId: number, allocationId: string): Promise<string>;
         releaseIpAllocation(_this: vimService.vim.ManagedObjectReference, dc: vimService.vim.ManagedObjectReference, poolId: number, allocationId: string): Promise<void>;
         queryIPAllocations(_this: vimService.vim.ManagedObjectReference, dc: vimService.vim.ManagedObjectReference, poolId: number, extensionKey: string): Promise<Array<vimService.vim.IpPoolManagerIpAllocation>>;
         updateAssignedLicense(_this: vimService.vim.ManagedObjectReference, entity: string, licenseKey: string, entityDisplayName: string): Promise<vimService.vim.LicenseManagerLicenseInfo>;
         removeAssignedLicense(_this: vimService.vim.ManagedObjectReference, entityId: string): Promise<void>;
         queryAssignedLicenses(_this: vimService.vim.ManagedObjectReference, entityId: string): Promise<Array<vimService.vim.LicenseAssignmentManagerLicenseAssignment>>;
         querySupportedFeatures(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.LicenseFeatureInfo>>;
         queryLicenseSourceAvailability(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.LicenseAvailabilityInfo>>;
         queryLicenseUsage(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.LicenseUsageInfo>;
         setLicenseEdition(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, featureKey: string): Promise<void>;
         checkLicenseFeature(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, featureKey: string): Promise<boolean>;
         enableFeature(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, featureKey: string): Promise<boolean>;
         disableFeature(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, featureKey: string): Promise<boolean>;
         configureLicenseSource(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, licenseSource: vimService.vim.LicenseSource): Promise<void>;
         updateLicense(_this: vimService.vim.ManagedObjectReference, licenseKey: string, labels: Array<vimService.vim.KeyValue>): Promise<vimService.vim.LicenseManagerLicenseInfo>;
         addLicense(_this: vimService.vim.ManagedObjectReference, licenseKey: string, labels: Array<vimService.vim.KeyValue>): Promise<vimService.vim.LicenseManagerLicenseInfo>;
         removeLicense(_this: vimService.vim.ManagedObjectReference, licenseKey: string): Promise<void>;
         decodeLicense(_this: vimService.vim.ManagedObjectReference, licenseKey: string): Promise<vimService.vim.LicenseManagerLicenseInfo>;
         updateLicenseLabel(_this: vimService.vim.ManagedObjectReference, licenseKey: string, labelKey: string, labelValue: string): Promise<void>;
         removeLicenseLabel(_this: vimService.vim.ManagedObjectReference, licenseKey: string, labelKey: string): Promise<void>;
         reload(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         renameTask(_this: vimService.vim.ManagedObjectReference, newName: string): Promise<vimService.vim.ManagedObjectReference>;
         destroyTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         destroyNetwork(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         lookupVmOverheadMemory(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<number>;
         validateHost(_this: vimService.vim.ManagedObjectReference, ovfDescriptor: string, host: vimService.vim.ManagedObjectReference, vhp: vimService.vim.OvfValidateHostParams): Promise<vimService.vim.OvfValidateHostResult>;
         parseDescriptor(_this: vimService.vim.ManagedObjectReference, ovfDescriptor: string, pdp: vimService.vim.OvfParseDescriptorParams): Promise<vimService.vim.OvfParseDescriptorResult>;
         createImportSpec(_this: vimService.vim.ManagedObjectReference, ovfDescriptor: string, resourcePool: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference, cisp: vimService.vim.OvfCreateImportSpecParams): Promise<vimService.vim.OvfCreateImportSpecResult>;
         createDescriptor(_this: vimService.vim.ManagedObjectReference, obj: vimService.vim.ManagedObjectReference, cdp: vimService.vim.OvfCreateDescriptorParams): Promise<vimService.vim.OvfCreateDescriptorResult>;
         queryPerfProviderSummary(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference): Promise<vimService.vim.PerfProviderSummary>;
         queryAvailablePerfMetric(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, beginTime: Date, endTime: Date, intervalId: number): Promise<Array<vimService.vim.PerfMetricId>>;
         queryPerfCounter(_this: vimService.vim.ManagedObjectReference, counterId: Array<number>): Promise<Array<vimService.vim.PerfCounterInfo>>;
         queryPerfCounterByLevel(_this: vimService.vim.ManagedObjectReference, level: number): Promise<Array<vimService.vim.PerfCounterInfo>>;
         queryPerf(_this: vimService.vim.ManagedObjectReference, querySpec: Array<vimService.vim.PerfQuerySpec>): Promise<Array<vimService.vim.PerfEntityMetricBase>>;
         queryPerfComposite(_this: vimService.vim.ManagedObjectReference, querySpec: vimService.vim.PerfQuerySpec): Promise<vimService.vim.PerfCompositeMetric>;
         createPerfInterval(_this: vimService.vim.ManagedObjectReference, intervalId: vimService.vim.PerfInterval): Promise<void>;
         removePerfInterval(_this: vimService.vim.ManagedObjectReference, samplePeriod: number): Promise<void>;
         updatePerfInterval(_this: vimService.vim.ManagedObjectReference, interval: vimService.vim.PerfInterval): Promise<void>;
         updateCounterLevelMapping(_this: vimService.vim.ManagedObjectReference, counterLevelMap: Array<vimService.vim.PerformanceManagerCounterLevelMapping>): Promise<void>;
         resetCounterLevelMapping(_this: vimService.vim.ManagedObjectReference, counters: Array<number>): Promise<void>;
         estimateDatabaseSize(_this: vimService.vim.ManagedObjectReference, dbSizeParam: vimService.vim.DatabaseSizeParam): Promise<vimService.vim.DatabaseSizeEstimate>;
         updateConfig(_this: vimService.vim.ManagedObjectReference, name: string, config: vimService.vim.ResourceConfigSpec): Promise<void>;
         moveIntoResourcePool(_this: vimService.vim.ManagedObjectReference, list: Array<vimService.vim.ManagedObjectReference>): Promise<void>;
         updateChildResourceConfiguration(_this: vimService.vim.ManagedObjectReference, spec: Array<vimService.vim.ResourceConfigSpec>): Promise<void>;
         createResourcePool(_this: vimService.vim.ManagedObjectReference, name: string, spec: vimService.vim.ResourceConfigSpec): Promise<vimService.vim.ManagedObjectReference>;
         destroyChildren(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         createVApp(_this: vimService.vim.ManagedObjectReference, name: string, resSpec: vimService.vim.ResourceConfigSpec, configSpec: vimService.vim.VAppConfigSpec, vmFolder: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         createChildVMTask(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.VirtualMachineConfigSpec, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         registerChildVMTask(_this: vimService.vim.ManagedObjectReference, path: string, name: string, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         importVApp(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.ImportSpec, folder: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         queryResourceConfigOption(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ResourceConfigOption>;
         refreshRuntime(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         findByUuid(_this: vimService.vim.ManagedObjectReference, datacenter: vimService.vim.ManagedObjectReference, uuid: string, vmSearch: boolean, instanceUuid: boolean): Promise<vimService.vim.ManagedObjectReference>;
         findByDatastorePath(_this: vimService.vim.ManagedObjectReference, datacenter: vimService.vim.ManagedObjectReference, path: string): Promise<vimService.vim.ManagedObjectReference>;
         findByDnsName(_this: vimService.vim.ManagedObjectReference, datacenter: vimService.vim.ManagedObjectReference, dnsName: string, vmSearch: boolean): Promise<vimService.vim.ManagedObjectReference>;
         findByIp(_this: vimService.vim.ManagedObjectReference, datacenter: vimService.vim.ManagedObjectReference, ip: string, vmSearch: boolean): Promise<vimService.vim.ManagedObjectReference>;
         findByInventoryPath(_this: vimService.vim.ManagedObjectReference, inventoryPath: string): Promise<vimService.vim.ManagedObjectReference>;
         findChild(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, name: string): Promise<vimService.vim.ManagedObjectReference>;
         findAllByUuid(_this: vimService.vim.ManagedObjectReference, datacenter: vimService.vim.ManagedObjectReference, uuid: string, vmSearch: boolean, instanceUuid: boolean): Promise<Array<vimService.vim.ManagedObjectReference>>;
         findAllByDnsName(_this: vimService.vim.ManagedObjectReference, datacenter: vimService.vim.ManagedObjectReference, dnsName: string, vmSearch: boolean): Promise<Array<vimService.vim.ManagedObjectReference>>;
         findAllByIp(_this: vimService.vim.ManagedObjectReference, datacenter: vimService.vim.ManagedObjectReference, ip: string, vmSearch: boolean): Promise<Array<vimService.vim.ManagedObjectReference>>;
         currentTime(_this: vimService.vim.ManagedObjectReference): Promise<Date>;
         retrieveServiceContent(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ServiceContent>;
         validateMigration(_this: vimService.vim.ManagedObjectReference, vm: Array<vimService.vim.ManagedObjectReference>, state: vimService.vim.VirtualMachinePowerState, testType: Array<string>, pool: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.Event>>;
         queryVMotionCompatibility(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, host: Array<vimService.vim.ManagedObjectReference>, compatibility: Array<string>): Promise<Array<vimService.vim.HostVMotionCompatibility>>;
         retrieveProductComponents(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ProductComponentInfo>>;
         queryServiceList(_this: vimService.vim.ManagedObjectReference, serviceName: string, location: Array<string>): Promise<Array<vimService.vim.ServiceManagerServiceInfo>>;
         updateServiceMessage(_this: vimService.vim.ManagedObjectReference, message: string): Promise<void>;
         loginByToken(_this: vimService.vim.ManagedObjectReference, locale: string): Promise<vimService.vim.UserSession>;
         login(_this: vimService.vim.ManagedObjectReference, userName: string, password: string, locale: string): Promise<vimService.vim.UserSession>;
         loginBySSPI(_this: vimService.vim.ManagedObjectReference, base64Token: string, locale: string): Promise<vimService.vim.UserSession>;
         logout(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         acquireLocalTicket(_this: vimService.vim.ManagedObjectReference, userName: string): Promise<vimService.vim.SessionManagerLocalTicket>;
         acquireGenericServiceTicket(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.SessionManagerServiceRequestSpec): Promise<vimService.vim.SessionManagerGenericServiceTicket>;
         terminateSession(_this: vimService.vim.ManagedObjectReference, sessionId: Array<string>): Promise<void>;
         setLocale(_this: vimService.vim.ManagedObjectReference, locale: string): Promise<void>;
         loginExtensionBySubjectName(_this: vimService.vim.ManagedObjectReference, extensionKey: string, locale: string): Promise<vimService.vim.UserSession>;
         loginExtensionByCertificate(_this: vimService.vim.ManagedObjectReference, extensionKey: string, locale: string): Promise<vimService.vim.UserSession>;
         impersonateUser(_this: vimService.vim.ManagedObjectReference, userName: string, locale: string): Promise<vimService.vim.UserSession>;
         sessionIsActive(_this: vimService.vim.ManagedObjectReference, sessionID: string, userName: string): Promise<boolean>;
         acquireCloneTicket(_this: vimService.vim.ManagedObjectReference): Promise<string>;
         cloneSession(_this: vimService.vim.ManagedObjectReference, cloneTicket: string): Promise<vimService.vim.UserSession>;
         executeSimpleCommand(_this: vimService.vim.ManagedObjectReference, argumentsb: Array<string>): Promise<string>;
         configureDatastoreIORMTask(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference, spec: vimService.vim.StorageIORMConfigSpec): Promise<vimService.vim.ManagedObjectReference>;
         queryIORMConfigOption(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.StorageIORMConfigOption>;
         queryDatastorePerformanceSummary(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.StoragePerformanceSummary>>;
         applyStorageDrsRecommendationToPodTask(_this: vimService.vim.ManagedObjectReference, pod: vimService.vim.ManagedObjectReference, key: string): Promise<vimService.vim.ManagedObjectReference>;
         applyStorageDrsRecommendationTask(_this: vimService.vim.ManagedObjectReference, key: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         cancelStorageDrsRecommendation(_this: vimService.vim.ManagedObjectReference, key: Array<string>): Promise<void>;
         refreshStorageDrsRecommendation(_this: vimService.vim.ManagedObjectReference, pod: vimService.vim.ManagedObjectReference): Promise<void>;
         configureStorageDrsForPodTask(_this: vimService.vim.ManagedObjectReference, pod: vimService.vim.ManagedObjectReference, spec: vimService.vim.StorageDrsConfigSpec, modify: boolean): Promise<vimService.vim.ManagedObjectReference>;
         recommendDatastores(_this: vimService.vim.ManagedObjectReference, storageSpec: vimService.vim.StoragePlacementSpec): Promise<vimService.vim.StoragePlacementResult>;
         cancelTask(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         updateProgress(_this: vimService.vim.ManagedObjectReference, percentDone: number): Promise<void>;
         setTaskState(_this: vimService.vim.ManagedObjectReference, state: vimService.vim.TaskInfoState, result: any, fault: vimService.vim.LocalizedMethodFault): Promise<void>;
         setTaskDescription(_this: vimService.vim.ManagedObjectReference, description: vimService.vim.LocalizableMessage): Promise<void>;
         readNextTasks(_this: vimService.vim.ManagedObjectReference, maxCount: number): Promise<Array<vimService.vim.TaskInfo>>;
         readPreviousTasks(_this: vimService.vim.ManagedObjectReference, maxCount: number): Promise<Array<vimService.vim.TaskInfo>>;
         createCollectorForTasks(_this: vimService.vim.ManagedObjectReference, filter: vimService.vim.TaskFilterSpec): Promise<vimService.vim.ManagedObjectReference>;
         createTask(_this: vimService.vim.ManagedObjectReference, obj: vimService.vim.ManagedObjectReference, taskTypeId: string, initiatedBy: string, cancelable: boolean, parentTaskKey: string, activationId: string): Promise<vimService.vim.TaskInfo>;
         retrieveUserGroups(_this: vimService.vim.ManagedObjectReference, domain: string, searchStr: string, belongsToGroup: string, belongsToUser: string, exactMatch: boolean, findUsers: boolean, findGroups: boolean): Promise<Array<vimService.vim.UserSearchResult>>;
         updateVAppConfig(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.VAppConfigSpec): Promise<void>;
         updateLinkedChildren(_this: vimService.vim.ManagedObjectReference, addChangeSet: Array<vimService.vim.VirtualAppLinkInfo>, removeSet: Array<vimService.vim.ManagedObjectReference>): Promise<void>;
         cloneVAppTask(_this: vimService.vim.ManagedObjectReference, name: string, target: vimService.vim.ManagedObjectReference, spec: vimService.vim.VAppCloneSpec): Promise<vimService.vim.ManagedObjectReference>;
         exportVApp(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         powerOnVAppTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         powerOffVAppTask(_this: vimService.vim.ManagedObjectReference, force: boolean): Promise<vimService.vim.ManagedObjectReference>;
         suspendVAppTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         unregisterVAppTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         createVirtualDiskTask(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference, spec: vimService.vim.VirtualDiskSpec): Promise<vimService.vim.ManagedObjectReference>;
         deleteVirtualDiskTask(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         moveVirtualDiskTask(_this: vimService.vim.ManagedObjectReference, sourceName: string, sourceDatacenter: vimService.vim.ManagedObjectReference, destName: string, destDatacenter: vimService.vim.ManagedObjectReference, force: boolean, profile: Array<vimService.vim.VirtualMachineProfileSpec>): Promise<vimService.vim.ManagedObjectReference>;
         copyVirtualDiskTask(_this: vimService.vim.ManagedObjectReference, sourceName: string, sourceDatacenter: vimService.vim.ManagedObjectReference, destName: string, destDatacenter: vimService.vim.ManagedObjectReference, destSpec: vimService.vim.VirtualDiskSpec, force: boolean): Promise<vimService.vim.ManagedObjectReference>;
         extendVirtualDiskTask(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference, newCapacityKb: number, eagerZero: boolean): Promise<vimService.vim.ManagedObjectReference>;
         queryVirtualDiskFragmentation(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference): Promise<number>;
         defragmentVirtualDiskTask(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         shrinkVirtualDiskTask(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference, copy: boolean): Promise<vimService.vim.ManagedObjectReference>;
         inflateVirtualDiskTask(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         eagerZeroVirtualDiskTask(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         zeroFillVirtualDiskTask(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         setVirtualDiskUuid(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference, uuid: string): Promise<void>;
         queryVirtualDiskUuid(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference): Promise<string>;
         queryVirtualDiskGeometry(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference): Promise<vimService.vim.HostDiskDimensionsChs>;
         importUnmanagedSnapshot(_this: vimService.vim.ManagedObjectReference, vdisk: string, datacenter: vimService.vim.ManagedObjectReference, vvolId: string): Promise<void>;
         releaseManagedSnapshot(_this: vimService.vim.ManagedObjectReference, vdisk: string, datacenter: vimService.vim.ManagedObjectReference): Promise<void>;
         refreshStorageInfo(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         createSnapshotTask(_this: vimService.vim.ManagedObjectReference, name: string, description: string, memory: boolean, quiesce: boolean): Promise<vimService.vim.ManagedObjectReference>;
         createSnapshotExTask(_this: vimService.vim.ManagedObjectReference, name: string, description: string, memory: boolean, quiesceSpec: vimService.vim.VirtualMachineGuestQuiesceSpec): Promise<vimService.vim.ManagedObjectReference>;
         revertToCurrentSnapshotTask(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, suppressPowerOn: boolean): Promise<vimService.vim.ManagedObjectReference>;
         removeAllSnapshotsTask(_this: vimService.vim.ManagedObjectReference, consolidate: boolean): Promise<vimService.vim.ManagedObjectReference>;
         consolidateVMDisksTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         estimateStorageForConsolidateSnapshotsTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         reconfigVMTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.VirtualMachineConfigSpec): Promise<vimService.vim.ManagedObjectReference>;
         upgradeVMTask(_this: vimService.vim.ManagedObjectReference, version: string): Promise<vimService.vim.ManagedObjectReference>;
         extractOvfEnvironment(_this: vimService.vim.ManagedObjectReference): Promise<string>;
         powerOnVMTask(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         powerOffVMTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         suspendVMTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         resetVMTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         shutdownGuest(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         rebootGuest(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         standbyGuest(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         answerVM(_this: vimService.vim.ManagedObjectReference, questionId: string, answerChoice: string): Promise<void>;
         customizeVMTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.CustomizationSpec): Promise<vimService.vim.ManagedObjectReference>;
         checkCustomizationSpec(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.CustomizationSpec): Promise<void>;
         migrateVMTask(_this: vimService.vim.ManagedObjectReference, pool: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, priority: vimService.vim.VirtualMachineMovePriority, state: vimService.vim.VirtualMachinePowerState): Promise<vimService.vim.ManagedObjectReference>;
         relocateVMTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.VirtualMachineRelocateSpec, priority: vimService.vim.VirtualMachineMovePriority): Promise<vimService.vim.ManagedObjectReference>;
         cloneVMTask(_this: vimService.vim.ManagedObjectReference, folder: vimService.vim.ManagedObjectReference, name: string, spec: vimService.vim.VirtualMachineCloneSpec): Promise<vimService.vim.ManagedObjectReference>;
         exportVm(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         markAsTemplate(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         markAsVirtualMachine(_this: vimService.vim.ManagedObjectReference, pool: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<void>;
         unregisterVM(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         resetGuestInformation(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         mountToolsInstaller(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         unmountToolsInstaller(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         upgradeToolsTask(_this: vimService.vim.ManagedObjectReference, installerOptions: string): Promise<vimService.vim.ManagedObjectReference>;
         acquireMksTicket(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.VirtualMachineMksTicket>;
         acquireTicket(_this: vimService.vim.ManagedObjectReference, ticketType: string): Promise<vimService.vim.VirtualMachineTicket>;
         setScreenResolution(_this: vimService.vim.ManagedObjectReference, width: number, height: number): Promise<void>;
         defragmentAllDisks(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         createSecondaryVMTask(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         createSecondaryVMExTask(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, spec: vimService.vim.FaultToleranceConfigSpec): Promise<vimService.vim.ManagedObjectReference>;
         turnOffFaultToleranceForVMTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         makePrimaryVMTask(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         terminateFaultTolerantVMTask(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         disableSecondaryVMTask(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         enableSecondaryVMTask(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         setDisplayTopology(_this: vimService.vim.ManagedObjectReference, displays: Array<vimService.vim.VirtualMachineDisplayTopology>): Promise<void>;
         startRecordingTask(_this: vimService.vim.ManagedObjectReference, name: string, description: string): Promise<vimService.vim.ManagedObjectReference>;
         stopRecordingTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         startReplayingTask(_this: vimService.vim.ManagedObjectReference, replaySnapshot: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         stopReplayingTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         promoteDisksTask(_this: vimService.vim.ManagedObjectReference, unlink: boolean, disks: Array<vimService.vim.VirtualDisk>): Promise<vimService.vim.ManagedObjectReference>;
         createScreenshotTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         putUsbScanCodes(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.UsbScanCodeSpec): Promise<number>;
         queryChangedDiskAreas(_this: vimService.vim.ManagedObjectReference, snapshot: vimService.vim.ManagedObjectReference, deviceKey: number, startOffset: number, changeId: string): Promise<vimService.vim.DiskChangeInfo>;
         queryUnownedFiles(_this: vimService.vim.ManagedObjectReference): Promise<Array<string>>;
         reloadVirtualMachineFromPathTask(_this: vimService.vim.ManagedObjectReference, configurationPath: string): Promise<vimService.vim.ManagedObjectReference>;
         queryFaultToleranceCompatibility(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.LocalizedMethodFault>>;
         queryFaultToleranceCompatibilityEx(_this: vimService.vim.ManagedObjectReference, forLegacyFt: boolean): Promise<Array<vimService.vim.LocalizedMethodFault>>;
         terminateVM(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         sendNMI(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         attachDiskTask(_this: vimService.vim.ManagedObjectReference, diskId: string, datastore: vimService.vim.ManagedObjectReference, controllerKey: number, unitNumber: number): Promise<vimService.vim.ManagedObjectReference>;
         detachDiskTask(_this: vimService.vim.ManagedObjectReference, diskId: string): Promise<vimService.vim.ManagedObjectReference>;
         performVsanUpgradePreflightCheck(_this: vimService.vim.ManagedObjectReference, cluster: vimService.vim.ManagedObjectReference, downgradeFormat: boolean): Promise<vimService.vim.VsanUpgradeSystemPreflightCheckResult>;
         queryVsanUpgradeStatus(_this: vimService.vim.ManagedObjectReference, cluster: vimService.vim.ManagedObjectReference): Promise<vimService.vim.VsanUpgradeSystemUpgradeStatus>;
         performVsanUpgradeTask(_this: vimService.vim.ManagedObjectReference, cluster: vimService.vim.ManagedObjectReference, performObjectUpgrade: boolean, downgradeFormat: boolean, allowReducedRedundancy: boolean, excludeHosts: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         removeAlarm(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         reconfigureAlarm(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.AlarmSpec): Promise<void>;
         createAlarm(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, spec: vimService.vim.AlarmSpec): Promise<vimService.vim.ManagedObjectReference>;
         getAlarm(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ManagedObjectReference>>;
         areAlarmActionsEnabled(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference): Promise<boolean>;
         enableAlarmActions(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, enabled: boolean): Promise<void>;
         getAlarmState(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.AlarmState>>;
         acknowledgeAlarm(_this: vimService.vim.ManagedObjectReference, alarm: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference): Promise<void>;
         configureEvcModeTask(_this: vimService.vim.ManagedObjectReference, evcModeKey: string): Promise<vimService.vim.ManagedObjectReference>;
         disableEvcModeTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         checkConfigureEvcModeTask(_this: vimService.vim.ManagedObjectReference, evcModeKey: string): Promise<vimService.vim.ManagedObjectReference>;
         checkAddHostEvcTask(_this: vimService.vim.ManagedObjectReference, cnxSpec: vimService.vim.HostConnectSpec): Promise<vimService.vim.ManagedObjectReference>;
         reconfigureDVPortgroupTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.DVPortgroupConfigSpec): Promise<vimService.vim.ManagedObjectReference>;
         dVPortgroupRollbackTask(_this: vimService.vim.ManagedObjectReference, entityBackup: vimService.vim.EntityBackupConfig): Promise<vimService.vim.ManagedObjectReference>;
         queryAvailableDvsSpec(_this: vimService.vim.ManagedObjectReference, recommended: boolean): Promise<Array<vimService.vim.DistributedVirtualSwitchProductSpec>>;
         queryCompatibleHostForNewDvs(_this: vimService.vim.ManagedObjectReference, container: vimService.vim.ManagedObjectReference, recursive: boolean, switchProductSpec: vimService.vim.DistributedVirtualSwitchProductSpec): Promise<Array<vimService.vim.ManagedObjectReference>>;
         queryCompatibleHostForExistingDvs(_this: vimService.vim.ManagedObjectReference, container: vimService.vim.ManagedObjectReference, recursive: boolean, dvs: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ManagedObjectReference>>;
         queryDvsCompatibleHostSpec(_this: vimService.vim.ManagedObjectReference, switchProductSpec: vimService.vim.DistributedVirtualSwitchProductSpec): Promise<Array<vimService.vim.DistributedVirtualSwitchHostProductSpec>>;
         queryDvsFeatureCapability(_this: vimService.vim.ManagedObjectReference, switchProductSpec: vimService.vim.DistributedVirtualSwitchProductSpec): Promise<vimService.vim.DVSFeatureCapability>;
         queryDvsByUuid(_this: vimService.vim.ManagedObjectReference, uuid: string): Promise<vimService.vim.ManagedObjectReference>;
         queryDvsConfigTarget(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, dvs: vimService.vim.ManagedObjectReference): Promise<vimService.vim.DVSManagerDvsConfigTarget>;
         queryDvsCheckCompatibility(_this: vimService.vim.ManagedObjectReference, hostContainer: vimService.vim.DistributedVirtualSwitchManagerHostContainer, dvsProductSpec: vimService.vim.DistributedVirtualSwitchManagerDvsProductSpec, hostFilterSpec: Array<vimService.vim.DistributedVirtualSwitchManagerHostDvsFilterSpec>): Promise<Array<vimService.vim.DistributedVirtualSwitchManagerCompatibilityResult>>;
         rectifyDvsOnHostTask(_this: vimService.vim.ManagedObjectReference, hosts: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         dVSManagerExportEntityTask(_this: vimService.vim.ManagedObjectReference, selectionSet: Array<vimService.vim.SelectionSet>): Promise<vimService.vim.ManagedObjectReference>;
         dVSManagerImportEntityTask(_this: vimService.vim.ManagedObjectReference, entityBackup: Array<vimService.vim.EntityBackupConfig>, importType: string): Promise<vimService.vim.ManagedObjectReference>;
         dVSManagerLookupDvPortGroup(_this: vimService.vim.ManagedObjectReference, switchUuid: string, portgroupKey: string): Promise<vimService.vim.ManagedObjectReference>;
         updateDVSLacpGroupConfigTask(_this: vimService.vim.ManagedObjectReference, lacpGroupSpec: Array<vimService.vim.VMwareDvsLacpGroupSpec>): Promise<vimService.vim.ManagedObjectReference>;
         addKey(_this: vimService.vim.ManagedObjectReference, key: vimService.vim.CryptoKeyPlain): Promise<void>;
         addKeys(_this: vimService.vim.ManagedObjectReference, keys: Array<vimService.vim.CryptoKeyPlain>): Promise<Array<vimService.vim.CryptoKeyResult>>;
         removeKey(_this: vimService.vim.ManagedObjectReference, key: vimService.vim.CryptoKeyId, force: boolean): Promise<void>;
         removeKeys(_this: vimService.vim.ManagedObjectReference, keys: Array<vimService.vim.CryptoKeyId>, force: boolean): Promise<Array<vimService.vim.CryptoKeyResult>>;
         listKeys(_this: vimService.vim.ManagedObjectReference, limit: number): Promise<Array<vimService.vim.CryptoKeyId>>;
         registerKmipServer(_this: vimService.vim.ManagedObjectReference, server: vimService.vim.KmipServerSpec): Promise<void>;
         markDefault(_this: vimService.vim.ManagedObjectReference, clusterId: vimService.vim.KeyProviderId): Promise<void>;
         updateKmipServer(_this: vimService.vim.ManagedObjectReference, server: vimService.vim.KmipServerSpec): Promise<void>;
         removeKmipServer(_this: vimService.vim.ManagedObjectReference, clusterId: vimService.vim.KeyProviderId, serverName: string): Promise<void>;
         listKmipServers(_this: vimService.vim.ManagedObjectReference, limit: number): Promise<Array<vimService.vim.KmipClusterInfo>>;
         retrieveKmipServersStatusTask(_this: vimService.vim.ManagedObjectReference, clusters: Array<vimService.vim.KmipClusterInfo>): Promise<vimService.vim.ManagedObjectReference>;
         generateKey(_this: vimService.vim.ManagedObjectReference, keyProvider: vimService.vim.KeyProviderId): Promise<vimService.vim.CryptoKeyResult>;
         retrieveKmipServerCert(_this: vimService.vim.ManagedObjectReference, keyProvider: vimService.vim.KeyProviderId, server: vimService.vim.KmipServerInfo): Promise<vimService.vim.CryptoManagerKmipServerCertInfo>;
         uploadKmipServerCert(_this: vimService.vim.ManagedObjectReference, cluster: vimService.vim.KeyProviderId, certificate: string): Promise<void>;
         generateSelfSignedClientCert(_this: vimService.vim.ManagedObjectReference, cluster: vimService.vim.KeyProviderId): Promise<string>;
         generateClientCsr(_this: vimService.vim.ManagedObjectReference, cluster: vimService.vim.KeyProviderId): Promise<string>;
         retrieveSelfSignedClientCert(_this: vimService.vim.ManagedObjectReference, cluster: vimService.vim.KeyProviderId): Promise<string>;
         retrieveClientCsr(_this: vimService.vim.ManagedObjectReference, cluster: vimService.vim.KeyProviderId): Promise<string>;
         retrieveClientCert(_this: vimService.vim.ManagedObjectReference, cluster: vimService.vim.KeyProviderId): Promise<string>;
         updateSelfSignedClientCert(_this: vimService.vim.ManagedObjectReference, cluster: vimService.vim.KeyProviderId, certificate: string): Promise<void>;
         updateKmsSignedCsrClientCert(_this: vimService.vim.ManagedObjectReference, cluster: vimService.vim.KeyProviderId, certificate: string): Promise<void>;
         uploadClientCert(_this: vimService.vim.ManagedObjectReference, cluster: vimService.vim.KeyProviderId, certificate: string, privateKey: string): Promise<void>;
         readNextEvents(_this: vimService.vim.ManagedObjectReference, maxCount: number): Promise<Array<vimService.vim.Event>>;
         readPreviousEvents(_this: vimService.vim.ManagedObjectReference, maxCount: number): Promise<Array<vimService.vim.Event>>;
         retrieveArgumentDescription(_this: vimService.vim.ManagedObjectReference, eventTypeId: string): Promise<Array<vimService.vim.EventArgDesc>>;
         createCollectorForEvents(_this: vimService.vim.ManagedObjectReference, filter: vimService.vim.EventFilterSpec): Promise<vimService.vim.ManagedObjectReference>;
         logUserEvent(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, msg: string): Promise<void>;
         queryEvents(_this: vimService.vim.ManagedObjectReference, filter: vimService.vim.EventFilterSpec): Promise<Array<vimService.vim.Event>>;
         postEvent(_this: vimService.vim.ManagedObjectReference, eventToPost: vimService.vim.Event, taskInfo: vimService.vim.TaskInfo): Promise<void>;
         joinDomainTask(_this: vimService.vim.ManagedObjectReference, domainName: string, userName: string, password: string): Promise<vimService.vim.ManagedObjectReference>;
         joinDomainWithCAMTask(_this: vimService.vim.ManagedObjectReference, domainName: string, camServer: string): Promise<vimService.vim.ManagedObjectReference>;
         importCertificateForCAMTask(_this: vimService.vim.ManagedObjectReference, certPath: string, camServer: string): Promise<vimService.vim.ManagedObjectReference>;
         leaveCurrentDomainTask(_this: vimService.vim.ManagedObjectReference, force: boolean): Promise<vimService.vim.ManagedObjectReference>;
         enableSmartCardAuthentication(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         installSmartCardTrustAnchor(_this: vimService.vim.ManagedObjectReference, cert: string): Promise<void>;
         replaceSmartCardTrustAnchors(_this: vimService.vim.ManagedObjectReference, certs: Array<string>): Promise<void>;
         removeSmartCardTrustAnchor(_this: vimService.vim.ManagedObjectReference, issuer: string, serial: string): Promise<void>;
         removeSmartCardTrustAnchorByFingerprint(_this: vimService.vim.ManagedObjectReference, fingerprint: string, digest: string): Promise<void>;
         listSmartCardTrustAnchors(_this: vimService.vim.ManagedObjectReference): Promise<Array<string>>;
         disableSmartCardAuthentication(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         reconfigureAutostart(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostAutoStartManagerConfig): Promise<void>;
         autoStartPowerOn(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         autoStartPowerOff(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         queryBootDevices(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.HostBootDeviceInfo>;
         updateBootDevice(_this: vimService.vim.ManagedObjectReference, key: string): Promise<void>;
         configureHostCacheTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostCacheConfigurationSpec): Promise<vimService.vim.ManagedObjectReference>;
         generateCertificateSigningRequest(_this: vimService.vim.ManagedObjectReference, useIpAddressAsCommonName: boolean): Promise<string>;
         generateCertificateSigningRequestByDn(_this: vimService.vim.ManagedObjectReference, distinguishedName: string): Promise<string>;
         installServerCertificate(_this: vimService.vim.ManagedObjectReference, cert: string): Promise<void>;
         replaceCACertificatesAndCRLs(_this: vimService.vim.ManagedObjectReference, caCert: Array<string>, caCrl: Array<string>): Promise<void>;
         listCACertificates(_this: vimService.vim.ManagedObjectReference): Promise<Array<string>>;
         listCACertificateRevocationLists(_this: vimService.vim.ManagedObjectReference): Promise<Array<string>>;
         enableHyperThreading(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         disableHyperThreading(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         searchDatastoreTask(_this: vimService.vim.ManagedObjectReference, datastorePath: string, searchSpec: vimService.vim.HostDatastoreBrowserSearchSpec): Promise<vimService.vim.ManagedObjectReference>;
         searchDatastoreSubFoldersTask(_this: vimService.vim.ManagedObjectReference, datastorePath: string, searchSpec: vimService.vim.HostDatastoreBrowserSearchSpec): Promise<vimService.vim.ManagedObjectReference>;
         deleteFile(_this: vimService.vim.ManagedObjectReference, datastorePath: string): Promise<void>;
         updateLocalSwapDatastore(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference): Promise<void>;
         queryAvailableDisksForVmfs(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.HostScsiDisk>>;
         queryVmfsDatastoreCreateOptions(_this: vimService.vim.ManagedObjectReference, devicePath: string, vmfsMajorVersion: number): Promise<Array<vimService.vim.VmfsDatastoreOption>>;
         createVmfsDatastore(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.VmfsDatastoreCreateSpec): Promise<vimService.vim.ManagedObjectReference>;
         queryVmfsDatastoreExtendOptions(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference, devicePath: string, suppressExpandCandidates: boolean): Promise<Array<vimService.vim.VmfsDatastoreOption>>;
         queryVmfsDatastoreExpandOptions(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.VmfsDatastoreOption>>;
         extendVmfsDatastore(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference, spec: vimService.vim.VmfsDatastoreExtendSpec): Promise<vimService.vim.ManagedObjectReference>;
         expandVmfsDatastore(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference, spec: vimService.vim.VmfsDatastoreExpandSpec): Promise<vimService.vim.ManagedObjectReference>;
         createNasDatastore(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostNasVolumeSpec): Promise<vimService.vim.ManagedObjectReference>;
         createLocalDatastore(_this: vimService.vim.ManagedObjectReference, name: string, path: string): Promise<vimService.vim.ManagedObjectReference>;
         createVvolDatastore(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostDatastoreSystemVvolDatastoreSpec): Promise<vimService.vim.ManagedObjectReference>;
         removeDatastore(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference): Promise<void>;
         removeDatastoreExTask(_this: vimService.vim.ManagedObjectReference, datastore: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         configureDatastorePrincipal(_this: vimService.vim.ManagedObjectReference, userName: string, password: string): Promise<void>;
         queryUnresolvedVmfsVolumes(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.HostUnresolvedVmfsVolume>>;
         resignatureUnresolvedVmfsVolumeTask(_this: vimService.vim.ManagedObjectReference, resolutionSpec: vimService.vim.HostUnresolvedVmfsResignatureSpec): Promise<vimService.vim.ManagedObjectReference>;
         updateDateTimeConfig(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.HostDateTimeConfig): Promise<void>;
         queryAvailableTimeZones(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.HostDateTimeSystemTimeZone>>;
         queryDateTime(_this: vimService.vim.ManagedObjectReference): Promise<Date>;
         updateDateTime(_this: vimService.vim.ManagedObjectReference, dateTime: Date): Promise<void>;
         refreshDateTimeSystem(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         queryAvailablePartition(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.HostDiagnosticPartition>>;
         selectActivePartition(_this: vimService.vim.ManagedObjectReference, partition: vimService.vim.HostScsiDiskPartition): Promise<void>;
         queryPartitionCreateOptions(_this: vimService.vim.ManagedObjectReference, storageType: string, diagnosticType: string): Promise<Array<vimService.vim.HostDiagnosticPartitionCreateOption>>;
         queryPartitionCreateDesc(_this: vimService.vim.ManagedObjectReference, diskUuid: string, diagnosticType: string): Promise<vimService.vim.HostDiagnosticPartitionCreateDescription>;
         createDiagnosticPartition(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostDiagnosticPartitionCreateSpec): Promise<void>;
         esxAgentHostManagerUpdateConfig(_this: vimService.vim.ManagedObjectReference, configInfo: vimService.vim.HostEsxAgentHostManagerConfigInfo): Promise<void>;
         updateDefaultPolicy(_this: vimService.vim.ManagedObjectReference, defaultPolicy: vimService.vim.HostFirewallDefaultPolicy): Promise<void>;
         enableRuleset(_this: vimService.vim.ManagedObjectReference, id: string): Promise<void>;
         disableRuleset(_this: vimService.vim.ManagedObjectReference, id: string): Promise<void>;
         updateRuleset(_this: vimService.vim.ManagedObjectReference, id: string, spec: vimService.vim.HostFirewallRulesetRulesetSpec): Promise<void>;
         refreshFirewall(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         resetFirmwareToFactoryDefaults(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         backupFirmwareConfiguration(_this: vimService.vim.ManagedObjectReference): Promise<string>;
         queryFirmwareConfigUploadURL(_this: vimService.vim.ManagedObjectReference): Promise<string>;
         restoreFirmwareConfiguration(_this: vimService.vim.ManagedObjectReference, force: boolean): Promise<void>;
         refreshGraphicsManager(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         isSharedGraphicsActive(_this: vimService.vim.ManagedObjectReference): Promise<boolean>;
         updateGraphicsConfig(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.HostGraphicsConfig): Promise<void>;
         refreshHealthStatusSystem(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         resetSystemHealthInfo(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         clearSystemEventLog(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         fetchSystemEventLog(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.SystemEventInfo>>;
         retrieveHostAccessControlEntries(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.HostAccessControlEntry>>;
         changeAccessMode(_this: vimService.vim.ManagedObjectReference, principal: string, isGroup: boolean, accessMode: vimService.vim.HostAccessMode): Promise<void>;
         querySystemUsers(_this: vimService.vim.ManagedObjectReference): Promise<Array<string>>;
         updateSystemUsers(_this: vimService.vim.ManagedObjectReference, users: Array<string>): Promise<void>;
         queryLockdownExceptions(_this: vimService.vim.ManagedObjectReference): Promise<Array<string>>;
         updateLockdownExceptions(_this: vimService.vim.ManagedObjectReference, users: Array<string>): Promise<void>;
         changeLockdownMode(_this: vimService.vim.ManagedObjectReference, mode: vimService.vim.HostLockdownMode): Promise<void>;
         hostImageConfigGetAcceptance(_this: vimService.vim.ManagedObjectReference): Promise<string>;
         hostImageConfigGetProfile(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.HostImageProfileSummary>;
         updateHostImageAcceptanceLevel(_this: vimService.vim.ManagedObjectReference, newAcceptanceLevel: string): Promise<void>;
         fetchSoftwarePackages(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.SoftwarePackage>>;
         installDate(_this: vimService.vim.ManagedObjectReference): Promise<Date>;
         queryVnicStatus(_this: vimService.vim.ManagedObjectReference, vnicDevice: string): Promise<vimService.vim.IscsiStatus>;
         queryPnicStatus(_this: vimService.vim.ManagedObjectReference, pnicDevice: string): Promise<vimService.vim.IscsiStatus>;
         queryBoundVnics(_this: vimService.vim.ManagedObjectReference, iScsiHbaName: string): Promise<Array<vimService.vim.IscsiPortInfo>>;
         queryCandidateNics(_this: vimService.vim.ManagedObjectReference, iScsiHbaName: string): Promise<Array<vimService.vim.IscsiPortInfo>>;
         bindVnic(_this: vimService.vim.ManagedObjectReference, iScsiHbaName: string, vnicDevice: string): Promise<void>;
         unbindVnic(_this: vimService.vim.ManagedObjectReference, iScsiHbaName: string, vnicDevice: string, force: boolean): Promise<void>;
         queryMigrationDependencies(_this: vimService.vim.ManagedObjectReference, pnicDevice: Array<string>): Promise<vimService.vim.IscsiMigrationDependency>;
         queryModules(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.KernelModuleInfo>>;
         updateModuleOptionString(_this: vimService.vim.ManagedObjectReference, name: string, options: string): Promise<void>;
         queryConfiguredModuleOptionString(_this: vimService.vim.ManagedObjectReference, name: string): Promise<string>;
         createUser(_this: vimService.vim.ManagedObjectReference, user: vimService.vim.HostAccountSpec): Promise<void>;
         updateUser(_this: vimService.vim.ManagedObjectReference, user: vimService.vim.HostAccountSpec): Promise<void>;
         createGroup(_this: vimService.vim.ManagedObjectReference, group: vimService.vim.HostAccountSpec): Promise<void>;
         removeUser(_this: vimService.vim.ManagedObjectReference, userName: string): Promise<void>;
         removeGroup(_this: vimService.vim.ManagedObjectReference, groupName: string): Promise<void>;
         assignUserToGroup(_this: vimService.vim.ManagedObjectReference, user: string, group: string): Promise<void>;
         unassignUserFromGroup(_this: vimService.vim.ManagedObjectReference, user: string, group: string): Promise<void>;
         reconfigureServiceConsoleReservation(_this: vimService.vim.ManagedObjectReference, cfgBytes: number): Promise<void>;
         reconfigureVirtualMachineReservation(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.VirtualMachineMemoryReservationSpec): Promise<void>;
         updateNetworkConfig(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.HostNetworkConfig, changeMode: string): Promise<vimService.vim.HostNetworkConfigResult>;
         updateDnsConfig(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.HostDnsConfig): Promise<void>;
         updateIpRouteConfig(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.HostIpRouteConfig): Promise<void>;
         updateConsoleIpRouteConfig(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.HostIpRouteConfig): Promise<void>;
         updateIpRouteTableConfig(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.HostIpRouteTableConfig): Promise<void>;
         addVirtualSwitch(_this: vimService.vim.ManagedObjectReference, vswitchName: string, spec: vimService.vim.HostVirtualSwitchSpec): Promise<void>;
         removeVirtualSwitch(_this: vimService.vim.ManagedObjectReference, vswitchName: string): Promise<void>;
         updateVirtualSwitch(_this: vimService.vim.ManagedObjectReference, vswitchName: string, spec: vimService.vim.HostVirtualSwitchSpec): Promise<void>;
         addPortGroup(_this: vimService.vim.ManagedObjectReference, portgrp: vimService.vim.HostPortGroupSpec): Promise<void>;
         removePortGroup(_this: vimService.vim.ManagedObjectReference, pgName: string): Promise<void>;
         updatePortGroup(_this: vimService.vim.ManagedObjectReference, pgName: string, portgrp: vimService.vim.HostPortGroupSpec): Promise<void>;
         updatePhysicalNicLinkSpeed(_this: vimService.vim.ManagedObjectReference, device: string, linkSpeed: vimService.vim.PhysicalNicLinkInfo): Promise<void>;
         queryNetworkHint(_this: vimService.vim.ManagedObjectReference, device: Array<string>): Promise<Array<vimService.vim.PhysicalNicHintInfo>>;
         addVirtualNic(_this: vimService.vim.ManagedObjectReference, portgroup: string, nic: vimService.vim.HostVirtualNicSpec): Promise<string>;
         removeVirtualNic(_this: vimService.vim.ManagedObjectReference, device: string): Promise<void>;
         updateVirtualNic(_this: vimService.vim.ManagedObjectReference, device: string, nic: vimService.vim.HostVirtualNicSpec): Promise<void>;
         addServiceConsoleVirtualNic(_this: vimService.vim.ManagedObjectReference, portgroup: string, nic: vimService.vim.HostVirtualNicSpec): Promise<string>;
         removeServiceConsoleVirtualNic(_this: vimService.vim.ManagedObjectReference, device: string): Promise<void>;
         updateServiceConsoleVirtualNic(_this: vimService.vim.ManagedObjectReference, device: string, nic: vimService.vim.HostVirtualNicSpec): Promise<void>;
         restartServiceConsoleVirtualNic(_this: vimService.vim.ManagedObjectReference, device: string): Promise<void>;
         refreshNetworkSystem(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         checkHostPatchTask(_this: vimService.vim.ManagedObjectReference, metaUrls: Array<string>, bundleUrls: Array<string>, spec: vimService.vim.HostPatchManagerPatchManagerOperationSpec): Promise<vimService.vim.ManagedObjectReference>;
         scanHostPatchTask(_this: vimService.vim.ManagedObjectReference, repository: vimService.vim.HostPatchManagerLocator, updateID: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         scanHostPatchV2Task(_this: vimService.vim.ManagedObjectReference, metaUrls: Array<string>, bundleUrls: Array<string>, spec: vimService.vim.HostPatchManagerPatchManagerOperationSpec): Promise<vimService.vim.ManagedObjectReference>;
         stageHostPatchTask(_this: vimService.vim.ManagedObjectReference, metaUrls: Array<string>, bundleUrls: Array<string>, vibUrls: Array<string>, spec: vimService.vim.HostPatchManagerPatchManagerOperationSpec): Promise<vimService.vim.ManagedObjectReference>;
         installHostPatchTask(_this: vimService.vim.ManagedObjectReference, repository: vimService.vim.HostPatchManagerLocator, updateID: string, force: boolean): Promise<vimService.vim.ManagedObjectReference>;
         installHostPatchV2Task(_this: vimService.vim.ManagedObjectReference, metaUrls: Array<string>, bundleUrls: Array<string>, vibUrls: Array<string>, spec: vimService.vim.HostPatchManagerPatchManagerOperationSpec): Promise<vimService.vim.ManagedObjectReference>;
         uninstallHostPatchTask(_this: vimService.vim.ManagedObjectReference, bulletinIds: Array<string>, spec: vimService.vim.HostPatchManagerPatchManagerOperationSpec): Promise<vimService.vim.ManagedObjectReference>;
         queryHostPatchTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostPatchManagerPatchManagerOperationSpec): Promise<vimService.vim.ManagedObjectReference>;
         refresh(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         updatePassthruConfig(_this: vimService.vim.ManagedObjectReference, config: Array<vimService.vim.HostPciPassthruConfig>): Promise<void>;
         configurePowerPolicy(_this: vimService.vim.ManagedObjectReference, key: number): Promise<void>;
         updateServicePolicy(_this: vimService.vim.ManagedObjectReference, id: string, policy: string): Promise<void>;
         startService(_this: vimService.vim.ManagedObjectReference, id: string): Promise<void>;
         stopService(_this: vimService.vim.ManagedObjectReference, id: string): Promise<void>;
         restartService(_this: vimService.vim.ManagedObjectReference, id: string): Promise<void>;
         uninstallService(_this: vimService.vim.ManagedObjectReference, id: string): Promise<void>;
         refreshServices(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         reconfigureSnmpAgent(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostSnmpConfigSpec): Promise<void>;
         sendTestNotification(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         retrieveDiskPartitionInfo(_this: vimService.vim.ManagedObjectReference, devicePath: Array<string>): Promise<Array<vimService.vim.HostDiskPartitionInfo>>;
         computeDiskPartitionInfo(_this: vimService.vim.ManagedObjectReference, devicePath: string, layout: vimService.vim.HostDiskPartitionLayout, partitionFormat: string): Promise<vimService.vim.HostDiskPartitionInfo>;
         computeDiskPartitionInfoForResize(_this: vimService.vim.ManagedObjectReference, partition: vimService.vim.HostScsiDiskPartition, blockRange: vimService.vim.HostDiskPartitionBlockRange, partitionFormat: string): Promise<vimService.vim.HostDiskPartitionInfo>;
         updateDiskPartitions(_this: vimService.vim.ManagedObjectReference, devicePath: string, spec: vimService.vim.HostDiskPartitionSpec): Promise<void>;
         formatVmfs(_this: vimService.vim.ManagedObjectReference, createSpec: vimService.vim.HostVmfsSpec): Promise<vimService.vim.HostVmfsVolume>;
         mountVmfsVolume(_this: vimService.vim.ManagedObjectReference, vmfsUuid: string): Promise<void>;
         unmountVmfsVolume(_this: vimService.vim.ManagedObjectReference, vmfsUuid: string): Promise<void>;
         unmountVmfsVolumeExTask(_this: vimService.vim.ManagedObjectReference, vmfsUuid: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         mountVmfsVolumeExTask(_this: vimService.vim.ManagedObjectReference, vmfsUuid: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         unmapVmfsVolumeExTask(_this: vimService.vim.ManagedObjectReference, vmfsUuid: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         deleteVmfsVolumeState(_this: vimService.vim.ManagedObjectReference, vmfsUuid: string): Promise<void>;
         rescanVmfs(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         attachVmfsExtent(_this: vimService.vim.ManagedObjectReference, vmfsPath: string, extent: vimService.vim.HostScsiDiskPartition): Promise<void>;
         expandVmfsExtent(_this: vimService.vim.ManagedObjectReference, vmfsPath: string, extent: vimService.vim.HostScsiDiskPartition): Promise<void>;
         upgradeVmfs(_this: vimService.vim.ManagedObjectReference, vmfsPath: string): Promise<void>;
         upgradeVmLayout(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         queryUnresolvedVmfsVolume(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.HostUnresolvedVmfsVolume>>;
         resolveMultipleUnresolvedVmfsVolumes(_this: vimService.vim.ManagedObjectReference, resolutionSpec: Array<vimService.vim.HostUnresolvedVmfsResolutionSpec>): Promise<Array<vimService.vim.HostUnresolvedVmfsResolutionResult>>;
         resolveMultipleUnresolvedVmfsVolumesExTask(_this: vimService.vim.ManagedObjectReference, resolutionSpec: Array<vimService.vim.HostUnresolvedVmfsResolutionSpec>): Promise<vimService.vim.ManagedObjectReference>;
         unmountForceMountedVmfsVolume(_this: vimService.vim.ManagedObjectReference, vmfsUuid: string): Promise<void>;
         rescanHba(_this: vimService.vim.ManagedObjectReference, hbaDevice: string): Promise<void>;
         rescanAllHba(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         updateSoftwareInternetScsiEnabled(_this: vimService.vim.ManagedObjectReference, enabled: boolean): Promise<void>;
         updateInternetScsiDiscoveryProperties(_this: vimService.vim.ManagedObjectReference, iScsiHbaDevice: string, discoveryProperties: vimService.vim.HostInternetScsiHbaDiscoveryProperties): Promise<void>;
         updateInternetScsiAuthenticationProperties(_this: vimService.vim.ManagedObjectReference, iScsiHbaDevice: string, authenticationProperties: vimService.vim.HostInternetScsiHbaAuthenticationProperties, targetSet: vimService.vim.HostInternetScsiHbaTargetSet): Promise<void>;
         updateInternetScsiDigestProperties(_this: vimService.vim.ManagedObjectReference, iScsiHbaDevice: string, targetSet: vimService.vim.HostInternetScsiHbaTargetSet, digestProperties: vimService.vim.HostInternetScsiHbaDigestProperties): Promise<void>;
         updateInternetScsiAdvancedOptions(_this: vimService.vim.ManagedObjectReference, iScsiHbaDevice: string, targetSet: vimService.vim.HostInternetScsiHbaTargetSet, options: Array<vimService.vim.HostInternetScsiHbaParamValue>): Promise<void>;
         updateInternetScsiIPProperties(_this: vimService.vim.ManagedObjectReference, iScsiHbaDevice: string, ipProperties: vimService.vim.HostInternetScsiHbaIPProperties): Promise<void>;
         updateInternetScsiName(_this: vimService.vim.ManagedObjectReference, iScsiHbaDevice: string, iScsiName: string): Promise<void>;
         updateInternetScsiAlias(_this: vimService.vim.ManagedObjectReference, iScsiHbaDevice: string, iScsiAlias: string): Promise<void>;
         addInternetScsiSendTargets(_this: vimService.vim.ManagedObjectReference, iScsiHbaDevice: string, targets: Array<vimService.vim.HostInternetScsiHbaSendTarget>): Promise<void>;
         removeInternetScsiSendTargets(_this: vimService.vim.ManagedObjectReference, iScsiHbaDevice: string, targets: Array<vimService.vim.HostInternetScsiHbaSendTarget>): Promise<void>;
         addInternetScsiStaticTargets(_this: vimService.vim.ManagedObjectReference, iScsiHbaDevice: string, targets: Array<vimService.vim.HostInternetScsiHbaStaticTarget>): Promise<void>;
         removeInternetScsiStaticTargets(_this: vimService.vim.ManagedObjectReference, iScsiHbaDevice: string, targets: Array<vimService.vim.HostInternetScsiHbaStaticTarget>): Promise<void>;
         enableMultipathPath(_this: vimService.vim.ManagedObjectReference, pathName: string): Promise<void>;
         disableMultipathPath(_this: vimService.vim.ManagedObjectReference, pathName: string): Promise<void>;
         setMultipathLunPolicy(_this: vimService.vim.ManagedObjectReference, lunId: string, policy: vimService.vim.HostMultipathInfoLogicalUnitPolicy): Promise<void>;
         queryPathSelectionPolicyOptions(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.HostPathSelectionPolicyOption>>;
         queryStorageArrayTypePolicyOptions(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.HostStorageArrayTypePolicyOption>>;
         updateScsiLunDisplayName(_this: vimService.vim.ManagedObjectReference, lunUuid: string, displayName: string): Promise<void>;
         detachScsiLun(_this: vimService.vim.ManagedObjectReference, lunUuid: string): Promise<void>;
         detachScsiLunExTask(_this: vimService.vim.ManagedObjectReference, lunUuid: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         deleteScsiLunState(_this: vimService.vim.ManagedObjectReference, lunCanonicalName: string): Promise<void>;
         attachScsiLun(_this: vimService.vim.ManagedObjectReference, lunUuid: string): Promise<void>;
         attachScsiLunExTask(_this: vimService.vim.ManagedObjectReference, lunUuid: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         refreshStorageSystem(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         discoverFcoeHbas(_this: vimService.vim.ManagedObjectReference, fcoeSpec: vimService.vim.FcoeConfigFcoeSpecification): Promise<void>;
         markForRemoval(_this: vimService.vim.ManagedObjectReference, hbaName: string, remove: boolean): Promise<void>;
         formatVffs(_this: vimService.vim.ManagedObjectReference, createSpec: vimService.vim.HostVffsSpec): Promise<vimService.vim.HostVffsVolume>;
         extendVffs(_this: vimService.vim.ManagedObjectReference, vffsPath: string, devicePath: string, spec: vimService.vim.HostDiskPartitionSpec): Promise<void>;
         destroyVffs(_this: vimService.vim.ManagedObjectReference, vffsPath: string): Promise<void>;
         mountVffsVolume(_this: vimService.vim.ManagedObjectReference, vffsUuid: string): Promise<void>;
         unmountVffsVolume(_this: vimService.vim.ManagedObjectReference, vffsUuid: string): Promise<void>;
         deleteVffsVolumeState(_this: vimService.vim.ManagedObjectReference, vffsUuid: string): Promise<void>;
         rescanVffs(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         queryAvailableSsds(_this: vimService.vim.ManagedObjectReference, vffsPath: string): Promise<Array<vimService.vim.HostScsiDisk>>;
         setNFSUser(_this: vimService.vim.ManagedObjectReference, user: string, password: string): Promise<void>;
         changeNFSUserPassword(_this: vimService.vim.ManagedObjectReference, password: string): Promise<void>;
         queryNFSUser(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.HostNasVolumeUserInfo>;
         clearNFSUser(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         turnDiskLocatorLedOnTask(_this: vimService.vim.ManagedObjectReference, scsiDiskUuids: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         turnDiskLocatorLedOffTask(_this: vimService.vim.ManagedObjectReference, scsiDiskUuids: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         markAsSsdTask(_this: vimService.vim.ManagedObjectReference, scsiDiskUuid: string): Promise<vimService.vim.ManagedObjectReference>;
         markAsNonSsdTask(_this: vimService.vim.ManagedObjectReference, scsiDiskUuid: string): Promise<vimService.vim.ManagedObjectReference>;
         markAsLocalTask(_this: vimService.vim.ManagedObjectReference, scsiDiskUuid: string): Promise<vimService.vim.ManagedObjectReference>;
         markAsNonLocalTask(_this: vimService.vim.ManagedObjectReference, scsiDiskUuid: string): Promise<vimService.vim.ManagedObjectReference>;
         updateVmfsUnmapPriority(_this: vimService.vim.ManagedObjectReference, vmfsUuid: string, unmapPriority: string): Promise<void>;
         queryVmfsConfigOption(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.VmfsConfigOption>>;
         configureVFlashResourceExTask(_this: vimService.vim.ManagedObjectReference, devicePath: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         hostConfigureVFlashResource(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostVFlashManagerVFlashResourceConfigSpec): Promise<void>;
         hostRemoveVFlashResource(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         hostConfigVFlashCache(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostVFlashManagerVFlashCacheConfigSpec): Promise<void>;
         hostGetVFlashModuleDefaultConfig(_this: vimService.vim.ManagedObjectReference, vFlashModule: string): Promise<vimService.vim.VirtualDiskVFlashCacheConfigInfo>;
         updateIpConfig(_this: vimService.vim.ManagedObjectReference, ipConfig: vimService.vim.HostIpConfig): Promise<void>;
         selectVnic(_this: vimService.vim.ManagedObjectReference, device: string): Promise<void>;
         deselectVnic(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         queryNetConfig(_this: vimService.vim.ManagedObjectReference, nicType: string): Promise<vimService.vim.VirtualNicManagerNetConfig>;
         selectVnicForNicType(_this: vimService.vim.ManagedObjectReference, nicType: string, device: string): Promise<void>;
         deselectVnicForNicType(_this: vimService.vim.ManagedObjectReference, nicType: string, device: string): Promise<void>;
         queryCmmds(_this: vimService.vim.ManagedObjectReference, queries: Array<vimService.vim.HostVsanInternalSystemCmmdsQuery>): Promise<string>;
         queryPhysicalVsanDisks(_this: vimService.vim.ManagedObjectReference, props: Array<string>): Promise<string>;
         queryVsanObjects(_this: vimService.vim.ManagedObjectReference, uuids: Array<string>): Promise<string>;
         queryObjectsOnPhysicalVsanDisk(_this: vimService.vim.ManagedObjectReference, disks: Array<string>): Promise<string>;
         abdicateDomOwnership(_this: vimService.vim.ManagedObjectReference, uuids: Array<string>): Promise<Array<string>>;
         queryVsanStatistics(_this: vimService.vim.ManagedObjectReference, labels: Array<string>): Promise<string>;
         reconfigureDomObject(_this: vimService.vim.ManagedObjectReference, uuid: string, policy: string): Promise<void>;
         querySyncingVsanObjects(_this: vimService.vim.ManagedObjectReference, uuids: Array<string>): Promise<string>;
         runVsanPhysicalDiskDiagnostics(_this: vimService.vim.ManagedObjectReference, disks: Array<string>): Promise<Array<vimService.vim.HostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult>>;
         getVsanObjExtAttrs(_this: vimService.vim.ManagedObjectReference, uuids: Array<string>): Promise<string>;
         reconfigurationSatisfiable(_this: vimService.vim.ManagedObjectReference, pcbs: Array<vimService.vim.VsanPolicyChangeBatch>, ignoreSatisfiability: boolean): Promise<Array<vimService.vim.VsanPolicySatisfiability>>;
         canProvisionObjects(_this: vimService.vim.ManagedObjectReference, npbs: Array<vimService.vim.VsanNewPolicyBatch>, ignoreSatisfiability: boolean): Promise<Array<vimService.vim.VsanPolicySatisfiability>>;
         deleteVsanObjects(_this: vimService.vim.ManagedObjectReference, uuids: Array<string>, force: boolean): Promise<Array<vimService.vim.HostVsanInternalSystemDeleteVsanObjectsResult>>;
         upgradeVsanObjects(_this: vimService.vim.ManagedObjectReference, uuids: Array<string>, newVersion: number): Promise<Array<vimService.vim.HostVsanInternalSystemVsanObjectOperationResult>>;
         queryVsanObjectUuidsByFilter(_this: vimService.vim.ManagedObjectReference, uuids: Array<string>, limit: number, version: number): Promise<Array<string>>;
         queryDisksForVsan(_this: vimService.vim.ManagedObjectReference, canonicalName: Array<string>): Promise<Array<vimService.vim.VsanHostDiskResult>>;
         addDisksTask(_this: vimService.vim.ManagedObjectReference, disk: Array<vimService.vim.HostScsiDisk>): Promise<vimService.vim.ManagedObjectReference>;
         initializeDisksTask(_this: vimService.vim.ManagedObjectReference, mapping: Array<vimService.vim.VsanHostDiskMapping>): Promise<vimService.vim.ManagedObjectReference>;
         removeDiskTask(_this: vimService.vim.ManagedObjectReference, disk: Array<vimService.vim.HostScsiDisk>, maintenanceSpec: vimService.vim.HostMaintenanceSpec, timeout: number): Promise<vimService.vim.ManagedObjectReference>;
         removeDiskMappingTask(_this: vimService.vim.ManagedObjectReference, mapping: Array<vimService.vim.VsanHostDiskMapping>, maintenanceSpec: vimService.vim.HostMaintenanceSpec, timeout: number): Promise<vimService.vim.ManagedObjectReference>;
         unmountDiskMappingTask(_this: vimService.vim.ManagedObjectReference, mapping: Array<vimService.vim.VsanHostDiskMapping>): Promise<vimService.vim.ManagedObjectReference>;
         updateVsanTask(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.VsanHostConfigInfo): Promise<vimService.vim.ManagedObjectReference>;
         queryHostStatus(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.VsanHostClusterStatus>;
         evacuateVsanNodeTask(_this: vimService.vim.ManagedObjectReference, maintenanceSpec: vimService.vim.HostMaintenanceSpec, timeout: number): Promise<vimService.vim.ManagedObjectReference>;
         recommissionVsanNodeTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         queryOptions(_this: vimService.vim.ManagedObjectReference, name: string): Promise<Array<vimService.vim.OptionValue>>;
         updateOptions(_this: vimService.vim.ManagedObjectReference, changedValue: Array<vimService.vim.OptionValue>): Promise<void>;
         checkComplianceTask(_this: vimService.vim.ManagedObjectReference, profile: Array<vimService.vim.ManagedObjectReference>, entity: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         queryComplianceStatus(_this: vimService.vim.ManagedObjectReference, profile: Array<vimService.vim.ManagedObjectReference>, entity: Array<vimService.vim.ManagedObjectReference>): Promise<Array<vimService.vim.ComplianceResult>>;
         clearComplianceStatus(_this: vimService.vim.ManagedObjectReference, profile: Array<vimService.vim.ManagedObjectReference>, entity: Array<vimService.vim.ManagedObjectReference>): Promise<void>;
         queryExpressionMetadata(_this: vimService.vim.ManagedObjectReference, expressionName: Array<string>, profile: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ProfileExpressionMetadata>>;
         retrieveDescription(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ProfileDescription>;
         destroyProfile(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         associateProfile(_this: vimService.vim.ManagedObjectReference, entity: Array<vimService.vim.ManagedObjectReference>): Promise<void>;
         dissociateProfile(_this: vimService.vim.ManagedObjectReference, entity: Array<vimService.vim.ManagedObjectReference>): Promise<void>;
         checkProfileComplianceTask(_this: vimService.vim.ManagedObjectReference, entity: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         exportProfile(_this: vimService.vim.ManagedObjectReference): Promise<string>;
         createProfile(_this: vimService.vim.ManagedObjectReference, createSpec: vimService.vim.ProfileCreateSpec): Promise<vimService.vim.ManagedObjectReference>;
         queryPolicyMetadata(_this: vimService.vim.ManagedObjectReference, policyName: Array<string>, profile: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ProfilePolicyMetadata>>;
         findAssociatedProfile(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ManagedObjectReference>>;
         updateClusterProfile(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.ClusterProfileConfigSpec): Promise<void>;
         updateReferenceHost(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<void>;
         updateHostProfile(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.HostProfileConfigSpec): Promise<void>;
         executeHostProfile(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, deferredParam: Array<vimService.vim.ProfileDeferredPolicyOptionParameter>): Promise<vimService.vim.ProfileExecuteResult>;
         updateHostSpecification(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, hostSpec: vimService.vim.HostSpecification): Promise<void>;
         updateHostSubSpecification(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, hostSubSpec: vimService.vim.HostSubSpecification): Promise<void>;
         retrieveHostSpecification(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, fromHost: boolean): Promise<vimService.vim.HostSpecification>;
         deleteHostSubSpecification(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, subSpecName: string): Promise<void>;
         deleteHostSpecification(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<void>;
         hostSpecGetUpdatedHosts(_this: vimService.vim.ManagedObjectReference, startChangeID: string, endChangeID: string): Promise<Array<vimService.vim.ManagedObjectReference>>;
         applyHostConfigTask(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, configSpec: vimService.vim.HostConfigSpec, userInput: Array<vimService.vim.ProfileDeferredPolicyOptionParameter>): Promise<vimService.vim.ManagedObjectReference>;
         generateConfigTaskList(_this: vimService.vim.ManagedObjectReference, configSpec: vimService.vim.HostConfigSpec, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.HostProfileManagerConfigTaskList>;
         generateHostProfileTaskListTask(_this: vimService.vim.ManagedObjectReference, configSpec: vimService.vim.HostConfigSpec, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         queryHostProfileMetadata(_this: vimService.vim.ManagedObjectReference, profileName: Array<string>, profile: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ProfileMetadata>>;
         queryProfileStructure(_this: vimService.vim.ManagedObjectReference, profile: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ProfileProfileStructure>;
         createDefaultProfile(_this: vimService.vim.ManagedObjectReference, profileType: string, profileTypeName: string, profile: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ApplyProfile>;
         updateAnswerFileTask(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, configSpec: vimService.vim.AnswerFileCreateSpec): Promise<vimService.vim.ManagedObjectReference>;
         retrieveAnswerFile(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.AnswerFile>;
         retrieveAnswerFileForProfile(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, applyProfile: vimService.vim.HostApplyProfile): Promise<vimService.vim.AnswerFile>;
         exportAnswerFileTask(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         checkAnswerFileStatusTask(_this: vimService.vim.ManagedObjectReference, host: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         queryAnswerFileStatus(_this: vimService.vim.ManagedObjectReference, host: Array<vimService.vim.ManagedObjectReference>): Promise<Array<vimService.vim.AnswerFileStatusResult>>;
         updateHostCustomizationsTask(_this: vimService.vim.ManagedObjectReference, hostToConfigSpecMap: Array<vimService.vim.HostProfileManagerHostToConfigSpecMap>): Promise<vimService.vim.ManagedObjectReference>;
         retrieveHostCustomizations(_this: vimService.vim.ManagedObjectReference, hosts: Array<vimService.vim.ManagedObjectReference>): Promise<Array<vimService.vim.StructuredCustomizations>>;
         retrieveHostCustomizationsForProfile(_this: vimService.vim.ManagedObjectReference, hosts: Array<vimService.vim.ManagedObjectReference>, applyProfile: vimService.vim.HostApplyProfile): Promise<Array<vimService.vim.StructuredCustomizations>>;
         generateHostConfigTaskSpecTask(_this: vimService.vim.ManagedObjectReference, hostsInfo: Array<vimService.vim.StructuredCustomizations>): Promise<vimService.vim.ManagedObjectReference>;
         applyEntitiesConfigTask(_this: vimService.vim.ManagedObjectReference, applyConfigSpecs: Array<vimService.vim.ApplyHostProfileConfigurationSpec>): Promise<vimService.vim.ManagedObjectReference>;
         removeScheduledTask(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         reconfigureScheduledTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.ScheduledTaskSpec): Promise<void>;
         runScheduledTask(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         createScheduledTask(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, spec: vimService.vim.ScheduledTaskSpec): Promise<vimService.vim.ManagedObjectReference>;
         retrieveEntityScheduledTask(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ManagedObjectReference>>;
         createObjectScheduledTask(_this: vimService.vim.ManagedObjectReference, obj: vimService.vim.ManagedObjectReference, spec: vimService.vim.ScheduledTaskSpec): Promise<vimService.vim.ManagedObjectReference>;
         retrieveObjectScheduledTask(_this: vimService.vim.ManagedObjectReference, obj: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ManagedObjectReference>>;
         prepareVchaTask(_this: vimService.vim.ManagedObjectReference, networkSpec: vimService.vim.VchaClusterNetworkSpec): Promise<vimService.vim.ManagedObjectReference>;
         deployVchaTask(_this: vimService.vim.ManagedObjectReference, deploymentSpec: vimService.vim.VchaClusterDeploymentSpec): Promise<vimService.vim.ManagedObjectReference>;
         configureVchaTask(_this: vimService.vim.ManagedObjectReference, configSpec: vimService.vim.VchaClusterConfigSpec): Promise<vimService.vim.ManagedObjectReference>;
         createPassiveNodeTask(_this: vimService.vim.ManagedObjectReference, passiveDeploymentSpec: vimService.vim.PassiveNodeDeploymentSpec, sourceVcSpec: vimService.vim.SourceNodeSpec): Promise<vimService.vim.ManagedObjectReference>;
         createWitnessNodeTask(_this: vimService.vim.ManagedObjectReference, witnessDeploymentSpec: vimService.vim.NodeDeploymentSpec, sourceVcSpec: vimService.vim.SourceNodeSpec): Promise<vimService.vim.ManagedObjectReference>;
         getVchaConfig(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.VchaClusterConfigInfo>;
         destroyVchaTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         setClusterModeTask(_this: vimService.vim.ManagedObjectReference, mode: string): Promise<vimService.vim.ManagedObjectReference>;
         getClusterMode(_this: vimService.vim.ManagedObjectReference): Promise<string>;
         getVchaClusterHealth(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.VchaClusterHealth>;
         initiateFailoverTask(_this: vimService.vim.ManagedObjectReference, planned: boolean): Promise<vimService.vim.ManagedObjectReference>;
         openInventoryViewFolder(_this: vimService.vim.ManagedObjectReference, entity: Array<vimService.vim.ManagedObjectReference>): Promise<Array<vimService.vim.ManagedObjectReference>>;
         closeInventoryViewFolder(_this: vimService.vim.ManagedObjectReference, entity: Array<vimService.vim.ManagedObjectReference>): Promise<Array<vimService.vim.ManagedObjectReference>>;
         modifyListView(_this: vimService.vim.ManagedObjectReference, add: Array<vimService.vim.ManagedObjectReference>, remove: Array<vimService.vim.ManagedObjectReference>): Promise<Array<vimService.vim.ManagedObjectReference>>;
         resetListView(_this: vimService.vim.ManagedObjectReference, obj: Array<vimService.vim.ManagedObjectReference>): Promise<Array<vimService.vim.ManagedObjectReference>>;
         resetListViewFromView(_this: vimService.vim.ManagedObjectReference, view: vimService.vim.ManagedObjectReference): Promise<void>;
         destroyView(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         createInventoryView(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         createContainerView(_this: vimService.vim.ManagedObjectReference, container: vimService.vim.ManagedObjectReference, type: Array<string>, recursive: boolean): Promise<vimService.vim.ManagedObjectReference>;
         createListView(_this: vimService.vim.ManagedObjectReference, obj: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         createListViewFromView(_this: vimService.vim.ManagedObjectReference, view: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         revertToSnapshotTask(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, suppressPowerOn: boolean): Promise<vimService.vim.ManagedObjectReference>;
         removeSnapshotTask(_this: vimService.vim.ManagedObjectReference, removeChildren: boolean, consolidate: boolean): Promise<vimService.vim.ManagedObjectReference>;
         renameSnapshot(_this: vimService.vim.ManagedObjectReference, name: string, description: string): Promise<void>;
         exportSnapshot(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         checkCompatibilityTask(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, pool: vimService.vim.ManagedObjectReference, testType: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         queryVMotionCompatibilityExTask(_this: vimService.vim.ManagedObjectReference, vm: Array<vimService.vim.ManagedObjectReference>, host: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         checkMigrateTask(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, pool: vimService.vim.ManagedObjectReference, state: vimService.vim.VirtualMachinePowerState, testType: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         checkRelocateTask(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, spec: vimService.vim.VirtualMachineRelocateSpec, testType: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         addGuestAlias(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, username: string, mapCert: boolean, base64Cert: string, aliasInfo: vimService.vim.GuestAuthAliasInfo): Promise<void>;
         removeGuestAlias(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, username: string, base64Cert: string, subject: vimService.vim.GuestAuthSubject): Promise<void>;
         removeGuestAliasByCert(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, username: string, base64Cert: string): Promise<void>;
         listGuestAliases(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, username: string): Promise<Array<vimService.vim.GuestAliases>>;
         listGuestMappedAliases(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication): Promise<Array<vimService.vim.GuestMappedAliases>>;
         validateCredentialsInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication): Promise<void>;
         acquireCredentialsInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, requestedAuth: vimService.vim.GuestAuthentication, sessionID: number): Promise<vimService.vim.GuestAuthentication>;
         releaseCredentialsInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication): Promise<void>;
         makeDirectoryInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, directoryPath: string, createParentDirectories: boolean): Promise<void>;
         deleteFileInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, filePath: string): Promise<void>;
         deleteDirectoryInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, directoryPath: string, recursive: boolean): Promise<void>;
         moveDirectoryInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, srcDirectoryPath: string, dstDirectoryPath: string): Promise<void>;
         moveFileInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, srcFilePath: string, dstFilePath: string, overwrite: boolean): Promise<void>;
         createTemporaryFileInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, prefix: string, suffix: string, directoryPath: string): Promise<string>;
         createTemporaryDirectoryInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, prefix: string, suffix: string, directoryPath: string): Promise<string>;
         listFilesInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, filePath: string, index: number, maxResults: number, matchPattern: string): Promise<vimService.vim.GuestListFileInfo>;
         changeFileAttributesInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, guestFilePath: string, fileAttributes: vimService.vim.GuestFileAttributes): Promise<void>;
         initiateFileTransferFromGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, guestFilePath: string): Promise<vimService.vim.FileTransferInformation>;
         initiateFileTransferToGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, guestFilePath: string, fileAttributes: vimService.vim.GuestFileAttributes, fileSize: number, overwrite: boolean): Promise<string>;
         startProgramInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, spec: vimService.vim.GuestProgramSpec): Promise<number>;
         listProcessesInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, pids: Array<number>): Promise<Array<vimService.vim.GuestProcessInfo>>;
         terminateProcessInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, pid: number): Promise<void>;
         readEnvironmentVariableInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, names: Array<string>): Promise<Array<string>>;
         createRegistryKeyInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, keyName: vimService.vim.GuestRegKeyNameSpec, isVolatile: boolean, classType: string): Promise<void>;
         listRegistryKeysInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, keyName: vimService.vim.GuestRegKeyNameSpec, recursive: boolean, matchPattern: string): Promise<Array<vimService.vim.GuestRegKeyRecordSpec>>;
         deleteRegistryKeyInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, keyName: vimService.vim.GuestRegKeyNameSpec, recursive: boolean): Promise<void>;
         setRegistryValueInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, value: vimService.vim.GuestRegValueSpec): Promise<void>;
         listRegistryValuesInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, keyName: vimService.vim.GuestRegKeyNameSpec, expandStrings: boolean, matchPattern: string): Promise<Array<vimService.vim.GuestRegValueSpec>>;
         deleteRegistryValueInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, valueName: vimService.vim.GuestRegValueNameSpec): Promise<void>;
         hostCreateDiskTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.VslmCreateSpec): Promise<vimService.vim.ManagedObjectReference>;
         hostRegisterDisk(_this: vimService.vim.ManagedObjectReference, path: string, name: string): Promise<vimService.vim.VStorageObject>;
         hostExtendDiskTask(_this: vimService.vim.ManagedObjectReference, id: string, datastore: vimService.vim.ManagedObjectReference, newCapacityInMB: number): Promise<vimService.vim.ManagedObjectReference>;
         hostInflateDiskTask(_this: vimService.vim.ManagedObjectReference, id: string, datastore: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         hostRenameVStorageObject(_this: vimService.vim.ManagedObjectReference, id: string, datastore: vimService.vim.ManagedObjectReference, name: string): Promise<void>;
         hostDeleteVStorageObjectTask(_this: vimService.vim.ManagedObjectReference, id: string, datastore: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         hostRetrieveVStorageObject(_this: vimService.vim.ManagedObjectReference, id: string, datastore: vimService.vim.ManagedObjectReference): Promise<vimService.vim.VStorageObject>;
         hostRetrieveVStorageObjectState(_this: vimService.vim.ManagedObjectReference, id: string, datastore: vimService.vim.ManagedObjectReference): Promise<vimService.vim.VStorageObjectStateInfo>;
         hostListVStorageObject(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference): Promise<Array<string>>;
         hostCloneVStorageObjectTask(_this: vimService.vim.ManagedObjectReference, id: string, datastore: vimService.vim.ManagedObjectReference, spec: vimService.vim.VslmCloneSpec): Promise<vimService.vim.ManagedObjectReference>;
         hostRelocateVStorageObjectTask(_this: vimService.vim.ManagedObjectReference, id: string, datastore: vimService.vim.ManagedObjectReference, spec: vimService.vim.VslmRelocateSpec): Promise<vimService.vim.ManagedObjectReference>;
         hostReconcileDatastoreInventoryTask(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         hostScheduleReconcileDatastoreInventory(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference): Promise<void>;
         createDiskTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.VslmCreateSpec): Promise<vimService.vim.ManagedObjectReference>;
         registerDisk(_this: vimService.vim.ManagedObjectReference, path: string, name: string): Promise<vimService.vim.VStorageObject>;
         extendDiskTask(_this: vimService.vim.ManagedObjectReference, id: string, datastore: vimService.vim.ManagedObjectReference, newCapacityInMB: number): Promise<vimService.vim.ManagedObjectReference>;
         inflateDiskTask(_this: vimService.vim.ManagedObjectReference, id: string, datastore: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         renameVStorageObject(_this: vimService.vim.ManagedObjectReference, id: string, datastore: vimService.vim.ManagedObjectReference, name: string): Promise<void>;
         deleteVStorageObjectTask(_this: vimService.vim.ManagedObjectReference, id: string, datastore: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         retrieveVStorageObject(_this: vimService.vim.ManagedObjectReference, id: string, datastore: vimService.vim.ManagedObjectReference): Promise<vimService.vim.VStorageObject>;
         retrieveVStorageObjectState(_this: vimService.vim.ManagedObjectReference, id: string, datastore: vimService.vim.ManagedObjectReference): Promise<vimService.vim.VStorageObjectStateInfo>;
         listVStorageObject(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference): Promise<Array<string>>;
         cloneVStorageObjectTask(_this: vimService.vim.ManagedObjectReference, id: string, datastore: vimService.vim.ManagedObjectReference, spec: vimService.vim.VslmCloneSpec): Promise<vimService.vim.ManagedObjectReference>;
         relocateVStorageObjectTask(_this: vimService.vim.ManagedObjectReference, id: string, datastore: vimService.vim.ManagedObjectReference, spec: vimService.vim.VslmRelocateSpec): Promise<vimService.vim.ManagedObjectReference>;
         attachTagToVStorageObject(_this: vimService.vim.ManagedObjectReference, id: string, category: string, tag: string): Promise<void>;
         detachTagFromVStorageObject(_this: vimService.vim.ManagedObjectReference, id: string, category: string, tag: string): Promise<void>;
         listVStorageObjectsAttachedToTag(_this: vimService.vim.ManagedObjectReference, category: string, tag: string): Promise<Array<string>>;
         listTagsAttachedToVStorageObject(_this: vimService.vim.ManagedObjectReference, id: string): Promise<Array<vimService.vim.VslmTagEntry>>;
         reconcileDatastoreInventoryTask(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         scheduleReconcileDatastoreInventory(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference): Promise<void>;
         destroyPropertyFilter(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         createFilter(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.PropertyFilterSpec, partialUpdates: boolean): Promise<vimService.vim.ManagedObjectReference>;
         retrieveProperties(_this: vimService.vim.ManagedObjectReference, specSet: Array<vimService.vim.PropertyFilterSpec>): Promise<Array<vimService.vim.ObjectContent>>;
         checkForUpdates(_this: vimService.vim.ManagedObjectReference, version: string): Promise<vimService.vim.UpdateSet>;
         waitForUpdates(_this: vimService.vim.ManagedObjectReference, version: string): Promise<vimService.vim.UpdateSet>;
         cancelWaitForUpdates(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         waitForUpdatesEx(_this: vimService.vim.ManagedObjectReference, version: string, options: vimService.vim.WaitOptions): Promise<vimService.vim.UpdateSet>;
         retrievePropertiesEx(_this: vimService.vim.ManagedObjectReference, specSet: Array<vimService.vim.PropertyFilterSpec>, options: vimService.vim.RetrieveOptions): Promise<vimService.vim.RetrieveResult>;
         continueRetrievePropertiesEx(_this: vimService.vim.ManagedObjectReference, token: string): Promise<vimService.vim.RetrieveResult>;
         cancelRetrievePropertiesEx(_this: vimService.vim.ManagedObjectReference, token: string): Promise<void>;
         createPropertyCollector(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         destroyPropertyCollector(_this: vimService.vim.ManagedObjectReference): Promise<void>;
      }
   }
   namespace vimService {
      interface xs {
      }
      namespace xs {
         interface AnyType {
            value: string;
         }
         interface AnyURI {
            value: string;
         }
         interface Base64Binary {
            value: string;
         }
         interface Boolean {
            value: string;
         }
         interface Byte {
            value: string;
         }
         interface DateTime {
            value: string;
         }
         interface Double {
            value: string;
         }
         interface Float {
            value: string;
         }
         interface ID {
            value: string;
         }
         interface Int {
            value: string;
         }
         interface Integer {
            value: string;
         }
         interface Long {
            value: string;
         }
         interface NCName {
            value: string;
         }
         interface NegativeInteger {
            value: string;
         }
         interface NonNegativeInteger {
            value: string;
         }
         interface NonPositiveInteger {
            value: string;
         }
         interface PositiveInteger {
            value: string;
         }
         interface QName {
            value: string;
         }
         interface Short {
            value: string;
         }
         interface String {
            value: string;
         }
         interface UnsignedLong {
            value: string;
         }
      }
      interface vim {
      }
      namespace vim {
         interface DynamicArray {
            val: Array<any>;
         }
         interface DynamicData {
         }
         interface DynamicProperty {
            name: string;
            val: any;
         }
         interface ArrayOfDynamicProperty {
            DynamicProperty?: Array<vimService.vim.DynamicProperty>;
         }
         interface KeyAnyValue extends vimService.vim.DynamicData {
            key: string;
            value: any;
         }
         interface ArrayOfKeyAnyValue {
            KeyAnyValue?: Array<vimService.vim.KeyAnyValue>;
         }
         interface LocalizableMessage extends vimService.vim.DynamicData {
            key: string;
            arg?: Array<vimService.vim.KeyAnyValue>;
            message?: string;
         }
         interface ArrayOfLocalizableMessage {
            LocalizableMessage?: Array<vimService.vim.LocalizableMessage>;
         }
         interface LocalizedMethodFault extends vimService.vim.DynamicData {
            fault: vimService.vim.MethodFault;
            localizedMessage?: string;
         }
         interface MethodFault {
            faultCause?: vimService.vim.LocalizedMethodFault;
            faultMessage?: Array<vimService.vim.LocalizableMessage>;
         }
         interface ArrayOfMethodFault {
            MethodFault?: Array<vimService.vim.MethodFault>;
         }
         interface RuntimeFault extends vimService.vim.MethodFault {
         }
         interface HostCommunication extends vimService.vim.RuntimeFault {
         }
         interface HostNotConnected extends vimService.vim.HostCommunication {
         }
         interface HostNotReachable extends vimService.vim.HostCommunication {
         }
         interface InvalidArgument extends vimService.vim.RuntimeFault {
            invalidProperty?: string;
         }
         interface InvalidRequest extends vimService.vim.RuntimeFault {
         }
         interface InvalidType extends vimService.vim.InvalidRequest {
            argument?: string;
         }
         interface ManagedObjectNotFound extends vimService.vim.RuntimeFault {
            obj: vimService.vim.ManagedObjectReference;
         }
         interface MethodNotFound extends vimService.vim.InvalidRequest {
            receiver: vimService.vim.ManagedObjectReference;
            method: string;
         }
         interface NotEnoughLicenses extends vimService.vim.RuntimeFault {
         }
         interface NotImplemented extends vimService.vim.RuntimeFault {
         }
         interface NotSupported extends vimService.vim.RuntimeFault {
         }
         interface RequestCanceled extends vimService.vim.RuntimeFault {
         }
         interface SecurityError extends vimService.vim.RuntimeFault {
         }
         interface SystemError extends vimService.vim.RuntimeFault {
            reason: string;
         }
         interface UnexpectedFault extends vimService.vim.RuntimeFault {
            faultName: string;
            fault?: vimService.vim.LocalizedMethodFault;
         }
         interface ManagedObjectReference extends vimService.xs.String {
            type: string;
            value: string;
         }
         interface ArrayOfString {
            string?: Array<string>;
         }
         interface ArrayOfAnyType {
            anyType?: Array<any>;
         }
         interface ArrayOfAnyURI {
            anyURI?: Array<string>;
         }
         interface ArrayOfManagedObjectReference {
            ManagedObjectReference?: Array<vimService.vim.ManagedObjectReference>;
         }
         interface ArrayOfBoolean {
            boolean?: Array<boolean>;
         }
         interface ArrayOfByte {
            byte?: Array<number>;
         }
         interface ArrayOfDouble {
            double?: Array<number>;
         }
         interface ArrayOfInt {
            int?: Array<number>;
         }
         interface ArrayOfLong {
            long?: Array<number>;
         }
         interface ArrayOfShort {
            short?: Array<number>;
         }
         interface InvalidCollectorVersion extends vimService.vim.MethodFault {
         }
         interface InvalidProperty extends vimService.vim.MethodFault {
            name: string;
         }
         interface PropertyFilterSpec extends vimService.vim.DynamicData {
            propSet: Array<vimService.vim.PropertySpec>;
            objectSet: Array<vimService.vim.ObjectSpec>;
            reportMissingObjectsInResults?: boolean;
         }
         interface ArrayOfPropertyFilterSpec {
            PropertyFilterSpec?: Array<vimService.vim.PropertyFilterSpec>;
         }
         interface PropertySpec extends vimService.vim.DynamicData {
            type: string;
            all?: boolean;
            pathSet?: Array<string>;
         }
         interface ArrayOfPropertySpec {
            PropertySpec?: Array<vimService.vim.PropertySpec>;
         }
         interface ObjectSpec extends vimService.vim.DynamicData {
            obj: vimService.vim.ManagedObjectReference;
            skip?: boolean;
            selectSet?: Array<vimService.vim.SelectionSpec>;
         }
         interface ArrayOfObjectSpec {
            ObjectSpec?: Array<vimService.vim.ObjectSpec>;
         }
         interface SelectionSpec extends vimService.vim.DynamicData {
            name?: string;
         }
         interface ArrayOfSelectionSpec {
            SelectionSpec?: Array<vimService.vim.SelectionSpec>;
         }
         interface TraversalSpec extends vimService.vim.SelectionSpec {
            type: string;
            path: string;
            skip?: boolean;
            selectSet?: Array<vimService.vim.SelectionSpec>;
         }
         interface ObjectContent extends vimService.vim.DynamicData {
            obj: vimService.vim.ManagedObjectReference;
            propSet?: Array<vimService.vim.DynamicProperty>;
            missingSet?: Array<vimService.vim.MissingProperty>;
         }
         interface ArrayOfObjectContent {
            ObjectContent?: Array<vimService.vim.ObjectContent>;
         }
         interface UpdateSet extends vimService.vim.DynamicData {
            version: string;
            filterSet?: Array<vimService.vim.PropertyFilterUpdate>;
            truncated?: boolean;
         }
         interface PropertyFilterUpdate extends vimService.vim.DynamicData {
            filter: vimService.vim.ManagedObjectReference;
            objectSet?: Array<vimService.vim.ObjectUpdate>;
            missingSet?: Array<vimService.vim.MissingObject>;
         }
         interface ArrayOfPropertyFilterUpdate {
            PropertyFilterUpdate?: Array<vimService.vim.PropertyFilterUpdate>;
         }
         enum ObjectUpdateKind {
            "modify",
            "enter",
            "leave",
         }
         interface ObjectUpdate extends vimService.vim.DynamicData {
            kind: vimService.vim.ObjectUpdateKind;
            obj: vimService.vim.ManagedObjectReference;
            changeSet?: Array<vimService.vim.PropertyChange>;
            missingSet?: Array<vimService.vim.MissingProperty>;
         }
         interface ArrayOfObjectUpdate {
            ObjectUpdate?: Array<vimService.vim.ObjectUpdate>;
         }
         enum PropertyChangeOp {
            "add",
            "remove",
            "assign",
            "indirectRemove",
         }
         interface PropertyChange extends vimService.vim.DynamicData {
            name: string;
            op: vimService.vim.PropertyChangeOp;
            val?: any;
         }
         interface ArrayOfPropertyChange {
            PropertyChange?: Array<vimService.vim.PropertyChange>;
         }
         interface MissingProperty extends vimService.vim.DynamicData {
            path: string;
            fault: vimService.vim.LocalizedMethodFault;
         }
         interface ArrayOfMissingProperty {
            MissingProperty?: Array<vimService.vim.MissingProperty>;
         }
         interface MissingObject extends vimService.vim.DynamicData {
            obj: vimService.vim.ManagedObjectReference;
            fault: vimService.vim.LocalizedMethodFault;
         }
         interface ArrayOfMissingObject {
            MissingObject?: Array<vimService.vim.MissingObject>;
         }
         interface WaitOptions extends vimService.vim.DynamicData {
            maxWaitSeconds?: number;
            maxObjectUpdates?: number;
         }
         interface RetrieveOptions extends vimService.vim.DynamicData {
            maxObjects?: number;
         }
         interface RetrieveResult extends vimService.vim.DynamicData {
            token?: string;
            objects: Array<vimService.vim.ObjectContent>;
         }
         interface AboutInfo extends vimService.vim.DynamicData {
            name: string;
            fullName: string;
            vendor: string;
            version: string;
            build: string;
            localeVersion?: string;
            localeBuild?: string;
            osType: string;
            productLineId: string;
            apiType: string;
            apiVersion: string;
            instanceUuid?: string;
            licenseProductName?: string;
            licenseProductVersion?: string;
         }
         interface AuthorizationDescription extends vimService.vim.DynamicData {
            privilege: Array<vimService.vim.ElementDescription>;
            privilegeGroup: Array<vimService.vim.ElementDescription>;
         }
         interface Permission extends vimService.vim.DynamicData {
            entity?: vimService.vim.ManagedObjectReference;
            principal: string;
            group: boolean;
            roleId: number;
            propagate: boolean;
         }
         interface ArrayOfPermission {
            Permission?: Array<vimService.vim.Permission>;
         }
         interface AuthorizationRole extends vimService.vim.DynamicData {
            roleId: number;
            system: boolean;
            name: string;
            info: vimService.vim.Description;
            privilege?: Array<string>;
         }
         interface ArrayOfAuthorizationRole {
            AuthorizationRole?: Array<vimService.vim.AuthorizationRole>;
         }
         interface AuthorizationPrivilege extends vimService.vim.DynamicData {
            privId: string;
            onParent: boolean;
            name: string;
            privGroupName: string;
         }
         interface ArrayOfAuthorizationPrivilege {
            AuthorizationPrivilege?: Array<vimService.vim.AuthorizationPrivilege>;
         }
         interface PrivilegeAvailability extends vimService.vim.DynamicData {
            privId: string;
            isGranted: boolean;
         }
         interface ArrayOfPrivilegeAvailability {
            PrivilegeAvailability?: Array<vimService.vim.PrivilegeAvailability>;
         }
         interface EntityPrivilege extends vimService.vim.DynamicData {
            entity: vimService.vim.ManagedObjectReference;
            privAvailability: Array<vimService.vim.PrivilegeAvailability>;
         }
         interface ArrayOfEntityPrivilege {
            EntityPrivilege?: Array<vimService.vim.EntityPrivilege>;
         }
         interface UserPrivilegeResult extends vimService.vim.DynamicData {
            entity: vimService.vim.ManagedObjectReference;
            privileges?: Array<string>;
         }
         interface ArrayOfUserPrivilegeResult {
            UserPrivilegeResult?: Array<vimService.vim.UserPrivilegeResult>;
         }
         enum BatchResultResult {
            "success",
            "fail",
         }
         interface BatchResult extends vimService.vim.DynamicData {
            result: string;
            hostKey: string;
            ds?: vimService.vim.ManagedObjectReference;
            fault?: vimService.vim.LocalizedMethodFault;
         }
         interface BoolPolicy extends vimService.vim.InheritablePolicy {
            value?: boolean;
         }
         interface Capability extends vimService.vim.DynamicData {
            provisioningSupported: boolean;
            multiHostSupported: boolean;
            userShellAccessSupported: boolean;
            supportedEVCMode?: Array<vimService.vim.EVCMode>;
            networkBackupAndRestoreSupported?: boolean;
         }
         interface ClusterComputeResourceSummary extends vimService.vim.ComputeResourceSummary {
            currentFailoverLevel: number;
            admissionControlInfo?: vimService.vim.ClusterDasAdmissionControlInfo;
            numVmotions: number;
            targetBalance?: number;
            currentBalance?: number;
            usageSummary?: vimService.vim.ClusterUsageSummary;
            currentEVCModeKey?: string;
            dasData?: vimService.vim.ClusterDasData;
         }
         interface ComputeResourceSummary extends vimService.vim.DynamicData {
            totalCpu: number;
            totalMemory: number;
            numCpuCores: number;
            numCpuThreads: number;
            effectiveCpu: number;
            effectiveMemory: number;
            numHosts: number;
            numEffectiveHosts: number;
            overallStatus: vimService.vim.ManagedEntityStatus;
         }
         interface ComputeResourceConfigInfo extends vimService.vim.DynamicData {
            vmSwapPlacement: string;
            spbmEnabled?: boolean;
            defaultHardwareVersionKey?: string;
         }
         enum ComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState {
            "licensed",
            "unlicensed",
            "unknown",
         }
         interface ComputeResourceHostSPBMLicenseInfo extends vimService.vim.DynamicData {
            host: vimService.vim.ManagedObjectReference;
            licenseState: vimService.vim.ComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState;
         }
         interface ArrayOfComputeResourceHostSPBMLicenseInfo {
            ComputeResourceHostSPBMLicenseInfo?: Array<vimService.vim.ComputeResourceHostSPBMLicenseInfo>;
         }
         interface ComputeResourceConfigSpec extends vimService.vim.DynamicData {
            vmSwapPlacement?: string;
            spbmEnabled?: boolean;
            defaultHardwareVersionKey?: string;
         }
         enum ConfigSpecOperation {
            "add",
            "edit",
            "remove",
         }
         interface CustomFieldDef extends vimService.vim.DynamicData {
            key: number;
            name: string;
            type: string;
            managedObjectType?: string;
            fieldDefPrivileges?: vimService.vim.PrivilegePolicyDef;
            fieldInstancePrivileges?: vimService.vim.PrivilegePolicyDef;
         }
         interface ArrayOfCustomFieldDef {
            CustomFieldDef?: Array<vimService.vim.CustomFieldDef>;
         }
         interface CustomFieldValue extends vimService.vim.DynamicData {
            key: number;
         }
         interface ArrayOfCustomFieldValue {
            CustomFieldValue?: Array<vimService.vim.CustomFieldValue>;
         }
         interface CustomFieldStringValue extends vimService.vim.CustomFieldValue {
            value: string;
         }
         interface CustomizationSpecInfo extends vimService.vim.DynamicData {
            name: string;
            description: string;
            type: string;
            changeVersion?: string;
            lastUpdateTime?: Date;
         }
         interface ArrayOfCustomizationSpecInfo {
            CustomizationSpecInfo?: Array<vimService.vim.CustomizationSpecInfo>;
         }
         interface CustomizationSpecItem extends vimService.vim.DynamicData {
            info: vimService.vim.CustomizationSpecInfo;
            spec: vimService.vim.CustomizationSpec;
         }
         interface DatacenterConfigInfo extends vimService.vim.DynamicData {
            defaultHardwareVersionKey?: string;
         }
         interface DatacenterConfigSpec extends vimService.vim.DynamicData {
            defaultHardwareVersionKey?: string;
         }
         enum DatastoreAccessible {
            "True",
            "False",
         }
         enum DatastoreSummaryMaintenanceModeState {
            "normal",
            "enteringMaintenance",
            "inMaintenance",
         }
         interface DatastoreSummary extends vimService.vim.DynamicData {
            datastore?: vimService.vim.ManagedObjectReference;
            name: string;
            url: string;
            capacity: number;
            freeSpace: number;
            uncommitted?: number;
            accessible: boolean;
            multipleHostAccess?: boolean;
            type: string;
            maintenanceMode?: string;
         }
         interface DatastoreInfo extends vimService.vim.DynamicData {
            name: string;
            url: string;
            freeSpace: number;
            maxFileSize: number;
            maxVirtualDiskCapacity?: number;
            maxMemoryFileSize?: number;
            timestamp?: Date;
            containerId?: string;
         }
         interface DatastoreCapability extends vimService.vim.DynamicData {
            directoryHierarchySupported: boolean;
            rawDiskMappingsSupported: boolean;
            perFileThinProvisioningSupported: boolean;
            storageIORMSupported?: boolean;
            nativeSnapshotSupported?: boolean;
            topLevelDirectoryCreateSupported?: boolean;
            seSparseSupported?: boolean;
            vmfsSparseSupported?: boolean;
            vsanSparseSupported?: boolean;
            upitSupported?: boolean;
         }
         interface DatastoreHostMount extends vimService.vim.DynamicData {
            key: vimService.vim.ManagedObjectReference;
            mountInfo: vimService.vim.HostMountInfo;
         }
         interface ArrayOfDatastoreHostMount {
            DatastoreHostMount?: Array<vimService.vim.DatastoreHostMount>;
         }
         interface DatastoreMountPathDatastorePair extends vimService.vim.DynamicData {
            oldMountPath: string;
            datastore: vimService.vim.ManagedObjectReference;
         }
         interface ArrayOfDatastoreMountPathDatastorePair {
            DatastoreMountPathDatastorePair?: Array<vimService.vim.DatastoreMountPathDatastorePair>;
         }
         interface DatastoreVVolContainerFailoverPair extends vimService.vim.DynamicData {
            srcContainer?: string;
            tgtContainer: string;
            vvolMapping?: Array<vimService.vim.KeyValue>;
         }
         interface ArrayOfDatastoreVVolContainerFailoverPair {
            DatastoreVVolContainerFailoverPair?: Array<vimService.vim.DatastoreVVolContainerFailoverPair>;
         }
         interface Description extends vimService.vim.DynamicData {
            label: string;
            summary: string;
         }
         enum DiagnosticManagerLogCreator {
            "vpxd",
            "vpxa",
            "hostd",
            "serverd",
            "install",
            "vpxClient",
            "recordLog",
         }
         enum DiagnosticManagerLogFormat {
            "plain",
         }
         interface DiagnosticManagerLogDescriptor extends vimService.vim.DynamicData {
            key: string;
            fileName: string;
            creator: string;
            format: string;
            mimeType: string;
            info: vimService.vim.Description;
         }
         interface ArrayOfDiagnosticManagerLogDescriptor {
            DiagnosticManagerLogDescriptor?: Array<vimService.vim.DiagnosticManagerLogDescriptor>;
         }
         interface DiagnosticManagerLogHeader extends vimService.vim.DynamicData {
            lineStart: number;
            lineEnd: number;
            lineText?: Array<string>;
         }
         interface DiagnosticManagerBundleInfo extends vimService.vim.DynamicData {
            system?: vimService.vim.ManagedObjectReference;
            url: string;
         }
         interface ArrayOfDiagnosticManagerBundleInfo {
            DiagnosticManagerBundleInfo?: Array<vimService.vim.DiagnosticManagerBundleInfo>;
         }
         enum DistributedVirtualSwitchProductSpecOperationType {
            "preInstall",
            "upgrade",
            "notifyAvailableUpgrade",
            "proceedWithUpgrade",
            "updateBundleInfo",
         }
         interface DVSContactInfo extends vimService.vim.DynamicData {
            name?: string;
            contact?: string;
         }
         enum DistributedVirtualSwitchNicTeamingPolicyMode {
            "loadbalance_ip",
            "loadbalance_srcmac",
            "loadbalance_srcid",
            "failover_explicit",
            "loadbalance_loadbased",
         }
         interface DVSNetworkResourceManagementCapability extends vimService.vim.DynamicData {
            networkResourceManagementSupported: boolean;
            networkResourcePoolHighShareValue: number;
            qosSupported: boolean;
            userDefinedNetworkResourcePoolsSupported: boolean;
            networkResourceControlVersion3Supported?: boolean;
         }
         interface DVSRollbackCapability extends vimService.vim.DynamicData {
            rollbackSupported: boolean;
         }
         interface DVSBackupRestoreCapability extends vimService.vim.DynamicData {
            backupRestoreSupported: boolean;
         }
         interface DVSFeatureCapability extends vimService.vim.DynamicData {
            networkResourceManagementSupported: boolean;
            vmDirectPathGen2Supported: boolean;
            nicTeamingPolicy?: Array<string>;
            networkResourcePoolHighShareValue?: number;
            networkResourceManagementCapability?: vimService.vim.DVSNetworkResourceManagementCapability;
            healthCheckCapability?: vimService.vim.DVSHealthCheckCapability;
            rollbackCapability?: vimService.vim.DVSRollbackCapability;
            backupRestoreCapability?: vimService.vim.DVSBackupRestoreCapability;
            networkFilterSupported?: boolean;
         }
         interface DVSHealthCheckCapability extends vimService.vim.DynamicData {
         }
         interface DVSCapability extends vimService.vim.DynamicData {
            dvsOperationSupported?: boolean;
            dvPortGroupOperationSupported?: boolean;
            dvPortOperationSupported?: boolean;
            compatibleHostComponentProductInfo?: Array<vimService.vim.DistributedVirtualSwitchHostProductSpec>;
            featuresSupported?: vimService.vim.DVSFeatureCapability;
         }
         interface DVSSummary extends vimService.vim.DynamicData {
            name: string;
            uuid: string;
            numPorts: number;
            productInfo?: vimService.vim.DistributedVirtualSwitchProductSpec;
            hostMember?: Array<vimService.vim.ManagedObjectReference>;
            vm?: Array<vimService.vim.ManagedObjectReference>;
            host?: Array<vimService.vim.ManagedObjectReference>;
            portgroupName?: Array<string>;
            description?: string;
            contact?: vimService.vim.DVSContactInfo;
            numHosts?: number;
         }
         interface DVSPolicy extends vimService.vim.DynamicData {
            autoPreInstallAllowed?: boolean;
            autoUpgradeAllowed?: boolean;
            partialUpgradeAllowed?: boolean;
         }
         interface DVSUplinkPortPolicy extends vimService.vim.DynamicData {
         }
         interface DVSNameArrayUplinkPortPolicy extends vimService.vim.DVSUplinkPortPolicy {
            uplinkPortName: Array<string>;
         }
         interface DVSConfigSpec extends vimService.vim.DynamicData {
            configVersion?: string;
            name?: string;
            numStandalonePorts?: number;
            maxPorts?: number;
            uplinkPortPolicy?: vimService.vim.DVSUplinkPortPolicy;
            uplinkPortgroup?: Array<vimService.vim.ManagedObjectReference>;
            defaultPortConfig?: vimService.vim.DVPortSetting;
            host?: Array<vimService.vim.DistributedVirtualSwitchHostMemberConfigSpec>;
            extensionKey?: string;
            description?: string;
            policy?: vimService.vim.DVSPolicy;
            vendorSpecificConfig?: Array<vimService.vim.DistributedVirtualSwitchKeyedOpaqueBlob>;
            contact?: vimService.vim.DVSContactInfo;
            switchIpAddress?: string;
            defaultProxySwitchMaxNumPorts?: number;
            infrastructureTrafficResourceConfig?: Array<vimService.vim.DvsHostInfrastructureTrafficResource>;
            networkResourceControlVersion?: string;
         }
         interface DVSCreateSpec extends vimService.vim.DynamicData {
            configSpec: vimService.vim.DVSConfigSpec;
            productInfo?: vimService.vim.DistributedVirtualSwitchProductSpec;
            capability?: vimService.vim.DVSCapability;
         }
         interface DVSConfigInfo extends vimService.vim.DynamicData {
            uuid: string;
            name: string;
            numStandalonePorts: number;
            numPorts: number;
            maxPorts: number;
            uplinkPortPolicy: vimService.vim.DVSUplinkPortPolicy;
            uplinkPortgroup?: Array<vimService.vim.ManagedObjectReference>;
            defaultPortConfig: vimService.vim.DVPortSetting;
            host?: Array<vimService.vim.DistributedVirtualSwitchHostMember>;
            productInfo: vimService.vim.DistributedVirtualSwitchProductSpec;
            targetInfo?: vimService.vim.DistributedVirtualSwitchProductSpec;
            extensionKey?: string;
            vendorSpecificConfig?: Array<vimService.vim.DistributedVirtualSwitchKeyedOpaqueBlob>;
            policy?: vimService.vim.DVSPolicy;
            description?: string;
            configVersion: string;
            contact: vimService.vim.DVSContactInfo;
            switchIpAddress?: string;
            createTime: Date;
            networkResourceManagementEnabled?: boolean;
            defaultProxySwitchMaxNumPorts?: number;
            healthCheckConfig?: Array<vimService.vim.DVSHealthCheckConfig>;
            infrastructureTrafficResourceConfig?: Array<vimService.vim.DvsHostInfrastructureTrafficResource>;
            networkResourceControlVersion?: string;
            vmVnicNetworkResourcePool?: Array<vimService.vim.DVSVmVnicNetworkResourcePool>;
            pnicCapacityRatioForReservation?: number;
         }
         enum DistributedVirtualSwitchNetworkResourceControlVersion {
            "version2",
            "version3",
         }
         enum DistributedVirtualSwitchHostInfrastructureTrafficClass {
            "management",
            "faultTolerance",
            "vmotion",
            "virtualMachine",
            "iSCSI",
            "nfs",
            "hbr",
            "vsan",
            "vdp",
         }
         interface DvsHostInfrastructureTrafficResourceAllocation extends vimService.vim.DynamicData {
            limit?: number;
            shares?: vimService.vim.SharesInfo;
            reservation?: number;
         }
         interface DvsHostInfrastructureTrafficResource extends vimService.vim.DynamicData {
            key: string;
            description?: string;
            allocationInfo: vimService.vim.DvsHostInfrastructureTrafficResourceAllocation;
         }
         interface ArrayOfDvsHostInfrastructureTrafficResource {
            DvsHostInfrastructureTrafficResource?: Array<vimService.vim.DvsHostInfrastructureTrafficResource>;
         }
         interface DVSHealthCheckConfig extends vimService.vim.DynamicData {
            enable?: boolean;
            interval?: number;
         }
         interface ArrayOfDVSHealthCheckConfig {
            DVSHealthCheckConfig?: Array<vimService.vim.DVSHealthCheckConfig>;
         }
         interface DvsResourceRuntimeInfo extends vimService.vim.DynamicData {
            capacity?: number;
            usage?: number;
            available?: number;
            allocatedResource?: Array<vimService.vim.DvsVnicAllocatedResource>;
            vmVnicNetworkResourcePoolRuntime?: Array<vimService.vim.DvsVmVnicNetworkResourcePoolRuntimeInfo>;
         }
         interface DVSRuntimeInfo extends vimService.vim.DynamicData {
            hostMemberRuntime?: Array<vimService.vim.HostMemberRuntimeInfo>;
            resourceRuntimeInfo?: vimService.vim.DvsResourceRuntimeInfo;
         }
         enum DrsInjectorWorkloadCorrelationState {
            "Correlated",
            "Uncorrelated",
         }
         interface EVCMode extends vimService.vim.ElementDescription {
            guaranteedCPUFeatures?: Array<vimService.vim.HostCpuIdInfo>;
            featureCapability?: Array<vimService.vim.HostFeatureCapability>;
            featureMask?: Array<vimService.vim.HostFeatureMask>;
            featureRequirement?: Array<vimService.vim.VirtualMachineFeatureRequirement>;
            vendor: string;
            track?: Array<string>;
            vendorTier: number;
         }
         interface ArrayOfEVCMode {
            EVCMode?: Array<vimService.vim.EVCMode>;
         }
         interface ElementDescription extends vimService.vim.Description {
            key: string;
         }
         interface ArrayOfElementDescription {
            ElementDescription?: Array<vimService.vim.ElementDescription>;
         }
         interface EnumDescription extends vimService.vim.DynamicData {
            key: string;
            tags: Array<vimService.vim.ElementDescription>;
         }
         interface ArrayOfEnumDescription {
            EnumDescription?: Array<vimService.vim.EnumDescription>;
         }
         interface EnvironmentBrowserConfigOptionQuerySpec extends vimService.vim.DynamicData {
            key?: string;
            host?: vimService.vim.ManagedObjectReference;
            guestId?: Array<string>;
         }
         interface ExtendedDescription extends vimService.vim.Description {
            messageCatalogKeyPrefix: string;
            messageArg?: Array<vimService.vim.KeyAnyValue>;
         }
         interface ExtendedElementDescription extends vimService.vim.ElementDescription {
            messageCatalogKeyPrefix: string;
            messageArg?: Array<vimService.vim.KeyAnyValue>;
         }
         interface ExtensionServerInfo extends vimService.vim.DynamicData {
            url: string;
            description: vimService.vim.Description;
            company: string;
            type: string;
            adminEmail: Array<string>;
            serverThumbprint?: string;
         }
         interface ArrayOfExtensionServerInfo {
            ExtensionServerInfo?: Array<vimService.vim.ExtensionServerInfo>;
         }
         interface ExtensionClientInfo extends vimService.vim.DynamicData {
            version: string;
            description: vimService.vim.Description;
            company: string;
            type: string;
            url: string;
         }
         interface ArrayOfExtensionClientInfo {
            ExtensionClientInfo?: Array<vimService.vim.ExtensionClientInfo>;
         }
         interface ExtensionTaskTypeInfo extends vimService.vim.DynamicData {
            taskID: string;
         }
         interface ArrayOfExtensionTaskTypeInfo {
            ExtensionTaskTypeInfo?: Array<vimService.vim.ExtensionTaskTypeInfo>;
         }
         interface ExtensionEventTypeInfo extends vimService.vim.DynamicData {
            eventID: string;
            eventTypeSchema?: string;
         }
         interface ArrayOfExtensionEventTypeInfo {
            ExtensionEventTypeInfo?: Array<vimService.vim.ExtensionEventTypeInfo>;
         }
         interface ExtensionFaultTypeInfo extends vimService.vim.DynamicData {
            faultID: string;
         }
         interface ArrayOfExtensionFaultTypeInfo {
            ExtensionFaultTypeInfo?: Array<vimService.vim.ExtensionFaultTypeInfo>;
         }
         interface ExtensionPrivilegeInfo extends vimService.vim.DynamicData {
            privID: string;
            privGroupName: string;
         }
         interface ArrayOfExtensionPrivilegeInfo {
            ExtensionPrivilegeInfo?: Array<vimService.vim.ExtensionPrivilegeInfo>;
         }
         interface ExtensionResourceInfo extends vimService.vim.DynamicData {
            locale: string;
            module: string;
            data: Array<vimService.vim.KeyValue>;
         }
         interface ArrayOfExtensionResourceInfo {
            ExtensionResourceInfo?: Array<vimService.vim.ExtensionResourceInfo>;
         }
         interface ExtensionHealthInfo extends vimService.vim.DynamicData {
            url: string;
         }
         interface ExtensionOvfConsumerInfo extends vimService.vim.DynamicData {
            callbackUrl: string;
            sectionType: Array<string>;
         }
         interface Extension extends vimService.vim.DynamicData {
            description: vimService.vim.Description;
            key: string;
            company?: string;
            type?: string;
            version: string;
            subjectName?: string;
            server?: Array<vimService.vim.ExtensionServerInfo>;
            client?: Array<vimService.vim.ExtensionClientInfo>;
            taskList?: Array<vimService.vim.ExtensionTaskTypeInfo>;
            eventList?: Array<vimService.vim.ExtensionEventTypeInfo>;
            faultList?: Array<vimService.vim.ExtensionFaultTypeInfo>;
            privilegeList?: Array<vimService.vim.ExtensionPrivilegeInfo>;
            resourceList?: Array<vimService.vim.ExtensionResourceInfo>;
            lastHeartbeatTime: Date;
            healthInfo?: vimService.vim.ExtensionHealthInfo;
            ovfConsumerInfo?: vimService.vim.ExtensionOvfConsumerInfo;
            extendedProductInfo?: vimService.vim.ExtExtendedProductInfo;
            managedEntityInfo?: Array<vimService.vim.ExtManagedEntityInfo>;
            shownInSolutionManager?: boolean;
            solutionManagerInfo?: vimService.vim.ExtSolutionManagerInfo;
         }
         interface ArrayOfExtension {
            Extension?: Array<vimService.vim.Extension>;
         }
         interface ExtensionManagerIpAllocationUsage extends vimService.vim.DynamicData {
            extensionKey: string;
            numAddresses: number;
         }
         interface ArrayOfExtensionManagerIpAllocationUsage {
            ExtensionManagerIpAllocationUsage?: Array<vimService.vim.ExtensionManagerIpAllocationUsage>;
         }
         enum ReplicationVmState {
            "none",
            "paused",
            "syncing",
            "idle",
            "active",
            "error",
         }
         interface ReplicationVmProgressInfo extends vimService.vim.DynamicData {
            progress: number;
            bytesTransferred: number;
            bytesToTransfer: number;
            checksumTotalBytes?: number;
            checksumComparedBytes?: number;
         }
         interface HbrManagerReplicationVmInfo extends vimService.vim.DynamicData {
            state: string;
            progressInfo?: vimService.vim.ReplicationVmProgressInfo;
            imageId?: string;
            lastError?: vimService.vim.LocalizedMethodFault;
         }
         enum QuiesceMode {
            "application",
            "filesystem",
            "none",
         }
         interface HbrManagerVmReplicationCapability extends vimService.vim.DynamicData {
            vm: vimService.vim.ManagedObjectReference;
            supportedQuiesceMode: string;
            compressionSupported: boolean;
            maxSupportedSourceDiskCapacity: number;
            minRpo?: number;
            fault?: vimService.vim.LocalizedMethodFault;
         }
         interface ArrayOfHbrManagerVmReplicationCapability {
            HbrManagerVmReplicationCapability?: Array<vimService.vim.HbrManagerVmReplicationCapability>;
         }
         enum HealthUpdateInfoComponentType {
            "Memory",
            "Power",
            "Fan",
            "Network",
            "Storage",
         }
         interface HealthUpdateInfo extends vimService.vim.DynamicData {
            id: string;
            componentType: string;
            description: string;
         }
         interface ArrayOfHealthUpdateInfo {
            HealthUpdateInfo?: Array<vimService.vim.HealthUpdateInfo>;
         }
         interface HealthUpdate extends vimService.vim.DynamicData {
            entity: vimService.vim.ManagedObjectReference;
            healthUpdateInfoId: string;
            id: string;
            status: vimService.vim.ManagedEntityStatus;
            remediation: string;
         }
         interface ArrayOfHealthUpdate {
            HealthUpdate?: Array<vimService.vim.HealthUpdate>;
         }
         interface HostServiceTicket extends vimService.vim.DynamicData {
            host?: string;
            port?: number;
            sslThumbprint?: string;
            service: string;
            serviceVersion: string;
            sessionId: string;
         }
         enum HostSystemConnectionState {
            "connected",
            "notResponding",
            "disconnected",
         }
         enum HostSystemPowerState {
            "poweredOn",
            "poweredOff",
            "standBy",
            "unknown",
         }
         enum HostStandbyMode {
            "entering",
            "exiting",
            "in",
            "none",
         }
         enum HostCryptoState {
            "incapable",
            "prepared",
            "safe",
         }
         interface HostSystemReconnectSpec extends vimService.vim.DynamicData {
            syncState?: boolean;
         }
         enum HttpNfcLeaseState {
            "initializing",
            "ready",
            "done",
            "error",
         }
         interface HttpNfcLeaseDatastoreLeaseInfo extends vimService.vim.DynamicData {
            datastoreKey: string;
            hosts: Array<vimService.vim.HttpNfcLeaseHostInfo>;
         }
         interface ArrayOfHttpNfcLeaseDatastoreLeaseInfo {
            HttpNfcLeaseDatastoreLeaseInfo?: Array<vimService.vim.HttpNfcLeaseDatastoreLeaseInfo>;
         }
         interface HttpNfcLeaseHostInfo extends vimService.vim.DynamicData {
            url: string;
            sslThumbprint: string;
         }
         interface ArrayOfHttpNfcLeaseHostInfo {
            HttpNfcLeaseHostInfo?: Array<vimService.vim.HttpNfcLeaseHostInfo>;
         }
         interface HttpNfcLeaseInfo extends vimService.vim.DynamicData {
            lease: vimService.vim.ManagedObjectReference;
            entity: vimService.vim.ManagedObjectReference;
            deviceUrl?: Array<vimService.vim.HttpNfcLeaseDeviceUrl>;
            totalDiskCapacityInKB: number;
            leaseTimeout: number;
            hostMap?: Array<vimService.vim.HttpNfcLeaseDatastoreLeaseInfo>;
         }
         interface HttpNfcLeaseDeviceUrl extends vimService.vim.DynamicData {
            key: string;
            importKey: string;
            url: string;
            sslThumbprint: string;
            disk?: boolean;
            targetId?: string;
            datastoreKey?: string;
            fileSize?: number;
         }
         interface ArrayOfHttpNfcLeaseDeviceUrl {
            HttpNfcLeaseDeviceUrl?: Array<vimService.vim.HttpNfcLeaseDeviceUrl>;
         }
         interface HttpNfcLeaseManifestEntry extends vimService.vim.DynamicData {
            key: string;
            sha1: string;
            size: number;
            disk: boolean;
            capacity?: number;
            populatedSize?: number;
         }
         interface ArrayOfHttpNfcLeaseManifestEntry {
            HttpNfcLeaseManifestEntry?: Array<vimService.vim.HttpNfcLeaseManifestEntry>;
         }
         interface ImportSpec extends vimService.vim.DynamicData {
            entityConfig?: vimService.vim.VAppEntityConfigInfo;
            instantiationOst?: vimService.vim.OvfConsumerOstNode;
         }
         interface ArrayOfImportSpec {
            ImportSpec?: Array<vimService.vim.ImportSpec>;
         }
         interface InheritablePolicy extends vimService.vim.DynamicData {
            inherited: boolean;
         }
         interface IntExpression extends vimService.vim.NegatableExpression {
            value?: number;
         }
         interface IntPolicy extends vimService.vim.InheritablePolicy {
            value?: number;
         }
         interface IoFilterInfo extends vimService.vim.DynamicData {
            id: string;
            name: string;
            vendor: string;
            version: string;
            type?: string;
            summary?: string;
            releaseDate?: string;
         }
         interface HostIoFilterInfo extends vimService.vim.IoFilterInfo {
            available: boolean;
         }
         interface ArrayOfHostIoFilterInfo {
            HostIoFilterInfo?: Array<vimService.vim.HostIoFilterInfo>;
         }
         enum IoFilterOperation {
            "install",
            "uninstall",
            "upgrade",
         }
         interface ClusterIoFilterInfo extends vimService.vim.IoFilterInfo {
            opType: string;
            vibUrl?: string;
         }
         interface ArrayOfClusterIoFilterInfo {
            ClusterIoFilterInfo?: Array<vimService.vim.ClusterIoFilterInfo>;
         }
         enum IoFilterType {
            "cache",
            "replication",
            "encryption",
            "compression",
            "inspection",
            "datastoreIoControl",
            "dataProvider",
         }
         interface IoFilterHostIssue extends vimService.vim.DynamicData {
            host: vimService.vim.ManagedObjectReference;
            issue: Array<vimService.vim.LocalizedMethodFault>;
         }
         interface ArrayOfIoFilterHostIssue {
            IoFilterHostIssue?: Array<vimService.vim.IoFilterHostIssue>;
         }
         interface IoFilterQueryIssueResult extends vimService.vim.DynamicData {
            opType: string;
            hostIssue?: Array<vimService.vim.IoFilterHostIssue>;
         }
         interface IpAddress extends vimService.vim.NegatableExpression {
         }
         interface IpPoolManagerIpAllocation extends vimService.vim.DynamicData {
            ipAddress: string;
            allocationId: string;
         }
         interface ArrayOfIpPoolManagerIpAllocation {
            IpPoolManagerIpAllocation?: Array<vimService.vim.IpPoolManagerIpAllocation>;
         }
         interface IpRange extends vimService.vim.IpAddress {
            addressPrefix: string;
            prefixLength?: number;
         }
         interface KeyValue extends vimService.vim.DynamicData {
            key: string;
            value: string;
         }
         interface ArrayOfKeyValue {
            KeyValue?: Array<vimService.vim.KeyValue>;
         }
         enum LatencySensitivitySensitivityLevel {
            "low",
            "normal",
            "medium",
            "high",
            "custom",
         }
         interface LatencySensitivity extends vimService.vim.DynamicData {
            level: vimService.vim.LatencySensitivitySensitivityLevel;
            sensitivity?: number;
         }
         interface LicenseAssignmentManagerLicenseAssignment extends vimService.vim.DynamicData {
            entityId: string;
            scope?: string;
            entityDisplayName?: string;
            assignedLicense: vimService.vim.LicenseManagerLicenseInfo;
            properties?: Array<vimService.vim.KeyAnyValue>;
         }
         interface ArrayOfLicenseAssignmentManagerLicenseAssignment {
            LicenseAssignmentManagerLicenseAssignment?: Array<vimService.vim.LicenseAssignmentManagerLicenseAssignment>;
         }
         enum LicenseManagerState {
            "initializing",
            "normal",
            "marginal",
            "fault",
         }
         enum LicenseManagerLicenseKey {
            "esxFull",
            "esxVmtn",
            "esxExpress",
            "san",
            "iscsi",
            "nas",
            "vsmp",
            "backup",
            "vc",
            "vcExpress",
            "esxHost",
            "gsxHost",
            "serverHost",
            "drsPower",
            "vmotion",
            "drs",
            "das",
         }
         interface LicenseSource extends vimService.vim.DynamicData {
         }
         interface LicenseServerSource extends vimService.vim.LicenseSource {
            licenseServer: string;
         }
         interface LocalLicenseSource extends vimService.vim.LicenseSource {
            licenseKeys: string;
         }
         interface EvaluationLicenseSource extends vimService.vim.LicenseSource {
            remainingHours?: number;
         }
         enum LicenseFeatureInfoUnit {
            "host",
            "cpuCore",
            "cpuPackage",
            "server",
            "vm",
         }
         enum LicenseFeatureInfoState {
            "enabled",
            "disabled",
            "optional",
         }
         enum LicenseFeatureInfoSourceRestriction {
            "unrestricted",
            "served",
            "file",
         }
         interface LicenseFeatureInfo extends vimService.vim.DynamicData {
            key: string;
            featureName: string;
            featureDescription?: string;
            state?: vimService.vim.LicenseFeatureInfoState;
            costUnit: string;
            sourceRestriction?: string;
            dependentKey?: Array<string>;
            edition?: boolean;
            expiresOn?: Date;
         }
         interface ArrayOfLicenseFeatureInfo {
            LicenseFeatureInfo?: Array<vimService.vim.LicenseFeatureInfo>;
         }
         enum LicenseReservationInfoState {
            "notUsed",
            "noLicense",
            "unlicensedUse",
            "licensed",
         }
         interface LicenseReservationInfo extends vimService.vim.DynamicData {
            key: string;
            state: vimService.vim.LicenseReservationInfoState;
            required: number;
         }
         interface ArrayOfLicenseReservationInfo {
            LicenseReservationInfo?: Array<vimService.vim.LicenseReservationInfo>;
         }
         interface LicenseAvailabilityInfo extends vimService.vim.DynamicData {
            feature: vimService.vim.LicenseFeatureInfo;
            total: number;
            available: number;
         }
         interface ArrayOfLicenseAvailabilityInfo {
            LicenseAvailabilityInfo?: Array<vimService.vim.LicenseAvailabilityInfo>;
         }
         interface LicenseDiagnostics extends vimService.vim.DynamicData {
            sourceLastChanged: Date;
            sourceLost: string;
            sourceLatency: number;
            licenseRequests: string;
            licenseRequestFailures: string;
            licenseFeatureUnknowns: string;
            opState: vimService.vim.LicenseManagerState;
            lastStatusUpdate: Date;
            opFailureMessage: string;
         }
         interface LicenseUsageInfo extends vimService.vim.DynamicData {
            source: vimService.vim.LicenseSource;
            sourceAvailable: boolean;
            reservationInfo?: Array<vimService.vim.LicenseReservationInfo>;
            featureInfo?: Array<vimService.vim.LicenseFeatureInfo>;
         }
         interface LicenseManagerEvaluationInfo extends vimService.vim.DynamicData {
            properties: Array<vimService.vim.KeyAnyValue>;
         }
         enum HostLicensableResourceKey {
            "numCpuPackages",
            "numCpuCores",
            "memorySize",
            "memoryForVms",
            "numVmsStarted",
            "numVmsStarting",
         }
         interface HostLicensableResourceInfo extends vimService.vim.DynamicData {
            resource: Array<vimService.vim.KeyAnyValue>;
         }
         interface LicenseManagerLicenseInfo extends vimService.vim.DynamicData {
            licenseKey: string;
            editionKey: string;
            name: string;
            total: number;
            used?: number;
            costUnit: string;
            properties?: Array<vimService.vim.KeyAnyValue>;
            labels?: Array<vimService.vim.KeyValue>;
         }
         interface ArrayOfLicenseManagerLicenseInfo {
            LicenseManagerLicenseInfo?: Array<vimService.vim.LicenseManagerLicenseInfo>;
         }
         interface LocalizationManagerMessageCatalog extends vimService.vim.DynamicData {
            moduleName: string;
            catalogName: string;
            locale: string;
            catalogUri: string;
            lastModified?: Date;
            md5sum?: string;
            version?: string;
         }
         interface ArrayOfLocalizationManagerMessageCatalog {
            LocalizationManagerMessageCatalog?: Array<vimService.vim.LocalizationManagerMessageCatalog>;
         }
         interface LongPolicy extends vimService.vim.InheritablePolicy {
            value?: number;
         }
         interface MacAddress extends vimService.vim.NegatableExpression {
         }
         interface MacRange extends vimService.vim.MacAddress {
            address: string;
            mask: string;
         }
         enum ManagedEntityStatus {
            "gray",
            "green",
            "yellow",
            "red",
         }
         interface MethodDescription extends vimService.vim.Description {
            key: string;
         }
         interface NegatableExpression extends vimService.vim.DynamicData {
            negate?: boolean;
         }
         interface NetworkSummary extends vimService.vim.DynamicData {
            network?: vimService.vim.ManagedObjectReference;
            name: string;
            accessible: boolean;
            ipPoolName?: string;
            ipPoolId?: number;
         }
         interface NumericRange extends vimService.vim.DynamicData {
            start: number;
            end: number;
         }
         interface ArrayOfNumericRange {
            NumericRange?: Array<vimService.vim.NumericRange>;
         }
         interface OpaqueNetworkSummary extends vimService.vim.NetworkSummary {
            opaqueNetworkId: string;
            opaqueNetworkType: string;
         }
         interface OpaqueNetworkCapability extends vimService.vim.DynamicData {
            networkReservationSupported: boolean;
         }
         interface OvfConsumerOvfSection extends vimService.vim.DynamicData {
            lineNumber: number;
            xml: string;
         }
         interface ArrayOfOvfConsumerOvfSection {
            OvfConsumerOvfSection?: Array<vimService.vim.OvfConsumerOvfSection>;
         }
         enum OvfConsumerOstNodeType {
            "envelope",
            "virtualSystem",
            "virtualSystemCollection",
         }
         interface OvfConsumerOstNode extends vimService.vim.DynamicData {
            id: string;
            type: string;
            section?: Array<vimService.vim.OvfConsumerOvfSection>;
            child?: Array<vimService.vim.OvfConsumerOstNode>;
            entity?: vimService.vim.ManagedObjectReference;
         }
         interface ArrayOfOvfConsumerOstNode {
            OvfConsumerOstNode?: Array<vimService.vim.OvfConsumerOstNode>;
         }
         interface OvfOptionInfo extends vimService.vim.DynamicData {
            option: string;
            description: vimService.vim.LocalizableMessage;
         }
         interface ArrayOfOvfOptionInfo {
            OvfOptionInfo?: Array<vimService.vim.OvfOptionInfo>;
         }
         interface OvfDeploymentOption extends vimService.vim.DynamicData {
            key: string;
            label: string;
            description: string;
         }
         interface ArrayOfOvfDeploymentOption {
            OvfDeploymentOption?: Array<vimService.vim.OvfDeploymentOption>;
         }
         interface OvfManagerCommonParams extends vimService.vim.DynamicData {
            locale: string;
            deploymentOption: string;
            msgBundle?: Array<vimService.vim.KeyValue>;
            importOption?: Array<string>;
         }
         interface OvfValidateHostParams extends vimService.vim.OvfManagerCommonParams {
         }
         interface OvfValidateHostResult extends vimService.vim.DynamicData {
            downloadSize?: number;
            flatDeploymentSize?: number;
            sparseDeploymentSize?: number;
            error?: Array<vimService.vim.LocalizedMethodFault>;
            warning?: Array<vimService.vim.LocalizedMethodFault>;
            supportedDiskProvisioning?: Array<string>;
         }
         interface OvfParseDescriptorParams extends vimService.vim.OvfManagerCommonParams {
         }
         interface OvfParseDescriptorResult extends vimService.vim.DynamicData {
            eula?: Array<string>;
            network?: Array<vimService.vim.OvfNetworkInfo>;
            ipAllocationScheme?: Array<string>;
            ipProtocols?: Array<string>;
            property?: Array<vimService.vim.VAppPropertyInfo>;
            productInfo?: vimService.vim.VAppProductInfo;
            annotation: string;
            approximateDownloadSize?: number;
            approximateFlatDeploymentSize?: number;
            approximateSparseDeploymentSize?: number;
            defaultEntityName: string;
            virtualApp: boolean;
            deploymentOption?: Array<vimService.vim.OvfDeploymentOption>;
            defaultDeploymentOption: string;
            entityName?: Array<vimService.vim.KeyValue>;
            annotatedOst?: vimService.vim.OvfConsumerOstNode;
            error?: Array<vimService.vim.LocalizedMethodFault>;
            warning?: Array<vimService.vim.LocalizedMethodFault>;
         }
         interface OvfNetworkInfo extends vimService.vim.DynamicData {
            name: string;
            description: string;
         }
         interface ArrayOfOvfNetworkInfo {
            OvfNetworkInfo?: Array<vimService.vim.OvfNetworkInfo>;
         }
         enum OvfCreateImportSpecParamsDiskProvisioningType {
            "monolithicSparse",
            "monolithicFlat",
            "twoGbMaxExtentSparse",
            "twoGbMaxExtentFlat",
            "thin",
            "thick",
            "seSparse",
            "eagerZeroedThick",
            "sparse",
            "flat",
         }
         interface OvfCreateImportSpecParams extends vimService.vim.OvfManagerCommonParams {
            entityName: string;
            hostSystem?: vimService.vim.ManagedObjectReference;
            networkMapping?: Array<vimService.vim.OvfNetworkMapping>;
            ipAllocationPolicy?: string;
            ipProtocol?: string;
            propertyMapping?: Array<vimService.vim.KeyValue>;
            resourceMapping?: Array<vimService.vim.OvfResourceMap>;
            diskProvisioning?: string;
            instantiationOst?: vimService.vim.OvfConsumerOstNode;
         }
         interface OvfResourceMap extends vimService.vim.DynamicData {
            source: string;
            parent?: vimService.vim.ManagedObjectReference;
            resourceSpec?: vimService.vim.ResourceConfigSpec;
            datastore?: vimService.vim.ManagedObjectReference;
         }
         interface ArrayOfOvfResourceMap {
            OvfResourceMap?: Array<vimService.vim.OvfResourceMap>;
         }
         interface OvfNetworkMapping extends vimService.vim.DynamicData {
            name: string;
            network: vimService.vim.ManagedObjectReference;
         }
         interface ArrayOfOvfNetworkMapping {
            OvfNetworkMapping?: Array<vimService.vim.OvfNetworkMapping>;
         }
         interface OvfCreateImportSpecResult extends vimService.vim.DynamicData {
            importSpec?: vimService.vim.ImportSpec;
            fileItem?: Array<vimService.vim.OvfFileItem>;
            warning?: Array<vimService.vim.LocalizedMethodFault>;
            error?: Array<vimService.vim.LocalizedMethodFault>;
         }
         interface OvfFileItem extends vimService.vim.DynamicData {
            deviceId: string;
            path: string;
            compressionMethod?: string;
            chunkSize?: number;
            size?: number;
            cimType: number;
            create: boolean;
         }
         interface ArrayOfOvfFileItem {
            OvfFileItem?: Array<vimService.vim.OvfFileItem>;
         }
         interface OvfCreateDescriptorParams extends vimService.vim.DynamicData {
            ovfFiles?: Array<vimService.vim.OvfFile>;
            name?: string;
            description?: string;
            includeImageFiles?: boolean;
            exportOption?: Array<string>;
            snapshot?: vimService.vim.ManagedObjectReference;
         }
         interface OvfCreateDescriptorResult extends vimService.vim.DynamicData {
            ovfDescriptor: string;
            error?: Array<vimService.vim.LocalizedMethodFault>;
            warning?: Array<vimService.vim.LocalizedMethodFault>;
            includeImageFiles?: boolean;
         }
         interface OvfFile extends vimService.vim.DynamicData {
            deviceId: string;
            path: string;
            compressionMethod?: string;
            chunkSize?: number;
            size: number;
            capacity?: number;
            populatedSize?: number;
         }
         interface ArrayOfOvfFile {
            OvfFile?: Array<vimService.vim.OvfFile>;
         }
         interface PasswordField extends vimService.vim.DynamicData {
            value: string;
         }
         interface PerformanceDescription extends vimService.vim.DynamicData {
            counterType: Array<vimService.vim.ElementDescription>;
            statsType: Array<vimService.vim.ElementDescription>;
         }
         enum PerfFormat {
            "normal",
            "csv",
         }
         interface PerfProviderSummary extends vimService.vim.DynamicData {
            entity: vimService.vim.ManagedObjectReference;
            currentSupported: boolean;
            summarySupported: boolean;
            refreshRate?: number;
         }
         enum PerfSummaryType {
            "average",
            "maximum",
            "minimum",
            "latest",
            "summation",
            "none",
         }
         enum PerfStatsType {
            "absolute",
            "delta",
            "rate",
         }
         enum PerformanceManagerUnit {
            "percent",
            "kiloBytes",
            "megaBytes",
            "megaHertz",
            "number",
            "microsecond",
            "millisecond",
            "second",
            "kiloBytesPerSecond",
            "megaBytesPerSecond",
            "watt",
            "joule",
            "teraBytes",
         }
         interface PerfCounterInfo extends vimService.vim.DynamicData {
            key: number;
            nameInfo: vimService.vim.ElementDescription;
            groupInfo: vimService.vim.ElementDescription;
            unitInfo: vimService.vim.ElementDescription;
            rollupType: vimService.vim.PerfSummaryType;
            statsType: vimService.vim.PerfStatsType;
            level?: number;
            perDeviceLevel?: number;
            associatedCounterId?: Array<number>;
         }
         interface ArrayOfPerfCounterInfo {
            PerfCounterInfo?: Array<vimService.vim.PerfCounterInfo>;
         }
         interface PerfMetricId extends vimService.vim.DynamicData {
            counterId: number;
            instance: string;
         }
         interface ArrayOfPerfMetricId {
            PerfMetricId?: Array<vimService.vim.PerfMetricId>;
         }
         interface PerfQuerySpec extends vimService.vim.DynamicData {
            entity: vimService.vim.ManagedObjectReference;
            startTime?: Date;
            endTime?: Date;
            maxSample?: number;
            metricId?: Array<vimService.vim.PerfMetricId>;
            intervalId?: number;
            format?: string;
         }
         interface ArrayOfPerfQuerySpec {
            PerfQuerySpec?: Array<vimService.vim.PerfQuerySpec>;
         }
         interface PerfSampleInfo extends vimService.vim.DynamicData {
            timestamp: Date;
            interval: number;
         }
         interface ArrayOfPerfSampleInfo {
            PerfSampleInfo?: Array<vimService.vim.PerfSampleInfo>;
         }
         interface PerfMetricSeries extends vimService.vim.DynamicData {
            id: vimService.vim.PerfMetricId;
         }
         interface ArrayOfPerfMetricSeries {
            PerfMetricSeries?: Array<vimService.vim.PerfMetricSeries>;
         }
         interface PerfMetricIntSeries extends vimService.vim.PerfMetricSeries {
            value?: Array<number>;
         }
         interface PerfMetricSeriesCSV extends vimService.vim.PerfMetricSeries {
            value?: string;
         }
         interface ArrayOfPerfMetricSeriesCSV {
            PerfMetricSeriesCSV?: Array<vimService.vim.PerfMetricSeriesCSV>;
         }
         interface PerfEntityMetricBase extends vimService.vim.DynamicData {
            entity: vimService.vim.ManagedObjectReference;
         }
         interface ArrayOfPerfEntityMetricBase {
            PerfEntityMetricBase?: Array<vimService.vim.PerfEntityMetricBase>;
         }
         interface PerfEntityMetric extends vimService.vim.PerfEntityMetricBase {
            sampleInfo?: Array<vimService.vim.PerfSampleInfo>;
            value?: Array<vimService.vim.PerfMetricSeries>;
         }
         interface PerfEntityMetricCSV extends vimService.vim.PerfEntityMetricBase {
            sampleInfoCSV: string;
            value?: Array<vimService.vim.PerfMetricSeriesCSV>;
         }
         interface PerfCompositeMetric extends vimService.vim.DynamicData {
            entity?: vimService.vim.PerfEntityMetricBase;
            childEntity?: Array<vimService.vim.PerfEntityMetricBase>;
         }
         interface PerformanceManagerCounterLevelMapping extends vimService.vim.DynamicData {
            counterId: number;
            aggregateLevel?: number;
            perDeviceLevel?: number;
         }
         interface ArrayOfPerformanceManagerCounterLevelMapping {
            PerformanceManagerCounterLevelMapping?: Array<vimService.vim.PerformanceManagerCounterLevelMapping>;
         }
         interface PerfInterval extends vimService.vim.DynamicData {
            key: number;
            samplingPeriod: number;
            name: string;
            length: number;
            level?: number;
            enabled: boolean;
         }
         interface ArrayOfPerfInterval {
            PerfInterval?: Array<vimService.vim.PerfInterval>;
         }
         interface PosixUserSearchResult extends vimService.vim.UserSearchResult {
            id: number;
            shellAccess?: boolean;
         }
         interface PrivilegePolicyDef extends vimService.vim.DynamicData {
            createPrivilege: string;
            readPrivilege: string;
            updatePrivilege: string;
            deletePrivilege: string;
         }
         interface ResourceAllocationInfo extends vimService.vim.DynamicData {
            reservation?: number;
            expandableReservation?: boolean;
            limit?: number;
            shares?: vimService.vim.SharesInfo;
            overheadLimit?: number;
         }
         interface ResourceAllocationOption extends vimService.vim.DynamicData {
            sharesOption: vimService.vim.SharesOption;
         }
         interface ResourceConfigOption extends vimService.vim.DynamicData {
            cpuAllocationOption: vimService.vim.ResourceAllocationOption;
            memoryAllocationOption: vimService.vim.ResourceAllocationOption;
         }
         interface ResourceConfigSpec extends vimService.vim.DynamicData {
            entity?: vimService.vim.ManagedObjectReference;
            changeVersion?: string;
            lastModified?: Date;
            cpuAllocation: vimService.vim.ResourceAllocationInfo;
            memoryAllocation: vimService.vim.ResourceAllocationInfo;
         }
         interface ArrayOfResourceConfigSpec {
            ResourceConfigSpec?: Array<vimService.vim.ResourceConfigSpec>;
         }
         interface DatabaseSizeParam extends vimService.vim.DynamicData {
            inventoryDesc: vimService.vim.InventoryDescription;
            perfStatsDesc?: vimService.vim.PerformanceStatisticsDescription;
         }
         interface InventoryDescription extends vimService.vim.DynamicData {
            numHosts: number;
            numVirtualMachines: number;
            numResourcePools?: number;
            numClusters?: number;
            numCpuDev?: number;
            numNetDev?: number;
            numDiskDev?: number;
            numvCpuDev?: number;
            numvNetDev?: number;
            numvDiskDev?: number;
         }
         interface PerformanceStatisticsDescription extends vimService.vim.DynamicData {
            intervals?: Array<vimService.vim.PerfInterval>;
         }
         interface DatabaseSizeEstimate extends vimService.vim.DynamicData {
            size: number;
         }
         interface ResourcePoolResourceUsage extends vimService.vim.DynamicData {
            reservationUsed: number;
            reservationUsedForVm: number;
            unreservedForPool: number;
            unreservedForVm: number;
            overallUsage: number;
            maxUsage: number;
         }
         interface ResourcePoolRuntimeInfo extends vimService.vim.DynamicData {
            memory: vimService.vim.ResourcePoolResourceUsage;
            cpu: vimService.vim.ResourcePoolResourceUsage;
            overallStatus: vimService.vim.ManagedEntityStatus;
         }
         interface ResourcePoolQuickStats extends vimService.vim.DynamicData {
            overallCpuUsage?: number;
            overallCpuDemand?: number;
            guestMemoryUsage?: number;
            hostMemoryUsage?: number;
            distributedCpuEntitlement?: number;
            distributedMemoryEntitlement?: number;
            staticCpuEntitlement?: number;
            staticMemoryEntitlement?: number;
            privateMemory?: number;
            sharedMemory?: number;
            swappedMemory?: number;
            balloonedMemory?: number;
            overheadMemory?: number;
            consumedOverheadMemory?: number;
            compressedMemory?: number;
         }
         interface ResourcePoolSummary extends vimService.vim.DynamicData {
            name: string;
            config: vimService.vim.ResourceConfigSpec;
            runtime: vimService.vim.ResourcePoolRuntimeInfo;
            quickStats?: vimService.vim.ResourcePoolQuickStats;
            configuredMemoryMB?: number;
         }
         interface SelectionSet extends vimService.vim.DynamicData {
         }
         interface ArrayOfSelectionSet {
            SelectionSet?: Array<vimService.vim.SelectionSet>;
         }
         enum ValidateMigrationTestType {
            "sourceTests",
            "compatibilityTests",
            "diskAccessibilityTests",
            "resourceTests",
         }
         enum VMotionCompatibilityType {
            "cpu",
            "software",
         }
         interface HostVMotionCompatibility extends vimService.vim.DynamicData {
            host: vimService.vim.ManagedObjectReference;
            compatibility?: Array<string>;
         }
         interface ArrayOfHostVMotionCompatibility {
            HostVMotionCompatibility?: Array<vimService.vim.HostVMotionCompatibility>;
         }
         interface ProductComponentInfo extends vimService.vim.DynamicData {
            id: string;
            name: string;
            version: string;
            release: number;
         }
         interface ArrayOfProductComponentInfo {
            ProductComponentInfo?: Array<vimService.vim.ProductComponentInfo>;
         }
         interface ServiceContent extends vimService.vim.DynamicData {
            rootFolder: vimService.vim.ManagedObjectReference;
            propertyCollector: vimService.vim.ManagedObjectReference;
            viewManager?: vimService.vim.ManagedObjectReference;
            about: vimService.vim.AboutInfo;
            setting?: vimService.vim.ManagedObjectReference;
            userDirectory?: vimService.vim.ManagedObjectReference;
            sessionManager?: vimService.vim.ManagedObjectReference;
            authorizationManager?: vimService.vim.ManagedObjectReference;
            serviceManager?: vimService.vim.ManagedObjectReference;
            perfManager?: vimService.vim.ManagedObjectReference;
            scheduledTaskManager?: vimService.vim.ManagedObjectReference;
            alarmManager?: vimService.vim.ManagedObjectReference;
            eventManager?: vimService.vim.ManagedObjectReference;
            taskManager?: vimService.vim.ManagedObjectReference;
            extensionManager?: vimService.vim.ManagedObjectReference;
            customizationSpecManager?: vimService.vim.ManagedObjectReference;
            customFieldsManager?: vimService.vim.ManagedObjectReference;
            accountManager?: vimService.vim.ManagedObjectReference;
            diagnosticManager?: vimService.vim.ManagedObjectReference;
            licenseManager?: vimService.vim.ManagedObjectReference;
            searchIndex?: vimService.vim.ManagedObjectReference;
            fileManager?: vimService.vim.ManagedObjectReference;
            datastoreNamespaceManager?: vimService.vim.ManagedObjectReference;
            virtualDiskManager?: vimService.vim.ManagedObjectReference;
            virtualizationManager?: vimService.vim.ManagedObjectReference;
            snmpSystem?: vimService.vim.ManagedObjectReference;
            vmProvisioningChecker?: vimService.vim.ManagedObjectReference;
            vmCompatibilityChecker?: vimService.vim.ManagedObjectReference;
            ovfManager?: vimService.vim.ManagedObjectReference;
            ipPoolManager?: vimService.vim.ManagedObjectReference;
            dvSwitchManager?: vimService.vim.ManagedObjectReference;
            hostProfileManager?: vimService.vim.ManagedObjectReference;
            clusterProfileManager?: vimService.vim.ManagedObjectReference;
            complianceManager?: vimService.vim.ManagedObjectReference;
            localizationManager?: vimService.vim.ManagedObjectReference;
            storageResourceManager?: vimService.vim.ManagedObjectReference;
            guestOperationsManager?: vimService.vim.ManagedObjectReference;
            overheadMemoryManager?: vimService.vim.ManagedObjectReference;
            certificateManager?: vimService.vim.ManagedObjectReference;
            ioFilterManager?: vimService.vim.ManagedObjectReference;
            vStorageObjectManager?: vimService.vim.ManagedObjectReference;
            hostSpecManager?: vimService.vim.ManagedObjectReference;
            cryptoManager?: vimService.vim.ManagedObjectReference;
            healthUpdateManager?: vimService.vim.ManagedObjectReference;
            failoverClusterConfigurator?: vimService.vim.ManagedObjectReference;
            failoverClusterManager?: vimService.vim.ManagedObjectReference;
         }
         interface ServiceLocatorCredential extends vimService.vim.DynamicData {
         }
         interface ServiceLocatorNamePassword extends vimService.vim.ServiceLocatorCredential {
            username: string;
            password: string;
         }
         interface ServiceLocatorSAMLCredential extends vimService.vim.ServiceLocatorCredential {
            token?: string;
         }
         interface ServiceLocator extends vimService.vim.DynamicData {
            instanceUuid: string;
            url: string;
            credential: vimService.vim.ServiceLocatorCredential;
            sslThumbprint?: string;
         }
         interface ArrayOfServiceLocator {
            ServiceLocator?: Array<vimService.vim.ServiceLocator>;
         }
         interface ServiceManagerServiceInfo extends vimService.vim.DynamicData {
            serviceName: string;
            location?: Array<string>;
            service: vimService.vim.ManagedObjectReference;
            description: string;
         }
         interface ArrayOfServiceManagerServiceInfo {
            ServiceManagerServiceInfo?: Array<vimService.vim.ServiceManagerServiceInfo>;
         }
         interface SessionManagerLocalTicket extends vimService.vim.DynamicData {
            userName: string;
            passwordFilePath: string;
         }
         interface SessionManagerGenericServiceTicket extends vimService.vim.DynamicData {
            id: string;
            hostName?: string;
            sslThumbprint?: string;
         }
         interface SessionManagerServiceRequestSpec extends vimService.vim.DynamicData {
         }
         interface SessionManagerVmomiServiceRequestSpec extends vimService.vim.SessionManagerServiceRequestSpec {
            method: string;
         }
         enum SessionManagerHttpServiceRequestSpecMethod {
            "httpOptions",
            "httpGet",
            "httpHead",
            "httpPost",
            "httpPut",
            "httpDelete",
            "httpTrace",
            "httpConnect",
         }
         interface SessionManagerHttpServiceRequestSpec extends vimService.vim.SessionManagerServiceRequestSpec {
            method?: string;
            url: string;
         }
         enum SharesLevel {
            "low",
            "normal",
            "high",
            "custom",
         }
         interface SharesInfo extends vimService.vim.DynamicData {
            shares: number;
            level: vimService.vim.SharesLevel;
         }
         interface SharesOption extends vimService.vim.DynamicData {
            sharesOption: vimService.vim.IntOption;
            defaultLevel: vimService.vim.SharesLevel;
         }
         enum SimpleCommandEncoding {
            "CSV",
            "HEX",
            "STRING",
         }
         interface SingleIp extends vimService.vim.IpAddress {
            address: string;
         }
         interface SingleMac extends vimService.vim.MacAddress {
            address: string;
         }
         interface StoragePodSummary extends vimService.vim.DynamicData {
            name: string;
            capacity: number;
            freeSpace: number;
         }
         interface StorageIOAllocationInfo extends vimService.vim.DynamicData {
            limit?: number;
            shares?: vimService.vim.SharesInfo;
            reservation?: number;
         }
         interface StorageIOAllocationOption extends vimService.vim.DynamicData {
            limitOption: vimService.vim.LongOption;
            sharesOption: vimService.vim.SharesOption;
         }
         enum StorageIORMThresholdMode {
            "automatic",
            "manual",
         }
         interface StorageIORMInfo extends vimService.vim.DynamicData {
            enabled: boolean;
            congestionThresholdMode?: string;
            congestionThreshold: number;
            percentOfPeakThroughput?: number;
            statsCollectionEnabled?: boolean;
            reservationEnabled?: boolean;
            statsAggregationDisabled?: boolean;
            reservableIopsThreshold?: number;
         }
         interface StorageIORMConfigSpec extends vimService.vim.DynamicData {
            enabled?: boolean;
            congestionThresholdMode?: string;
            congestionThreshold?: number;
            percentOfPeakThroughput?: number;
            statsCollectionEnabled?: boolean;
            reservationEnabled?: boolean;
            statsAggregationDisabled?: boolean;
            reservableIopsThreshold?: number;
         }
         interface StorageIORMConfigOption extends vimService.vim.DynamicData {
            enabledOption: vimService.vim.BoolOption;
            congestionThresholdOption: vimService.vim.IntOption;
            statsCollectionEnabledOption?: vimService.vim.BoolOption;
            reservationEnabledOption?: vimService.vim.BoolOption;
         }
         interface StoragePerformanceSummary extends vimService.vim.DynamicData {
            interval: number;
            percentile: Array<number>;
            datastoreReadLatency: Array<number>;
            datastoreWriteLatency: Array<number>;
            datastoreVmLatency: Array<number>;
            datastoreReadIops: Array<number>;
            datastoreWriteIops: Array<number>;
            siocActivityDuration: number;
         }
         interface ArrayOfStoragePerformanceSummary {
            StoragePerformanceSummary?: Array<vimService.vim.StoragePerformanceSummary>;
         }
         interface PodStorageDrsEntry extends vimService.vim.DynamicData {
            storageDrsConfig: vimService.vim.StorageDrsConfigInfo;
            recommendation?: Array<vimService.vim.ClusterRecommendation>;
            drsFault?: Array<vimService.vim.ClusterDrsFaults>;
            actionHistory?: Array<vimService.vim.ClusterActionHistory>;
         }
         interface StorageResourceManagerStorageProfileStatistics extends vimService.vim.DynamicData {
            profileId: string;
            totalSpaceMB: number;
            usedSpaceMB: number;
         }
         interface StringExpression extends vimService.vim.NegatableExpression {
            value?: string;
         }
         interface StringPolicy extends vimService.vim.InheritablePolicy {
            value?: string;
         }
         interface Tag extends vimService.vim.DynamicData {
            key: string;
         }
         interface ArrayOfTag {
            Tag?: Array<vimService.vim.Tag>;
         }
         interface TaskDescription extends vimService.vim.DynamicData {
            methodInfo: Array<vimService.vim.ElementDescription>;
            state: Array<vimService.vim.ElementDescription>;
            reason: Array<vimService.vim.TypeDescription>;
         }
         enum TaskFilterSpecRecursionOption {
            "self",
            "children",
            "all",
         }
         enum TaskFilterSpecTimeOption {
            "queuedTime",
            "startedTime",
            "completedTime",
         }
         interface TaskFilterSpecByEntity extends vimService.vim.DynamicData {
            entity: vimService.vim.ManagedObjectReference;
            recursion: vimService.vim.TaskFilterSpecRecursionOption;
         }
         interface TaskFilterSpecByTime extends vimService.vim.DynamicData {
            timeType: vimService.vim.TaskFilterSpecTimeOption;
            beginTime?: Date;
            endTime?: Date;
         }
         interface TaskFilterSpecByUsername extends vimService.vim.DynamicData {
            systemUser: boolean;
            userList?: Array<string>;
         }
         interface TaskFilterSpec extends vimService.vim.DynamicData {
            entity?: vimService.vim.TaskFilterSpecByEntity;
            time?: vimService.vim.TaskFilterSpecByTime;
            userName?: vimService.vim.TaskFilterSpecByUsername;
            activationId?: Array<string>;
            state?: Array<vimService.vim.TaskInfoState>;
            alarm?: vimService.vim.ManagedObjectReference;
            scheduledTask?: vimService.vim.ManagedObjectReference;
            eventChainId?: Array<number>;
            tag?: Array<string>;
            parentTaskKey?: Array<string>;
            rootTaskKey?: Array<string>;
         }
         enum TaskInfoState {
            "queued",
            "running",
            "success",
            "error",
         }
         interface ArrayOfTaskInfoState {
            TaskInfoState?: Array<vimService.vim.TaskInfoState>;
         }
         interface TaskInfo extends vimService.vim.DynamicData {
            key: string;
            task: vimService.vim.ManagedObjectReference;
            description?: vimService.vim.LocalizableMessage;
            name?: string;
            descriptionId: string;
            entity?: vimService.vim.ManagedObjectReference;
            entityName?: string;
            locked?: Array<vimService.vim.ManagedObjectReference>;
            state: vimService.vim.TaskInfoState;
            cancelled: boolean;
            cancelable: boolean;
            error?: vimService.vim.LocalizedMethodFault;
            result?: any;
            progress?: number;
            reason: vimService.vim.TaskReason;
            queueTime: Date;
            startTime?: Date;
            completeTime?: Date;
            eventChainId: number;
            changeTag?: string;
            parentTaskKey?: string;
            rootTaskKey?: string;
            activationId?: string;
         }
         interface ArrayOfTaskInfo {
            TaskInfo?: Array<vimService.vim.TaskInfo>;
         }
         interface TaskReason extends vimService.vim.DynamicData {
         }
         interface TaskReasonSystem extends vimService.vim.TaskReason {
         }
         interface TaskReasonUser extends vimService.vim.TaskReason {
            userName: string;
         }
         interface TaskReasonAlarm extends vimService.vim.TaskReason {
            alarmName: string;
            alarm: vimService.vim.ManagedObjectReference;
            entityName: string;
            entity: vimService.vim.ManagedObjectReference;
         }
         interface TaskReasonSchedule extends vimService.vim.TaskReason {
            name: string;
            scheduledTask: vimService.vim.ManagedObjectReference;
         }
         interface TypeDescription extends vimService.vim.Description {
            key: string;
         }
         interface ArrayOfTypeDescription {
            TypeDescription?: Array<vimService.vim.TypeDescription>;
         }
         interface UpdateVirtualMachineFilesResultFailedVmFileInfo extends vimService.vim.DynamicData {
            vmFile: string;
            fault: vimService.vim.LocalizedMethodFault;
         }
         interface ArrayOfUpdateVirtualMachineFilesResultFailedVmFileInfo {
            UpdateVirtualMachineFilesResultFailedVmFileInfo?: Array<vimService.vim.UpdateVirtualMachineFilesResultFailedVmFileInfo>;
         }
         interface UpdateVirtualMachineFilesResult extends vimService.vim.DynamicData {
            failedVmFile?: Array<vimService.vim.UpdateVirtualMachineFilesResultFailedVmFileInfo>;
         }
         interface UserSearchResult extends vimService.vim.DynamicData {
            principal: string;
            fullName?: string;
            group: boolean;
         }
         interface ArrayOfUserSearchResult {
            UserSearchResult?: Array<vimService.vim.UserSearchResult>;
         }
         interface UserSession extends vimService.vim.DynamicData {
            key: string;
            userName: string;
            fullName: string;
            loginTime: Date;
            lastActiveTime: Date;
            locale: string;
            messageLocale: string;
            extensionSession?: boolean;
            ipAddress?: string;
            userAgent?: string;
            callCount?: number;
         }
         interface ArrayOfUserSession {
            UserSession?: Array<vimService.vim.UserSession>;
         }
         interface VrpResourceAllocationInfo extends vimService.vim.ResourceAllocationInfo {
            reservationLimit?: number;
         }
         interface VirtualResourcePoolSpec extends vimService.vim.DynamicData {
            vrpId?: string;
            vrpName?: string;
            description?: string;
            cpuAllocation: vimService.vim.VrpResourceAllocationInfo;
            memoryAllocation: vimService.vim.VrpResourceAllocationInfo;
            rpList?: Array<vimService.vim.ManagedObjectReference>;
            hubList?: Array<vimService.vim.ManagedObjectReference>;
            rootVRP?: boolean;
            staticVRP?: boolean;
            changeVersion?: number;
         }
         interface VRPEditSpec extends vimService.vim.DynamicData {
            vrpId: string;
            description?: string;
            cpuAllocation?: vimService.vim.VrpResourceAllocationInfo;
            memoryAllocation?: vimService.vim.VrpResourceAllocationInfo;
            addedHubs?: Array<vimService.vim.ManagedObjectReference>;
            removedHubs?: Array<vimService.vim.ManagedObjectReference>;
            changeVersion?: number;
         }
         interface VirtualResourcePoolUsage extends vimService.vim.DynamicData {
            vrpId: string;
            cpuReservationMhz: number;
            memReservationMB: number;
            cpuReservationUsedMhz: number;
            memReservationUsedMB: number;
         }
         interface VVolVmConfigFileUpdateResultFailedVmConfigFileInfo extends vimService.vim.DynamicData {
            targetConfigVVolId: string;
            fault: vimService.vim.LocalizedMethodFault;
         }
         interface ArrayOfVVolVmConfigFileUpdateResultFailedVmConfigFileInfo {
            VVolVmConfigFileUpdateResultFailedVmConfigFileInfo?: Array<vimService.vim.VVolVmConfigFileUpdateResultFailedVmConfigFileInfo>;
         }
         interface VVolVmConfigFileUpdateResult extends vimService.vim.DynamicData {
            succeededVmConfigFile?: Array<vimService.vim.KeyValue>;
            failedVmConfigFile?: Array<vimService.vim.VVolVmConfigFileUpdateResultFailedVmConfigFileInfo>;
         }
         interface VASAStorageArray extends vimService.vim.DynamicData {
            name: string;
            uuid: string;
            vendorId: string;
            modelId: string;
         }
         interface ArrayOfVASAStorageArray {
            VASAStorageArray?: Array<vimService.vim.VASAStorageArray>;
         }
         interface VasaProviderContainerSpec extends vimService.vim.DynamicData {
            vasaProviderInfo?: Array<vimService.vim.VimVasaProviderInfo>;
            scId: string;
            deleted: boolean;
         }
         interface VimVasaProviderStatePerArray extends vimService.vim.DynamicData {
            priority: number;
            arrayId: string;
            active: boolean;
         }
         interface ArrayOfVimVasaProviderStatePerArray {
            VimVasaProviderStatePerArray?: Array<vimService.vim.VimVasaProviderStatePerArray>;
         }
         interface VimVasaProvider extends vimService.vim.DynamicData {
            url: string;
            name?: string;
            selfSignedCertificate?: string;
         }
         interface VimVasaProviderInfo extends vimService.vim.DynamicData {
            provider: vimService.vim.VimVasaProvider;
            arrayState?: Array<vimService.vim.VimVasaProviderStatePerArray>;
         }
         interface ArrayOfVimVasaProviderInfo {
            VimVasaProviderInfo?: Array<vimService.vim.VimVasaProviderInfo>;
         }
         enum VirtualAppVAppState {
            "started",
            "stopped",
            "starting",
            "stopping",
         }
         interface VirtualAppSummary extends vimService.vim.ResourcePoolSummary {
            product?: vimService.vim.VAppProductInfo;
            vAppState?: vimService.vim.VirtualAppVAppState;
            suspended?: boolean;
            installBootRequired?: boolean;
            instanceUuid?: string;
         }
         interface VirtualAppLinkInfo extends vimService.vim.DynamicData {
            key: vimService.vim.ManagedObjectReference;
            destroyWithParent?: boolean;
         }
         interface ArrayOfVirtualAppLinkInfo {
            VirtualAppLinkInfo?: Array<vimService.vim.VirtualAppLinkInfo>;
         }
         enum VirtualDiskType {
            "preallocated",
            "thin",
            "seSparse",
            "rdm",
            "rdmp",
            "raw",
            "delta",
            "sparse2Gb",
            "thick2Gb",
            "eagerZeroedThick",
            "sparseMonolithic",
            "flatMonolithic",
            "thick",
         }
         enum VirtualDiskAdapterType {
            "ide",
            "busLogic",
            "lsiLogic",
         }
         interface VirtualDiskSpec extends vimService.vim.DynamicData {
            diskType: string;
            adapterType: string;
         }
         interface FileBackedVirtualDiskSpec extends vimService.vim.VirtualDiskSpec {
            capacityKb: number;
            profile?: Array<vimService.vim.VirtualMachineProfileSpec>;
            crypto?: vimService.vim.CryptoSpec;
         }
         interface SeSparseVirtualDiskSpec extends vimService.vim.FileBackedVirtualDiskSpec {
            grainSizeKb?: number;
         }
         interface DeviceBackedVirtualDiskSpec extends vimService.vim.VirtualDiskSpec {
            device: string;
         }
         interface StorageRequirement extends vimService.vim.DynamicData {
            datastore: vimService.vim.ManagedObjectReference;
            freeSpaceRequiredInKb: number;
         }
         interface ArrayOfStorageRequirement {
            StorageRequirement?: Array<vimService.vim.StorageRequirement>;
         }
         enum VirtualMachinePowerState {
            "poweredOff",
            "poweredOn",
            "suspended",
         }
         enum VirtualMachineAppHeartbeatStatusType {
            "appStatusGray",
            "appStatusGreen",
            "appStatusRed",
         }
         enum VirtualMachineConnectionState {
            "connected",
            "disconnected",
            "orphaned",
            "inaccessible",
            "invalid",
         }
         enum VirtualMachineMovePriority {
            "lowPriority",
            "highPriority",
            "defaultPriority",
         }
         interface VirtualMachineTicket extends vimService.vim.DynamicData {
            ticket: string;
            cfgFile: string;
            host?: string;
            port?: number;
            sslThumbprint?: string;
         }
         interface VirtualMachineMksTicket extends vimService.vim.DynamicData {
            ticket: string;
            cfgFile: string;
            host?: string;
            port?: number;
            sslThumbprint?: string;
         }
         enum VirtualMachineFaultToleranceState {
            "notConfigured",
            "disabled",
            "enabled",
            "needSecondary",
            "starting",
            "running",
         }
         enum VirtualMachineRecordReplayState {
            "recording",
            "replaying",
            "inactive",
         }
         enum VirtualMachineNeedSecondaryReason {
            "initializing",
            "divergence",
            "lostConnection",
            "partialHardwareFailure",
            "userAction",
            "checkpointError",
            "other",
         }
         enum VirtualMachineFaultToleranceType {
            "unset",
            "recordReplay",
            "checkpointing",
         }
         enum VirtualMachineTicketType {
            "mks",
            "device",
            "guestControl",
            "webmks",
         }
         interface VirtualMachineDisplayTopology extends vimService.vim.DynamicData {
            x: number;
            y: number;
            width: number;
            height: number;
         }
         interface ArrayOfVirtualMachineDisplayTopology {
            VirtualMachineDisplayTopology?: Array<vimService.vim.VirtualMachineDisplayTopology>;
         }
         interface DiskChangeExtent extends vimService.vim.DynamicData {
            start: number;
            length: number;
         }
         interface ArrayOfDiskChangeExtent {
            DiskChangeExtent?: Array<vimService.vim.DiskChangeExtent>;
         }
         interface DiskChangeInfo extends vimService.vim.DynamicData {
            startOffset: number;
            length: number;
            changedArea?: Array<vimService.vim.DiskChangeExtent>;
         }
         interface VirtualMachineWipeResult extends vimService.vim.DynamicData {
            diskId: number;
            shrinkableDiskSpace: number;
         }
         interface VsanUpgradeSystemPreflightCheckIssue extends vimService.vim.DynamicData {
            msg: string;
         }
         interface ArrayOfVsanUpgradeSystemPreflightCheckIssue {
            VsanUpgradeSystemPreflightCheckIssue?: Array<vimService.vim.VsanUpgradeSystemPreflightCheckIssue>;
         }
         interface VsanUpgradeSystemHostsDisconnectedIssue extends vimService.vim.VsanUpgradeSystemPreflightCheckIssue {
            hosts: Array<vimService.vim.ManagedObjectReference>;
         }
         interface VsanUpgradeSystemMissingHostsInClusterIssue extends vimService.vim.VsanUpgradeSystemPreflightCheckIssue {
            hosts: Array<vimService.vim.ManagedObjectReference>;
         }
         interface VsanUpgradeSystemRogueHostsInClusterIssue extends vimService.vim.VsanUpgradeSystemPreflightCheckIssue {
            uuids: Array<string>;
         }
         interface VsanUpgradeSystemWrongEsxVersionIssue extends vimService.vim.VsanUpgradeSystemPreflightCheckIssue {
            hosts: Array<vimService.vim.ManagedObjectReference>;
         }
         interface VsanUpgradeSystemAutoClaimEnabledOnHostsIssue extends vimService.vim.VsanUpgradeSystemPreflightCheckIssue {
            hosts: Array<vimService.vim.ManagedObjectReference>;
         }
         interface VsanUpgradeSystemAPIBrokenIssue extends vimService.vim.VsanUpgradeSystemPreflightCheckIssue {
            hosts: Array<vimService.vim.ManagedObjectReference>;
         }
         interface VsanUpgradeSystemV2ObjectsPresentDuringDowngradeIssue extends vimService.vim.VsanUpgradeSystemPreflightCheckIssue {
            uuids: Array<string>;
         }
         interface VsanUpgradeSystemNotEnoughFreeCapacityIssue extends vimService.vim.VsanUpgradeSystemPreflightCheckIssue {
            reducedRedundancyUpgradePossible: boolean;
         }
         interface VsanUpgradeSystemNetworkPartitionInfo extends vimService.vim.DynamicData {
            hosts: Array<vimService.vim.ManagedObjectReference>;
         }
         interface ArrayOfVsanUpgradeSystemNetworkPartitionInfo {
            VsanUpgradeSystemNetworkPartitionInfo?: Array<vimService.vim.VsanUpgradeSystemNetworkPartitionInfo>;
         }
         interface VsanUpgradeSystemNetworkPartitionIssue extends vimService.vim.VsanUpgradeSystemPreflightCheckIssue {
            partitions: Array<vimService.vim.VsanUpgradeSystemNetworkPartitionInfo>;
         }
         interface VsanUpgradeSystemPreflightCheckResult extends vimService.vim.DynamicData {
            issues?: Array<vimService.vim.VsanUpgradeSystemPreflightCheckIssue>;
            diskMappingToRestore?: vimService.vim.VsanHostDiskMapping;
         }
         interface VsanUpgradeSystemUpgradeHistoryItem extends vimService.vim.DynamicData {
            timestamp: Date;
            host?: vimService.vim.ManagedObjectReference;
            message: string;
            task?: vimService.vim.ManagedObjectReference;
         }
         interface ArrayOfVsanUpgradeSystemUpgradeHistoryItem {
            VsanUpgradeSystemUpgradeHistoryItem?: Array<vimService.vim.VsanUpgradeSystemUpgradeHistoryItem>;
         }
         enum VsanUpgradeSystemUpgradeHistoryDiskGroupOpType {
            "add",
            "remove",
         }
         interface VsanUpgradeSystemUpgradeHistoryDiskGroupOp extends vimService.vim.VsanUpgradeSystemUpgradeHistoryItem {
            operation: string;
            diskMapping: vimService.vim.VsanHostDiskMapping;
         }
         interface VsanUpgradeSystemUpgradeHistoryPreflightFail extends vimService.vim.VsanUpgradeSystemUpgradeHistoryItem {
            preflightResult: vimService.vim.VsanUpgradeSystemPreflightCheckResult;
         }
         interface VsanUpgradeSystemUpgradeStatus extends vimService.vim.DynamicData {
            inProgress: boolean;
            history?: Array<vimService.vim.VsanUpgradeSystemUpgradeHistoryItem>;
            aborted?: boolean;
            completed?: boolean;
            progress?: number;
         }
         enum ActionParameter {
            "targetName",
            "alarmName",
            "oldStatus",
            "newStatus",
            "triggeringSummary",
            "declaringSummary",
            "eventDescription",
            "target",
            "alarm",
         }
         interface Action extends vimService.vim.DynamicData {
         }
         interface MethodActionArgument extends vimService.vim.DynamicData {
            value?: any;
         }
         interface ArrayOfMethodActionArgument {
            MethodActionArgument?: Array<vimService.vim.MethodActionArgument>;
         }
         interface MethodAction extends vimService.vim.Action {
            name: string;
            argument?: Array<vimService.vim.MethodActionArgument>;
         }
         interface SendEmailAction extends vimService.vim.Action {
            toList: string;
            ccList: string;
            subject: string;
            body: string;
         }
         interface SendSNMPAction extends vimService.vim.Action {
         }
         interface RunScriptAction extends vimService.vim.Action {
            script: string;
         }
         interface CreateTaskAction extends vimService.vim.Action {
            taskTypeId: string;
            cancelable: boolean;
         }
         interface AlarmAction extends vimService.vim.DynamicData {
         }
         interface ArrayOfAlarmAction {
            AlarmAction?: Array<vimService.vim.AlarmAction>;
         }
         interface AlarmTriggeringActionTransitionSpec extends vimService.vim.DynamicData {
            startState: vimService.vim.ManagedEntityStatus;
            finalState: vimService.vim.ManagedEntityStatus;
            repeats: boolean;
         }
         interface ArrayOfAlarmTriggeringActionTransitionSpec {
            AlarmTriggeringActionTransitionSpec?: Array<vimService.vim.AlarmTriggeringActionTransitionSpec>;
         }
         interface AlarmTriggeringAction extends vimService.vim.AlarmAction {
            action: vimService.vim.Action;
            transitionSpecs?: Array<vimService.vim.AlarmTriggeringActionTransitionSpec>;
            green2yellow: boolean;
            yellow2red: boolean;
            red2yellow: boolean;
            yellow2green: boolean;
         }
         interface GroupAlarmAction extends vimService.vim.AlarmAction {
            action: Array<vimService.vim.AlarmAction>;
         }
         interface AlarmDescription extends vimService.vim.DynamicData {
            expr: Array<vimService.vim.TypeDescription>;
            stateOperator: Array<vimService.vim.ElementDescription>;
            metricOperator: Array<vimService.vim.ElementDescription>;
            hostSystemConnectionState: Array<vimService.vim.ElementDescription>;
            virtualMachinePowerState: Array<vimService.vim.ElementDescription>;
            datastoreConnectionState?: Array<vimService.vim.ElementDescription>;
            hostSystemPowerState?: Array<vimService.vim.ElementDescription>;
            virtualMachineGuestHeartbeatStatus?: Array<vimService.vim.ElementDescription>;
            entityStatus: Array<vimService.vim.ElementDescription>;
            action: Array<vimService.vim.TypeDescription>;
         }
         interface AlarmExpression extends vimService.vim.DynamicData {
         }
         interface ArrayOfAlarmExpression {
            AlarmExpression?: Array<vimService.vim.AlarmExpression>;
         }
         interface AndAlarmExpression extends vimService.vim.AlarmExpression {
            expression: Array<vimService.vim.AlarmExpression>;
         }
         interface OrAlarmExpression extends vimService.vim.AlarmExpression {
            expression: Array<vimService.vim.AlarmExpression>;
         }
         enum StateAlarmOperator {
            "isEqual",
            "isUnequal",
         }
         interface StateAlarmExpression extends vimService.vim.AlarmExpression {
            operator: vimService.vim.StateAlarmOperator;
            type: string;
            statePath: string;
            yellow?: string;
            red?: string;
         }
         enum EventAlarmExpressionComparisonOperator {
            "equals",
            "notEqualTo",
            "startsWith",
            "doesNotStartWith",
            "endsWith",
            "doesNotEndWith",
         }
         interface EventAlarmExpressionComparison extends vimService.vim.DynamicData {
            attributeName: string;
            operator: string;
            value: string;
         }
         interface ArrayOfEventAlarmExpressionComparison {
            EventAlarmExpressionComparison?: Array<vimService.vim.EventAlarmExpressionComparison>;
         }
         interface EventAlarmExpression extends vimService.vim.AlarmExpression {
            comparisons?: Array<vimService.vim.EventAlarmExpressionComparison>;
            eventType: string;
            eventTypeId?: string;
            objectType?: string;
            status?: vimService.vim.ManagedEntityStatus;
         }
         enum MetricAlarmOperator {
            "isAbove",
            "isBelow",
         }
         interface MetricAlarmExpression extends vimService.vim.AlarmExpression {
            operator: vimService.vim.MetricAlarmOperator;
            type: string;
            metric: vimService.vim.PerfMetricId;
            yellow?: number;
            yellowInterval?: number;
            red?: number;
            redInterval?: number;
         }
         interface AlarmInfo extends vimService.vim.AlarmSpec {
            key: string;
            alarm: vimService.vim.ManagedObjectReference;
            entity: vimService.vim.ManagedObjectReference;
            lastModifiedTime: Date;
            lastModifiedUser: string;
            creationEventId: number;
         }
         interface AlarmSetting extends vimService.vim.DynamicData {
            toleranceRange: number;
            reportingFrequency: number;
         }
         interface AlarmSpec extends vimService.vim.DynamicData {
            name: string;
            systemName?: string;
            description: string;
            enabled: boolean;
            expression: vimService.vim.AlarmExpression;
            action?: vimService.vim.AlarmAction;
            actionFrequency?: number;
            setting?: vimService.vim.AlarmSetting;
         }
         interface AlarmState extends vimService.vim.DynamicData {
            key: string;
            entity: vimService.vim.ManagedObjectReference;
            alarm: vimService.vim.ManagedObjectReference;
            overallStatus: vimService.vim.ManagedEntityStatus;
            time: Date;
            acknowledged?: boolean;
            acknowledgedByUser?: string;
            acknowledgedTime?: Date;
            eventKey?: number;
         }
         interface ArrayOfAlarmState {
            AlarmState?: Array<vimService.vim.AlarmState>;
         }
         enum ActionType {
            "MigrationV1",
            "VmPowerV1",
            "HostPowerV1",
            "HostMaintenanceV1",
            "StorageMigrationV1",
            "StoragePlacementV1",
            "PlacementV1",
            "HostInfraUpdateHaV1",
         }
         interface ClusterAction extends vimService.vim.DynamicData {
            type: string;
            target?: vimService.vim.ManagedObjectReference;
         }
         interface ArrayOfClusterAction {
            ClusterAction?: Array<vimService.vim.ClusterAction>;
         }
         interface ClusterActionHistory extends vimService.vim.DynamicData {
            action: vimService.vim.ClusterAction;
            time: Date;
         }
         interface ArrayOfClusterActionHistory {
            ClusterActionHistory?: Array<vimService.vim.ClusterActionHistory>;
         }
         interface ClusterAffinityRuleSpec extends vimService.vim.ClusterRuleInfo {
            vm: Array<vimService.vim.ManagedObjectReference>;
         }
         interface ClusterAntiAffinityRuleSpec extends vimService.vim.ClusterRuleInfo {
            vm: Array<vimService.vim.ManagedObjectReference>;
         }
         interface ClusterAttemptedVmInfo extends vimService.vim.DynamicData {
            vm: vimService.vim.ManagedObjectReference;
            task?: vimService.vim.ManagedObjectReference;
         }
         interface ArrayOfClusterAttemptedVmInfo {
            ClusterAttemptedVmInfo?: Array<vimService.vim.ClusterAttemptedVmInfo>;
         }
         interface ClusterConfigInfo extends vimService.vim.DynamicData {
            dasConfig: vimService.vim.ClusterDasConfigInfo;
            dasVmConfig?: Array<vimService.vim.ClusterDasVmConfigInfo>;
            drsConfig: vimService.vim.ClusterDrsConfigInfo;
            drsVmConfig?: Array<vimService.vim.ClusterDrsVmConfigInfo>;
            rule?: Array<vimService.vim.ClusterRuleInfo>;
         }
         enum DrsBehavior {
            "manual",
            "partiallyAutomated",
            "fullyAutomated",
         }
         interface ClusterDrsConfigInfo extends vimService.vim.DynamicData {
            enabled?: boolean;
            enableVmBehaviorOverrides?: boolean;
            defaultVmBehavior?: vimService.vim.DrsBehavior;
            vmotionRate?: number;
            option?: Array<vimService.vim.OptionValue>;
         }
         interface ClusterDrsVmConfigInfo extends vimService.vim.DynamicData {
            key: vimService.vim.ManagedObjectReference;
            enabled?: boolean;
            behavior?: vimService.vim.DrsBehavior;
         }
         interface ArrayOfClusterDrsVmConfigInfo {
            ClusterDrsVmConfigInfo?: Array<vimService.vim.ClusterDrsVmConfigInfo>;
         }
         interface ClusterConfigInfoEx extends vimService.vim.ComputeResourceConfigInfo {
            dasConfig: vimService.vim.ClusterDasConfigInfo;
            dasVmConfig?: Array<vimService.vim.ClusterDasVmConfigInfo>;
            drsConfig: vimService.vim.ClusterDrsConfigInfo;
            drsVmConfig?: Array<vimService.vim.ClusterDrsVmConfigInfo>;
            rule?: Array<vimService.vim.ClusterRuleInfo>;
            orchestration?: vimService.vim.ClusterOrchestrationInfo;
            vmOrchestration?: Array<vimService.vim.ClusterVmOrchestrationInfo>;
            dpmConfigInfo?: vimService.vim.ClusterDpmConfigInfo;
            dpmHostConfig?: Array<vimService.vim.ClusterDpmHostConfigInfo>;
            vsanConfigInfo?: vimService.vim.VsanClusterConfigInfo;
            vsanHostConfig?: Array<vimService.vim.VsanHostConfigInfo>;
            group?: Array<vimService.vim.ClusterGroupInfo>;
            infraUpdateHaConfig?: vimService.vim.ClusterInfraUpdateHaConfigInfo;
            proactiveDrsConfig?: vimService.vim.ClusterProactiveDrsConfigInfo;
         }
         enum DpmBehavior {
            "manual",
            "automated",
         }
         interface ClusterDpmConfigInfo extends vimService.vim.DynamicData {
            enabled?: boolean;
            defaultDpmBehavior?: vimService.vim.DpmBehavior;
            hostPowerActionRate?: number;
            option?: Array<vimService.vim.OptionValue>;
         }
         interface ClusterDpmHostConfigInfo extends vimService.vim.DynamicData {
            key: vimService.vim.ManagedObjectReference;
            enabled?: boolean;
            behavior?: vimService.vim.DpmBehavior;
         }
         interface ArrayOfClusterDpmHostConfigInfo {
            ClusterDpmHostConfigInfo?: Array<vimService.vim.ClusterDpmHostConfigInfo>;
         }
         enum ClusterInfraUpdateHaConfigInfoBehaviorType {
            "Manual",
            "Automated",
         }
         enum ClusterInfraUpdateHaConfigInfoRemediationType {
            "QuarantineMode",
            "MaintenanceMode",
         }
         interface ClusterInfraUpdateHaConfigInfo extends vimService.vim.DynamicData {
            enabled?: boolean;
            behavior?: string;
            moderateRemediation?: string;
            severeRemediation?: string;
            providers?: Array<string>;
         }
         interface ClusterProactiveDrsConfigInfo extends vimService.vim.DynamicData {
            enabled?: boolean;
         }
         interface ClusterConfigSpec extends vimService.vim.DynamicData {
            dasConfig?: vimService.vim.ClusterDasConfigInfo;
            dasVmConfigSpec?: Array<vimService.vim.ClusterDasVmConfigSpec>;
            drsConfig?: vimService.vim.ClusterDrsConfigInfo;
            drsVmConfigSpec?: Array<vimService.vim.ClusterDrsVmConfigSpec>;
            rulesSpec?: Array<vimService.vim.ClusterRuleSpec>;
         }
         interface ClusterDasVmConfigSpec extends vimService.vim.ArrayUpdateSpec {
            info?: vimService.vim.ClusterDasVmConfigInfo;
         }
         interface ArrayOfClusterDasVmConfigSpec {
            ClusterDasVmConfigSpec?: Array<vimService.vim.ClusterDasVmConfigSpec>;
         }
         interface ClusterDrsVmConfigSpec extends vimService.vim.ArrayUpdateSpec {
            info?: vimService.vim.ClusterDrsVmConfigInfo;
         }
         interface ArrayOfClusterDrsVmConfigSpec {
            ClusterDrsVmConfigSpec?: Array<vimService.vim.ClusterDrsVmConfigSpec>;
         }
         interface ClusterConfigSpecEx extends vimService.vim.ComputeResourceConfigSpec {
            dasConfig?: vimService.vim.ClusterDasConfigInfo;
            dasVmConfigSpec?: Array<vimService.vim.ClusterDasVmConfigSpec>;
            drsConfig?: vimService.vim.ClusterDrsConfigInfo;
            drsVmConfigSpec?: Array<vimService.vim.ClusterDrsVmConfigSpec>;
            rulesSpec?: Array<vimService.vim.ClusterRuleSpec>;
            orchestration?: vimService.vim.ClusterOrchestrationInfo;
            vmOrchestrationSpec?: Array<vimService.vim.ClusterVmOrchestrationSpec>;
            dpmConfig?: vimService.vim.ClusterDpmConfigInfo;
            dpmHostConfigSpec?: Array<vimService.vim.ClusterDpmHostConfigSpec>;
            vsanConfig?: vimService.vim.VsanClusterConfigInfo;
            vsanHostConfigSpec?: Array<vimService.vim.VsanHostConfigInfo>;
            groupSpec?: Array<vimService.vim.ClusterGroupSpec>;
            infraUpdateHaConfig?: vimService.vim.ClusterInfraUpdateHaConfigInfo;
            proactiveDrsConfig?: vimService.vim.ClusterProactiveDrsConfigInfo;
         }
         interface ClusterDpmHostConfigSpec extends vimService.vim.ArrayUpdateSpec {
            info?: vimService.vim.ClusterDpmHostConfigInfo;
         }
         interface ArrayOfClusterDpmHostConfigSpec {
            ClusterDpmHostConfigSpec?: Array<vimService.vim.ClusterDpmHostConfigSpec>;
         }
         interface ClusterGroupSpec extends vimService.vim.ArrayUpdateSpec {
            info?: vimService.vim.ClusterGroupInfo;
         }
         interface ArrayOfClusterGroupSpec {
            ClusterGroupSpec?: Array<vimService.vim.ClusterGroupSpec>;
         }
         interface ClusterVmOrchestrationSpec extends vimService.vim.ArrayUpdateSpec {
            info?: vimService.vim.ClusterVmOrchestrationInfo;
         }
         interface ArrayOfClusterVmOrchestrationSpec {
            ClusterVmOrchestrationSpec?: Array<vimService.vim.ClusterVmOrchestrationSpec>;
         }
         interface ClusterDasAamHostInfo extends vimService.vim.ClusterDasHostInfo {
            hostDasState?: Array<vimService.vim.ClusterDasAamNodeState>;
            primaryHosts?: Array<string>;
         }
         enum ClusterDasAamNodeStateDasState {
            "uninitialized",
            "initialized",
            "configuring",
            "unconfiguring",
            "running",
            "error",
            "agentShutdown",
            "nodeFailed",
         }
         interface ClusterDasAamNodeState extends vimService.vim.DynamicData {
            host: vimService.vim.ManagedObjectReference;
            name: string;
            configState: string;
            runtimeState: string;
         }
         interface ArrayOfClusterDasAamNodeState {
            ClusterDasAamNodeState?: Array<vimService.vim.ClusterDasAamNodeState>;
         }
         interface ClusterDasAdmissionControlInfo extends vimService.vim.DynamicData {
         }
         interface ClusterDasAdmissionControlPolicy extends vimService.vim.DynamicData {
            resourceReductionToToleratePercent?: number;
         }
         interface ClusterDasAdvancedRuntimeInfoVmcpCapabilityInfo extends vimService.vim.DynamicData {
            storageAPDSupported: boolean;
            storagePDLSupported: boolean;
         }
         interface DasHeartbeatDatastoreInfo extends vimService.vim.DynamicData {
            datastore: vimService.vim.ManagedObjectReference;
            hosts: Array<vimService.vim.ManagedObjectReference>;
         }
         interface ArrayOfDasHeartbeatDatastoreInfo {
            DasHeartbeatDatastoreInfo?: Array<vimService.vim.DasHeartbeatDatastoreInfo>;
         }
         interface ClusterDasAdvancedRuntimeInfo extends vimService.vim.DynamicData {
            dasHostInfo?: vimService.vim.ClusterDasHostInfo;
            vmcpSupported?: vimService.vim.ClusterDasAdvancedRuntimeInfoVmcpCapabilityInfo;
            heartbeatDatastoreInfo?: Array<vimService.vim.DasHeartbeatDatastoreInfo>;
         }
         enum ClusterDasConfigInfoServiceState {
            "disabled",
            "enabled",
         }
         enum ClusterDasConfigInfoVmMonitoringState {
            "vmMonitoringDisabled",
            "vmMonitoringOnly",
            "vmAndAppMonitoring",
         }
         enum ClusterDasConfigInfoHBDatastoreCandidate {
            "userSelectedDs",
            "allFeasibleDs",
            "allFeasibleDsWithUserPreference",
         }
         interface ClusterDasConfigInfo extends vimService.vim.DynamicData {
            enabled?: boolean;
            vmMonitoring?: string;
            hostMonitoring?: string;
            vmComponentProtecting?: string;
            failoverLevel?: number;
            admissionControlPolicy?: vimService.vim.ClusterDasAdmissionControlPolicy;
            admissionControlEnabled?: boolean;
            defaultVmSettings?: vimService.vim.ClusterDasVmSettings;
            option?: Array<vimService.vim.OptionValue>;
            heartbeatDatastore?: Array<vimService.vim.ManagedObjectReference>;
            hBDatastoreCandidatePolicy?: string;
         }
         interface ClusterDasData extends vimService.vim.DynamicData {
         }
         interface ClusterDasDataSummary extends vimService.vim.ClusterDasData {
            hostListVersion: number;
            clusterConfigVersion: number;
            compatListVersion: number;
         }
         interface ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo extends vimService.vim.DynamicData {
            numVcpus: number;
            cpuMHz: number;
            memoryMB: number;
         }
         interface ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots extends vimService.vim.DynamicData {
            host: vimService.vim.ManagedObjectReference;
            slots: number;
         }
         interface ArrayOfClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots {
            ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots?: Array<vimService.vim.ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots>;
         }
         interface ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots extends vimService.vim.DynamicData {
            vm: vimService.vim.ManagedObjectReference;
            slots: number;
         }
         interface ArrayOfClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots {
            ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots?: Array<vimService.vim.ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots>;
         }
         interface ClusterDasFailoverLevelAdvancedRuntimeInfo extends vimService.vim.ClusterDasAdvancedRuntimeInfo {
            slotInfo: vimService.vim.ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo;
            totalSlots: number;
            usedSlots: number;
            unreservedSlots: number;
            totalVms: number;
            totalHosts: number;
            totalGoodHosts: number;
            hostSlots?: Array<vimService.vim.ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots>;
            vmsRequiringMultipleSlots?: Array<vimService.vim.ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots>;
         }
         enum ClusterDasFdmAvailabilityState {
            "uninitialized",
            "election",
            "master",
            "connectedToMaster",
            "networkPartitionedFromMaster",
            "networkIsolated",
            "hostDown",
            "initializationError",
            "uninitializationError",
            "fdmUnreachable",
         }
         interface ClusterDasFdmHostState extends vimService.vim.DynamicData {
            state: string;
            stateReporter?: vimService.vim.ManagedObjectReference;
         }
         interface ClusterDasHostInfo extends vimService.vim.DynamicData {
         }
         interface ClusterDasHostRecommendation extends vimService.vim.DynamicData {
            host: vimService.vim.ManagedObjectReference;
            drsRating?: number;
         }
         enum DasVmPriority {
            "disabled",
            "low",
            "medium",
            "high",
         }
         interface ClusterDasVmConfigInfo extends vimService.vim.DynamicData {
            key: vimService.vim.ManagedObjectReference;
            restartPriority?: vimService.vim.DasVmPriority;
            powerOffOnIsolation?: boolean;
            dasSettings?: vimService.vim.ClusterDasVmSettings;
         }
         interface ArrayOfClusterDasVmConfigInfo {
            ClusterDasVmConfigInfo?: Array<vimService.vim.ClusterDasVmConfigInfo>;
         }
         enum ClusterDasVmSettingsRestartPriority {
            "disabled",
            "lowest",
            "low",
            "medium",
            "high",
            "highest",
            "clusterRestartPriority",
         }
         enum ClusterDasVmSettingsIsolationResponse {
            "none",
            "powerOff",
            "shutdown",
            "clusterIsolationResponse",
         }
         interface ClusterDasVmSettings extends vimService.vim.DynamicData {
            restartPriority?: string;
            restartPriorityTimeout?: number;
            isolationResponse?: string;
            vmToolsMonitoringSettings?: vimService.vim.ClusterVmToolsMonitoringSettings;
            vmComponentProtectionSettings?: vimService.vim.ClusterVmComponentProtectionSettings;
         }
         interface ClusterDependencyRuleInfo extends vimService.vim.ClusterRuleInfo {
            vmGroup: string;
            dependsOnVmGroup: string;
         }
         interface ClusterDrsFaultsFaultsByVm extends vimService.vim.DynamicData {
            vm?: vimService.vim.ManagedObjectReference;
            fault: Array<vimService.vim.LocalizedMethodFault>;
         }
         interface ArrayOfClusterDrsFaultsFaultsByVm {
            ClusterDrsFaultsFaultsByVm?: Array<vimService.vim.ClusterDrsFaultsFaultsByVm>;
         }
         interface ClusterDrsFaultsFaultsByVirtualDisk extends vimService.vim.ClusterDrsFaultsFaultsByVm {
            disk?: vimService.vim.VirtualDiskId;
         }
         interface ClusterDrsFaults extends vimService.vim.DynamicData {
            reason: string;
            faultsByVm: Array<vimService.vim.ClusterDrsFaultsFaultsByVm>;
         }
         interface ArrayOfClusterDrsFaults {
            ClusterDrsFaults?: Array<vimService.vim.ClusterDrsFaults>;
         }
         interface ClusterDrsMigration extends vimService.vim.DynamicData {
            key: string;
            time: Date;
            vm: vimService.vim.ManagedObjectReference;
            cpuLoad?: number;
            memoryLoad?: number;
            source: vimService.vim.ManagedObjectReference;
            sourceCpuLoad?: number;
            sourceMemoryLoad?: number;
            destination: vimService.vim.ManagedObjectReference;
            destinationCpuLoad?: number;
            destinationMemoryLoad?: number;
         }
         interface ArrayOfClusterDrsMigration {
            ClusterDrsMigration?: Array<vimService.vim.ClusterDrsMigration>;
         }
         enum DrsRecommendationReasonCode {
            "fairnessCpuAvg",
            "fairnessMemAvg",
            "jointAffin",
            "antiAffin",
            "hostMaint",
         }
         interface ClusterDrsRecommendation extends vimService.vim.DynamicData {
            key: string;
            rating: number;
            reason: string;
            reasonText: string;
            migrationList: Array<vimService.vim.ClusterDrsMigration>;
         }
         interface ArrayOfClusterDrsRecommendation {
            ClusterDrsRecommendation?: Array<vimService.vim.ClusterDrsRecommendation>;
         }
         interface ClusterEVCManagerEVCState extends vimService.vim.DynamicData {
            supportedEVCMode: Array<vimService.vim.EVCMode>;
            currentEVCModeKey?: string;
            guaranteedCPUFeatures?: Array<vimService.vim.HostCpuIdInfo>;
            featureCapability?: Array<vimService.vim.HostFeatureCapability>;
            featureMask?: Array<vimService.vim.HostFeatureMask>;
            featureRequirement?: Array<vimService.vim.VirtualMachineFeatureRequirement>;
         }
         interface ClusterEVCManagerCheckResult extends vimService.vim.DynamicData {
            evcModeKey: string;
            error: vimService.vim.LocalizedMethodFault;
            host?: Array<vimService.vim.ManagedObjectReference>;
         }
         interface ArrayOfClusterEVCManagerCheckResult {
            ClusterEVCManagerCheckResult?: Array<vimService.vim.ClusterEVCManagerCheckResult>;
         }
         interface ClusterEnterMaintenanceResult extends vimService.vim.DynamicData {
            recommendations?: Array<vimService.vim.ClusterRecommendation>;
            fault?: vimService.vim.ClusterDrsFaults;
         }
         interface ClusterFailoverHostAdmissionControlInfoHostStatus extends vimService.vim.DynamicData {
            host: vimService.vim.ManagedObjectReference;
            status: vimService.vim.ManagedEntityStatus;
         }
         interface ArrayOfClusterFailoverHostAdmissionControlInfoHostStatus {
            ClusterFailoverHostAdmissionControlInfoHostStatus?: Array<vimService.vim.ClusterFailoverHostAdmissionControlInfoHostStatus>;
         }
         interface ClusterFailoverHostAdmissionControlInfo extends vimService.vim.ClusterDasAdmissionControlInfo {
            hostStatus?: Array<vimService.vim.ClusterFailoverHostAdmissionControlInfoHostStatus>;
         }
         interface ClusterFailoverHostAdmissionControlPolicy extends vimService.vim.ClusterDasAdmissionControlPolicy {
            failoverHosts?: Array<vimService.vim.ManagedObjectReference>;
            failoverLevel?: number;
         }
         interface ClusterFailoverLevelAdmissionControlInfo extends vimService.vim.ClusterDasAdmissionControlInfo {
            currentFailoverLevel: number;
         }
         interface ClusterFailoverLevelAdmissionControlPolicy extends vimService.vim.ClusterDasAdmissionControlPolicy {
            failoverLevel: number;
            slotPolicy?: vimService.vim.ClusterSlotPolicy;
         }
         interface ClusterFailoverResourcesAdmissionControlInfo extends vimService.vim.ClusterDasAdmissionControlInfo {
            currentCpuFailoverResourcesPercent: number;
            currentMemoryFailoverResourcesPercent: number;
         }
         interface ClusterFailoverResourcesAdmissionControlPolicy extends vimService.vim.ClusterDasAdmissionControlPolicy {
            cpuFailoverResourcesPercent: number;
            memoryFailoverResourcesPercent: number;
            failoverLevel?: number;
            autoComputePercentages?: boolean;
         }
         interface ClusterGroupInfo extends vimService.vim.DynamicData {
            name: string;
            userCreated?: boolean;
            uniqueID?: string;
         }
         interface ArrayOfClusterGroupInfo {
            ClusterGroupInfo?: Array<vimService.vim.ClusterGroupInfo>;
         }
         interface ClusterHostGroup extends vimService.vim.ClusterGroupInfo {
            host?: Array<vimService.vim.ManagedObjectReference>;
         }
         enum ClusterHostInfraUpdateHaModeActionOperationType {
            "enterQuarantine",
            "exitQuarantine",
            "enterMaintenance",
         }
         interface ClusterHostInfraUpdateHaModeAction extends vimService.vim.ClusterAction {
            operationType: string;
         }
         enum HostPowerOperationType {
            "powerOn",
            "powerOff",
         }
         interface ClusterHostPowerAction extends vimService.vim.ClusterAction {
            operationType: vimService.vim.HostPowerOperationType;
            powerConsumptionWatt?: number;
            cpuCapacityMHz?: number;
            memCapacityMB?: number;
         }
         interface ClusterHostRecommendation extends vimService.vim.DynamicData {
            host: vimService.vim.ManagedObjectReference;
            rating: number;
         }
         interface ArrayOfClusterHostRecommendation {
            ClusterHostRecommendation?: Array<vimService.vim.ClusterHostRecommendation>;
         }
         interface ClusterInitialPlacementAction extends vimService.vim.ClusterAction {
            targetHost: vimService.vim.ManagedObjectReference;
            pool?: vimService.vim.ManagedObjectReference;
         }
         interface ClusterMigrationAction extends vimService.vim.ClusterAction {
            drsMigration?: vimService.vim.ClusterDrsMigration;
         }
         interface ClusterNotAttemptedVmInfo extends vimService.vim.DynamicData {
            vm: vimService.vim.ManagedObjectReference;
            fault: vimService.vim.LocalizedMethodFault;
         }
         interface ArrayOfClusterNotAttemptedVmInfo {
            ClusterNotAttemptedVmInfo?: Array<vimService.vim.ClusterNotAttemptedVmInfo>;
         }
         interface ClusterOrchestrationInfo extends vimService.vim.DynamicData {
            defaultVmReadiness?: vimService.vim.ClusterVmReadiness;
         }
         interface PlacementAction extends vimService.vim.ClusterAction {
            vm?: vimService.vim.ManagedObjectReference;
            targetHost?: vimService.vim.ManagedObjectReference;
            relocateSpec?: vimService.vim.VirtualMachineRelocateSpec;
         }
         interface PlacementResult extends vimService.vim.DynamicData {
            recommendations?: Array<vimService.vim.ClusterRecommendation>;
            drsFault?: vimService.vim.ClusterDrsFaults;
         }
         enum PlacementSpecPlacementType {
            "create",
            "reconfigure",
            "relocate",
            "clone",
         }
         interface PlacementSpec extends vimService.vim.DynamicData {
            priority?: vimService.vim.VirtualMachineMovePriority;
            vm?: vimService.vim.ManagedObjectReference;
            configSpec?: vimService.vim.VirtualMachineConfigSpec;
            relocateSpec?: vimService.vim.VirtualMachineRelocateSpec;
            hosts?: Array<vimService.vim.ManagedObjectReference>;
            datastores?: Array<vimService.vim.ManagedObjectReference>;
            storagePods?: Array<vimService.vim.ManagedObjectReference>;
            disallowPrerequisiteMoves?: boolean;
            rules?: Array<vimService.vim.ClusterRuleInfo>;
            key?: string;
            placementType?: string;
            cloneSpec?: vimService.vim.VirtualMachineCloneSpec;
            cloneName?: string;
         }
         interface ArrayOfPlacementSpec {
            PlacementSpec?: Array<vimService.vim.PlacementSpec>;
         }
         enum ClusterPowerOnVmOption {
            "OverrideAutomationLevel",
            "ReserveResources",
         }
         interface ClusterPowerOnVmResult extends vimService.vim.DynamicData {
            attempted?: Array<vimService.vim.ClusterAttemptedVmInfo>;
            notAttempted?: Array<vimService.vim.ClusterNotAttemptedVmInfo>;
            recommendations?: Array<vimService.vim.ClusterRecommendation>;
         }
         enum RecommendationType {
            "V1",
         }
         enum RecommendationReasonCode {
            "fairnessCpuAvg",
            "fairnessMemAvg",
            "jointAffin",
            "antiAffin",
            "hostMaint",
            "enterStandby",
            "reservationCpu",
            "reservationMem",
            "powerOnVm",
            "powerSaving",
            "increaseCapacity",
            "checkResource",
            "unreservedCapacity",
            "vmHostHardAffinity",
            "vmHostSoftAffinity",
            "balanceDatastoreSpaceUsage",
            "balanceDatastoreIOLoad",
            "balanceDatastoreIOPSReservation",
            "datastoreMaint",
            "virtualDiskJointAffin",
            "virtualDiskAntiAffin",
            "datastoreSpaceOutage",
            "storagePlacement",
            "iolbDisabledInternal",
            "xvmotionPlacement",
            "networkBandwidthReservation",
            "hostInDegradation",
            "hostExitDegradation",
            "maxVmsConstraint",
            "ftConstraints",
         }
         interface ClusterRecommendation extends vimService.vim.DynamicData {
            key: string;
            type: string;
            time: Date;
            rating: number;
            reason: string;
            reasonText: string;
            warningText?: string;
            warningDetails?: vimService.vim.LocalizableMessage;
            prerequisite?: Array<string>;
            action?: Array<vimService.vim.ClusterAction>;
            target?: vimService.vim.ManagedObjectReference;
         }
         interface ArrayOfClusterRecommendation {
            ClusterRecommendation?: Array<vimService.vim.ClusterRecommendation>;
         }
         interface ClusterResourceUsageSummary extends vimService.vim.DynamicData {
            cpuUsedMHz: number;
            cpuCapacityMHz: number;
            memUsedMB: number;
            memCapacityMB: number;
            storageUsedMB: number;
            storageCapacityMB: number;
         }
         interface ClusterRuleInfo extends vimService.vim.DynamicData {
            key?: number;
            status?: vimService.vim.ManagedEntityStatus;
            enabled?: boolean;
            name?: string;
            mandatory?: boolean;
            userCreated?: boolean;
            inCompliance?: boolean;
            ruleUuid?: string;
         }
         interface ArrayOfClusterRuleInfo {
            ClusterRuleInfo?: Array<vimService.vim.ClusterRuleInfo>;
         }
         interface ClusterRuleSpec extends vimService.vim.ArrayUpdateSpec {
            info?: vimService.vim.ClusterRuleInfo;
         }
         interface ArrayOfClusterRuleSpec {
            ClusterRuleSpec?: Array<vimService.vim.ClusterRuleSpec>;
         }
         interface ClusterSlotPolicy extends vimService.vim.DynamicData {
         }
         interface ClusterFixedSizeSlotPolicy extends vimService.vim.ClusterSlotPolicy {
            cpu: number;
            memory: number;
         }
         interface ClusterUsageSummary extends vimService.vim.DynamicData {
            totalCpuCapacityMhz: number;
            totalMemCapacityMB: number;
            cpuReservationMhz: number;
            memReservationMB: number;
            poweredOffCpuReservationMhz?: number;
            poweredOffMemReservationMB?: number;
            cpuDemandMhz: number;
            memDemandMB: number;
            statsGenNumber: number;
            cpuEntitledMhz: number;
            memEntitledMB: number;
            poweredOffVmCount: number;
            totalVmCount: number;
         }
         enum ClusterVmComponentProtectionSettingsStorageVmReaction {
            "disabled",
            "warning",
            "restartConservative",
            "restartAggressive",
            "clusterDefault",
         }
         enum ClusterVmComponentProtectionSettingsVmReactionOnAPDCleared {
            "none",
            "reset",
            "useClusterDefault",
         }
         interface ClusterVmComponentProtectionSettings extends vimService.vim.DynamicData {
            vmStorageProtectionForAPD?: string;
            enableAPDTimeoutForHosts?: boolean;
            vmTerminateDelayForAPDSec?: number;
            vmReactionOnAPDCleared?: string;
            vmStorageProtectionForPDL?: string;
         }
         interface ClusterVmGroup extends vimService.vim.ClusterGroupInfo {
            vm?: Array<vimService.vim.ManagedObjectReference>;
         }
         interface ClusterVmHostRuleInfo extends vimService.vim.ClusterRuleInfo {
            vmGroupName?: string;
            affineHostGroupName?: string;
            antiAffineHostGroupName?: string;
         }
         interface ClusterVmOrchestrationInfo extends vimService.vim.DynamicData {
            vm: vimService.vim.ManagedObjectReference;
            vmReadiness: vimService.vim.ClusterVmReadiness;
         }
         interface ArrayOfClusterVmOrchestrationInfo {
            ClusterVmOrchestrationInfo?: Array<vimService.vim.ClusterVmOrchestrationInfo>;
         }
         enum ClusterVmReadinessReadyCondition {
            "none",
            "poweredOn",
            "guestHbStatusGreen",
            "appHbStatusGreen",
            "useClusterDefault",
         }
         interface ClusterVmReadiness extends vimService.vim.DynamicData {
            readyCondition?: string;
            postReadyDelay?: number;
         }
         interface ClusterVmToolsMonitoringSettings extends vimService.vim.DynamicData {
            enabled?: boolean;
            vmMonitoring?: string;
            clusterSettings?: boolean;
            failureInterval?: number;
            minUpTime?: number;
            maxFailures?: number;
            maxFailureWindow?: number;
         }
         interface DVPortConfigSpec extends vimService.vim.DynamicData {
            operation: string;
            key?: string;
            name?: string;
            scope?: Array<vimService.vim.ManagedObjectReference>;
            description?: string;
            setting?: vimService.vim.DVPortSetting;
            configVersion?: string;
         }
         interface ArrayOfDVPortConfigSpec {
            DVPortConfigSpec?: Array<vimService.vim.DVPortConfigSpec>;
         }
         interface DVPortConfigInfo extends vimService.vim.DynamicData {
            name?: string;
            scope?: Array<vimService.vim.ManagedObjectReference>;
            description?: string;
            setting?: vimService.vim.DVPortSetting;
            configVersion: string;
         }
         interface DVSTrafficShapingPolicy extends vimService.vim.InheritablePolicy {
            enabled?: vimService.vim.BoolPolicy;
            averageBandwidth?: vimService.vim.LongPolicy;
            peakBandwidth?: vimService.vim.LongPolicy;
            burstSize?: vimService.vim.LongPolicy;
         }
         interface DVSHostLocalPortInfo extends vimService.vim.DynamicData {
            switchUuid: string;
            portKey: string;
            setting: vimService.vim.DVPortSetting;
            vnic: string;
         }
         interface DVSVendorSpecificConfig extends vimService.vim.InheritablePolicy {
            keyValue?: Array<vimService.vim.DistributedVirtualSwitchKeyedOpaqueBlob>;
         }
         interface DvsFilterParameter extends vimService.vim.DynamicData {
            parameters?: Array<string>;
         }
         enum DvsFilterOnFailure {
            "failOpen",
            "failClosed",
         }
         interface DvsFilterConfig extends vimService.vim.InheritablePolicy {
            key?: string;
            agentName?: string;
            slotNumber?: string;
            parameters?: vimService.vim.DvsFilterParameter;
            onFailure?: string;
         }
         interface ArrayOfDvsFilterConfig {
            DvsFilterConfig?: Array<vimService.vim.DvsFilterConfig>;
         }
         interface DvsTrafficFilterConfig extends vimService.vim.DvsFilterConfig {
            trafficRuleset?: vimService.vim.DvsTrafficRuleset;
         }
         interface DvsFilterConfigSpec extends vimService.vim.DvsFilterConfig {
            operation: string;
         }
         interface DvsTrafficFilterConfigSpec extends vimService.vim.DvsTrafficFilterConfig {
            operation: string;
         }
         interface DvsFilterPolicy extends vimService.vim.InheritablePolicy {
            filterConfig?: Array<vimService.vim.DvsFilterConfig>;
         }
         interface DVPortSetting extends vimService.vim.DynamicData {
            blocked?: vimService.vim.BoolPolicy;
            vmDirectPathGen2Allowed?: vimService.vim.BoolPolicy;
            inShapingPolicy?: vimService.vim.DVSTrafficShapingPolicy;
            outShapingPolicy?: vimService.vim.DVSTrafficShapingPolicy;
            vendorSpecificConfig?: vimService.vim.DVSVendorSpecificConfig;
            networkResourcePoolKey?: vimService.vim.StringPolicy;
            filterPolicy?: vimService.vim.DvsFilterPolicy;
         }
         enum DVPortStatusVmDirectPathGen2InactiveReasonNetwork {
            "portNptIncompatibleDvs",
            "portNptNoCompatibleNics",
            "portNptNoVirtualFunctionsAvailable",
            "portNptDisabledForPort",
         }
         enum DVPortStatusVmDirectPathGen2InactiveReasonOther {
            "portNptIncompatibleHost",
            "portNptIncompatibleConnectee",
         }
         interface DVPortStatus extends vimService.vim.DynamicData {
            linkUp: boolean;
            blocked: boolean;
            vlanIds?: Array<vimService.vim.NumericRange>;
            trunkingMode?: boolean;
            mtu?: number;
            linkPeer?: string;
            macAddress?: string;
            statusDetail?: string;
            vmDirectPathGen2Active?: boolean;
            vmDirectPathGen2InactiveReasonNetwork?: Array<string>;
            vmDirectPathGen2InactiveReasonOther?: Array<string>;
            vmDirectPathGen2InactiveReasonExtended?: string;
         }
         interface DVPortState extends vimService.vim.DynamicData {
            runtimeInfo?: vimService.vim.DVPortStatus;
            stats: vimService.vim.DistributedVirtualSwitchPortStatistics;
            vendorSpecificState?: Array<vimService.vim.DistributedVirtualSwitchKeyedOpaqueBlob>;
         }
         interface DistributedVirtualPort extends vimService.vim.DynamicData {
            key: string;
            config: vimService.vim.DVPortConfigInfo;
            dvsUuid: string;
            portgroupKey?: string;
            proxyHost?: vimService.vim.ManagedObjectReference;
            connectee?: vimService.vim.DistributedVirtualSwitchPortConnectee;
            conflict: boolean;
            conflictPortKey?: string;
            state?: vimService.vim.DVPortState;
            connectionCookie?: number;
            lastStatusChange: Date;
            hostLocalPort?: boolean;
         }
         interface ArrayOfDistributedVirtualPort {
            DistributedVirtualPort?: Array<vimService.vim.DistributedVirtualPort>;
         }
         enum DistributedVirtualPortgroupPortgroupType {
            "earlyBinding",
            "lateBinding",
            "ephemeral",
         }
         interface DVPortgroupPolicy extends vimService.vim.DynamicData {
            blockOverrideAllowed: boolean;
            shapingOverrideAllowed: boolean;
            vendorConfigOverrideAllowed: boolean;
            livePortMovingAllowed: boolean;
            portConfigResetAtDisconnect: boolean;
            networkResourcePoolOverrideAllowed?: boolean;
            trafficFilterOverrideAllowed?: boolean;
         }
         enum DistributedVirtualPortgroupMetaTagName {
            "dvsName",
            "portgroupName",
            "portIndex",
         }
         interface DVPortgroupConfigSpec extends vimService.vim.DynamicData {
            configVersion?: string;
            name?: string;
            numPorts?: number;
            portNameFormat?: string;
            defaultPortConfig?: vimService.vim.DVPortSetting;
            description?: string;
            type?: string;
            scope?: Array<vimService.vim.ManagedObjectReference>;
            policy?: vimService.vim.DVPortgroupPolicy;
            vendorSpecificConfig?: Array<vimService.vim.DistributedVirtualSwitchKeyedOpaqueBlob>;
            autoExpand?: boolean;
            vmVnicNetworkResourcePoolKey?: string;
         }
         interface ArrayOfDVPortgroupConfigSpec {
            DVPortgroupConfigSpec?: Array<vimService.vim.DVPortgroupConfigSpec>;
         }
         interface DVPortgroupConfigInfo extends vimService.vim.DynamicData {
            key: string;
            name: string;
            numPorts: number;
            distributedVirtualSwitch?: vimService.vim.ManagedObjectReference;
            defaultPortConfig?: vimService.vim.DVPortSetting;
            description?: string;
            type: string;
            policy: vimService.vim.DVPortgroupPolicy;
            portNameFormat?: string;
            scope?: Array<vimService.vim.ManagedObjectReference>;
            vendorSpecificConfig?: Array<vimService.vim.DistributedVirtualSwitchKeyedOpaqueBlob>;
            configVersion?: string;
            autoExpand?: boolean;
            vmVnicNetworkResourcePoolKey?: string;
            uplink?: boolean;
         }
         interface DistributedVirtualPortgroupInfo extends vimService.vim.DynamicData {
            switchName: string;
            switchUuid: string;
            portgroupName: string;
            portgroupKey: string;
            portgroupType: string;
            uplinkPortgroup: boolean;
            portgroup: vimService.vim.ManagedObjectReference;
            networkReservationSupported?: boolean;
         }
         interface ArrayOfDistributedVirtualPortgroupInfo {
            DistributedVirtualPortgroupInfo?: Array<vimService.vim.DistributedVirtualPortgroupInfo>;
         }
         interface DVPortgroupSelection extends vimService.vim.SelectionSet {
            dvsUuid: string;
            portgroupKey: Array<string>;
         }
         interface DistributedVirtualSwitchInfo extends vimService.vim.DynamicData {
            switchName: string;
            switchUuid: string;
            distributedVirtualSwitch: vimService.vim.ManagedObjectReference;
            networkReservationSupported?: boolean;
         }
         interface ArrayOfDistributedVirtualSwitchInfo {
            DistributedVirtualSwitchInfo?: Array<vimService.vim.DistributedVirtualSwitchInfo>;
         }
         interface DVSManagerDvsConfigTarget extends vimService.vim.DynamicData {
            distributedVirtualPortgroup?: Array<vimService.vim.DistributedVirtualPortgroupInfo>;
            distributedVirtualSwitch?: Array<vimService.vim.DistributedVirtualSwitchInfo>;
         }
         interface DistributedVirtualSwitchManagerCompatibilityResult extends vimService.vim.DynamicData {
            host: vimService.vim.ManagedObjectReference;
            error?: Array<vimService.vim.LocalizedMethodFault>;
         }
         interface ArrayOfDistributedVirtualSwitchManagerCompatibilityResult {
            DistributedVirtualSwitchManagerCompatibilityResult?: Array<vimService.vim.DistributedVirtualSwitchManagerCompatibilityResult>;
         }
         interface DistributedVirtualSwitchManagerHostContainer extends vimService.vim.DynamicData {
            container: vimService.vim.ManagedObjectReference;
            recursive: boolean;
         }
         interface DistributedVirtualSwitchManagerHostDvsFilterSpec extends vimService.vim.DynamicData {
            inclusive: boolean;
         }
         interface ArrayOfDistributedVirtualSwitchManagerHostDvsFilterSpec {
            DistributedVirtualSwitchManagerHostDvsFilterSpec?: Array<vimService.vim.DistributedVirtualSwitchManagerHostDvsFilterSpec>;
         }
         interface DistributedVirtualSwitchManagerHostArrayFilter extends vimService.vim.DistributedVirtualSwitchManagerHostDvsFilterSpec {
            host: Array<vimService.vim.ManagedObjectReference>;
         }
         interface DistributedVirtualSwitchManagerHostContainerFilter extends vimService.vim.DistributedVirtualSwitchManagerHostDvsFilterSpec {
            hostContainer: vimService.vim.DistributedVirtualSwitchManagerHostContainer;
         }
         interface DistributedVirtualSwitchManagerHostDvsMembershipFilter extends vimService.vim.DistributedVirtualSwitchManagerHostDvsFilterSpec {
            distributedVirtualSwitch: vimService.vim.ManagedObjectReference;
         }
         interface DistributedVirtualSwitchManagerDvsProductSpec extends vimService.vim.DynamicData {
            newSwitchProductSpec?: vimService.vim.DistributedVirtualSwitchProductSpec;
            distributedVirtualSwitch?: vimService.vim.ManagedObjectReference;
         }
         interface DistributedVirtualSwitchManagerImportResult extends vimService.vim.DynamicData {
            distributedVirtualSwitch?: Array<vimService.vim.ManagedObjectReference>;
            distributedVirtualPortgroup?: Array<vimService.vim.ManagedObjectReference>;
            importFault?: Array<vimService.vim.ImportOperationBulkFaultFaultOnImport>;
         }
         interface DVSSelection extends vimService.vim.SelectionSet {
            dvsUuid: string;
         }
         interface EntityBackupConfig extends vimService.vim.DynamicData {
            entityType: string;
            configBlob: string;
            key?: string;
            name?: string;
            container?: vimService.vim.ManagedObjectReference;
            configVersion?: string;
         }
         interface ArrayOfEntityBackupConfig {
            EntityBackupConfig?: Array<vimService.vim.EntityBackupConfig>;
         }
         enum EntityType {
            "distributedVirtualSwitch",
            "distributedVirtualPortgroup",
         }
         enum EntityImportType {
            "createEntityWithNewIdentifier",
            "createEntityWithOriginalIdentifier",
            "applyToEntitySpecified",
         }
         interface EntityBackup extends vimService.vim.DynamicData {
         }
         enum DistributedVirtualSwitchHostMemberHostComponentState {
            "up",
            "pending",
            "outOfSync",
            "warning",
            "disconnected",
            "down",
         }
         interface DistributedVirtualSwitchHostMemberConfigSpec extends vimService.vim.DynamicData {
            operation: string;
            host: vimService.vim.ManagedObjectReference;
            backing?: vimService.vim.DistributedVirtualSwitchHostMemberBacking;
            maxProxySwitchPorts?: number;
            vendorSpecificConfig?: Array<vimService.vim.DistributedVirtualSwitchKeyedOpaqueBlob>;
         }
         interface ArrayOfDistributedVirtualSwitchHostMemberConfigSpec {
            DistributedVirtualSwitchHostMemberConfigSpec?: Array<vimService.vim.DistributedVirtualSwitchHostMemberConfigSpec>;
         }
         interface DistributedVirtualSwitchHostMemberPnicSpec extends vimService.vim.DynamicData {
            pnicDevice: string;
            uplinkPortKey?: string;
            uplinkPortgroupKey?: string;
            connectionCookie?: number;
         }
         interface ArrayOfDistributedVirtualSwitchHostMemberPnicSpec {
            DistributedVirtualSwitchHostMemberPnicSpec?: Array<vimService.vim.DistributedVirtualSwitchHostMemberPnicSpec>;
         }
         interface DistributedVirtualSwitchHostMemberBacking extends vimService.vim.DynamicData {
         }
         interface DistributedVirtualSwitchHostMemberPnicBacking extends vimService.vim.DistributedVirtualSwitchHostMemberBacking {
            pnicSpec?: Array<vimService.vim.DistributedVirtualSwitchHostMemberPnicSpec>;
         }
         interface DistributedVirtualSwitchHostMemberRuntimeState extends vimService.vim.DynamicData {
            currentMaxProxySwitchPorts: number;
         }
         interface DistributedVirtualSwitchHostMemberConfigInfo extends vimService.vim.DynamicData {
            host?: vimService.vim.ManagedObjectReference;
            maxProxySwitchPorts: number;
            vendorSpecificConfig?: Array<vimService.vim.DistributedVirtualSwitchKeyedOpaqueBlob>;
            backing: vimService.vim.DistributedVirtualSwitchHostMemberBacking;
         }
         interface HostMemberRuntimeInfo extends vimService.vim.DynamicData {
            host: vimService.vim.ManagedObjectReference;
            status?: string;
            statusDetail?: string;
            healthCheckResult?: Array<vimService.vim.HostMemberHealthCheckResult>;
         }
         interface ArrayOfHostMemberRuntimeInfo {
            HostMemberRuntimeInfo?: Array<vimService.vim.HostMemberRuntimeInfo>;
         }
         interface HostMemberHealthCheckResult extends vimService.vim.DynamicData {
            summary?: string;
         }
         interface ArrayOfHostMemberHealthCheckResult {
            HostMemberHealthCheckResult?: Array<vimService.vim.HostMemberHealthCheckResult>;
         }
         interface HostMemberUplinkHealthCheckResult extends vimService.vim.HostMemberHealthCheckResult {
            uplinkPortKey: string;
         }
         interface DistributedVirtualSwitchHostMember extends vimService.vim.DynamicData {
            runtimeState?: vimService.vim.DistributedVirtualSwitchHostMemberRuntimeState;
            config: vimService.vim.DistributedVirtualSwitchHostMemberConfigInfo;
            productInfo?: vimService.vim.DistributedVirtualSwitchProductSpec;
            uplinkPortKey?: Array<string>;
            status: string;
            statusDetail?: string;
         }
         interface ArrayOfDistributedVirtualSwitchHostMember {
            DistributedVirtualSwitchHostMember?: Array<vimService.vim.DistributedVirtualSwitchHostMember>;
         }
         interface DistributedVirtualSwitchHostProductSpec extends vimService.vim.DynamicData {
            productLineId?: string;
            version?: string;
         }
         interface ArrayOfDistributedVirtualSwitchHostProductSpec {
            DistributedVirtualSwitchHostProductSpec?: Array<vimService.vim.DistributedVirtualSwitchHostProductSpec>;
         }
         interface DistributedVirtualSwitchKeyedOpaqueBlob extends vimService.vim.DynamicData {
            key: string;
            opaqueData: string;
         }
         interface ArrayOfDistributedVirtualSwitchKeyedOpaqueBlob {
            DistributedVirtualSwitchKeyedOpaqueBlob?: Array<vimService.vim.DistributedVirtualSwitchKeyedOpaqueBlob>;
         }
         interface DVSNetworkResourcePoolAllocationInfo extends vimService.vim.DynamicData {
            limit?: number;
            shares?: vimService.vim.SharesInfo;
            priorityTag?: number;
         }
         interface DVSNetworkResourcePoolConfigSpec extends vimService.vim.DynamicData {
            key: string;
            configVersion?: string;
            allocationInfo?: vimService.vim.DVSNetworkResourcePoolAllocationInfo;
            name?: string;
            description?: string;
         }
         interface ArrayOfDVSNetworkResourcePoolConfigSpec {
            DVSNetworkResourcePoolConfigSpec?: Array<vimService.vim.DVSNetworkResourcePoolConfigSpec>;
         }
         interface DVSNetworkResourcePool extends vimService.vim.DynamicData {
            key: string;
            name?: string;
            description?: string;
            configVersion: string;
            allocationInfo: vimService.vim.DVSNetworkResourcePoolAllocationInfo;
         }
         interface ArrayOfDVSNetworkResourcePool {
            DVSNetworkResourcePool?: Array<vimService.vim.DVSNetworkResourcePool>;
         }
         enum DistributedVirtualSwitchPortConnecteeConnecteeType {
            "pnic",
            "vmVnic",
            "hostConsoleVnic",
            "hostVmkVnic",
         }
         interface DistributedVirtualSwitchPortConnectee extends vimService.vim.DynamicData {
            connectedEntity?: vimService.vim.ManagedObjectReference;
            nicKey?: string;
            type?: string;
            addressHint?: string;
         }
         interface DistributedVirtualSwitchPortConnection extends vimService.vim.DynamicData {
            switchUuid: string;
            portgroupKey?: string;
            portKey?: string;
            connectionCookie?: number;
         }
         interface DistributedVirtualSwitchPortCriteria extends vimService.vim.DynamicData {
            connected?: boolean;
            active?: boolean;
            uplinkPort?: boolean;
            scope?: vimService.vim.ManagedObjectReference;
            portgroupKey?: Array<string>;
            inside?: boolean;
            portKey?: Array<string>;
            host?: Array<vimService.vim.ManagedObjectReference>;
         }
         interface DistributedVirtualSwitchPortStatistics extends vimService.vim.DynamicData {
            packetsInMulticast: number;
            packetsOutMulticast: number;
            bytesInMulticast: number;
            bytesOutMulticast: number;
            packetsInUnicast: number;
            packetsOutUnicast: number;
            bytesInUnicast: number;
            bytesOutUnicast: number;
            packetsInBroadcast: number;
            packetsOutBroadcast: number;
            bytesInBroadcast: number;
            bytesOutBroadcast: number;
            packetsInDropped: number;
            packetsOutDropped: number;
            packetsInException: number;
            packetsOutException: number;
            bytesInFromPnic?: number;
            bytesOutToPnic?: number;
         }
         interface DistributedVirtualSwitchProductSpec extends vimService.vim.DynamicData {
            name?: string;
            vendor?: string;
            version?: string;
            build?: string;
            forwardingClass?: string;
            bundleId?: string;
            bundleUrl?: string;
         }
         interface ArrayOfDistributedVirtualSwitchProductSpec {
            DistributedVirtualSwitchProductSpec?: Array<vimService.vim.DistributedVirtualSwitchProductSpec>;
         }
         interface DvsNetworkRuleQualifier extends vimService.vim.DynamicData {
            key?: string;
         }
         interface ArrayOfDvsNetworkRuleQualifier {
            DvsNetworkRuleQualifier?: Array<vimService.vim.DvsNetworkRuleQualifier>;
         }
         interface DvsNetworkRuleAction extends vimService.vim.DynamicData {
         }
         enum DvsNetworkRuleDirectionType {
            "incomingPackets",
            "outgoingPackets",
            "both",
         }
         interface DvsIpNetworkRuleQualifier extends vimService.vim.DvsNetworkRuleQualifier {
            sourceAddress?: vimService.vim.IpAddress;
            destinationAddress?: vimService.vim.IpAddress;
            protocol?: vimService.vim.IntExpression;
            sourceIpPort?: vimService.vim.DvsIpPort;
            destinationIpPort?: vimService.vim.DvsIpPort;
            tcpFlags?: vimService.vim.IntExpression;
         }
         interface DvsIpPort extends vimService.vim.NegatableExpression {
         }
         interface DvsSingleIpPort extends vimService.vim.DvsIpPort {
            portNumber: number;
         }
         interface DvsIpPortRange extends vimService.vim.DvsIpPort {
            startPortNumber: number;
            endPortNumber: number;
         }
         interface DvsMacNetworkRuleQualifier extends vimService.vim.DvsNetworkRuleQualifier {
            sourceAddress?: vimService.vim.MacAddress;
            destinationAddress?: vimService.vim.MacAddress;
            protocol?: vimService.vim.IntExpression;
            vlanId?: vimService.vim.IntExpression;
         }
         interface DvsSystemTrafficNetworkRuleQualifier extends vimService.vim.DvsNetworkRuleQualifier {
            typeOfSystemTraffic?: vimService.vim.StringExpression;
         }
         interface DvsDropNetworkRuleAction extends vimService.vim.DvsNetworkRuleAction {
         }
         interface DvsAcceptNetworkRuleAction extends vimService.vim.DvsNetworkRuleAction {
         }
         interface DvsUpdateTagNetworkRuleAction extends vimService.vim.DvsNetworkRuleAction {
            qosTag?: number;
            dscpTag?: number;
         }
         interface DvsRateLimitNetworkRuleAction extends vimService.vim.DvsNetworkRuleAction {
            packetsPerSecond: number;
         }
         interface DvsLogNetworkRuleAction extends vimService.vim.DvsNetworkRuleAction {
         }
         interface DvsGreEncapNetworkRuleAction extends vimService.vim.DvsNetworkRuleAction {
            encapsulationIp: vimService.vim.SingleIp;
         }
         interface DvsMacRewriteNetworkRuleAction extends vimService.vim.DvsNetworkRuleAction {
            rewriteMac: string;
         }
         interface DvsPuntNetworkRuleAction extends vimService.vim.DvsNetworkRuleAction {
         }
         interface DvsCopyNetworkRuleAction extends vimService.vim.DvsNetworkRuleAction {
         }
         interface DvsTrafficRule extends vimService.vim.DynamicData {
            key?: string;
            description?: string;
            sequence?: number;
            qualifier?: Array<vimService.vim.DvsNetworkRuleQualifier>;
            action?: vimService.vim.DvsNetworkRuleAction;
            direction?: string;
         }
         interface ArrayOfDvsTrafficRule {
            DvsTrafficRule?: Array<vimService.vim.DvsTrafficRule>;
         }
         interface DvsTrafficRuleset extends vimService.vim.DynamicData {
            key?: string;
            enabled?: boolean;
            precedence?: number;
            rules?: Array<vimService.vim.DvsTrafficRule>;
         }
         interface DvsVmVnicResourceAllocation extends vimService.vim.DynamicData {
            reservationQuota?: number;
         }
         interface DvsVmVnicResourcePoolConfigSpec extends vimService.vim.DynamicData {
            operation: string;
            key?: string;
            configVersion?: string;
            allocationInfo?: vimService.vim.DvsVmVnicResourceAllocation;
            name?: string;
            description?: string;
         }
         interface ArrayOfDvsVmVnicResourcePoolConfigSpec {
            DvsVmVnicResourcePoolConfigSpec?: Array<vimService.vim.DvsVmVnicResourcePoolConfigSpec>;
         }
         interface DvsVnicAllocatedResource extends vimService.vim.DynamicData {
            vm: vimService.vim.ManagedObjectReference;
            vnicKey: string;
            reservation?: number;
         }
         interface ArrayOfDvsVnicAllocatedResource {
            DvsVnicAllocatedResource?: Array<vimService.vim.DvsVnicAllocatedResource>;
         }
         interface DvsVmVnicNetworkResourcePoolRuntimeInfo extends vimService.vim.DynamicData {
            key: string;
            name?: string;
            capacity?: number;
            usage?: number;
            available?: number;
            status: string;
            allocatedResource?: Array<vimService.vim.DvsVnicAllocatedResource>;
         }
         interface ArrayOfDvsVmVnicNetworkResourcePoolRuntimeInfo {
            DvsVmVnicNetworkResourcePoolRuntimeInfo?: Array<vimService.vim.DvsVmVnicNetworkResourcePoolRuntimeInfo>;
         }
         interface DVSVmVnicNetworkResourcePool extends vimService.vim.DynamicData {
            key: string;
            name?: string;
            description?: string;
            configVersion: string;
            allocationInfo?: vimService.vim.DvsVmVnicResourceAllocation;
         }
         interface ArrayOfDVSVmVnicNetworkResourcePool {
            DVSVmVnicNetworkResourcePool?: Array<vimService.vim.DVSVmVnicNetworkResourcePool>;
         }
         interface VMwareDVSFeatureCapability extends vimService.vim.DVSFeatureCapability {
            vspanSupported?: boolean;
            lldpSupported?: boolean;
            ipfixSupported?: boolean;
            ipfixCapability?: vimService.vim.VMwareDvsIpfixCapability;
            multicastSnoopingSupported?: boolean;
            vspanCapability?: vimService.vim.VMwareDVSVspanCapability;
            lacpCapability?: vimService.vim.VMwareDvsLacpCapability;
         }
         interface VMwareDvsIpfixCapability extends vimService.vim.DynamicData {
            ipfixSupported?: boolean;
            ipv6ForIpfixSupported?: boolean;
            observationDomainIdSupported?: boolean;
         }
         interface VMwareDvsLacpCapability extends vimService.vim.DynamicData {
            lacpSupported?: boolean;
            multiLacpGroupSupported?: boolean;
         }
         interface VMwareDVSHealthCheckCapability extends vimService.vim.DVSHealthCheckCapability {
            vlanMtuSupported: boolean;
            teamingSupported: boolean;
         }
         interface VMwareDVSVspanCapability extends vimService.vim.DynamicData {
            mixedDestSupported: boolean;
            dvportSupported: boolean;
            remoteSourceSupported: boolean;
            remoteDestSupported: boolean;
            encapRemoteSourceSupported: boolean;
            erspanProtocolSupported?: boolean;
         }
         interface VMwareVspanPort extends vimService.vim.DynamicData {
            portKey?: Array<string>;
            uplinkPortName?: Array<string>;
            wildcardPortConnecteeType?: Array<string>;
            vlans?: Array<number>;
            ipAddress?: Array<string>;
         }
         interface VMwareVspanSession extends vimService.vim.DynamicData {
            key?: string;
            name?: string;
            description?: string;
            enabled: boolean;
            sourcePortTransmitted?: vimService.vim.VMwareVspanPort;
            sourcePortReceived?: vimService.vim.VMwareVspanPort;
            destinationPort?: vimService.vim.VMwareVspanPort;
            encapsulationVlanId?: number;
            stripOriginalVlan: boolean;
            mirroredPacketLength?: number;
            normalTrafficAllowed: boolean;
            sessionType?: string;
            samplingRate?: number;
            encapType?: string;
            erspanId?: number;
            erspanCOS?: number;
            erspanGraNanosec?: boolean;
         }
         interface ArrayOfVMwareVspanSession {
            VMwareVspanSession?: Array<vimService.vim.VMwareVspanSession>;
         }
         interface VMwareIpfixConfig extends vimService.vim.DynamicData {
            collectorIpAddress?: string;
            collectorPort?: number;
            observationDomainId?: number;
            activeFlowTimeout: number;
            idleFlowTimeout: number;
            samplingRate: number;
            internalFlowsOnly: boolean;
         }
         interface VMwareDVSConfigInfo extends vimService.vim.DVSConfigInfo {
            vspanSession?: Array<vimService.vim.VMwareVspanSession>;
            pvlanConfig?: Array<vimService.vim.VMwareDVSPvlanMapEntry>;
            maxMtu: number;
            linkDiscoveryProtocolConfig?: vimService.vim.LinkDiscoveryProtocolConfig;
            ipfixConfig?: vimService.vim.VMwareIpfixConfig;
            lacpGroupConfig?: Array<vimService.vim.VMwareDvsLacpGroupConfig>;
            lacpApiVersion?: string;
            multicastFilteringMode?: string;
         }
         interface VMwareDVSConfigSpec extends vimService.vim.DVSConfigSpec {
            pvlanConfigSpec?: Array<vimService.vim.VMwareDVSPvlanConfigSpec>;
            vspanConfigSpec?: Array<vimService.vim.VMwareDVSVspanConfigSpec>;
            maxMtu?: number;
            linkDiscoveryProtocolConfig?: vimService.vim.LinkDiscoveryProtocolConfig;
            ipfixConfig?: vimService.vim.VMwareIpfixConfig;
            lacpApiVersion?: string;
            multicastFilteringMode?: string;
         }
         interface VMwareUplinkPortOrderPolicy extends vimService.vim.InheritablePolicy {
            activeUplinkPort?: Array<string>;
            standbyUplinkPort?: Array<string>;
         }
         interface DVSFailureCriteria extends vimService.vim.InheritablePolicy {
            checkSpeed?: vimService.vim.StringPolicy;
            speed?: vimService.vim.IntPolicy;
            checkDuplex?: vimService.vim.BoolPolicy;
            fullDuplex?: vimService.vim.BoolPolicy;
            checkErrorPercent?: vimService.vim.BoolPolicy;
            percentage?: vimService.vim.IntPolicy;
            checkBeacon?: vimService.vim.BoolPolicy;
         }
         interface VmwareUplinkPortTeamingPolicy extends vimService.vim.InheritablePolicy {
            policy?: vimService.vim.StringPolicy;
            reversePolicy?: vimService.vim.BoolPolicy;
            notifySwitches?: vimService.vim.BoolPolicy;
            rollingOrder?: vimService.vim.BoolPolicy;
            failureCriteria?: vimService.vim.DVSFailureCriteria;
            uplinkPortOrder?: vimService.vim.VMwareUplinkPortOrderPolicy;
         }
         interface VmwareDistributedVirtualSwitchVlanSpec extends vimService.vim.InheritablePolicy {
         }
         interface VmwareDistributedVirtualSwitchPvlanSpec extends vimService.vim.VmwareDistributedVirtualSwitchVlanSpec {
            pvlanId: number;
         }
         interface VmwareDistributedVirtualSwitchVlanIdSpec extends vimService.vim.VmwareDistributedVirtualSwitchVlanSpec {
            vlanId: number;
         }
         interface VmwareDistributedVirtualSwitchTrunkVlanSpec extends vimService.vim.VmwareDistributedVirtualSwitchVlanSpec {
            vlanId: Array<vimService.vim.NumericRange>;
         }
         interface DVSSecurityPolicy extends vimService.vim.InheritablePolicy {
            allowPromiscuous?: vimService.vim.BoolPolicy;
            macChanges?: vimService.vim.BoolPolicy;
            forgedTransmits?: vimService.vim.BoolPolicy;
         }
         interface VMwareDVSPortSetting extends vimService.vim.DVPortSetting {
            vlan?: vimService.vim.VmwareDistributedVirtualSwitchVlanSpec;
            qosTag?: vimService.vim.IntPolicy;
            uplinkTeamingPolicy?: vimService.vim.VmwareUplinkPortTeamingPolicy;
            securityPolicy?: vimService.vim.DVSSecurityPolicy;
            ipfixEnabled?: vimService.vim.BoolPolicy;
            txUplink?: vimService.vim.BoolPolicy;
            lacpPolicy?: vimService.vim.VMwareUplinkLacpPolicy;
         }
         interface VMwareDVSPortgroupPolicy extends vimService.vim.DVPortgroupPolicy {
            vlanOverrideAllowed: boolean;
            uplinkTeamingOverrideAllowed: boolean;
            securityPolicyOverrideAllowed: boolean;
            ipfixOverrideAllowed?: boolean;
         }
         enum VmwareDistributedVirtualSwitchPvlanPortType {
            "promiscuous",
            "isolated",
            "community",
         }
         interface VMwareDVSPvlanConfigSpec extends vimService.vim.DynamicData {
            pvlanEntry: vimService.vim.VMwareDVSPvlanMapEntry;
            operation: string;
         }
         interface ArrayOfVMwareDVSPvlanConfigSpec {
            VMwareDVSPvlanConfigSpec?: Array<vimService.vim.VMwareDVSPvlanConfigSpec>;
         }
         interface VMwareDVSPvlanMapEntry extends vimService.vim.DynamicData {
            primaryVlanId: number;
            secondaryVlanId: number;
            pvlanType: string;
         }
         interface ArrayOfVMwareDVSPvlanMapEntry {
            VMwareDVSPvlanMapEntry?: Array<vimService.vim.VMwareDVSPvlanMapEntry>;
         }
         interface VMwareDVSVspanConfigSpec extends vimService.vim.DynamicData {
            vspanSession: vimService.vim.VMwareVspanSession;
            operation: string;
         }
         interface ArrayOfVMwareDVSVspanConfigSpec {
            VMwareDVSVspanConfigSpec?: Array<vimService.vim.VMwareDVSVspanConfigSpec>;
         }
         enum VMwareDVSVspanSessionEncapType {
            "gre",
            "erspan2",
            "erspan3",
         }
         enum VMwareDVSVspanSessionType {
            "mixedDestMirror",
            "dvPortMirror",
            "remoteMirrorSource",
            "remoteMirrorDest",
            "encapsulatedRemoteMirrorSource",
         }
         interface VMwareDVSHealthCheckConfig extends vimService.vim.DVSHealthCheckConfig {
         }
         interface VMwareDVSVlanMtuHealthCheckConfig extends vimService.vim.VMwareDVSHealthCheckConfig {
         }
         interface VMwareDVSTeamingHealthCheckConfig extends vimService.vim.VMwareDVSHealthCheckConfig {
         }
         interface VMwareDVSVlanHealthCheckResult extends vimService.vim.HostMemberUplinkHealthCheckResult {
            trunkedVlan?: Array<vimService.vim.NumericRange>;
            untrunkedVlan?: Array<vimService.vim.NumericRange>;
         }
         interface VMwareDVSMtuHealthCheckResult extends vimService.vim.HostMemberUplinkHealthCheckResult {
            mtuMismatch: boolean;
            vlanSupportSwitchMtu?: Array<vimService.vim.NumericRange>;
            vlanNotSupportSwitchMtu?: Array<vimService.vim.NumericRange>;
         }
         enum VMwareDVSTeamingMatchStatus {
            "iphashMatch",
            "nonIphashMatch",
            "iphashMismatch",
            "nonIphashMismatch",
         }
         interface VMwareDVSTeamingHealthCheckResult extends vimService.vim.HostMemberHealthCheckResult {
            teamingStatus: string;
         }
         interface VMwareUplinkLacpPolicy extends vimService.vim.InheritablePolicy {
            enable?: vimService.vim.BoolPolicy;
            mode?: vimService.vim.StringPolicy;
         }
         interface VMwareDvsLacpGroupConfig extends vimService.vim.DynamicData {
            key?: string;
            name?: string;
            mode?: string;
            uplinkNum?: number;
            loadbalanceAlgorithm?: string;
            vlan?: vimService.vim.VMwareDvsLagVlanConfig;
            ipfix?: vimService.vim.VMwareDvsLagIpfixConfig;
            uplinkName?: Array<string>;
            uplinkPortKey?: Array<string>;
         }
         interface ArrayOfVMwareDvsLacpGroupConfig {
            VMwareDvsLacpGroupConfig?: Array<vimService.vim.VMwareDvsLacpGroupConfig>;
         }
         interface VMwareDvsLagVlanConfig extends vimService.vim.DynamicData {
            vlanId?: Array<vimService.vim.NumericRange>;
         }
         interface VMwareDvsLagIpfixConfig extends vimService.vim.DynamicData {
            ipfixEnabled?: boolean;
         }
         enum VMwareUplinkLacpMode {
            "active",
            "passive",
         }
         interface VMwareDvsLacpGroupSpec extends vimService.vim.DynamicData {
            lacpGroupConfig: vimService.vim.VMwareDvsLacpGroupConfig;
            operation: string;
         }
         interface ArrayOfVMwareDvsLacpGroupSpec {
            VMwareDvsLacpGroupSpec?: Array<vimService.vim.VMwareDvsLacpGroupSpec>;
         }
         enum VMwareDvsLacpLoadBalanceAlgorithm {
            "srcMac",
            "destMac",
            "srcDestMac",
            "destIpVlan",
            "srcIpVlan",
            "srcDestIpVlan",
            "destTcpUdpPort",
            "srcTcpUdpPort",
            "srcDestTcpUdpPort",
            "destIpTcpUdpPort",
            "srcIpTcpUdpPort",
            "srcDestIpTcpUdpPort",
            "destIpTcpUdpPortVlan",
            "srcIpTcpUdpPortVlan",
            "srcDestIpTcpUdpPortVlan",
            "destIp",
            "srcIp",
            "srcDestIp",
            "vlan",
            "srcPortId",
         }
         enum VMwareDvsLacpApiVersion {
            "singleLag",
            "multipleLag",
         }
         enum VMwareDvsMulticastFilteringMode {
            "legacyFiltering",
            "snooping",
         }
         interface CryptoKeyId extends vimService.vim.DynamicData {
            keyId: string;
            providerId?: vimService.vim.KeyProviderId;
         }
         interface ArrayOfCryptoKeyId {
            CryptoKeyId?: Array<vimService.vim.CryptoKeyId>;
         }
         interface CryptoKeyPlain extends vimService.vim.DynamicData {
            keyId: vimService.vim.CryptoKeyId;
            algorithm: string;
            keyData: string;
         }
         interface ArrayOfCryptoKeyPlain {
            CryptoKeyPlain?: Array<vimService.vim.CryptoKeyPlain>;
         }
         interface CryptoKeyResult extends vimService.vim.DynamicData {
            keyId: vimService.vim.CryptoKeyId;
            success: boolean;
            reason?: string;
         }
         interface ArrayOfCryptoKeyResult {
            CryptoKeyResult?: Array<vimService.vim.CryptoKeyResult>;
         }
         interface CryptoManagerKmipCertificateInfo extends vimService.vim.DynamicData {
            subject: string;
            issuer: string;
            serialNumber: string;
            notBefore: Date;
            notAfter: Date;
            fingerprint: string;
            checkTime: Date;
            secondsSinceValid?: number;
            secondsBeforeExpire?: number;
         }
         interface CryptoManagerKmipServerStatus extends vimService.vim.DynamicData {
            name: string;
            status: vimService.vim.ManagedEntityStatus;
            connectionStatus: string;
            certInfo?: vimService.vim.CryptoManagerKmipCertificateInfo;
            clientTrustServer?: boolean;
            serverTrustClient?: boolean;
         }
         interface ArrayOfCryptoManagerKmipServerStatus {
            CryptoManagerKmipServerStatus?: Array<vimService.vim.CryptoManagerKmipServerStatus>;
         }
         interface CryptoManagerKmipClusterStatus extends vimService.vim.DynamicData {
            clusterId: vimService.vim.KeyProviderId;
            servers: Array<vimService.vim.CryptoManagerKmipServerStatus>;
            clientCertInfo?: vimService.vim.CryptoManagerKmipCertificateInfo;
         }
         interface ArrayOfCryptoManagerKmipClusterStatus {
            CryptoManagerKmipClusterStatus?: Array<vimService.vim.CryptoManagerKmipClusterStatus>;
         }
         interface CryptoManagerKmipServerCertInfo extends vimService.vim.DynamicData {
            certificate: string;
            certInfo?: vimService.vim.CryptoManagerKmipCertificateInfo;
            clientTrustServer?: boolean;
         }
         interface CryptoSpec extends vimService.vim.DynamicData {
         }
         interface CryptoSpecDecrypt extends vimService.vim.CryptoSpec {
         }
         interface CryptoSpecDeepRecrypt extends vimService.vim.CryptoSpec {
            newKeyId: vimService.vim.CryptoKeyId;
         }
         interface CryptoSpecEncrypt extends vimService.vim.CryptoSpec {
            cryptoKeyId: vimService.vim.CryptoKeyId;
         }
         interface CryptoSpecNoOp extends vimService.vim.CryptoSpec {
         }
         interface CryptoSpecRegister extends vimService.vim.CryptoSpecNoOp {
            cryptoKeyId: vimService.vim.CryptoKeyId;
         }
         interface CryptoSpecShallowRecrypt extends vimService.vim.CryptoSpec {
            newKeyId: vimService.vim.CryptoKeyId;
         }
         interface KeyProviderId extends vimService.vim.DynamicData {
            id: string;
         }
         interface KmipClusterInfo extends vimService.vim.DynamicData {
            clusterId: vimService.vim.KeyProviderId;
            servers?: Array<vimService.vim.KmipServerInfo>;
            useAsDefault: boolean;
         }
         interface ArrayOfKmipClusterInfo {
            KmipClusterInfo?: Array<vimService.vim.KmipClusterInfo>;
         }
         interface KmipServerInfo extends vimService.vim.DynamicData {
            name: string;
            address: string;
            port: number;
            proxyAddress?: string;
            proxyPort?: number;
            reconnect?: number;
            protocol?: string;
            nbio?: number;
            timeout?: number;
            userName?: string;
         }
         interface ArrayOfKmipServerInfo {
            KmipServerInfo?: Array<vimService.vim.KmipServerInfo>;
         }
         interface KmipServerSpec extends vimService.vim.DynamicData {
            clusterId: vimService.vim.KeyProviderId;
            info: vimService.vim.KmipServerInfo;
            password?: string;
         }
         interface KmipServerStatus extends vimService.vim.DynamicData {
            clusterId: vimService.vim.KeyProviderId;
            name: string;
            status: vimService.vim.ManagedEntityStatus;
            description: string;
         }
         enum EventEventSeverity {
            "error",
            "warning",
            "info",
            "user",
         }
         interface Event extends vimService.vim.DynamicData {
            key: number;
            chainId: number;
            createdTime: Date;
            userName: string;
            datacenter?: vimService.vim.DatacenterEventArgument;
            computeResource?: vimService.vim.ComputeResourceEventArgument;
            host?: vimService.vim.HostEventArgument;
            vm?: vimService.vim.VmEventArgument;
            ds?: vimService.vim.DatastoreEventArgument;
            net?: vimService.vim.NetworkEventArgument;
            dvs?: vimService.vim.DvsEventArgument;
            fullFormattedMessage?: string;
            changeTag?: string;
         }
         interface ArrayOfEvent {
            Event?: Array<vimService.vim.Event>;
         }
         interface GeneralEvent extends vimService.vim.Event {
            message: string;
         }
         interface GeneralHostInfoEvent extends vimService.vim.GeneralEvent {
         }
         interface GeneralHostWarningEvent extends vimService.vim.GeneralEvent {
         }
         interface GeneralHostErrorEvent extends vimService.vim.GeneralEvent {
         }
         interface GeneralVmInfoEvent extends vimService.vim.GeneralEvent {
         }
         interface GeneralVmWarningEvent extends vimService.vim.GeneralEvent {
         }
         interface GeneralVmErrorEvent extends vimService.vim.GeneralEvent {
         }
         interface GeneralUserEvent extends vimService.vim.GeneralEvent {
            entity?: vimService.vim.ManagedEntityEventArgument;
         }
         interface ExtendedEventPair extends vimService.vim.DynamicData {
            key: string;
            value: string;
         }
         interface ArrayOfExtendedEventPair {
            ExtendedEventPair?: Array<vimService.vim.ExtendedEventPair>;
         }
         interface ExtendedEvent extends vimService.vim.GeneralEvent {
            eventTypeId: string;
            managedObject: vimService.vim.ManagedObjectReference;
            data?: Array<vimService.vim.ExtendedEventPair>;
         }
         interface HealthStatusChangedEvent extends vimService.vim.Event {
            componentId: string;
            oldStatus: string;
            newStatus: string;
            componentName: string;
            serviceId?: string;
         }
         interface HostInventoryUnreadableEvent extends vimService.vim.Event {
         }
         interface DatacenterEvent extends vimService.vim.Event {
         }
         interface DatacenterCreatedEvent extends vimService.vim.DatacenterEvent {
            parent: vimService.vim.FolderEventArgument;
         }
         interface DatacenterRenamedEvent extends vimService.vim.DatacenterEvent {
            oldName: string;
            newName: string;
         }
         interface SessionEvent extends vimService.vim.Event {
         }
         interface ServerStartedSessionEvent extends vimService.vim.SessionEvent {
         }
         interface UserLoginSessionEvent extends vimService.vim.SessionEvent {
            ipAddress: string;
            userAgent?: string;
            locale: string;
            sessionId: string;
         }
         interface UserLogoutSessionEvent extends vimService.vim.SessionEvent {
            ipAddress?: string;
            userAgent?: string;
            callCount?: number;
            sessionId?: string;
            loginTime?: Date;
         }
         interface BadUsernameSessionEvent extends vimService.vim.SessionEvent {
            ipAddress: string;
         }
         interface AlreadyAuthenticatedSessionEvent extends vimService.vim.SessionEvent {
         }
         interface NoAccessUserEvent extends vimService.vim.SessionEvent {
            ipAddress: string;
         }
         interface SessionTerminatedEvent extends vimService.vim.SessionEvent {
            sessionId: string;
            terminatedUsername: string;
         }
         interface GlobalMessageChangedEvent extends vimService.vim.SessionEvent {
            message: string;
            prevMessage?: string;
         }
         interface UpgradeEvent extends vimService.vim.Event {
            message: string;
         }
         interface InfoUpgradeEvent extends vimService.vim.UpgradeEvent {
         }
         interface WarningUpgradeEvent extends vimService.vim.UpgradeEvent {
         }
         interface ErrorUpgradeEvent extends vimService.vim.UpgradeEvent {
         }
         interface UserUpgradeEvent extends vimService.vim.UpgradeEvent {
         }
         interface HostEvent extends vimService.vim.Event {
         }
         interface HostDasEvent extends vimService.vim.HostEvent {
         }
         interface HostConnectedEvent extends vimService.vim.HostEvent {
         }
         enum HostDisconnectedEventReasonCode {
            "sslThumbprintVerifyFailed",
            "licenseExpired",
            "agentUpgrade",
            "userRequest",
            "insufficientLicenses",
            "agentOutOfDate",
            "passwordDecryptFailure",
            "unknown",
            "vcVRAMCapacityExceeded",
         }
         interface HostDisconnectedEvent extends vimService.vim.HostEvent {
            reason?: string;
         }
         interface HostSyncFailedEvent extends vimService.vim.HostEvent {
            reason: vimService.vim.LocalizedMethodFault;
         }
         interface HostConnectionLostEvent extends vimService.vim.HostEvent {
         }
         interface HostReconnectionFailedEvent extends vimService.vim.HostEvent {
         }
         interface HostCnxFailedNoConnectionEvent extends vimService.vim.HostEvent {
         }
         interface HostCnxFailedBadUsernameEvent extends vimService.vim.HostEvent {
         }
         interface HostCnxFailedBadVersionEvent extends vimService.vim.HostEvent {
         }
         interface HostCnxFailedAlreadyManagedEvent extends vimService.vim.HostEvent {
            serverName: string;
         }
         interface HostCnxFailedNoLicenseEvent extends vimService.vim.HostEvent {
         }
         interface HostCnxFailedNetworkErrorEvent extends vimService.vim.HostEvent {
         }
         interface HostRemovedEvent extends vimService.vim.HostEvent {
         }
         interface HostCnxFailedCcagentUpgradeEvent extends vimService.vim.HostEvent {
         }
         interface HostCnxFailedBadCcagentEvent extends vimService.vim.HostEvent {
         }
         interface HostCnxFailedEvent extends vimService.vim.HostEvent {
         }
         interface HostCnxFailedAccountFailedEvent extends vimService.vim.HostEvent {
         }
         interface HostCnxFailedNoAccessEvent extends vimService.vim.HostEvent {
         }
         interface HostShutdownEvent extends vimService.vim.HostEvent {
            reason: string;
         }
         interface HostCnxFailedNotFoundEvent extends vimService.vim.HostEvent {
         }
         interface HostCnxFailedTimeoutEvent extends vimService.vim.HostEvent {
         }
         interface HostUpgradeFailedEvent extends vimService.vim.HostEvent {
         }
         interface EnteringMaintenanceModeEvent extends vimService.vim.HostEvent {
         }
         interface EnteredMaintenanceModeEvent extends vimService.vim.HostEvent {
         }
         interface ExitMaintenanceModeEvent extends vimService.vim.HostEvent {
         }
         interface CanceledHostOperationEvent extends vimService.vim.HostEvent {
         }
         interface TimedOutHostOperationEvent extends vimService.vim.HostEvent {
         }
         interface HostDasEnabledEvent extends vimService.vim.HostEvent {
         }
         interface HostDasDisabledEvent extends vimService.vim.HostEvent {
         }
         interface HostDasEnablingEvent extends vimService.vim.HostEvent {
         }
         interface HostDasDisablingEvent extends vimService.vim.HostEvent {
         }
         enum HostDasErrorEventHostDasErrorReason {
            "configFailed",
            "timeout",
            "communicationInitFailed",
            "healthCheckScriptFailed",
            "agentFailed",
            "agentShutdown",
            "isolationAddressUnpingable",
            "other",
         }
         interface HostDasErrorEvent extends vimService.vim.HostEvent {
            message?: string;
            reason?: string;
         }
         interface HostDasOkEvent extends vimService.vim.HostEvent {
         }
         interface VcAgentUpgradedEvent extends vimService.vim.HostEvent {
         }
         interface VcAgentUninstalledEvent extends vimService.vim.HostEvent {
         }
         interface VcAgentUpgradeFailedEvent extends vimService.vim.HostEvent {
            reason?: string;
         }
         interface VcAgentUninstallFailedEvent extends vimService.vim.HostEvent {
            reason?: string;
         }
         interface HostAddedEvent extends vimService.vim.HostEvent {
         }
         interface HostAddFailedEvent extends vimService.vim.HostEvent {
            hostname: string;
         }
         interface HostIpChangedEvent extends vimService.vim.HostEvent {
            oldIP: string;
            newIP: string;
         }
         interface EnteringStandbyModeEvent extends vimService.vim.HostEvent {
         }
         interface DrsEnteringStandbyModeEvent extends vimService.vim.EnteringStandbyModeEvent {
         }
         interface EnteredStandbyModeEvent extends vimService.vim.HostEvent {
         }
         interface DrsEnteredStandbyModeEvent extends vimService.vim.EnteredStandbyModeEvent {
         }
         interface ExitingStandbyModeEvent extends vimService.vim.HostEvent {
         }
         interface DrsExitingStandbyModeEvent extends vimService.vim.ExitingStandbyModeEvent {
         }
         interface ExitedStandbyModeEvent extends vimService.vim.HostEvent {
         }
         interface DrsExitedStandbyModeEvent extends vimService.vim.ExitedStandbyModeEvent {
         }
         interface ExitStandbyModeFailedEvent extends vimService.vim.HostEvent {
         }
         interface DrsExitStandbyModeFailedEvent extends vimService.vim.ExitStandbyModeFailedEvent {
         }
         interface UpdatedAgentBeingRestartedEvent extends vimService.vim.HostEvent {
         }
         interface AccountCreatedEvent extends vimService.vim.HostEvent {
            spec: vimService.vim.HostAccountSpec;
            group: boolean;
         }
         interface AccountRemovedEvent extends vimService.vim.HostEvent {
            account: string;
            group: boolean;
         }
         interface UserPasswordChanged extends vimService.vim.HostEvent {
            userLogin: string;
         }
         interface AccountUpdatedEvent extends vimService.vim.HostEvent {
            spec: vimService.vim.HostAccountSpec;
            group: boolean;
            prevDescription?: string;
         }
         interface UserAssignedToGroup extends vimService.vim.HostEvent {
            userLogin: string;
            group: string;
         }
         interface UserUnassignedFromGroup extends vimService.vim.HostEvent {
            userLogin: string;
            group: string;
         }
         interface DatastorePrincipalConfigured extends vimService.vim.HostEvent {
            datastorePrincipal: string;
         }
         interface VMFSDatastoreCreatedEvent extends vimService.vim.HostEvent {
            datastore: vimService.vim.DatastoreEventArgument;
            datastoreUrl?: string;
         }
         interface NASDatastoreCreatedEvent extends vimService.vim.HostEvent {
            datastore: vimService.vim.DatastoreEventArgument;
            datastoreUrl?: string;
         }
         interface LocalDatastoreCreatedEvent extends vimService.vim.HostEvent {
            datastore: vimService.vim.DatastoreEventArgument;
            datastoreUrl?: string;
         }
         interface VMFSDatastoreExtendedEvent extends vimService.vim.HostEvent {
            datastore: vimService.vim.DatastoreEventArgument;
         }
         interface VMFSDatastoreExpandedEvent extends vimService.vim.HostEvent {
            datastore: vimService.vim.DatastoreEventArgument;
         }
         interface DatastoreRemovedOnHostEvent extends vimService.vim.HostEvent {
            datastore: vimService.vim.DatastoreEventArgument;
         }
         interface DatastoreRenamedOnHostEvent extends vimService.vim.HostEvent {
            oldName: string;
            newName: string;
         }
         interface DuplicateIpDetectedEvent extends vimService.vim.HostEvent {
            duplicateIP: string;
            macAddress: string;
         }
         interface DatastoreDiscoveredEvent extends vimService.vim.HostEvent {
            datastore: vimService.vim.DatastoreEventArgument;
         }
         interface DrsResourceConfigureFailedEvent extends vimService.vim.HostEvent {
            reason: vimService.vim.LocalizedMethodFault;
         }
         interface DrsResourceConfigureSyncedEvent extends vimService.vim.HostEvent {
         }
         interface HostGetShortNameFailedEvent extends vimService.vim.HostEvent {
         }
         interface HostShortNameToIpFailedEvent extends vimService.vim.HostEvent {
            shortName: string;
         }
         interface HostIpToShortNameFailedEvent extends vimService.vim.HostEvent {
         }
         interface HostPrimaryAgentNotShortNameEvent extends vimService.vim.HostDasEvent {
            primaryAgent: string;
         }
         interface HostNotInClusterEvent extends vimService.vim.HostDasEvent {
         }
         interface HostIsolationIpPingFailedEvent extends vimService.vim.HostDasEvent {
            isolationIp: string;
         }
         interface HostIpInconsistentEvent extends vimService.vim.HostEvent {
            ipAddress: string;
            ipAddress2: string;
         }
         interface HostUserWorldSwapNotEnabledEvent extends vimService.vim.HostEvent {
         }
         interface HostNonCompliantEvent extends vimService.vim.HostEvent {
         }
         interface HostCompliantEvent extends vimService.vim.HostEvent {
         }
         interface HostComplianceCheckedEvent extends vimService.vim.HostEvent {
            profile: vimService.vim.ProfileEventArgument;
         }
         interface ClusterComplianceCheckedEvent extends vimService.vim.ClusterEvent {
            profile: vimService.vim.ProfileEventArgument;
         }
         interface ProfileEvent extends vimService.vim.Event {
            profile: vimService.vim.ProfileEventArgument;
         }
         interface ProfileCreatedEvent extends vimService.vim.ProfileEvent {
         }
         interface ProfileRemovedEvent extends vimService.vim.ProfileEvent {
         }
         interface ProfileAssociatedEvent extends vimService.vim.ProfileEvent {
         }
         interface ProfileDissociatedEvent extends vimService.vim.ProfileEvent {
         }
         interface HostConfigAppliedEvent extends vimService.vim.HostEvent {
         }
         interface ProfileReferenceHostChangedEvent extends vimService.vim.ProfileEvent {
            referenceHost?: vimService.vim.ManagedObjectReference;
            referenceHostName?: string;
            prevReferenceHostName?: string;
         }
         interface ProfileChangedEvent extends vimService.vim.ProfileEvent {
         }
         interface HostProfileAppliedEvent extends vimService.vim.HostEvent {
            profile: vimService.vim.ProfileEventArgument;
         }
         interface HostShortNameInconsistentEvent extends vimService.vim.HostDasEvent {
            shortName: string;
            shortName2: string;
         }
         interface HostNoRedundantManagementNetworkEvent extends vimService.vim.HostDasEvent {
         }
         interface HostNoAvailableNetworksEvent extends vimService.vim.HostDasEvent {
            ips?: string;
         }
         interface HostExtraNetworksEvent extends vimService.vim.HostDasEvent {
            ips?: string;
         }
         interface HostNoHAEnabledPortGroupsEvent extends vimService.vim.HostDasEvent {
         }
         interface HostMissingNetworksEvent extends vimService.vim.HostDasEvent {
            ips?: string;
         }
         interface VnicPortArgument extends vimService.vim.DynamicData {
            vnic: string;
            port: vimService.vim.DistributedVirtualSwitchPortConnection;
         }
         interface ArrayOfVnicPortArgument {
            VnicPortArgument?: Array<vimService.vim.VnicPortArgument>;
         }
         interface HostVnicConnectedToCustomizedDVPortEvent extends vimService.vim.HostEvent {
            vnic: vimService.vim.VnicPortArgument;
            prevPortKey?: string;
         }
         interface GhostDvsProxySwitchDetectedEvent extends vimService.vim.HostEvent {
            switchUuid: Array<string>;
         }
         interface GhostDvsProxySwitchRemovedEvent extends vimService.vim.HostEvent {
            switchUuid: Array<string>;
         }
         interface VmEvent extends vimService.vim.Event {
            template: boolean;
         }
         interface VmPoweredOffEvent extends vimService.vim.VmEvent {
         }
         interface VmPoweredOnEvent extends vimService.vim.VmEvent {
         }
         interface VmSuspendedEvent extends vimService.vim.VmEvent {
         }
         interface VmStartingEvent extends vimService.vim.VmEvent {
         }
         interface VmStoppingEvent extends vimService.vim.VmEvent {
         }
         interface VmSuspendingEvent extends vimService.vim.VmEvent {
         }
         interface VmResumingEvent extends vimService.vim.VmEvent {
         }
         interface VmDisconnectedEvent extends vimService.vim.VmEvent {
         }
         interface VmRemoteConsoleConnectedEvent extends vimService.vim.VmEvent {
         }
         interface VmRemoteConsoleDisconnectedEvent extends vimService.vim.VmEvent {
         }
         interface VmDiscoveredEvent extends vimService.vim.VmEvent {
         }
         interface VmOrphanedEvent extends vimService.vim.VmEvent {
         }
         interface VmBeingCreatedEvent extends vimService.vim.VmEvent {
            configSpec?: vimService.vim.VirtualMachineConfigSpec;
         }
         interface VmCreatedEvent extends vimService.vim.VmEvent {
         }
         interface VmStartRecordingEvent extends vimService.vim.VmEvent {
         }
         interface VmEndRecordingEvent extends vimService.vim.VmEvent {
         }
         interface VmStartReplayingEvent extends vimService.vim.VmEvent {
         }
         interface VmEndReplayingEvent extends vimService.vim.VmEvent {
         }
         interface VmRegisteredEvent extends vimService.vim.VmEvent {
         }
         interface VmAutoRenameEvent extends vimService.vim.VmEvent {
            oldName: string;
            newName: string;
         }
         interface VmBeingHotMigratedEvent extends vimService.vim.VmEvent {
            destHost: vimService.vim.HostEventArgument;
            destDatacenter?: vimService.vim.DatacenterEventArgument;
            destDatastore?: vimService.vim.DatastoreEventArgument;
         }
         interface VmResettingEvent extends vimService.vim.VmEvent {
         }
         interface VmStaticMacConflictEvent extends vimService.vim.VmEvent {
            conflictedVm: vimService.vim.VmEventArgument;
            mac: string;
         }
         interface VmMacConflictEvent extends vimService.vim.VmEvent {
            conflictedVm: vimService.vim.VmEventArgument;
            mac: string;
         }
         interface VmBeingDeployedEvent extends vimService.vim.VmEvent {
            srcTemplate: vimService.vim.VmEventArgument;
         }
         interface VmDeployFailedEvent extends vimService.vim.VmEvent {
            destDatastore: vimService.vim.EntityEventArgument;
            reason: vimService.vim.LocalizedMethodFault;
         }
         interface VmDeployedEvent extends vimService.vim.VmEvent {
            srcTemplate: vimService.vim.VmEventArgument;
         }
         interface VmMacChangedEvent extends vimService.vim.VmEvent {
            adapter: string;
            oldMac: string;
            newMac: string;
         }
         interface VmMacAssignedEvent extends vimService.vim.VmEvent {
            adapter: string;
            mac: string;
         }
         interface VmUuidConflictEvent extends vimService.vim.VmEvent {
            conflictedVm: vimService.vim.VmEventArgument;
            uuid: string;
         }
         interface VmInstanceUuidConflictEvent extends vimService.vim.VmEvent {
            conflictedVm: vimService.vim.VmEventArgument;
            instanceUuid: string;
         }
         interface VmBeingMigratedEvent extends vimService.vim.VmEvent {
            destHost: vimService.vim.HostEventArgument;
            destDatacenter?: vimService.vim.DatacenterEventArgument;
            destDatastore?: vimService.vim.DatastoreEventArgument;
         }
         interface VmFailedMigrateEvent extends vimService.vim.VmEvent {
            destHost: vimService.vim.HostEventArgument;
            reason: vimService.vim.LocalizedMethodFault;
            destDatacenter?: vimService.vim.DatacenterEventArgument;
            destDatastore?: vimService.vim.DatastoreEventArgument;
         }
         interface VmMigratedEvent extends vimService.vim.VmEvent {
            sourceHost: vimService.vim.HostEventArgument;
            sourceDatacenter?: vimService.vim.DatacenterEventArgument;
            sourceDatastore?: vimService.vim.DatastoreEventArgument;
         }
         interface VmUnsupportedStartingEvent extends vimService.vim.VmStartingEvent {
            guestId: string;
         }
         interface DrsVmMigratedEvent extends vimService.vim.VmMigratedEvent {
         }
         interface DrsVmPoweredOnEvent extends vimService.vim.VmPoweredOnEvent {
         }
         interface DrsRuleViolationEvent extends vimService.vim.VmEvent {
         }
         interface DrsSoftRuleViolationEvent extends vimService.vim.VmEvent {
         }
         interface DrsRuleComplianceEvent extends vimService.vim.VmEvent {
         }
         interface VmRelocateSpecEvent extends vimService.vim.VmEvent {
         }
         interface VmBeingRelocatedEvent extends vimService.vim.VmRelocateSpecEvent {
            destHost: vimService.vim.HostEventArgument;
            destDatacenter?: vimService.vim.DatacenterEventArgument;
            destDatastore?: vimService.vim.DatastoreEventArgument;
         }
         interface VmRelocatedEvent extends vimService.vim.VmRelocateSpecEvent {
            sourceHost: vimService.vim.HostEventArgument;
            sourceDatacenter?: vimService.vim.DatacenterEventArgument;
            sourceDatastore?: vimService.vim.DatastoreEventArgument;
         }
         interface VmRelocateFailedEvent extends vimService.vim.VmRelocateSpecEvent {
            destHost: vimService.vim.HostEventArgument;
            reason: vimService.vim.LocalizedMethodFault;
            destDatacenter?: vimService.vim.DatacenterEventArgument;
            destDatastore?: vimService.vim.DatastoreEventArgument;
         }
         interface VmEmigratingEvent extends vimService.vim.VmEvent {
         }
         interface VmCloneEvent extends vimService.vim.VmEvent {
         }
         interface VmBeingClonedEvent extends vimService.vim.VmCloneEvent {
            destFolder: vimService.vim.FolderEventArgument;
            destName: string;
            destHost: vimService.vim.HostEventArgument;
         }
         interface VmBeingClonedNoFolderEvent extends vimService.vim.VmCloneEvent {
            destName: string;
            destHost: vimService.vim.HostEventArgument;
         }
         interface VmCloneFailedEvent extends vimService.vim.VmCloneEvent {
            destFolder: vimService.vim.FolderEventArgument;
            destName: string;
            destHost: vimService.vim.HostEventArgument;
            reason: vimService.vim.LocalizedMethodFault;
         }
         interface VmClonedEvent extends vimService.vim.VmCloneEvent {
            sourceVm: vimService.vim.VmEventArgument;
         }
         interface VmResourceReallocatedEvent extends vimService.vim.VmEvent {
            configChanges?: vimService.vim.ChangesInfoEventArgument;
         }
         interface VmRenamedEvent extends vimService.vim.VmEvent {
            oldName: string;
            newName: string;
         }
         interface VmDateRolledBackEvent extends vimService.vim.VmEvent {
         }
         interface VmNoNetworkAccessEvent extends vimService.vim.VmEvent {
            destHost: vimService.vim.HostEventArgument;
         }
         interface VmDiskFailedEvent extends vimService.vim.VmEvent {
            disk: string;
            reason: vimService.vim.LocalizedMethodFault;
         }
         interface VmFailedToPowerOnEvent extends vimService.vim.VmEvent {
            reason: vimService.vim.LocalizedMethodFault;
         }
         interface VmFailedToPowerOffEvent extends vimService.vim.VmEvent {
            reason: vimService.vim.LocalizedMethodFault;
         }
         interface VmFailedToSuspendEvent extends vimService.vim.VmEvent {
            reason: vimService.vim.LocalizedMethodFault;
         }
         interface VmFailedToResetEvent extends vimService.vim.VmEvent {
            reason: vimService.vim.LocalizedMethodFault;
         }
         interface VmFailedToShutdownGuestEvent extends vimService.vim.VmEvent {
            reason: vimService.vim.LocalizedMethodFault;
         }
         interface VmFailedToRebootGuestEvent extends vimService.vim.VmEvent {
            reason: vimService.vim.LocalizedMethodFault;
         }
         interface VmFailedToStandbyGuestEvent extends vimService.vim.VmEvent {
            reason: vimService.vim.LocalizedMethodFault;
         }
         interface VmRemovedEvent extends vimService.vim.VmEvent {
         }
         interface VmGuestShutdownEvent extends vimService.vim.VmEvent {
         }
         interface VmGuestRebootEvent extends vimService.vim.VmEvent {
         }
         interface VmGuestStandbyEvent extends vimService.vim.VmEvent {
         }
         interface VmUpgradingEvent extends vimService.vim.VmEvent {
            version: string;
         }
         interface VmUpgradeCompleteEvent extends vimService.vim.VmEvent {
            version: string;
         }
         interface VmUpgradeFailedEvent extends vimService.vim.VmEvent {
         }
         interface VmRestartedOnAlternateHostEvent extends vimService.vim.VmPoweredOnEvent {
            sourceHost: vimService.vim.HostEventArgument;
         }
         interface VmReconfiguredEvent extends vimService.vim.VmEvent {
            configSpec: vimService.vim.VirtualMachineConfigSpec;
            configChanges?: vimService.vim.ChangesInfoEventArgument;
         }
         interface VmMessageEvent extends vimService.vim.VmEvent {
            message: string;
            messageInfo?: Array<vimService.vim.VirtualMachineMessage>;
         }
         interface VmMessageWarningEvent extends vimService.vim.VmEvent {
            message: string;
            messageInfo?: Array<vimService.vim.VirtualMachineMessage>;
         }
         interface VmMessageErrorEvent extends vimService.vim.VmEvent {
            message: string;
            messageInfo?: Array<vimService.vim.VirtualMachineMessage>;
         }
         interface VmConfigMissingEvent extends vimService.vim.VmEvent {
         }
         interface VmPowerOffOnIsolationEvent extends vimService.vim.VmPoweredOffEvent {
            isolatedHost: vimService.vim.HostEventArgument;
         }
         enum VmShutdownOnIsolationEventOperation {
            "shutdown",
            "poweredOff",
         }
         interface VmShutdownOnIsolationEvent extends vimService.vim.VmPoweredOffEvent {
            isolatedHost: vimService.vim.HostEventArgument;
            shutdownResult?: string;
         }
         interface VmFailoverFailed extends vimService.vim.VmEvent {
            reason?: vimService.vim.LocalizedMethodFault;
         }
         enum VmDasBeingResetEventReasonCode {
            "vmtoolsHeartbeatFailure",
            "appHeartbeatFailure",
            "appImmediateResetRequest",
            "vmcpResetApdCleared",
         }
         interface VmDasBeingResetEvent extends vimService.vim.VmEvent {
            reason?: string;
         }
         interface VmDasResetFailedEvent extends vimService.vim.VmEvent {
         }
         interface VmMaxRestartCountReached extends vimService.vim.VmEvent {
         }
         interface VmMaxFTRestartCountReached extends vimService.vim.VmEvent {
         }
         interface VmDasBeingResetWithScreenshotEvent extends vimService.vim.VmDasBeingResetEvent {
            screenshotFilePath: string;
         }
         interface NotEnoughResourcesToStartVmEvent extends vimService.vim.VmEvent {
            reason?: string;
         }
         interface VmUuidAssignedEvent extends vimService.vim.VmEvent {
            uuid: string;
         }
         interface VmInstanceUuidAssignedEvent extends vimService.vim.VmEvent {
            instanceUuid: string;
         }
         interface VmUuidChangedEvent extends vimService.vim.VmEvent {
            oldUuid: string;
            newUuid: string;
         }
         interface VmInstanceUuidChangedEvent extends vimService.vim.VmEvent {
            oldInstanceUuid: string;
            newInstanceUuid: string;
         }
         interface VmWwnConflictEvent extends vimService.vim.VmEvent {
            conflictedVms?: Array<vimService.vim.VmEventArgument>;
            conflictedHosts?: Array<vimService.vim.HostEventArgument>;
            wwn: number;
         }
         interface VmAcquiredMksTicketEvent extends vimService.vim.VmEvent {
         }
         interface VmAcquiredTicketEvent extends vimService.vim.VmEvent {
            ticketType: string;
         }
         interface VmGuestOSCrashedEvent extends vimService.vim.VmEvent {
         }
         interface HostWwnConflictEvent extends vimService.vim.HostEvent {
            conflictedVms?: Array<vimService.vim.VmEventArgument>;
            conflictedHosts?: Array<vimService.vim.HostEventArgument>;
            wwn: number;
         }
         interface VmWwnAssignedEvent extends vimService.vim.VmEvent {
            nodeWwns: Array<number>;
            portWwns: Array<number>;
         }
         interface VmWwnChangedEvent extends vimService.vim.VmEvent {
            oldNodeWwns?: Array<number>;
            oldPortWwns?: Array<number>;
            newNodeWwns?: Array<number>;
            newPortWwns?: Array<number>;
         }
         interface VmSecondaryAddedEvent extends vimService.vim.VmEvent {
         }
         interface VmFaultToleranceTurnedOffEvent extends vimService.vim.VmEvent {
         }
         interface VmFaultToleranceStateChangedEvent extends vimService.vim.VmEvent {
            oldState: vimService.vim.VirtualMachineFaultToleranceState;
            newState: vimService.vim.VirtualMachineFaultToleranceState;
         }
         interface VmSecondaryDisabledEvent extends vimService.vim.VmEvent {
         }
         interface VmSecondaryDisabledBySystemEvent extends vimService.vim.VmEvent {
            reason?: vimService.vim.LocalizedMethodFault;
         }
         interface VmSecondaryEnabledEvent extends vimService.vim.VmEvent {
         }
         interface VmStartingSecondaryEvent extends vimService.vim.VmEvent {
         }
         interface VmSecondaryStartedEvent extends vimService.vim.VmEvent {
         }
         interface VmFailedUpdatingSecondaryConfig extends vimService.vim.VmEvent {
         }
         enum VmFailedStartingSecondaryEventFailureReason {
            "incompatibleHost",
            "loginFailed",
            "registerVmFailed",
            "migrateFailed",
         }
         interface VmFailedStartingSecondaryEvent extends vimService.vim.VmEvent {
            reason?: string;
         }
         interface VmTimedoutStartingSecondaryEvent extends vimService.vim.VmEvent {
            timeout?: number;
         }
         interface VmNoCompatibleHostForSecondaryEvent extends vimService.vim.VmEvent {
         }
         interface VmPrimaryFailoverEvent extends vimService.vim.VmEvent {
            reason?: string;
         }
         interface VmFaultToleranceVmTerminatedEvent extends vimService.vim.VmEvent {
            reason?: string;
         }
         interface HostWwnChangedEvent extends vimService.vim.HostEvent {
            oldNodeWwns?: Array<number>;
            oldPortWwns?: Array<number>;
            newNodeWwns?: Array<number>;
            newPortWwns?: Array<number>;
         }
         interface HostAdminDisableEvent extends vimService.vim.HostEvent {
         }
         interface HostAdminEnableEvent extends vimService.vim.HostEvent {
         }
         interface HostEnableAdminFailedEvent extends vimService.vim.HostEvent {
            permissions: Array<vimService.vim.Permission>;
         }
         interface VmFailedRelayoutOnVmfs2DatastoreEvent extends vimService.vim.VmEvent {
         }
         interface VmFailedRelayoutEvent extends vimService.vim.VmEvent {
            reason: vimService.vim.LocalizedMethodFault;
         }
         interface VmRelayoutSuccessfulEvent extends vimService.vim.VmEvent {
         }
         interface VmRelayoutUpToDateEvent extends vimService.vim.VmEvent {
         }
         interface VmConnectedEvent extends vimService.vim.VmEvent {
         }
         interface VmPoweringOnWithCustomizedDVPortEvent extends vimService.vim.VmEvent {
            vnic: Array<vimService.vim.VnicPortArgument>;
         }
         interface VmDasUpdateErrorEvent extends vimService.vim.VmEvent {
         }
         interface NoMaintenanceModeDrsRecommendationForVM extends vimService.vim.VmEvent {
         }
         interface VmDasUpdateOkEvent extends vimService.vim.VmEvent {
         }
         interface ScheduledTaskEvent extends vimService.vim.Event {
            scheduledTask: vimService.vim.ScheduledTaskEventArgument;
            entity: vimService.vim.ManagedEntityEventArgument;
         }
         interface ScheduledTaskCreatedEvent extends vimService.vim.ScheduledTaskEvent {
         }
         interface ScheduledTaskStartedEvent extends vimService.vim.ScheduledTaskEvent {
         }
         interface ScheduledTaskRemovedEvent extends vimService.vim.ScheduledTaskEvent {
         }
         interface ScheduledTaskReconfiguredEvent extends vimService.vim.ScheduledTaskEvent {
            configChanges?: vimService.vim.ChangesInfoEventArgument;
         }
         interface ScheduledTaskCompletedEvent extends vimService.vim.ScheduledTaskEvent {
         }
         interface ScheduledTaskFailedEvent extends vimService.vim.ScheduledTaskEvent {
            reason: vimService.vim.LocalizedMethodFault;
         }
         interface ScheduledTaskEmailCompletedEvent extends vimService.vim.ScheduledTaskEvent {
            to: string;
         }
         interface ScheduledTaskEmailFailedEvent extends vimService.vim.ScheduledTaskEvent {
            to: string;
            reason: vimService.vim.LocalizedMethodFault;
         }
         interface AlarmEvent extends vimService.vim.Event {
            alarm: vimService.vim.AlarmEventArgument;
         }
         interface AlarmCreatedEvent extends vimService.vim.AlarmEvent {
            entity: vimService.vim.ManagedEntityEventArgument;
         }
         interface AlarmStatusChangedEvent extends vimService.vim.AlarmEvent {
            source: vimService.vim.ManagedEntityEventArgument;
            entity: vimService.vim.ManagedEntityEventArgument;
            from: string;
            to: string;
         }
         interface AlarmActionTriggeredEvent extends vimService.vim.AlarmEvent {
            source: vimService.vim.ManagedEntityEventArgument;
            entity: vimService.vim.ManagedEntityEventArgument;
         }
         interface AlarmEmailCompletedEvent extends vimService.vim.AlarmEvent {
            entity: vimService.vim.ManagedEntityEventArgument;
            to: string;
         }
         interface AlarmEmailFailedEvent extends vimService.vim.AlarmEvent {
            entity: vimService.vim.ManagedEntityEventArgument;
            to: string;
            reason: vimService.vim.LocalizedMethodFault;
         }
         interface AlarmSnmpCompletedEvent extends vimService.vim.AlarmEvent {
            entity: vimService.vim.ManagedEntityEventArgument;
         }
         interface AlarmSnmpFailedEvent extends vimService.vim.AlarmEvent {
            entity: vimService.vim.ManagedEntityEventArgument;
            reason: vimService.vim.LocalizedMethodFault;
         }
         interface AlarmScriptCompleteEvent extends vimService.vim.AlarmEvent {
            entity: vimService.vim.ManagedEntityEventArgument;
            script: string;
         }
         interface AlarmScriptFailedEvent extends vimService.vim.AlarmEvent {
            entity: vimService.vim.ManagedEntityEventArgument;
            script: string;
            reason: vimService.vim.LocalizedMethodFault;
         }
         interface AlarmRemovedEvent extends vimService.vim.AlarmEvent {
            entity: vimService.vim.ManagedEntityEventArgument;
         }
         interface AlarmReconfiguredEvent extends vimService.vim.AlarmEvent {
            entity: vimService.vim.ManagedEntityEventArgument;
            configChanges?: vimService.vim.ChangesInfoEventArgument;
         }
         interface AlarmAcknowledgedEvent extends vimService.vim.AlarmEvent {
            source: vimService.vim.ManagedEntityEventArgument;
            entity: vimService.vim.ManagedEntityEventArgument;
         }
         interface AlarmClearedEvent extends vimService.vim.AlarmEvent {
            source: vimService.vim.ManagedEntityEventArgument;
            entity: vimService.vim.ManagedEntityEventArgument;
            from: string;
         }
         interface CustomFieldEvent extends vimService.vim.Event {
         }
         interface CustomFieldDefEvent extends vimService.vim.CustomFieldEvent {
            fieldKey: number;
            name: string;
         }
         interface CustomFieldDefAddedEvent extends vimService.vim.CustomFieldDefEvent {
         }
         interface CustomFieldDefRemovedEvent extends vimService.vim.CustomFieldDefEvent {
         }
         interface CustomFieldDefRenamedEvent extends vimService.vim.CustomFieldDefEvent {
            newName: string;
         }
         interface CustomFieldValueChangedEvent extends vimService.vim.CustomFieldEvent {
            entity: vimService.vim.ManagedEntityEventArgument;
            fieldKey: number;
            name: string;
            value: string;
            prevState?: string;
         }
         interface AuthorizationEvent extends vimService.vim.Event {
         }
         interface PermissionEvent extends vimService.vim.AuthorizationEvent {
            entity: vimService.vim.ManagedEntityEventArgument;
            principal: string;
            group: boolean;
         }
         interface PermissionAddedEvent extends vimService.vim.PermissionEvent {
            role: vimService.vim.RoleEventArgument;
            propagate: boolean;
         }
         interface PermissionUpdatedEvent extends vimService.vim.PermissionEvent {
            role: vimService.vim.RoleEventArgument;
            propagate: boolean;
            prevRole?: vimService.vim.RoleEventArgument;
            prevPropagate?: boolean;
         }
         interface PermissionRemovedEvent extends vimService.vim.PermissionEvent {
         }
         interface RoleEvent extends vimService.vim.AuthorizationEvent {
            role: vimService.vim.RoleEventArgument;
         }
         interface RoleAddedEvent extends vimService.vim.RoleEvent {
            privilegeList?: Array<string>;
         }
         interface RoleUpdatedEvent extends vimService.vim.RoleEvent {
            privilegeList?: Array<string>;
            prevRoleName?: string;
            privilegesAdded?: Array<string>;
            privilegesRemoved?: Array<string>;
         }
         interface RoleRemovedEvent extends vimService.vim.RoleEvent {
         }
         interface DatastoreEvent extends vimService.vim.Event {
            datastore?: vimService.vim.DatastoreEventArgument;
         }
         interface DatastoreDestroyedEvent extends vimService.vim.DatastoreEvent {
         }
         interface DatastoreRenamedEvent extends vimService.vim.DatastoreEvent {
            oldName: string;
            newName: string;
         }
         interface DatastoreCapacityIncreasedEvent extends vimService.vim.DatastoreEvent {
            oldCapacity: number;
            newCapacity: number;
         }
         interface DatastoreDuplicatedEvent extends vimService.vim.DatastoreEvent {
         }
         interface DatastoreFileEvent extends vimService.vim.DatastoreEvent {
            targetFile: string;
            sourceOfOperation?: string;
            succeeded?: boolean;
         }
         interface DatastoreFileCopiedEvent extends vimService.vim.DatastoreFileEvent {
            sourceDatastore: vimService.vim.DatastoreEventArgument;
            sourceFile: string;
         }
         interface DatastoreFileMovedEvent extends vimService.vim.DatastoreFileEvent {
            sourceDatastore: vimService.vim.DatastoreEventArgument;
            sourceFile: string;
         }
         interface DatastoreFileDeletedEvent extends vimService.vim.DatastoreFileEvent {
         }
         interface NonVIWorkloadDetectedOnDatastoreEvent extends vimService.vim.DatastoreEvent {
         }
         interface DatastoreIORMReconfiguredEvent extends vimService.vim.DatastoreEvent {
         }
         interface TaskEvent extends vimService.vim.Event {
            info: vimService.vim.TaskInfo;
         }
         interface TaskTimeoutEvent extends vimService.vim.TaskEvent {
         }
         interface LicenseEvent extends vimService.vim.Event {
         }
         interface ServerLicenseExpiredEvent extends vimService.vim.LicenseEvent {
            product: string;
         }
         interface HostLicenseExpiredEvent extends vimService.vim.LicenseEvent {
         }
         interface VMotionLicenseExpiredEvent extends vimService.vim.LicenseEvent {
         }
         interface NoLicenseEvent extends vimService.vim.LicenseEvent {
            feature: vimService.vim.LicenseFeatureInfo;
         }
         interface LicenseServerUnavailableEvent extends vimService.vim.LicenseEvent {
            licenseServer: string;
         }
         interface LicenseServerAvailableEvent extends vimService.vim.LicenseEvent {
            licenseServer: string;
         }
         interface LicenseExpiredEvent extends vimService.vim.Event {
            feature: vimService.vim.LicenseFeatureInfo;
         }
         interface InvalidEditionEvent extends vimService.vim.LicenseEvent {
            feature: string;
         }
         interface HostInventoryFullEvent extends vimService.vim.LicenseEvent {
            capacity: number;
         }
         interface LicenseRestrictedEvent extends vimService.vim.LicenseEvent {
         }
         interface IncorrectHostInformationEvent extends vimService.vim.LicenseEvent {
         }
         interface UnlicensedVirtualMachinesEvent extends vimService.vim.LicenseEvent {
            unlicensed: number;
            available: number;
         }
         interface UnlicensedVirtualMachinesFoundEvent extends vimService.vim.LicenseEvent {
            available: number;
         }
         interface AllVirtualMachinesLicensedEvent extends vimService.vim.LicenseEvent {
         }
         interface LicenseNonComplianceEvent extends vimService.vim.LicenseEvent {
            url: string;
         }
         interface MigrationEvent extends vimService.vim.VmEvent {
            fault: vimService.vim.LocalizedMethodFault;
         }
         interface MigrationWarningEvent extends vimService.vim.MigrationEvent {
         }
         interface MigrationErrorEvent extends vimService.vim.MigrationEvent {
         }
         interface MigrationHostWarningEvent extends vimService.vim.MigrationEvent {
            dstHost: vimService.vim.HostEventArgument;
         }
         interface MigrationHostErrorEvent extends vimService.vim.MigrationEvent {
            dstHost: vimService.vim.HostEventArgument;
         }
         interface MigrationResourceWarningEvent extends vimService.vim.MigrationEvent {
            dstPool: vimService.vim.ResourcePoolEventArgument;
            dstHost: vimService.vim.HostEventArgument;
         }
         interface MigrationResourceErrorEvent extends vimService.vim.MigrationEvent {
            dstPool: vimService.vim.ResourcePoolEventArgument;
            dstHost: vimService.vim.HostEventArgument;
         }
         interface ClusterEvent extends vimService.vim.Event {
         }
         interface DasEnabledEvent extends vimService.vim.ClusterEvent {
         }
         interface DasDisabledEvent extends vimService.vim.ClusterEvent {
         }
         interface DasAdmissionControlDisabledEvent extends vimService.vim.ClusterEvent {
         }
         interface DasAdmissionControlEnabledEvent extends vimService.vim.ClusterEvent {
         }
         interface DasHostFailedEvent extends vimService.vim.ClusterEvent {
            failedHost: vimService.vim.HostEventArgument;
         }
         interface DasHostIsolatedEvent extends vimService.vim.ClusterEvent {
            isolatedHost: vimService.vim.HostEventArgument;
         }
         interface DasClusterIsolatedEvent extends vimService.vim.ClusterEvent {
         }
         interface DasAgentUnavailableEvent extends vimService.vim.ClusterEvent {
         }
         interface DasAgentFoundEvent extends vimService.vim.ClusterEvent {
         }
         interface InsufficientFailoverResourcesEvent extends vimService.vim.ClusterEvent {
         }
         interface FailoverLevelRestored extends vimService.vim.ClusterEvent {
         }
         interface ClusterOvercommittedEvent extends vimService.vim.ClusterEvent {
         }
         interface HostOvercommittedEvent extends vimService.vim.ClusterOvercommittedEvent {
         }
         interface ClusterStatusChangedEvent extends vimService.vim.ClusterEvent {
            oldStatus: string;
            newStatus: string;
         }
         interface HostStatusChangedEvent extends vimService.vim.ClusterStatusChangedEvent {
         }
         interface ClusterCreatedEvent extends vimService.vim.ClusterEvent {
            parent: vimService.vim.FolderEventArgument;
         }
         interface ClusterDestroyedEvent extends vimService.vim.ClusterEvent {
         }
         interface DrsEnabledEvent extends vimService.vim.ClusterEvent {
            behavior: string;
         }
         interface DrsDisabledEvent extends vimService.vim.ClusterEvent {
         }
         interface ClusterReconfiguredEvent extends vimService.vim.ClusterEvent {
            configChanges?: vimService.vim.ChangesInfoEventArgument;
         }
         interface HostMonitoringStateChangedEvent extends vimService.vim.ClusterEvent {
            state: string;
            prevState?: string;
         }
         interface VmHealthMonitoringStateChangedEvent extends vimService.vim.ClusterEvent {
            state: string;
            prevState?: string;
         }
         interface ResourcePoolEvent extends vimService.vim.Event {
            resourcePool: vimService.vim.ResourcePoolEventArgument;
         }
         interface ResourcePoolCreatedEvent extends vimService.vim.ResourcePoolEvent {
            parent: vimService.vim.ResourcePoolEventArgument;
         }
         interface ResourcePoolDestroyedEvent extends vimService.vim.ResourcePoolEvent {
         }
         interface ResourcePoolMovedEvent extends vimService.vim.ResourcePoolEvent {
            oldParent: vimService.vim.ResourcePoolEventArgument;
            newParent: vimService.vim.ResourcePoolEventArgument;
         }
         interface ResourcePoolReconfiguredEvent extends vimService.vim.ResourcePoolEvent {
            configChanges?: vimService.vim.ChangesInfoEventArgument;
         }
         interface ResourceViolatedEvent extends vimService.vim.ResourcePoolEvent {
         }
         interface VmResourcePoolMovedEvent extends vimService.vim.VmEvent {
            oldParent: vimService.vim.ResourcePoolEventArgument;
            newParent: vimService.vim.ResourcePoolEventArgument;
         }
         interface TemplateUpgradeEvent extends vimService.vim.Event {
            legacyTemplate: string;
         }
         interface TemplateBeingUpgradedEvent extends vimService.vim.TemplateUpgradeEvent {
         }
         interface TemplateUpgradeFailedEvent extends vimService.vim.TemplateUpgradeEvent {
            reason: vimService.vim.LocalizedMethodFault;
         }
         interface TemplateUpgradedEvent extends vimService.vim.TemplateUpgradeEvent {
         }
         interface CustomizationEvent extends vimService.vim.VmEvent {
            logLocation?: string;
         }
         interface CustomizationStartedEvent extends vimService.vim.CustomizationEvent {
         }
         interface CustomizationSucceeded extends vimService.vim.CustomizationEvent {
         }
         interface CustomizationFailed extends vimService.vim.CustomizationEvent {
         }
         interface CustomizationUnknownFailure extends vimService.vim.CustomizationFailed {
         }
         interface CustomizationSysprepFailed extends vimService.vim.CustomizationFailed {
            sysprepVersion: string;
            systemVersion: string;
         }
         interface CustomizationLinuxIdentityFailed extends vimService.vim.CustomizationFailed {
         }
         interface CustomizationNetworkSetupFailed extends vimService.vim.CustomizationFailed {
         }
         interface LockerMisconfiguredEvent extends vimService.vim.Event {
            datastore: vimService.vim.DatastoreEventArgument;
         }
         interface LockerReconfiguredEvent extends vimService.vim.Event {
            oldDatastore?: vimService.vim.DatastoreEventArgument;
            newDatastore?: vimService.vim.DatastoreEventArgument;
         }
         interface NoDatastoresConfiguredEvent extends vimService.vim.HostEvent {
         }
         interface AdminPasswordNotChangedEvent extends vimService.vim.HostEvent {
         }
         interface HostInAuditModeEvent extends vimService.vim.HostEvent {
         }
         interface LocalTSMEnabledEvent extends vimService.vim.HostEvent {
         }
         interface RemoteTSMEnabledEvent extends vimService.vim.HostEvent {
         }
         interface VimAccountPasswordChangedEvent extends vimService.vim.HostEvent {
         }
         interface IScsiBootFailureEvent extends vimService.vim.HostEvent {
         }
         interface DvsHealthStatusChangeEvent extends vimService.vim.HostEvent {
            switchUuid: string;
            healthResult?: vimService.vim.HostMemberHealthCheckResult;
         }
         interface NetworkRollbackEvent extends vimService.vim.Event {
            methodName: string;
            transactionId: string;
         }
         interface UplinkPortVlanTrunkedEvent extends vimService.vim.DvsHealthStatusChangeEvent {
         }
         interface UplinkPortVlanUntrunkedEvent extends vimService.vim.DvsHealthStatusChangeEvent {
         }
         interface MtuMatchEvent extends vimService.vim.DvsHealthStatusChangeEvent {
         }
         interface MtuMismatchEvent extends vimService.vim.DvsHealthStatusChangeEvent {
         }
         interface UplinkPortMtuNotSupportEvent extends vimService.vim.DvsHealthStatusChangeEvent {
         }
         interface UplinkPortMtuSupportEvent extends vimService.vim.DvsHealthStatusChangeEvent {
         }
         interface TeamingMatchEvent extends vimService.vim.DvsHealthStatusChangeEvent {
         }
         interface TeamingMisMatchEvent extends vimService.vim.DvsHealthStatusChangeEvent {
         }
         enum DvsEventPortBlockState {
            "unset",
            "blocked",
            "unblocked",
            "unknown",
         }
         interface DvsEvent extends vimService.vim.Event {
         }
         interface DvsCreatedEvent extends vimService.vim.DvsEvent {
            parent: vimService.vim.FolderEventArgument;
         }
         interface DvsRenamedEvent extends vimService.vim.DvsEvent {
            oldName: string;
            newName: string;
         }
         interface DvsReconfiguredEvent extends vimService.vim.DvsEvent {
            configSpec: vimService.vim.DVSConfigSpec;
            configChanges?: vimService.vim.ChangesInfoEventArgument;
         }
         interface DvsUpgradeAvailableEvent extends vimService.vim.DvsEvent {
            productInfo: vimService.vim.DistributedVirtualSwitchProductSpec;
         }
         interface DvsUpgradeInProgressEvent extends vimService.vim.DvsEvent {
            productInfo: vimService.vim.DistributedVirtualSwitchProductSpec;
         }
         interface DvsUpgradeRejectedEvent extends vimService.vim.DvsEvent {
            productInfo: vimService.vim.DistributedVirtualSwitchProductSpec;
         }
         interface DvsUpgradedEvent extends vimService.vim.DvsEvent {
            productInfo: vimService.vim.DistributedVirtualSwitchProductSpec;
         }
         interface DvsHostJoinedEvent extends vimService.vim.DvsEvent {
            hostJoined: vimService.vim.HostEventArgument;
         }
         interface DvsHostLeftEvent extends vimService.vim.DvsEvent {
            hostLeft: vimService.vim.HostEventArgument;
         }
         interface DvsOutOfSyncHostArgument extends vimService.vim.DynamicData {
            outOfSyncHost: vimService.vim.HostEventArgument;
            configParamters: Array<string>;
         }
         interface ArrayOfDvsOutOfSyncHostArgument {
            DvsOutOfSyncHostArgument?: Array<vimService.vim.DvsOutOfSyncHostArgument>;
         }
         interface OutOfSyncDvsHost extends vimService.vim.DvsEvent {
            hostOutOfSync: Array<vimService.vim.DvsOutOfSyncHostArgument>;
         }
         interface DvsHostWentOutOfSyncEvent extends vimService.vim.DvsEvent {
            hostOutOfSync: vimService.vim.DvsOutOfSyncHostArgument;
         }
         interface DvsHostBackInSyncEvent extends vimService.vim.DvsEvent {
            hostBackInSync: vimService.vim.HostEventArgument;
         }
         interface DvsHostStatusUpdated extends vimService.vim.DvsEvent {
            hostMember: vimService.vim.HostEventArgument;
            oldStatus?: string;
            newStatus?: string;
            oldStatusDetail?: string;
            newStatusDetail?: string;
         }
         interface DvsPortCreatedEvent extends vimService.vim.DvsEvent {
            portKey: Array<string>;
         }
         interface DvsPortReconfiguredEvent extends vimService.vim.DvsEvent {
            portKey: Array<string>;
            configChanges?: Array<vimService.vim.ChangesInfoEventArgument>;
         }
         interface DvsPortDeletedEvent extends vimService.vim.DvsEvent {
            portKey: Array<string>;
         }
         interface DvsPortConnectedEvent extends vimService.vim.DvsEvent {
            portKey: string;
            connectee?: vimService.vim.DistributedVirtualSwitchPortConnectee;
         }
         interface DvsPortDisconnectedEvent extends vimService.vim.DvsEvent {
            portKey: string;
            connectee?: vimService.vim.DistributedVirtualSwitchPortConnectee;
         }
         interface DvsPortVendorSpecificStateChangeEvent extends vimService.vim.DvsEvent {
            portKey: string;
         }
         interface DvsPortRuntimeChangeEvent extends vimService.vim.DvsEvent {
            portKey: string;
            runtimeInfo: vimService.vim.DVPortStatus;
         }
         interface DvsPortLinkUpEvent extends vimService.vim.DvsEvent {
            portKey: string;
            runtimeInfo?: vimService.vim.DVPortStatus;
         }
         interface DvsPortLinkDownEvent extends vimService.vim.DvsEvent {
            portKey: string;
            runtimeInfo?: vimService.vim.DVPortStatus;
         }
         interface DvsPortJoinPortgroupEvent extends vimService.vim.DvsEvent {
            portKey: string;
            portgroupKey: string;
            portgroupName: string;
         }
         interface DvsPortLeavePortgroupEvent extends vimService.vim.DvsEvent {
            portKey: string;
            portgroupKey: string;
            portgroupName: string;
         }
         interface DvsPortBlockedEvent extends vimService.vim.DvsEvent {
            portKey: string;
            statusDetail?: string;
            runtimeInfo?: vimService.vim.DVPortStatus;
            prevBlockState?: string;
         }
         interface DvsPortUnblockedEvent extends vimService.vim.DvsEvent {
            portKey: string;
            runtimeInfo?: vimService.vim.DVPortStatus;
            prevBlockState?: string;
         }
         interface DvsPortEnteredPassthruEvent extends vimService.vim.DvsEvent {
            portKey: string;
            runtimeInfo?: vimService.vim.DVPortStatus;
         }
         interface DvsPortExitedPassthruEvent extends vimService.vim.DvsEvent {
            portKey: string;
            runtimeInfo?: vimService.vim.DVPortStatus;
         }
         interface DvsDestroyedEvent extends vimService.vim.DvsEvent {
         }
         interface DvsMergedEvent extends vimService.vim.DvsEvent {
            sourceDvs: vimService.vim.DvsEventArgument;
            destinationDvs: vimService.vim.DvsEventArgument;
         }
         interface HostLocalPortCreatedEvent extends vimService.vim.DvsEvent {
            hostLocalPort: vimService.vim.DVSHostLocalPortInfo;
         }
         interface RollbackEvent extends vimService.vim.DvsEvent {
            hostName: string;
            methodName?: string;
         }
         interface RecoveryEvent extends vimService.vim.DvsEvent {
            hostName: string;
            portKey: string;
            dvsUuid?: string;
            vnic?: string;
         }
         interface DvsImportEvent extends vimService.vim.DvsEvent {
            importType: string;
         }
         interface DvsRestoreEvent extends vimService.vim.DvsEvent {
         }
         interface VmVnicPoolReservationViolationRaiseEvent extends vimService.vim.DvsEvent {
            vmVnicResourcePoolKey: string;
            vmVnicResourcePoolName?: string;
         }
         interface VmVnicPoolReservationViolationClearEvent extends vimService.vim.DvsEvent {
            vmVnicResourcePoolKey: string;
            vmVnicResourcePoolName?: string;
         }
         interface DVPortgroupEvent extends vimService.vim.Event {
         }
         interface DVPortgroupCreatedEvent extends vimService.vim.DVPortgroupEvent {
         }
         interface DVPortgroupRenamedEvent extends vimService.vim.DVPortgroupEvent {
            oldName: string;
            newName: string;
         }
         interface DVPortgroupReconfiguredEvent extends vimService.vim.DVPortgroupEvent {
            configSpec: vimService.vim.DVPortgroupConfigSpec;
            configChanges?: vimService.vim.ChangesInfoEventArgument;
         }
         interface DVPortgroupDestroyedEvent extends vimService.vim.DVPortgroupEvent {
         }
         interface DvpgImportEvent extends vimService.vim.DVPortgroupEvent {
            importType: string;
         }
         interface DvpgRestoreEvent extends vimService.vim.DVPortgroupEvent {
         }
         interface DrsInvocationFailedEvent extends vimService.vim.ClusterEvent {
         }
         interface DrsRecoveredFromFailureEvent extends vimService.vim.ClusterEvent {
         }
         interface VmReloadFromPathEvent extends vimService.vim.VmEvent {
            configPath: string;
         }
         interface VmReloadFromPathFailedEvent extends vimService.vim.VmEvent {
            configPath: string;
         }
         interface VmRequirementsExceedCurrentEVCModeEvent extends vimService.vim.VmEvent {
         }
         interface EventArgument extends vimService.vim.DynamicData {
         }
         interface RoleEventArgument extends vimService.vim.EventArgument {
            roleId: number;
            name: string;
         }
         interface EntityEventArgument extends vimService.vim.EventArgument {
            name: string;
         }
         interface ManagedEntityEventArgument extends vimService.vim.EntityEventArgument {
            entity: vimService.vim.ManagedObjectReference;
         }
         interface FolderEventArgument extends vimService.vim.EntityEventArgument {
            folder: vimService.vim.ManagedObjectReference;
         }
         interface DatacenterEventArgument extends vimService.vim.EntityEventArgument {
            datacenter: vimService.vim.ManagedObjectReference;
         }
         interface ComputeResourceEventArgument extends vimService.vim.EntityEventArgument {
            computeResource: vimService.vim.ManagedObjectReference;
         }
         interface ResourcePoolEventArgument extends vimService.vim.EntityEventArgument {
            resourcePool: vimService.vim.ManagedObjectReference;
         }
         interface HostEventArgument extends vimService.vim.EntityEventArgument {
            host: vimService.vim.ManagedObjectReference;
         }
         interface ArrayOfHostEventArgument {
            HostEventArgument?: Array<vimService.vim.HostEventArgument>;
         }
         interface VmEventArgument extends vimService.vim.EntityEventArgument {
            vm: vimService.vim.ManagedObjectReference;
         }
         interface ArrayOfVmEventArgument {
            VmEventArgument?: Array<vimService.vim.VmEventArgument>;
         }
         interface DatastoreEventArgument extends vimService.vim.EntityEventArgument {
            datastore: vimService.vim.ManagedObjectReference;
         }
         interface NetworkEventArgument extends vimService.vim.EntityEventArgument {
            network: vimService.vim.ManagedObjectReference;
         }
         interface AlarmEventArgument extends vimService.vim.EntityEventArgument {
            alarm: vimService.vim.ManagedObjectReference;
         }
         interface ScheduledTaskEventArgument extends vimService.vim.EntityEventArgument {
            scheduledTask: vimService.vim.ManagedObjectReference;
         }
         interface ProfileEventArgument extends vimService.vim.EventArgument {
            profile: vimService.vim.ManagedObjectReference;
            name: string;
         }
         interface DvsEventArgument extends vimService.vim.EntityEventArgument {
            dvs: vimService.vim.ManagedObjectReference;
         }
         interface ChangesInfoEventArgument extends vimService.vim.DynamicData {
            modified?: string;
            added?: string;
            deleted?: string;
         }
         interface ArrayOfChangesInfoEventArgument {
            ChangesInfoEventArgument?: Array<vimService.vim.ChangesInfoEventArgument>;
         }
         enum EventCategory {
            "info",
            "warning",
            "error",
            "user",
         }
         interface EventArgDesc extends vimService.vim.DynamicData {
            name: string;
            type: string;
            description?: vimService.vim.ElementDescription;
         }
         interface ArrayOfEventArgDesc {
            EventArgDesc?: Array<vimService.vim.EventArgDesc>;
         }
         interface EventDescriptionEventDetail extends vimService.vim.DynamicData {
            key: string;
            description?: string;
            category: string;
            formatOnDatacenter: string;
            formatOnComputeResource: string;
            formatOnHost: string;
            formatOnVm: string;
            fullFormat: string;
            longDescription?: string;
         }
         interface ArrayOfEventDescriptionEventDetail {
            EventDescriptionEventDetail?: Array<vimService.vim.EventDescriptionEventDetail>;
         }
         interface EventDescription extends vimService.vim.DynamicData {
            category: Array<vimService.vim.ElementDescription>;
            eventInfo: Array<vimService.vim.EventDescriptionEventDetail>;
            enumeratedTypes?: Array<vimService.vim.EnumDescription>;
         }
         interface EventEx extends vimService.vim.Event {
            eventTypeId: string;
            severity?: string;
            message?: string;
            arguments?: Array<vimService.vim.KeyAnyValue>;
            objectId?: string;
            objectType?: string;
            objectName?: string;
            fault?: vimService.vim.LocalizedMethodFault;
         }
         enum EventFilterSpecRecursionOption {
            "self",
            "children",
            "all",
         }
         interface EventFilterSpecByEntity extends vimService.vim.DynamicData {
            entity: vimService.vim.ManagedObjectReference;
            recursion: vimService.vim.EventFilterSpecRecursionOption;
         }
         interface EventFilterSpecByTime extends vimService.vim.DynamicData {
            beginTime?: Date;
            endTime?: Date;
         }
         interface EventFilterSpecByUsername extends vimService.vim.DynamicData {
            systemUser: boolean;
            userList?: Array<string>;
         }
         interface EventFilterSpec extends vimService.vim.DynamicData {
            entity?: vimService.vim.EventFilterSpecByEntity;
            time?: vimService.vim.EventFilterSpecByTime;
            userName?: vimService.vim.EventFilterSpecByUsername;
            eventChainId?: number;
            alarm?: vimService.vim.ManagedObjectReference;
            scheduledTask?: vimService.vim.ManagedObjectReference;
            disableFullMessage?: boolean;
            category?: Array<string>;
            type?: Array<string>;
            tag?: Array<string>;
            eventTypeId?: Array<string>;
            maxCount?: number;
         }
         interface ExtExtendedProductInfo extends vimService.vim.DynamicData {
            companyUrl?: string;
            productUrl?: string;
            managementUrl?: string;
            self?: vimService.vim.ManagedObjectReference;
         }
         interface ManagedByInfo extends vimService.vim.DynamicData {
            extensionKey: string;
            type: string;
         }
         interface ExtManagedEntityInfo extends vimService.vim.DynamicData {
            type: string;
            smallIconUrl?: string;
            iconUrl?: string;
            description?: string;
         }
         interface ArrayOfExtManagedEntityInfo {
            ExtManagedEntityInfo?: Array<vimService.vim.ExtManagedEntityInfo>;
         }
         interface ExtSolutionManagerInfoTabInfo extends vimService.vim.DynamicData {
            label: string;
            url: string;
         }
         interface ArrayOfExtSolutionManagerInfoTabInfo {
            ExtSolutionManagerInfoTabInfo?: Array<vimService.vim.ExtSolutionManagerInfoTabInfo>;
         }
         interface ExtSolutionManagerInfo extends vimService.vim.DynamicData {
            tab?: Array<vimService.vim.ExtSolutionManagerInfoTabInfo>;
            smallIconUrl?: string;
         }
         interface ActiveDirectoryFault extends vimService.vim.VimFault {
            errorCode?: number;
         }
         interface ActiveVMsBlockingEVC extends vimService.vim.EVCConfigFault {
            evcMode?: string;
            host?: Array<vimService.vim.ManagedObjectReference>;
            hostName?: Array<string>;
         }
         interface AdminDisabled extends vimService.vim.HostConfigFault {
         }
         interface AdminNotDisabled extends vimService.vim.HostConfigFault {
         }
         enum AffinityType {
            "memory",
            "cpu",
         }
         interface AffinityConfigured extends vimService.vim.MigrationFault {
            configuredAffinity: Array<string>;
         }
         enum AgentInstallFailedReason {
            "NotEnoughSpaceOnDevice",
            "PrepareToUpgradeFailed",
            "AgentNotRunning",
            "AgentNotReachable",
            "InstallTimedout",
            "SignatureVerificationFailed",
            "AgentUploadFailed",
            "AgentUploadTimedout",
            "UnknownInstallerError",
         }
         interface AgentInstallFailed extends vimService.vim.HostConnectFault {
            reason?: string;
            statusCode?: number;
            installerOutput?: string;
         }
         interface AlreadyBeingManaged extends vimService.vim.HostConnectFault {
            ipAddress: string;
         }
         interface AlreadyConnected extends vimService.vim.HostConnectFault {
            name: string;
         }
         interface AlreadyExists extends vimService.vim.VimFault {
            name?: string;
         }
         interface AlreadyUpgraded extends vimService.vim.VimFault {
         }
         interface AnswerFileUpdateFailure extends vimService.vim.DynamicData {
            userInputPath: vimService.vim.ProfilePropertyPath;
            errMsg: vimService.vim.LocalizableMessage;
         }
         interface ArrayOfAnswerFileUpdateFailure {
            AnswerFileUpdateFailure?: Array<vimService.vim.AnswerFileUpdateFailure>;
         }
         interface AnswerFileUpdateFailed extends vimService.vim.VimFault {
            failure: Array<vimService.vim.AnswerFileUpdateFailure>;
         }
         interface ApplicationQuiesceFault extends vimService.vim.SnapshotFault {
         }
         interface AuthMinimumAdminPermission extends vimService.vim.VimFault {
         }
         interface BackupBlobReadFailure extends vimService.vim.DvsFault {
            entityName: string;
            entityType: string;
            fault: vimService.vim.LocalizedMethodFault;
         }
         interface BackupBlobWriteFailure extends vimService.vim.DvsFault {
            entityName: string;
            entityType: string;
            fault: vimService.vim.LocalizedMethodFault;
         }
         interface BlockedByFirewall extends vimService.vim.HostConfigFault {
         }
         interface CAMServerRefusedConnection extends vimService.vim.InvalidCAMServer {
         }
         interface CannotAccessFile extends vimService.vim.FileFault {
         }
         interface CannotAccessLocalSource extends vimService.vim.VimFault {
         }
         interface CannotAccessNetwork extends vimService.vim.CannotAccessVmDevice {
            network?: vimService.vim.ManagedObjectReference;
         }
         interface CannotAccessVmComponent extends vimService.vim.VmConfigFault {
         }
         interface CannotAccessVmConfig extends vimService.vim.CannotAccessVmComponent {
            reason: vimService.vim.LocalizedMethodFault;
         }
         interface CannotAccessVmDevice extends vimService.vim.CannotAccessVmComponent {
            device: string;
            backing: string;
            connected: boolean;
         }
         interface CannotAccessVmDisk extends vimService.vim.CannotAccessVmDevice {
            fault: vimService.vim.LocalizedMethodFault;
         }
         interface CannotAddHostWithFTVmAsStandalone extends vimService.vim.HostConnectFault {
         }
         interface CannotAddHostWithFTVmToDifferentCluster extends vimService.vim.HostConnectFault {
         }
         interface CannotAddHostWithFTVmToNonHACluster extends vimService.vim.HostConnectFault {
         }
         interface CannotChangeDrsBehaviorForFtSecondary extends vimService.vim.VmFaultToleranceIssue {
            vm: vimService.vim.ManagedObjectReference;
            vmName: string;
         }
         interface CannotChangeHaSettingsForFtSecondary extends vimService.vim.VmFaultToleranceIssue {
            vm: vimService.vim.ManagedObjectReference;
            vmName: string;
         }
         interface CannotChangeVsanClusterUuid extends vimService.vim.VsanFault {
         }
         interface CannotChangeVsanNodeUuid extends vimService.vim.VsanFault {
         }
         interface CannotComputeFTCompatibleHosts extends vimService.vim.VmFaultToleranceIssue {
            vm: vimService.vim.ManagedObjectReference;
            vmName: string;
         }
         interface CannotCreateFile extends vimService.vim.FileFault {
         }
         interface CannotDecryptPasswords extends vimService.vim.CustomizationFault {
         }
         interface CannotDeleteFile extends vimService.vim.FileFault {
         }
         interface CannotDisableDrsOnClustersWithVApps extends vimService.vim.RuntimeFault {
         }
         interface CannotDisableSnapshot extends vimService.vim.VmConfigFault {
         }
         interface CannotDisconnectHostWithFaultToleranceVm extends vimService.vim.VimFault {
            hostName: string;
         }
         enum CannotEnableVmcpForClusterReason {
            "APDTimeoutDisabled",
            "IncompatibleHostVersion",
         }
         interface CannotEnableVmcpForCluster extends vimService.vim.VimFault {
            host?: vimService.vim.ManagedObjectReference;
            hostName?: string;
            reason?: string;
         }
         interface CannotModifyConfigCpuRequirements extends vimService.vim.MigrationFault {
         }
         enum CannotMoveFaultToleranceVmMoveType {
            "resourcePool",
            "cluster",
         }
         interface CannotMoveFaultToleranceVm extends vimService.vim.VimFault {
            moveType: string;
            vmName: string;
         }
         interface CannotMoveHostWithFaultToleranceVm extends vimService.vim.VimFault {
         }
         interface CannotMoveVmWithDeltaDisk extends vimService.vim.MigrationFault {
            device: string;
         }
         interface CannotMoveVmWithNativeDeltaDisk extends vimService.vim.MigrationFault {
         }
         interface CannotMoveVsanEnabledHost extends vimService.vim.VsanFault {
         }
         interface CannotPlaceWithoutPrerequisiteMoves extends vimService.vim.VimFault {
         }
         enum CannotPowerOffVmInClusterOperation {
            "suspend",
            "powerOff",
            "guestShutdown",
            "guestSuspend",
         }
         interface CannotPowerOffVmInCluster extends vimService.vim.InvalidState {
            operation: string;
            vm: vimService.vim.ManagedObjectReference;
            vmName: string;
         }
         interface CannotReconfigureVsanWhenHaEnabled extends vimService.vim.VsanFault {
         }
         enum CannotUseNetworkReason {
            "NetworkReservationNotSupported",
            "MismatchedNetworkPolicies",
            "MismatchedDvsVersionOrVendor",
            "VMotionToUnsupportedNetworkType",
         }
         interface CannotUseNetwork extends vimService.vim.VmConfigFault {
            device: string;
            backing: string;
            connected: boolean;
            reason: string;
            network?: vimService.vim.ManagedObjectReference;
         }
         interface ClockSkew extends vimService.vim.HostConfigFault {
         }
         interface CloneFromSnapshotNotSupported extends vimService.vim.MigrationFault {
         }
         interface CollectorAddressUnset extends vimService.vim.DvsFault {
         }
         interface ConcurrentAccess extends vimService.vim.VimFault {
         }
         interface ConflictingConfigurationConfig extends vimService.vim.DynamicData {
            entity?: vimService.vim.ManagedObjectReference;
            propertyPath: string;
         }
         interface ArrayOfConflictingConfigurationConfig {
            ConflictingConfigurationConfig?: Array<vimService.vim.ConflictingConfigurationConfig>;
         }
         interface ConflictingConfiguration extends vimService.vim.DvsFault {
            configInConflict: Array<vimService.vim.ConflictingConfigurationConfig>;
         }
         interface ConflictingDatastoreFound extends vimService.vim.RuntimeFault {
            name: string;
            url: string;
         }
         interface ConnectedIso extends vimService.vim.OvfExport {
            cdrom: vimService.vim.VirtualCdrom;
            filename: string;
         }
         interface CpuCompatibilityUnknown extends vimService.vim.CpuIncompatible {
         }
         interface CpuHotPlugNotSupported extends vimService.vim.VmConfigFault {
         }
         interface CpuIncompatible extends vimService.vim.VirtualHardwareCompatibilityIssue {
            level: number;
            registerName: string;
            registerBits?: string;
            desiredBits?: string;
            host?: vimService.vim.ManagedObjectReference;
         }
         interface CpuIncompatible1ECX extends vimService.vim.CpuIncompatible {
            sse3: boolean;
            pclmulqdq?: boolean;
            ssse3: boolean;
            sse41: boolean;
            sse42: boolean;
            aes?: boolean;
            other: boolean;
            otherOnly: boolean;
         }
         interface CpuIncompatible81EDX extends vimService.vim.CpuIncompatible {
            nx: boolean;
            ffxsr: boolean;
            rdtscp: boolean;
            lm: boolean;
            other: boolean;
            otherOnly: boolean;
         }
         interface CustomizationFault extends vimService.vim.VimFault {
         }
         interface CustomizationPending extends vimService.vim.CustomizationFault {
         }
         interface DVPortNotSupported extends vimService.vim.DeviceBackingNotSupported {
         }
         enum DasConfigFaultDasConfigFaultReason {
            "HostNetworkMisconfiguration",
            "HostMisconfiguration",
            "InsufficientPrivileges",
            "NoPrimaryAgentAvailable",
            "Other",
            "NoDatastoresConfigured",
            "CreateConfigVvolFailed",
            "VSanNotSupportedOnHost",
            "DasNetworkMisconfiguration",
         }
         interface DasConfigFault extends vimService.vim.VimFault {
            reason?: string;
            output?: string;
            event?: Array<vimService.vim.Event>;
         }
         interface DatabaseError extends vimService.vim.RuntimeFault {
         }
         interface DatacenterMismatchArgument extends vimService.vim.DynamicData {
            entity: vimService.vim.ManagedObjectReference;
            inputDatacenter?: vimService.vim.ManagedObjectReference;
         }
         interface ArrayOfDatacenterMismatchArgument {
            DatacenterMismatchArgument?: Array<vimService.vim.DatacenterMismatchArgument>;
         }
         interface DatacenterMismatch extends vimService.vim.MigrationFault {
            invalidArgument: Array<vimService.vim.DatacenterMismatchArgument>;
            expectedDatacenter: vimService.vim.ManagedObjectReference;
         }
         interface DatastoreNotWritableOnHost extends vimService.vim.InvalidDatastore {
            host: vimService.vim.ManagedObjectReference;
         }
         interface DeltaDiskFormatNotSupported extends vimService.vim.VmConfigFault {
            datastore?: Array<vimService.vim.ManagedObjectReference>;
            deltaDiskFormat: string;
         }
         interface DestinationSwitchFull extends vimService.vim.CannotAccessNetwork {
         }
         interface DestinationVsanDisabled extends vimService.vim.CannotMoveVsanEnabledHost {
            destinationCluster: string;
         }
         interface DeviceBackingNotSupported extends vimService.vim.DeviceNotSupported {
            backing: string;
         }
         interface DeviceControllerNotSupported extends vimService.vim.DeviceNotSupported {
            controller: string;
         }
         interface DeviceHotPlugNotSupported extends vimService.vim.InvalidDeviceSpec {
         }
         interface DeviceNotFound extends vimService.vim.InvalidDeviceSpec {
         }
         enum DeviceNotSupportedReason {
            "host",
            "guest",
         }
         interface DeviceNotSupported extends vimService.vim.VirtualHardwareCompatibilityIssue {
            device: string;
            reason?: string;
         }
         interface DeviceUnsupportedForVmPlatform extends vimService.vim.InvalidDeviceSpec {
         }
         interface DeviceUnsupportedForVmVersion extends vimService.vim.InvalidDeviceSpec {
            currentVersion: string;
            expectedVersion: string;
         }
         interface DigestNotSupported extends vimService.vim.DeviceNotSupported {
         }
         interface DirectoryNotEmpty extends vimService.vim.FileFault {
         }
         interface DisableAdminNotSupported extends vimService.vim.HostConfigFault {
         }
         enum DisallowedChangeByServiceDisallowedChange {
            "hotExtendDisk",
         }
         interface DisallowedChangeByService extends vimService.vim.RuntimeFault {
            serviceName: string;
            disallowedChange?: string;
         }
         interface DisallowedDiskModeChange extends vimService.vim.InvalidDeviceSpec {
         }
         interface DisallowedMigrationDeviceAttached extends vimService.vim.MigrationFault {
            fault: vimService.vim.LocalizedMethodFault;
         }
         interface DisallowedOperationOnFailoverHost extends vimService.vim.RuntimeFault {
            host: vimService.vim.ManagedObjectReference;
            hostname: string;
         }
         interface DisconnectedHostsBlockingEVC extends vimService.vim.EVCConfigFault {
         }
         interface DiskHasPartitions extends vimService.vim.VsanDiskFault {
         }
         interface DiskIsLastRemainingNonSSD extends vimService.vim.VsanDiskFault {
         }
         interface DiskIsNonLocal extends vimService.vim.VsanDiskFault {
         }
         interface DiskIsUSB extends vimService.vim.VsanDiskFault {
         }
         interface DiskMoveTypeNotSupported extends vimService.vim.MigrationFault {
         }
         interface DiskNotSupported extends vimService.vim.VirtualHardwareCompatibilityIssue {
            disk: number;
         }
         interface DiskTooSmall extends vimService.vim.VsanDiskFault {
         }
         interface DomainNotFound extends vimService.vim.ActiveDirectoryFault {
            domainName: string;
         }
         interface DrsDisabledOnVm extends vimService.vim.VimFault {
         }
         interface DrsVmotionIncompatibleFault extends vimService.vim.VirtualHardwareCompatibilityIssue {
            host: vimService.vim.ManagedObjectReference;
         }
         interface DuplicateDisks extends vimService.vim.VsanDiskFault {
         }
         interface DuplicateName extends vimService.vim.VimFault {
            name: string;
            object: vimService.vim.ManagedObjectReference;
         }
         interface DuplicateVsanNetworkInterface extends vimService.vim.VsanFault {
            device: string;
         }
         interface DvsApplyOperationFaultFaultOnObject extends vimService.vim.DynamicData {
            objectId: string;
            type: string;
            fault: vimService.vim.LocalizedMethodFault;
         }
         interface ArrayOfDvsApplyOperationFaultFaultOnObject {
            DvsApplyOperationFaultFaultOnObject?: Array<vimService.vim.DvsApplyOperationFaultFaultOnObject>;
         }
         interface DvsApplyOperationFault extends vimService.vim.DvsFault {
            objectFault: Array<vimService.vim.DvsApplyOperationFaultFaultOnObject>;
         }
         interface DvsFault extends vimService.vim.VimFault {
         }
         interface DvsNotAuthorized extends vimService.vim.DvsFault {
            sessionExtensionKey?: string;
            dvsExtensionKey?: string;
         }
         interface DvsOperationBulkFaultFaultOnHost extends vimService.vim.DynamicData {
            host: vimService.vim.ManagedObjectReference;
            fault: vimService.vim.LocalizedMethodFault;
         }
         interface ArrayOfDvsOperationBulkFaultFaultOnHost {
            DvsOperationBulkFaultFaultOnHost?: Array<vimService.vim.DvsOperationBulkFaultFaultOnHost>;
         }
         interface DvsOperationBulkFault extends vimService.vim.DvsFault {
            hostFault: Array<vimService.vim.DvsOperationBulkFaultFaultOnHost>;
         }
         interface DvsScopeViolated extends vimService.vim.DvsFault {
            scope: Array<vimService.vim.ManagedObjectReference>;
            entity: vimService.vim.ManagedObjectReference;
         }
         interface EVCAdmissionFailed extends vimService.vim.NotSupportedHostInCluster {
            faults?: Array<vimService.vim.LocalizedMethodFault>;
         }
         interface EVCAdmissionFailedCPUFeaturesForMode extends vimService.vim.EVCAdmissionFailed {
            currentEVCModeKey: string;
         }
         interface EVCAdmissionFailedCPUModel extends vimService.vim.EVCAdmissionFailed {
         }
         interface EVCAdmissionFailedCPUModelForMode extends vimService.vim.EVCAdmissionFailed {
            currentEVCModeKey: string;
         }
         interface EVCAdmissionFailedCPUVendor extends vimService.vim.EVCAdmissionFailed {
            clusterCPUVendor: string;
            hostCPUVendor: string;
         }
         interface EVCAdmissionFailedCPUVendorUnknown extends vimService.vim.EVCAdmissionFailed {
         }
         interface EVCAdmissionFailedHostDisconnected extends vimService.vim.EVCAdmissionFailed {
         }
         interface EVCAdmissionFailedHostSoftware extends vimService.vim.EVCAdmissionFailed {
         }
         interface EVCAdmissionFailedHostSoftwareForMode extends vimService.vim.EVCAdmissionFailed {
         }
         interface EVCAdmissionFailedVmActive extends vimService.vim.EVCAdmissionFailed {
         }
         interface EVCConfigFault extends vimService.vim.VimFault {
            faults?: Array<vimService.vim.LocalizedMethodFault>;
         }
         interface EVCModeIllegalByVendor extends vimService.vim.EVCConfigFault {
            clusterCPUVendor: string;
            modeCPUVendor: string;
         }
         interface EVCModeUnsupportedByHosts extends vimService.vim.EVCConfigFault {
            evcMode?: string;
            host?: Array<vimService.vim.ManagedObjectReference>;
            hostName?: Array<string>;
         }
         interface EVCUnsupportedByHostHardware extends vimService.vim.EVCConfigFault {
            host: Array<vimService.vim.ManagedObjectReference>;
            hostName: Array<string>;
         }
         interface EVCUnsupportedByHostSoftware extends vimService.vim.EVCConfigFault {
            host: Array<vimService.vim.ManagedObjectReference>;
            hostName: Array<string>;
         }
         interface EightHostLimitViolated extends vimService.vim.VmConfigFault {
         }
         interface ExpiredAddonLicense extends vimService.vim.ExpiredFeatureLicense {
         }
         interface ExpiredEditionLicense extends vimService.vim.ExpiredFeatureLicense {
         }
         interface ExpiredFeatureLicense extends vimService.vim.NotEnoughLicenses {
            feature: string;
            count: number;
            expirationDate: Date;
         }
         interface ExtendedFault extends vimService.vim.VimFault {
            faultTypeId: string;
            data?: Array<vimService.vim.KeyValue>;
         }
         interface FailToEnableSPBM extends vimService.vim.NotEnoughLicenses {
            cs: vimService.vim.ManagedObjectReference;
            csName: string;
            hostLicenseStates: Array<vimService.vim.ComputeResourceHostSPBMLicenseInfo>;
         }
         interface FailToLockFaultToleranceVMs extends vimService.vim.RuntimeFault {
            vmName: string;
            vm: vimService.vim.ManagedObjectReference;
            alreadyLockedVm: vimService.vim.ManagedObjectReference;
         }
         interface FaultToleranceAntiAffinityViolated extends vimService.vim.MigrationFault {
            hostName: string;
            host: vimService.vim.ManagedObjectReference;
         }
         interface FaultToleranceCannotEditMem extends vimService.vim.VmConfigFault {
            vmName: string;
            vm: vimService.vim.ManagedObjectReference;
         }
         interface FaultToleranceCpuIncompatible extends vimService.vim.CpuIncompatible {
            model: boolean;
            family: boolean;
            stepping: boolean;
         }
         interface FaultToleranceNeedsThickDisk extends vimService.vim.MigrationFault {
            vmName: string;
         }
         interface FaultToleranceNotLicensed extends vimService.vim.VmFaultToleranceIssue {
            hostName?: string;
         }
         interface FaultToleranceNotSameBuild extends vimService.vim.MigrationFault {
            build: string;
         }
         interface FaultTolerancePrimaryPowerOnNotAttempted extends vimService.vim.VmFaultToleranceIssue {
            secondaryVm: vimService.vim.ManagedObjectReference;
            primaryVm: vimService.vim.ManagedObjectReference;
         }
         interface FaultToleranceVmNotDasProtected extends vimService.vim.VimFault {
            vm: vimService.vim.ManagedObjectReference;
            vmName: string;
         }
         interface FcoeFault extends vimService.vim.VimFault {
         }
         interface FcoeFaultPnicHasNoPortSet extends vimService.vim.FcoeFault {
            nicDevice: string;
         }
         interface FeatureRequirementsNotMet extends vimService.vim.VirtualHardwareCompatibilityIssue {
            featureRequirement?: Array<vimService.vim.VirtualMachineFeatureRequirement>;
            vm?: vimService.vim.ManagedObjectReference;
            host?: vimService.vim.ManagedObjectReference;
         }
         interface FileAlreadyExists extends vimService.vim.FileFault {
         }
         interface FileBackedPortNotSupported extends vimService.vim.DeviceNotSupported {
         }
         interface FileFault extends vimService.vim.VimFault {
            file: string;
         }
         interface FileLocked extends vimService.vim.FileFault {
         }
         interface FileNameTooLong extends vimService.vim.FileFault {
         }
         interface FileNotFound extends vimService.vim.FileFault {
         }
         interface FileNotWritable extends vimService.vim.FileFault {
         }
         interface FileTooLarge extends vimService.vim.FileFault {
            datastore: string;
            fileSize: number;
            maxFileSize?: number;
         }
         interface FilesystemQuiesceFault extends vimService.vim.SnapshotFault {
         }
         interface FilterInUse extends vimService.vim.ResourceInUse {
            disk?: Array<vimService.vim.VirtualDiskId>;
         }
         enum FtIssuesOnHostHostSelectionType {
            "user",
            "vc",
            "drs",
         }
         interface FtIssuesOnHost extends vimService.vim.VmFaultToleranceIssue {
            host: vimService.vim.ManagedObjectReference;
            hostName: string;
            errors?: Array<vimService.vim.LocalizedMethodFault>;
         }
         interface FullStorageVMotionNotSupported extends vimService.vim.MigrationFeatureNotSupported {
         }
         interface GatewayConnectFault extends vimService.vim.HostConnectFault {
            gatewayType: string;
            gatewayId: string;
            gatewayInfo: string;
            details?: vimService.vim.LocalizableMessage;
         }
         interface GatewayHostNotReachable extends vimService.vim.GatewayToHostConnectFault {
         }
         interface GatewayNotFound extends vimService.vim.GatewayConnectFault {
         }
         interface GatewayNotReachable extends vimService.vim.GatewayConnectFault {
         }
         interface GatewayOperationRefused extends vimService.vim.GatewayConnectFault {
         }
         interface GatewayToHostAuthFault extends vimService.vim.GatewayToHostConnectFault {
            invalidProperties: Array<string>;
            missingProperties: Array<string>;
         }
         interface GatewayToHostConnectFault extends vimService.vim.GatewayConnectFault {
            hostname: string;
            port?: number;
         }
         interface GatewayToHostTrustVerifyFault extends vimService.vim.GatewayToHostConnectFault {
            verificationToken: string;
            propertiesToVerify: Array<vimService.vim.KeyValue>;
         }
         interface GenericDrsFault extends vimService.vim.VimFault {
            hostFaults?: Array<vimService.vim.LocalizedMethodFault>;
         }
         interface GenericVmConfigFault extends vimService.vim.VmConfigFault {
            reason: string;
         }
         interface GuestAuthenticationChallenge extends vimService.vim.GuestOperationsFault {
            serverChallenge: vimService.vim.GuestAuthentication;
            sessionID: number;
         }
         interface GuestComponentsOutOfDate extends vimService.vim.GuestOperationsFault {
         }
         interface GuestMultipleMappings extends vimService.vim.GuestOperationsFault {
         }
         interface GuestOperationsFault extends vimService.vim.VimFault {
         }
         interface GuestOperationsUnavailable extends vimService.vim.GuestOperationsFault {
         }
         interface GuestPermissionDenied extends vimService.vim.GuestOperationsFault {
         }
         interface GuestProcessNotFound extends vimService.vim.GuestOperationsFault {
            pid: number;
         }
         interface GuestRegistryFault extends vimService.vim.GuestOperationsFault {
            windowsSystemErrorCode: number;
         }
         interface GuestRegistryKeyAlreadyExists extends vimService.vim.GuestRegistryKeyFault {
         }
         interface GuestRegistryKeyFault extends vimService.vim.GuestRegistryFault {
            keyName: string;
         }
         interface GuestRegistryKeyHasSubkeys extends vimService.vim.GuestRegistryKeyFault {
         }
         interface GuestRegistryKeyInvalid extends vimService.vim.GuestRegistryKeyFault {
         }
         interface GuestRegistryKeyParentVolatile extends vimService.vim.GuestRegistryKeyFault {
         }
         interface GuestRegistryValueFault extends vimService.vim.GuestRegistryFault {
            keyName: string;
            valueName: string;
         }
         interface GuestRegistryValueNotFound extends vimService.vim.GuestRegistryValueFault {
         }
         interface HAErrorsAtDest extends vimService.vim.MigrationFault {
         }
         interface HeterogenousHostsBlockingEVC extends vimService.vim.EVCConfigFault {
         }
         interface HostAccessRestrictedToManagementServer extends vimService.vim.NotSupported {
            managementServer: string;
         }
         interface HostConfigFailed extends vimService.vim.HostConfigFault {
            failure: Array<vimService.vim.LocalizedMethodFault>;
         }
         interface HostConfigFault extends vimService.vim.VimFault {
         }
         interface HostConnectFault extends vimService.vim.VimFault {
         }
         enum HostHasComponentFailureHostComponentType {
            "Datastore",
         }
         interface HostHasComponentFailure extends vimService.vim.VimFault {
            hostName: string;
            componentType: string;
            componentName: string;
         }
         interface HostInDomain extends vimService.vim.HostConfigFault {
         }
         enum HostIncompatibleForFaultToleranceReason {
            "product",
            "processor",
         }
         interface HostIncompatibleForFaultTolerance extends vimService.vim.VmFaultToleranceIssue {
            hostName?: string;
            reason?: string;
         }
         enum HostIncompatibleForRecordReplayReason {
            "product",
            "processor",
         }
         interface HostIncompatibleForRecordReplay extends vimService.vim.VimFault {
            hostName?: string;
            reason?: string;
         }
         interface HostInventoryFull extends vimService.vim.NotEnoughLicenses {
            capacity: number;
         }
         interface HostPowerOpFailed extends vimService.vim.VimFault {
         }
         interface HostSpecificationOperationFailed extends vimService.vim.VimFault {
            host: vimService.vim.ManagedObjectReference;
         }
         interface HotSnapshotMoveNotSupported extends vimService.vim.SnapshotCopyNotSupported {
         }
         interface IDEDiskNotSupported extends vimService.vim.DiskNotSupported {
         }
         interface IORMNotSupportedHostOnDatastore extends vimService.vim.VimFault {
            datastore: vimService.vim.ManagedObjectReference;
            datastoreName: string;
            host?: Array<vimService.vim.ManagedObjectReference>;
         }
         interface ImportHostAddFailure extends vimService.vim.DvsFault {
            hostIp: Array<string>;
         }
         interface ImportOperationBulkFaultFaultOnImport extends vimService.vim.DynamicData {
            entityType?: string;
            key?: string;
            fault: vimService.vim.LocalizedMethodFault;
         }
         interface ArrayOfImportOperationBulkFaultFaultOnImport {
            ImportOperationBulkFaultFaultOnImport?: Array<vimService.vim.ImportOperationBulkFaultFaultOnImport>;
         }
         interface ImportOperationBulkFault extends vimService.vim.DvsFault {
            importFaults: Array<vimService.vim.ImportOperationBulkFaultFaultOnImport>;
         }
         interface InUseFeatureManipulationDisallowed extends vimService.vim.NotEnoughLicenses {
         }
         interface InaccessibleDatastore extends vimService.vim.InvalidDatastore {
            detail?: string;
         }
         interface InaccessibleFTMetadataDatastore extends vimService.vim.InaccessibleDatastore {
         }
         interface InaccessibleVFlashSource extends vimService.vim.VimFault {
            hostName: string;
         }
         interface IncompatibleDefaultDevice extends vimService.vim.MigrationFault {
            device: string;
         }
         interface IncompatibleHostForFtSecondary extends vimService.vim.VmFaultToleranceIssue {
            host: vimService.vim.ManagedObjectReference;
            error?: Array<vimService.vim.LocalizedMethodFault>;
         }
         enum IncompatibleHostForVmReplicationIncompatibleReason {
            "rpo",
            "netCompression",
         }
         interface IncompatibleHostForVmReplication extends vimService.vim.ReplicationFault {
            vmName: string;
            hostName: string;
            reason: string;
         }
         interface IncompatibleSetting extends vimService.vim.InvalidArgument {
            conflictingProperty: string;
         }
         interface IncorrectFileType extends vimService.vim.FileFault {
         }
         interface IncorrectHostInformation extends vimService.vim.NotEnoughLicenses {
         }
         interface IndependentDiskVMotionNotSupported extends vimService.vim.MigrationFeatureNotSupported {
         }
         interface InsufficientAgentVmsDeployed extends vimService.vim.InsufficientResourcesFault {
            hostName: string;
            requiredNumAgentVms: number;
            currentNumAgentVms: number;
         }
         interface InsufficientCpuResourcesFault extends vimService.vim.InsufficientResourcesFault {
            unreserved: number;
            requested: number;
         }
         interface InsufficientDisks extends vimService.vim.VsanDiskFault {
         }
         interface InsufficientFailoverResourcesFault extends vimService.vim.InsufficientResourcesFault {
         }
         interface InsufficientGraphicsResourcesFault extends vimService.vim.InsufficientResourcesFault {
         }
         interface InsufficientHostCapacityFault extends vimService.vim.InsufficientResourcesFault {
            host?: vimService.vim.ManagedObjectReference;
         }
         interface InsufficientHostCpuCapacityFault extends vimService.vim.InsufficientHostCapacityFault {
            unreserved: number;
            requested: number;
         }
         interface InsufficientHostMemoryCapacityFault extends vimService.vim.InsufficientHostCapacityFault {
            unreserved: number;
            requested: number;
         }
         interface InsufficientMemoryResourcesFault extends vimService.vim.InsufficientResourcesFault {
            unreserved: number;
            requested: number;
         }
         interface InsufficientNetworkCapacity extends vimService.vim.InsufficientResourcesFault {
         }
         interface InsufficientNetworkResourcePoolCapacity extends vimService.vim.InsufficientResourcesFault {
            dvsName: string;
            dvsUuid: string;
            resourcePoolKey: string;
            available: number;
            requested: number;
            device: Array<string>;
         }
         interface InsufficientPerCpuCapacity extends vimService.vim.InsufficientHostCapacityFault {
         }
         interface InsufficientResourcesFault extends vimService.vim.VimFault {
         }
         interface InsufficientStandbyCpuResource extends vimService.vim.InsufficientStandbyResource {
            available: number;
            requested: number;
         }
         interface InsufficientStandbyMemoryResource extends vimService.vim.InsufficientStandbyResource {
            available: number;
            requested: number;
         }
         interface InsufficientStandbyResource extends vimService.vim.InsufficientResourcesFault {
         }
         interface InsufficientStorageIops extends vimService.vim.VimFault {
            unreservedIops: number;
            requestedIops: number;
            datastoreName: string;
         }
         interface InsufficientStorageSpace extends vimService.vim.InsufficientResourcesFault {
         }
         interface InsufficientVFlashResourcesFault extends vimService.vim.InsufficientResourcesFault {
            freeSpaceInMB?: number;
            freeSpace: number;
            requestedSpaceInMB?: number;
            requestedSpace: number;
         }
         interface InvalidAffinitySettingFault extends vimService.vim.VimFault {
         }
         interface InvalidBmcRole extends vimService.vim.VimFault {
         }
         interface InvalidBundle extends vimService.vim.PlatformConfigFault {
         }
         interface InvalidCAMCertificate extends vimService.vim.InvalidCAMServer {
         }
         interface InvalidCAMServer extends vimService.vim.ActiveDirectoryFault {
            camServer: string;
         }
         interface InvalidClientCertificate extends vimService.vim.InvalidLogin {
         }
         interface InvalidController extends vimService.vim.InvalidDeviceSpec {
            controllerKey: number;
         }
         enum InvalidDasConfigArgumentEntryForInvalidArgument {
            "admissionControl",
            "userHeartbeatDs",
            "vmConfig",
         }
         interface InvalidDasConfigArgument extends vimService.vim.InvalidArgument {
            entry?: string;
            clusterName?: string;
         }
         interface InvalidDasRestartPriorityForFtVm extends vimService.vim.InvalidArgument {
            vm: vimService.vim.ManagedObjectReference;
            vmName: string;
         }
         interface InvalidDatastore extends vimService.vim.VimFault {
            datastore?: vimService.vim.ManagedObjectReference;
            name?: string;
         }
         interface InvalidDatastorePath extends vimService.vim.InvalidDatastore {
            datastorePath: string;
         }
         interface InvalidDatastoreState extends vimService.vim.InvalidState {
            datastoreName?: string;
         }
         interface InvalidDeviceBacking extends vimService.vim.InvalidDeviceSpec {
         }
         interface InvalidDeviceOperation extends vimService.vim.InvalidDeviceSpec {
            badOp?: vimService.vim.VirtualDeviceConfigSpecOperation;
            badFileOp?: vimService.vim.VirtualDeviceConfigSpecFileOperation;
         }
         interface InvalidDeviceSpec extends vimService.vim.InvalidVmConfig {
            deviceIndex: number;
         }
         interface InvalidDiskFormat extends vimService.vim.InvalidFormat {
         }
         interface InvalidDrsBehaviorForFtVm extends vimService.vim.InvalidArgument {
            vm: vimService.vim.ManagedObjectReference;
            vmName: string;
         }
         interface InvalidEditionLicense extends vimService.vim.NotEnoughLicenses {
            feature: string;
         }
         interface InvalidEvent extends vimService.vim.VimFault {
         }
         interface InvalidFolder extends vimService.vim.VimFault {
            target: vimService.vim.ManagedObjectReference;
         }
         interface InvalidFormat extends vimService.vim.VmConfigFault {
         }
         interface InvalidGuestLogin extends vimService.vim.GuestOperationsFault {
         }
         interface InvalidHostConnectionState extends vimService.vim.InvalidHostState {
         }
         interface InvalidHostName extends vimService.vim.HostConfigFault {
         }
         interface InvalidHostState extends vimService.vim.InvalidState {
            host?: vimService.vim.ManagedObjectReference;
         }
         interface InvalidIndexArgument extends vimService.vim.InvalidArgument {
            key: string;
         }
         interface InvalidIpfixConfig extends vimService.vim.DvsFault {
            property?: string;
         }
         interface InvalidIpmiLoginInfo extends vimService.vim.VimFault {
         }
         interface InvalidIpmiMacAddress extends vimService.vim.VimFault {
            userProvidedMacAddress: string;
            observedMacAddress: string;
         }
         interface InvalidLicense extends vimService.vim.VimFault {
            licenseContent: string;
         }
         interface InvalidLocale extends vimService.vim.VimFault {
         }
         interface InvalidLogin extends vimService.vim.VimFault {
         }
         interface InvalidName extends vimService.vim.VimFault {
            name: string;
            entity?: vimService.vim.ManagedObjectReference;
         }
         interface InvalidNasCredentials extends vimService.vim.NasConfigFault {
            userName: string;
         }
         interface InvalidNetworkInType extends vimService.vim.VAppPropertyFault {
         }
         interface InvalidNetworkResource extends vimService.vim.NasConfigFault {
            remoteHost: string;
            remotePath: string;
         }
         interface InvalidOperationOnSecondaryVm extends vimService.vim.VmFaultToleranceIssue {
            instanceUuid?: string;
         }
         interface InvalidPowerState extends vimService.vim.InvalidState {
            requestedState?: vimService.vim.VirtualMachinePowerState;
            existingState: vimService.vim.VirtualMachinePowerState;
         }
         interface InvalidPrivilege extends vimService.vim.VimFault {
            privilege: string;
         }
         enum InvalidProfileReferenceHostReason {
            "incompatibleVersion",
            "missingReferenceHost",
         }
         interface InvalidProfileReferenceHost extends vimService.vim.RuntimeFault {
            reason?: string;
            host?: vimService.vim.ManagedObjectReference;
            profile?: vimService.vim.ManagedObjectReference;
            profileName?: string;
         }
         interface InvalidPropertyType extends vimService.vim.VAppPropertyFault {
         }
         interface InvalidPropertyValue extends vimService.vim.VAppPropertyFault {
         }
         interface InvalidResourcePoolStructureFault extends vimService.vim.InsufficientResourcesFault {
         }
         interface InvalidSnapshotFormat extends vimService.vim.InvalidFormat {
         }
         interface InvalidState extends vimService.vim.VimFault {
         }
         interface InvalidVmConfig extends vimService.vim.VmConfigFault {
            property?: string;
         }
         interface InvalidVmState extends vimService.vim.InvalidState {
            vm: vimService.vim.ManagedObjectReference;
         }
         interface InventoryHasStandardAloneHosts extends vimService.vim.NotEnoughLicenses {
            hosts: Array<string>;
         }
         interface IpHostnameGeneratorError extends vimService.vim.CustomizationFault {
         }
         interface IscsiFault extends vimService.vim.VimFault {
         }
         interface IscsiFaultInvalidVnic extends vimService.vim.IscsiFault {
            vnicDevice: string;
         }
         interface IscsiFaultPnicInUse extends vimService.vim.IscsiFault {
            pnicDevice: string;
         }
         interface IscsiFaultVnicAlreadyBound extends vimService.vim.IscsiFault {
            vnicDevice: string;
         }
         interface IscsiFaultVnicHasActivePaths extends vimService.vim.IscsiFault {
            vnicDevice: string;
         }
         interface IscsiFaultVnicHasMultipleUplinks extends vimService.vim.IscsiFault {
            vnicDevice: string;
         }
         interface IscsiFaultVnicHasNoUplinks extends vimService.vim.IscsiFault {
            vnicDevice: string;
         }
         interface IscsiFaultVnicHasWrongUplink extends vimService.vim.IscsiFault {
            vnicDevice: string;
         }
         interface IscsiFaultVnicInUse extends vimService.vim.IscsiFault {
            vnicDevice: string;
         }
         interface IscsiFaultVnicIsLastPath extends vimService.vim.IscsiFault {
            vnicDevice: string;
         }
         interface IscsiFaultVnicNotBound extends vimService.vim.IscsiFault {
            vnicDevice: string;
         }
         interface IscsiFaultVnicNotFound extends vimService.vim.IscsiFault {
            vnicDevice: string;
         }
         interface LargeRDMConversionNotSupported extends vimService.vim.MigrationFault {
            device: string;
         }
         interface LargeRDMNotSupportedOnDatastore extends vimService.vim.VmConfigFault {
            device: string;
            datastore: vimService.vim.ManagedObjectReference;
            datastoreName: string;
         }
         interface LegacyNetworkInterfaceInUse extends vimService.vim.CannotAccessNetwork {
         }
         enum LicenseAssignmentFailedReason {
            "keyEntityMismatch",
            "downgradeDisallowed",
            "inventoryNotManageableByVirtualCenter",
            "hostsUnmanageableByVirtualCenterWithoutLicenseServer",
         }
         interface LicenseAssignmentFailed extends vimService.vim.RuntimeFault {
            reason?: string;
         }
         interface LicenseDowngradeDisallowed extends vimService.vim.NotEnoughLicenses {
            edition: string;
            entityId: string;
            features: Array<vimService.vim.KeyAnyValue>;
         }
         interface LicenseEntityNotFound extends vimService.vim.VimFault {
            entityId: string;
         }
         interface LicenseExpired extends vimService.vim.NotEnoughLicenses {
            licenseKey: string;
         }
         interface LicenseKeyEntityMismatch extends vimService.vim.NotEnoughLicenses {
         }
         interface LicenseRestricted extends vimService.vim.NotEnoughLicenses {
         }
         interface LicenseServerUnavailable extends vimService.vim.VimFault {
            licenseServer: string;
         }
         interface LicenseSourceUnavailable extends vimService.vim.NotEnoughLicenses {
            licenseSource: vimService.vim.LicenseSource;
         }
         interface LimitExceeded extends vimService.vim.VimFault {
            property?: string;
            limit?: number;
         }
         interface LinuxVolumeNotClean extends vimService.vim.CustomizationFault {
         }
         interface LogBundlingFailed extends vimService.vim.VimFault {
         }
         interface MaintenanceModeFileMove extends vimService.vim.MigrationFault {
         }
         interface MemoryFileFormatNotSupportedByDatastore extends vimService.vim.UnsupportedDatastore {
            datastoreName: string;
            type: string;
         }
         interface MemoryHotPlugNotSupported extends vimService.vim.VmConfigFault {
         }
         interface MemorySizeNotRecommended extends vimService.vim.VirtualHardwareCompatibilityIssue {
            memorySizeMB: number;
            minMemorySizeMB: number;
            maxMemorySizeMB: number;
         }
         interface MemorySizeNotSupported extends vimService.vim.VirtualHardwareCompatibilityIssue {
            memorySizeMB: number;
            minMemorySizeMB: number;
            maxMemorySizeMB: number;
         }
         interface MemorySizeNotSupportedByDatastore extends vimService.vim.VirtualHardwareCompatibilityIssue {
            datastore: vimService.vim.ManagedObjectReference;
            memorySizeMB: number;
            maxMemorySizeMB: number;
         }
         interface MemorySnapshotOnIndependentDisk extends vimService.vim.SnapshotFault {
         }
         interface MethodAlreadyDisabledFault extends vimService.vim.RuntimeFault {
            sourceId: string;
         }
         interface MethodDisabled extends vimService.vim.RuntimeFault {
            source?: string;
         }
         interface MigrationDisabled extends vimService.vim.MigrationFault {
         }
         interface MigrationFault extends vimService.vim.VimFault {
         }
         interface MigrationFeatureNotSupported extends vimService.vim.MigrationFault {
            atSourceHost: boolean;
            failedHostName: string;
            failedHost: vimService.vim.ManagedObjectReference;
         }
         interface MigrationNotReady extends vimService.vim.MigrationFault {
            reason: string;
         }
         interface MismatchedBundle extends vimService.vim.VimFault {
            bundleUuid: string;
            hostUuid: string;
            bundleBuildNumber: number;
            hostBuildNumber: number;
         }
         interface MismatchedNetworkPolicies extends vimService.vim.MigrationFault {
            device: string;
            backing: string;
            connected: boolean;
         }
         interface MismatchedVMotionNetworkNames extends vimService.vim.MigrationFault {
            sourceNetwork: string;
            destNetwork: string;
         }
         interface MissingBmcSupport extends vimService.vim.VimFault {
         }
         interface MissingController extends vimService.vim.InvalidDeviceSpec {
         }
         interface MissingIpPool extends vimService.vim.VAppPropertyFault {
         }
         interface MissingLinuxCustResources extends vimService.vim.CustomizationFault {
         }
         interface MissingNetworkIpConfig extends vimService.vim.VAppPropertyFault {
         }
         interface MissingPowerOffConfiguration extends vimService.vim.VAppConfigFault {
         }
         interface MissingPowerOnConfiguration extends vimService.vim.VAppConfigFault {
         }
         interface MissingWindowsCustResources extends vimService.vim.CustomizationFault {
         }
         interface MksConnectionLimitReached extends vimService.vim.InvalidState {
            connectionLimit: number;
         }
         interface MountError extends vimService.vim.CustomizationFault {
            vm: vimService.vim.ManagedObjectReference;
            diskIndex: number;
         }
         interface MultiWriterNotSupported extends vimService.vim.DeviceNotSupported {
         }
         interface MultipleCertificatesVerifyFaultThumbprintData extends vimService.vim.DynamicData {
            port: number;
            thumbprint: string;
         }
         interface ArrayOfMultipleCertificatesVerifyFaultThumbprintData {
            MultipleCertificatesVerifyFaultThumbprintData?: Array<vimService.vim.MultipleCertificatesVerifyFaultThumbprintData>;
         }
         interface MultipleCertificatesVerifyFault extends vimService.vim.HostConnectFault {
            thumbprintData: Array<vimService.vim.MultipleCertificatesVerifyFaultThumbprintData>;
         }
         interface MultipleSnapshotsNotSupported extends vimService.vim.SnapshotFault {
         }
         interface NamespaceFull extends vimService.vim.VimFault {
            name: string;
            currentMaxSize: number;
            requiredSize?: number;
         }
         interface NamespaceLimitReached extends vimService.vim.VimFault {
            limit?: number;
         }
         interface NamespaceWriteProtected extends vimService.vim.VimFault {
            name: string;
         }
         interface NasConfigFault extends vimService.vim.HostConfigFault {
            name: string;
         }
         interface NasConnectionLimitReached extends vimService.vim.NasConfigFault {
            remoteHost: string;
            remotePath: string;
         }
         interface NasSessionCredentialConflict extends vimService.vim.NasConfigFault {
            remoteHost: string;
            remotePath: string;
            userName: string;
         }
         interface NasVolumeNotMounted extends vimService.vim.NasConfigFault {
            remoteHost: string;
            remotePath: string;
         }
         interface NetworkCopyFault extends vimService.vim.FileFault {
         }
         interface NetworkDisruptedAndConfigRolledBack extends vimService.vim.VimFault {
            host: string;
         }
         interface NetworkInaccessible extends vimService.vim.NasConfigFault {
         }
         interface NetworksMayNotBeTheSame extends vimService.vim.MigrationFault {
            name?: string;
         }
         interface NicSettingMismatch extends vimService.vim.CustomizationFault {
            numberOfNicsInSpec: number;
            numberOfNicsInVM: number;
         }
         interface NoActiveHostInCluster extends vimService.vim.InvalidState {
            computeResource: vimService.vim.ManagedObjectReference;
         }
         interface NoAvailableIp extends vimService.vim.VAppPropertyFault {
            network: vimService.vim.ManagedObjectReference;
         }
         interface NoClientCertificate extends vimService.vim.VimFault {
         }
         interface NoCompatibleDatastore extends vimService.vim.VimFault {
         }
         interface NoCompatibleHardAffinityHost extends vimService.vim.VmConfigFault {
            vmName: string;
         }
         interface NoCompatibleHost extends vimService.vim.VimFault {
            host?: Array<vimService.vim.ManagedObjectReference>;
            error?: Array<vimService.vim.LocalizedMethodFault>;
         }
         interface NoCompatibleHostWithAccessToDevice extends vimService.vim.NoCompatibleHost {
         }
         interface NoCompatibleSoftAffinityHost extends vimService.vim.VmConfigFault {
            vmName: string;
         }
         interface NoConnectedDatastore extends vimService.vim.VimFault {
         }
         interface NoDiskFound extends vimService.vim.VimFault {
         }
         interface NoDiskSpace extends vimService.vim.FileFault {
            datastore: string;
         }
         interface NoDisksToCustomize extends vimService.vim.CustomizationFault {
         }
         interface NoGateway extends vimService.vim.HostConfigFault {
         }
         interface NoGuestHeartbeat extends vimService.vim.MigrationFault {
         }
         interface NoHost extends vimService.vim.HostConnectFault {
            name?: string;
         }
         interface NoHostSuitableForFtSecondary extends vimService.vim.VmFaultToleranceIssue {
            vm: vimService.vim.ManagedObjectReference;
            vmName: string;
         }
         interface NoLicenseServerConfigured extends vimService.vim.NotEnoughLicenses {
         }
         interface NoPeerHostFound extends vimService.vim.HostPowerOpFailed {
         }
         interface NoPermission extends vimService.vim.SecurityError {
            object: vimService.vim.ManagedObjectReference;
            privilegeId: string;
         }
         interface NoPermissionOnAD extends vimService.vim.ActiveDirectoryFault {
         }
         interface NoPermissionOnHost extends vimService.vim.HostConnectFault {
         }
         interface NoPermissionOnNasVolume extends vimService.vim.NasConfigFault {
            userName?: string;
         }
         interface NoSubjectName extends vimService.vim.VimFault {
         }
         interface NoVcManagedIpConfigured extends vimService.vim.VAppPropertyFault {
         }
         interface NoVirtualNic extends vimService.vim.HostConfigFault {
         }
         interface NoVmInVApp extends vimService.vim.VAppConfigFault {
         }
         interface NonADUserRequired extends vimService.vim.ActiveDirectoryFault {
         }
         interface NonHomeRDMVMotionNotSupported extends vimService.vim.MigrationFeatureNotSupported {
            device: string;
         }
         interface NonPersistentDisksNotSupported extends vimService.vim.DeviceNotSupported {
         }
         interface NonVmwareOuiMacNotSupportedHost extends vimService.vim.NotSupportedHost {
            hostName: string;
         }
         interface NotADirectory extends vimService.vim.FileFault {
         }
         interface NotAFile extends vimService.vim.FileFault {
         }
         interface NotAuthenticated extends vimService.vim.NoPermission {
         }
         interface NotEnoughCpus extends vimService.vim.VirtualHardwareCompatibilityIssue {
            numCpuDest: number;
            numCpuVm: number;
         }
         interface NotEnoughLogicalCpus extends vimService.vim.NotEnoughCpus {
            host?: vimService.vim.ManagedObjectReference;
         }
         interface NotFound extends vimService.vim.VimFault {
         }
         enum NotSupportedDeviceForFTDeviceType {
            "virtualVmxnet3",
            "paraVirtualSCSIController",
         }
         interface NotSupportedDeviceForFT extends vimService.vim.VmFaultToleranceIssue {
            host: vimService.vim.ManagedObjectReference;
            hostName?: string;
            vm: vimService.vim.ManagedObjectReference;
            vmName?: string;
            deviceType: string;
            deviceLabel?: string;
         }
         interface NotSupportedHost extends vimService.vim.HostConnectFault {
            productName?: string;
            productVersion?: string;
         }
         interface NotSupportedHostForChecksum extends vimService.vim.VimFault {
         }
         interface NotSupportedHostForVFlash extends vimService.vim.NotSupportedHost {
            hostName: string;
         }
         interface NotSupportedHostForVmcp extends vimService.vim.NotSupportedHost {
            hostName: string;
         }
         interface NotSupportedHostForVmemFile extends vimService.vim.NotSupportedHost {
            hostName: string;
         }
         interface NotSupportedHostForVsan extends vimService.vim.NotSupportedHost {
            hostName: string;
         }
         interface NotSupportedHostInCluster extends vimService.vim.NotSupportedHost {
         }
         interface NotSupportedHostInDvs extends vimService.vim.NotSupportedHost {
            switchProductSpec: vimService.vim.DistributedVirtualSwitchProductSpec;
         }
         interface NotSupportedHostInHACluster extends vimService.vim.NotSupportedHost {
            hostName: string;
            build: string;
         }
         interface NotUserConfigurableProperty extends vimService.vim.VAppPropertyFault {
         }
         interface NumVirtualCoresPerSocketNotSupported extends vimService.vim.VirtualHardwareCompatibilityIssue {
            maxSupportedCoresPerSocketDest: number;
            numCoresPerSocketVm: number;
         }
         interface NumVirtualCpusExceedsLimit extends vimService.vim.InsufficientResourcesFault {
            maxSupportedVcpus: number;
         }
         enum NumVirtualCpusIncompatibleReason {
            "recordReplay",
            "faultTolerance",
         }
         interface NumVirtualCpusIncompatible extends vimService.vim.VmConfigFault {
            reason: string;
            numCpu: number;
         }
         interface NumVirtualCpusNotSupported extends vimService.vim.VirtualHardwareCompatibilityIssue {
            maxSupportedVcpusDest: number;
            numCpuVm: number;
         }
         interface OperationDisabledByGuest extends vimService.vim.GuestOperationsFault {
         }
         interface OperationDisallowedOnHost extends vimService.vim.RuntimeFault {
         }
         interface OperationNotSupportedByGuest extends vimService.vim.GuestOperationsFault {
         }
         interface OutOfBounds extends vimService.vim.VimFault {
            argumentName: string;
         }
         interface OvfAttribute extends vimService.vim.OvfInvalidPackage {
            elementName: string;
            attributeName: string;
         }
         interface OvfConnectedDevice extends vimService.vim.OvfHardwareExport {
         }
         interface OvfConnectedDeviceFloppy extends vimService.vim.OvfConnectedDevice {
            filename: string;
         }
         interface OvfConnectedDeviceIso extends vimService.vim.OvfConnectedDevice {
            filename: string;
         }
         interface OvfConstraint extends vimService.vim.OvfInvalidPackage {
            name: string;
         }
         interface OvfConsumerCallbackFault extends vimService.vim.OvfFault {
            extensionKey: string;
            extensionName: string;
         }
         interface OvfConsumerCommunicationError extends vimService.vim.OvfConsumerCallbackFault {
            description: string;
         }
         interface OvfConsumerFault extends vimService.vim.OvfConsumerCallbackFault {
            errorKey: string;
            message: string;
            params?: Array<vimService.vim.KeyValue>;
         }
         interface OvfConsumerInvalidSection extends vimService.vim.OvfConsumerCallbackFault {
            lineNumber: number;
            description: string;
         }
         interface OvfConsumerPowerOnFault extends vimService.vim.InvalidState {
            extensionKey: string;
            extensionName: string;
            description: string;
         }
         interface OvfConsumerUndeclaredSection extends vimService.vim.OvfConsumerCallbackFault {
            qualifiedSectionType: string;
         }
         interface OvfConsumerUndefinedPrefix extends vimService.vim.OvfConsumerCallbackFault {
            prefix: string;
         }
         interface OvfConsumerValidationFault extends vimService.vim.VmConfigFault {
            extensionKey: string;
            extensionName: string;
            message: string;
         }
         interface OvfCpuCompatibility extends vimService.vim.OvfImport {
            registerName: string;
            level: number;
            registerValue: string;
            desiredRegisterValue: string;
         }
         interface OvfCpuCompatibilityCheckNotSupported extends vimService.vim.OvfImport {
         }
         interface OvfDiskMappingNotFound extends vimService.vim.OvfSystemFault {
            diskName: string;
            vmName: string;
         }
         interface OvfDiskOrderConstraint extends vimService.vim.OvfConstraint {
         }
         interface OvfDuplicateElement extends vimService.vim.OvfElement {
         }
         interface OvfDuplicatedElementBoundary extends vimService.vim.OvfElement {
            boundary: string;
         }
         interface OvfDuplicatedPropertyIdExport extends vimService.vim.OvfExport {
            fqid: string;
         }
         interface OvfDuplicatedPropertyIdImport extends vimService.vim.OvfExport {
         }
         interface OvfElement extends vimService.vim.OvfInvalidPackage {
            name: string;
         }
         interface OvfElementInvalidValue extends vimService.vim.OvfElement {
            value: string;
         }
         interface OvfExport extends vimService.vim.OvfFault {
         }
         interface OvfExportFailed extends vimService.vim.OvfExport {
         }
         interface OvfFault extends vimService.vim.VimFault {
         }
         interface OvfHardwareCheck extends vimService.vim.OvfImport {
         }
         interface OvfHardwareExport extends vimService.vim.OvfExport {
            device?: vimService.vim.VirtualDevice;
            vmPath: string;
         }
         interface OvfHostResourceConstraint extends vimService.vim.OvfConstraint {
            value: string;
         }
         interface OvfHostValueNotParsed extends vimService.vim.OvfSystemFault {
            property: string;
            value: string;
         }
         interface OvfImport extends vimService.vim.OvfFault {
         }
         interface OvfImportFailed extends vimService.vim.OvfImport {
         }
         interface OvfInternalError extends vimService.vim.OvfSystemFault {
         }
         interface OvfInvalidPackage extends vimService.vim.OvfFault {
            lineNumber: number;
         }
         interface OvfInvalidValue extends vimService.vim.OvfAttribute {
            value: string;
         }
         interface OvfInvalidValueConfiguration extends vimService.vim.OvfInvalidValue {
         }
         interface OvfInvalidValueEmpty extends vimService.vim.OvfInvalidValue {
         }
         interface OvfInvalidValueFormatMalformed extends vimService.vim.OvfInvalidValue {
         }
         interface OvfInvalidValueReference extends vimService.vim.OvfInvalidValue {
         }
         interface OvfInvalidVmName extends vimService.vim.OvfUnsupportedPackage {
            name: string;
         }
         interface OvfMappedOsId extends vimService.vim.OvfImport {
            ovfId: number;
            ovfDescription: string;
            targetDescription: string;
         }
         interface OvfMissingAttribute extends vimService.vim.OvfAttribute {
         }
         interface OvfMissingElement extends vimService.vim.OvfElement {
         }
         interface OvfMissingElementNormalBoundary extends vimService.vim.OvfMissingElement {
            boundary: string;
         }
         interface OvfMissingHardware extends vimService.vim.OvfImport {
            name: string;
            resourceType: number;
         }
         interface OvfNetworkMappingNotSupported extends vimService.vim.OvfImport {
         }
         interface OvfNoHostNic extends vimService.vim.OvfUnsupportedPackage {
         }
         interface OvfNoSpaceOnController extends vimService.vim.OvfUnsupportedElement {
            parent: string;
         }
         interface OvfNoSupportedHardwareFamily extends vimService.vim.OvfUnsupportedPackage {
            version: string;
         }
         interface OvfProperty extends vimService.vim.OvfInvalidPackage {
            type: string;
            value: string;
         }
         interface OvfPropertyExport extends vimService.vim.OvfExport {
            type: string;
            value: string;
         }
         interface OvfPropertyNetwork extends vimService.vim.OvfProperty {
         }
         interface OvfPropertyNetworkExport extends vimService.vim.OvfExport {
            network: string;
         }
         interface OvfPropertyQualifier extends vimService.vim.OvfProperty {
            qualifier: string;
         }
         interface OvfPropertyQualifierDuplicate extends vimService.vim.OvfProperty {
            qualifier: string;
         }
         interface OvfPropertyQualifierIgnored extends vimService.vim.OvfProperty {
            qualifier: string;
         }
         interface OvfPropertyType extends vimService.vim.OvfProperty {
         }
         interface OvfPropertyValue extends vimService.vim.OvfProperty {
         }
         interface OvfSystemFault extends vimService.vim.OvfFault {
         }
         interface OvfToXmlUnsupportedElement extends vimService.vim.OvfSystemFault {
            name?: string;
         }
         interface OvfUnableToExportDisk extends vimService.vim.OvfHardwareExport {
            diskName: string;
         }
         interface OvfUnexpectedElement extends vimService.vim.OvfElement {
         }
         interface OvfUnknownDevice extends vimService.vim.OvfSystemFault {
            device?: vimService.vim.VirtualDevice;
            vmName: string;
         }
         interface OvfUnknownDeviceBacking extends vimService.vim.OvfHardwareExport {
            backing: vimService.vim.VirtualDeviceBackingInfo;
         }
         interface OvfUnknownEntity extends vimService.vim.OvfSystemFault {
            lineNumber: number;
         }
         interface OvfUnsupportedAttribute extends vimService.vim.OvfUnsupportedPackage {
            elementName: string;
            attributeName: string;
         }
         interface OvfUnsupportedAttributeValue extends vimService.vim.OvfUnsupportedAttribute {
            value: string;
         }
         interface OvfUnsupportedDeviceBackingInfo extends vimService.vim.OvfSystemFault {
            elementName?: string;
            instanceId?: string;
            deviceName: string;
            backingName?: string;
         }
         interface OvfUnsupportedDeviceBackingOption extends vimService.vim.OvfSystemFault {
            elementName?: string;
            instanceId?: string;
            deviceName: string;
            backingName?: string;
         }
         interface OvfUnsupportedDeviceExport extends vimService.vim.OvfHardwareExport {
         }
         interface OvfUnsupportedDiskProvisioning extends vimService.vim.OvfImport {
            diskProvisioning: string;
            supportedDiskProvisioning: string;
         }
         interface OvfUnsupportedElement extends vimService.vim.OvfUnsupportedPackage {
            name: string;
         }
         interface OvfUnsupportedElementValue extends vimService.vim.OvfUnsupportedElement {
            value: string;
         }
         interface OvfUnsupportedPackage extends vimService.vim.OvfFault {
            lineNumber?: number;
         }
         interface OvfUnsupportedSection extends vimService.vim.OvfUnsupportedElement {
            info: string;
         }
         interface OvfUnsupportedSubType extends vimService.vim.OvfUnsupportedPackage {
            elementName: string;
            instanceId: string;
            deviceType: number;
            deviceSubType: string;
         }
         interface OvfUnsupportedType extends vimService.vim.OvfUnsupportedPackage {
            name: string;
            instanceId: string;
            deviceType: number;
         }
         interface OvfWrongElement extends vimService.vim.OvfElement {
         }
         interface OvfWrongNamespace extends vimService.vim.OvfInvalidPackage {
            namespaceName: string;
         }
         interface OvfXmlFormat extends vimService.vim.OvfInvalidPackage {
            description: string;
         }
         interface PatchAlreadyInstalled extends vimService.vim.PatchNotApplicable {
         }
         interface PatchBinariesNotFound extends vimService.vim.VimFault {
            patchID: string;
            binary?: Array<string>;
         }
         interface PatchInstallFailed extends vimService.vim.PlatformConfigFault {
            rolledBack: boolean;
         }
         interface PatchIntegrityError extends vimService.vim.PlatformConfigFault {
         }
         interface PatchMetadataCorrupted extends vimService.vim.PatchMetadataInvalid {
         }
         interface PatchMetadataInvalid extends vimService.vim.VimFault {
            patchID: string;
            metaData?: Array<string>;
         }
         interface PatchMetadataNotFound extends vimService.vim.PatchMetadataInvalid {
         }
         interface PatchMissingDependencies extends vimService.vim.PatchNotApplicable {
            prerequisitePatch?: Array<string>;
            prerequisiteLib?: Array<string>;
         }
         interface PatchNotApplicable extends vimService.vim.VimFault {
            patchID: string;
         }
         interface PatchSuperseded extends vimService.vim.PatchNotApplicable {
            supersede?: Array<string>;
         }
         interface PhysCompatRDMNotSupported extends vimService.vim.RDMNotSupported {
         }
         interface PlatformConfigFault extends vimService.vim.HostConfigFault {
            text: string;
         }
         interface PowerOnFtSecondaryFailed extends vimService.vim.VmFaultToleranceIssue {
            vm: vimService.vim.ManagedObjectReference;
            vmName: string;
            hostSelectionBy: vimService.vim.FtIssuesOnHostHostSelectionType;
            hostErrors?: Array<vimService.vim.LocalizedMethodFault>;
            rootCause: vimService.vim.LocalizedMethodFault;
         }
         interface PowerOnFtSecondaryTimedout extends vimService.vim.Timedout {
            vm: vimService.vim.ManagedObjectReference;
            vmName: string;
            timeout: number;
         }
         interface ProfileUpdateFailedUpdateFailure extends vimService.vim.DynamicData {
            profilePath: vimService.vim.ProfilePropertyPath;
            errMsg: vimService.vim.LocalizableMessage;
         }
         interface ArrayOfProfileUpdateFailedUpdateFailure {
            ProfileUpdateFailedUpdateFailure?: Array<vimService.vim.ProfileUpdateFailedUpdateFailure>;
         }
         interface ProfileUpdateFailed extends vimService.vim.VimFault {
            failure: Array<vimService.vim.ProfileUpdateFailedUpdateFailure>;
         }
         enum QuarantineModeFaultFaultType {
            "NoCompatibleNonQuarantinedHost",
            "CorrectionDisallowed",
            "CorrectionImpact",
         }
         interface QuarantineModeFault extends vimService.vim.VmConfigFault {
            vmName: string;
            faultType: string;
         }
         interface QuestionPending extends vimService.vim.InvalidState {
            text: string;
         }
         interface QuiesceDatastoreIOForHAFailed extends vimService.vim.ResourceInUse {
            host: vimService.vim.ManagedObjectReference;
            hostName: string;
            ds: vimService.vim.ManagedObjectReference;
            dsName: string;
         }
         interface RDMConversionNotSupported extends vimService.vim.MigrationFault {
            device: string;
         }
         interface RDMNotPreserved extends vimService.vim.MigrationFault {
            device: string;
         }
         interface RDMNotSupported extends vimService.vim.DeviceNotSupported {
         }
         interface RDMNotSupportedOnDatastore extends vimService.vim.VmConfigFault {
            device: string;
            datastore: vimService.vim.ManagedObjectReference;
            datastoreName: string;
         }
         interface RDMPointsToInaccessibleDisk extends vimService.vim.CannotAccessVmDisk {
         }
         interface RawDiskNotSupported extends vimService.vim.DeviceNotSupported {
         }
         interface ReadHostResourcePoolTreeFailed extends vimService.vim.HostConnectFault {
         }
         interface ReadOnlyDisksWithLegacyDestination extends vimService.vim.MigrationFault {
            roDiskCount: number;
            timeoutDanger: boolean;
         }
         interface RebootRequired extends vimService.vim.VimFault {
            patch?: string;
         }
         interface RecordReplayDisabled extends vimService.vim.VimFault {
         }
         interface RemoteDeviceNotSupported extends vimService.vim.DeviceNotSupported {
         }
         interface RemoveFailed extends vimService.vim.VimFault {
         }
         interface ReplicationConfigFault extends vimService.vim.ReplicationFault {
         }
         enum ReplicationDiskConfigFaultReasonForFault {
            "diskNotFound",
            "diskTypeNotSupported",
            "invalidDiskKey",
            "invalidDiskReplicationId",
            "duplicateDiskReplicationId",
            "invalidPersistentFilePath",
            "reconfigureDiskReplicationIdNotAllowed",
         }
         interface ReplicationDiskConfigFault extends vimService.vim.ReplicationConfigFault {
            reason?: string;
            vmRef?: vimService.vim.ManagedObjectReference;
            key?: number;
         }
         interface ReplicationFault extends vimService.vim.VimFault {
         }
         interface ReplicationIncompatibleWithFT extends vimService.vim.ReplicationFault {
         }
         interface ReplicationInvalidOptions extends vimService.vim.ReplicationFault {
            options: string;
            entity?: vimService.vim.ManagedObjectReference;
         }
         interface ReplicationNotSupportedOnHost extends vimService.vim.ReplicationFault {
         }
         enum ReplicationVmConfigFaultReasonForFault {
            "incompatibleHwVersion",
            "invalidVmReplicationId",
            "invalidGenerationNumber",
            "outOfBoundsRpoValue",
            "invalidDestinationIpAddress",
            "invalidDestinationPort",
            "invalidExtraVmOptions",
            "staleGenerationNumber",
            "reconfigureVmReplicationIdNotAllowed",
            "cannotRetrieveVmReplicationConfiguration",
            "replicationAlreadyEnabled",
            "invalidPriorConfiguration",
            "replicationNotEnabled",
            "replicationConfigurationFailed",
            "encryptedVm",
         }
         interface ReplicationVmConfigFault extends vimService.vim.ReplicationConfigFault {
            reason?: string;
            vmRef?: vimService.vim.ManagedObjectReference;
         }
         enum ReplicationVmFaultReasonForFault {
            "notConfigured",
            "poweredOff",
            "suspended",
            "poweredOn",
            "offlineReplicating",
            "invalidState",
            "invalidInstanceId",
            "closeDiskError",
         }
         interface ReplicationVmFault extends vimService.vim.ReplicationFault {
            reason?: string;
            state?: string;
            instanceId?: string;
            vm?: vimService.vim.ManagedObjectReference;
         }
         enum ReplicationVmInProgressFaultActivity {
            "fullSync",
            "delta",
         }
         interface ReplicationVmInProgressFault extends vimService.vim.ReplicationVmFault {
            requestedActivity: string;
            inProgressActivity: string;
         }
         interface ResourceInUse extends vimService.vim.VimFault {
            type?: string;
            name?: string;
         }
         interface ResourceNotAvailable extends vimService.vim.VimFault {
            containerType?: string;
            containerName?: string;
            type?: string;
         }
         interface RestrictedByAdministrator extends vimService.vim.RuntimeFault {
            details: string;
         }
         interface RestrictedVersion extends vimService.vim.SecurityError {
         }
         interface RollbackFailure extends vimService.vim.DvsFault {
            entityName: string;
            entityType: string;
         }
         interface RuleViolation extends vimService.vim.VmConfigFault {
            host?: vimService.vim.ManagedObjectReference;
            rule?: vimService.vim.ClusterRuleInfo;
         }
         interface SSLDisabledFault extends vimService.vim.HostConnectFault {
         }
         interface SSLVerifyFault extends vimService.vim.HostConnectFault {
            selfSigned: boolean;
            thumbprint: string;
         }
         interface SSPIChallenge extends vimService.vim.VimFault {
            base64Token: string;
         }
         interface SecondaryVmAlreadyDisabled extends vimService.vim.VmFaultToleranceIssue {
            instanceUuid: string;
         }
         interface SecondaryVmAlreadyEnabled extends vimService.vim.VmFaultToleranceIssue {
            instanceUuid: string;
         }
         interface SecondaryVmAlreadyRegistered extends vimService.vim.VmFaultToleranceIssue {
            instanceUuid?: string;
         }
         interface SecondaryVmNotRegistered extends vimService.vim.VmFaultToleranceIssue {
            instanceUuid?: string;
         }
         interface SharedBusControllerNotSupported extends vimService.vim.DeviceNotSupported {
         }
         interface ShrinkDiskFault extends vimService.vim.VimFault {
            diskId?: number;
         }
         interface SnapshotCloneNotSupported extends vimService.vim.SnapshotCopyNotSupported {
         }
         interface SnapshotCopyNotSupported extends vimService.vim.MigrationFault {
         }
         interface SnapshotDisabled extends vimService.vim.SnapshotFault {
         }
         interface SnapshotFault extends vimService.vim.VimFault {
         }
         interface SnapshotIncompatibleDeviceInVm extends vimService.vim.SnapshotFault {
            fault: vimService.vim.LocalizedMethodFault;
         }
         interface SnapshotLocked extends vimService.vim.SnapshotFault {
         }
         interface SnapshotMoveFromNonHomeNotSupported extends vimService.vim.SnapshotCopyNotSupported {
         }
         interface SnapshotMoveNotSupported extends vimService.vim.SnapshotCopyNotSupported {
         }
         interface SnapshotMoveToNonHomeNotSupported extends vimService.vim.SnapshotCopyNotSupported {
         }
         interface SnapshotNoChange extends vimService.vim.SnapshotFault {
         }
         interface SnapshotRevertIssue extends vimService.vim.MigrationFault {
            snapshotName?: string;
            event?: Array<vimService.vim.Event>;
            errors: boolean;
         }
         interface SoftRuleVioCorrectionDisallowed extends vimService.vim.VmConfigFault {
            vmName: string;
         }
         interface SoftRuleVioCorrectionImpact extends vimService.vim.VmConfigFault {
            vmName: string;
         }
         interface SsdDiskNotAvailable extends vimService.vim.VimFault {
            devicePath: string;
         }
         interface StorageDrsCannotMoveDiskInMultiWriterMode extends vimService.vim.VimFault {
         }
         interface StorageDrsCannotMoveFTVm extends vimService.vim.VimFault {
         }
         interface StorageDrsCannotMoveIndependentDisk extends vimService.vim.VimFault {
         }
         interface StorageDrsCannotMoveManuallyPlacedSwapFile extends vimService.vim.VimFault {
         }
         interface StorageDrsCannotMoveManuallyPlacedVm extends vimService.vim.VimFault {
         }
         interface StorageDrsCannotMoveSharedDisk extends vimService.vim.VimFault {
         }
         interface StorageDrsCannotMoveTemplate extends vimService.vim.VimFault {
         }
         interface StorageDrsCannotMoveVmInUserFolder extends vimService.vim.VimFault {
         }
         interface StorageDrsCannotMoveVmWithMountedCDROM extends vimService.vim.VimFault {
         }
         interface StorageDrsCannotMoveVmWithNoFilesInLayout extends vimService.vim.VimFault {
         }
         interface StorageDrsDatacentersCannotShareDatastore extends vimService.vim.VimFault {
         }
         interface StorageDrsDisabledOnVm extends vimService.vim.VimFault {
         }
         interface StorageDrsHbrDiskNotMovable extends vimService.vim.VimFault {
            nonMovableDiskIds: string;
         }
         interface StorageDrsHmsMoveInProgress extends vimService.vim.VimFault {
         }
         interface StorageDrsHmsUnreachable extends vimService.vim.VimFault {
         }
         interface StorageDrsIolbDisabledInternally extends vimService.vim.VimFault {
         }
         interface StorageDrsRelocateDisabled extends vimService.vim.VimFault {
         }
         interface StorageDrsStaleHmsCollection extends vimService.vim.VimFault {
         }
         interface StorageDrsUnableToMoveFiles extends vimService.vim.VimFault {
         }
         interface StorageVMotionNotSupported extends vimService.vim.MigrationFeatureNotSupported {
         }
         interface StorageVmotionIncompatible extends vimService.vim.VirtualHardwareCompatibilityIssue {
            datastore?: vimService.vim.ManagedObjectReference;
         }
         interface SuspendedRelocateNotSupported extends vimService.vim.MigrationFault {
         }
         interface SwapDatastoreNotWritableOnHost extends vimService.vim.DatastoreNotWritableOnHost {
         }
         interface SwapDatastoreUnset extends vimService.vim.VimFault {
         }
         interface SwapPlacementOverrideNotSupported extends vimService.vim.InvalidVmConfig {
         }
         interface SwitchIpUnset extends vimService.vim.DvsFault {
         }
         interface SwitchNotInUpgradeMode extends vimService.vim.DvsFault {
         }
         interface TaskInProgress extends vimService.vim.VimFault {
            task: vimService.vim.ManagedObjectReference;
         }
         enum ThirdPartyLicenseAssignmentFailedReason {
            "licenseAssignmentFailed",
            "moduleNotInstalled",
         }
         interface ThirdPartyLicenseAssignmentFailed extends vimService.vim.RuntimeFault {
            host: vimService.vim.ManagedObjectReference;
            module: string;
            reason?: string;
         }
         interface Timedout extends vimService.vim.VimFault {
         }
         interface TooManyConcurrentNativeClones extends vimService.vim.FileFault {
         }
         interface TooManyConsecutiveOverrides extends vimService.vim.VimFault {
         }
         interface TooManyDevices extends vimService.vim.InvalidVmConfig {
         }
         interface TooManyDisksOnLegacyHost extends vimService.vim.MigrationFault {
            diskCount: number;
            timeoutDanger: boolean;
         }
         interface TooManyGuestLogons extends vimService.vim.GuestOperationsFault {
         }
         interface TooManyHosts extends vimService.vim.HostConnectFault {
         }
         interface TooManyNativeCloneLevels extends vimService.vim.FileFault {
         }
         interface TooManyNativeClonesOnFile extends vimService.vim.FileFault {
         }
         interface TooManySnapshotLevels extends vimService.vim.SnapshotFault {
         }
         interface ToolsAlreadyUpgraded extends vimService.vim.VmToolsUpgradeFault {
         }
         interface ToolsAutoUpgradeNotSupported extends vimService.vim.VmToolsUpgradeFault {
         }
         interface ToolsImageCopyFailed extends vimService.vim.VmToolsUpgradeFault {
         }
         interface ToolsImageNotAvailable extends vimService.vim.VmToolsUpgradeFault {
         }
         interface ToolsImageSignatureCheckFailed extends vimService.vim.VmToolsUpgradeFault {
         }
         interface ToolsInstallationInProgress extends vimService.vim.MigrationFault {
         }
         interface ToolsUnavailable extends vimService.vim.VimFault {
         }
         interface ToolsUpgradeCancelled extends vimService.vim.VmToolsUpgradeFault {
         }
         interface UnSupportedDatastoreForVFlash extends vimService.vim.UnsupportedDatastore {
            datastoreName: string;
            type: string;
         }
         interface UncommittedUndoableDisk extends vimService.vim.MigrationFault {
         }
         interface UnconfiguredPropertyValue extends vimService.vim.InvalidPropertyValue {
         }
         interface UncustomizableGuest extends vimService.vim.CustomizationFault {
            uncustomizableGuestOS: string;
         }
         interface UnexpectedCustomizationFault extends vimService.vim.CustomizationFault {
         }
         interface UnrecognizedHost extends vimService.vim.VimFault {
            hostName: string;
         }
         interface UnsharedSwapVMotionNotSupported extends vimService.vim.MigrationFeatureNotSupported {
         }
         interface UnsupportedDatastore extends vimService.vim.VmConfigFault {
            datastore?: vimService.vim.ManagedObjectReference;
         }
         interface UnsupportedGuest extends vimService.vim.InvalidVmConfig {
            unsupportedGuestOS: string;
         }
         interface UnsupportedVimApiVersion extends vimService.vim.VimFault {
            version?: string;
         }
         interface UnsupportedVmxLocation extends vimService.vim.VmConfigFault {
         }
         interface UnusedVirtualDiskBlocksNotScrubbed extends vimService.vim.DeviceBackingNotSupported {
         }
         interface UserNotFound extends vimService.vim.VimFault {
            principal: string;
            unresolved: boolean;
         }
         interface VAppConfigFault extends vimService.vim.VimFault {
         }
         interface VAppNotRunning extends vimService.vim.VmConfigFault {
         }
         interface VAppOperationInProgress extends vimService.vim.RuntimeFault {
         }
         interface VAppPropertyFault extends vimService.vim.VmConfigFault {
            id: string;
            category: string;
            label: string;
            type: string;
            value: string;
         }
         interface VAppTaskInProgress extends vimService.vim.TaskInProgress {
         }
         interface VFlashCacheHotConfigNotSupported extends vimService.vim.VmConfigFault {
         }
         enum VFlashModuleNotSupportedReason {
            "CacheModeNotSupported",
            "CacheConsistencyTypeNotSupported",
            "CacheBlockSizeNotSupported",
            "CacheReservationNotSupported",
            "DiskSizeNotSupported",
         }
         interface VFlashModuleNotSupported extends vimService.vim.VmConfigFault {
            vmName: string;
            moduleName: string;
            reason: string;
            hostName: string;
         }
         interface VFlashModuleVersionIncompatible extends vimService.vim.VimFault {
            moduleName: string;
            vmRequestModuleVersion: string;
            hostMinSupportedVerson: string;
            hostModuleVersion: string;
         }
         interface VMINotSupported extends vimService.vim.DeviceNotSupported {
         }
         interface VMOnConflictDVPort extends vimService.vim.CannotAccessNetwork {
         }
         interface VMOnVirtualIntranet extends vimService.vim.CannotAccessNetwork {
         }
         interface VMotionAcrossNetworkNotSupported extends vimService.vim.MigrationFeatureNotSupported {
         }
         interface VMotionInterfaceIssue extends vimService.vim.MigrationFault {
            atSourceHost: boolean;
            failedHost: string;
            failedHostEntity?: vimService.vim.ManagedObjectReference;
         }
         interface VMotionLinkCapacityLow extends vimService.vim.VMotionInterfaceIssue {
            network: string;
         }
         interface VMotionLinkDown extends vimService.vim.VMotionInterfaceIssue {
            network: string;
         }
         interface VMotionNotConfigured extends vimService.vim.VMotionInterfaceIssue {
         }
         interface VMotionNotLicensed extends vimService.vim.VMotionInterfaceIssue {
         }
         interface VMotionNotSupported extends vimService.vim.VMotionInterfaceIssue {
         }
         interface VMotionProtocolIncompatible extends vimService.vim.MigrationFault {
         }
         interface VimFault extends vimService.vim.MethodFault {
         }
         interface VirtualDiskBlocksNotFullyProvisioned extends vimService.vim.DeviceBackingNotSupported {
         }
         interface VirtualDiskModeNotSupported extends vimService.vim.DeviceNotSupported {
            mode: string;
         }
         interface VirtualEthernetCardNotSupported extends vimService.vim.DeviceNotSupported {
         }
         interface VirtualHardwareCompatibilityIssue extends vimService.vim.VmConfigFault {
         }
         interface VirtualHardwareVersionNotSupported extends vimService.vim.VirtualHardwareCompatibilityIssue {
            hostName: string;
            host: vimService.vim.ManagedObjectReference;
         }
         interface VmAlreadyExistsInDatacenter extends vimService.vim.InvalidFolder {
            host: vimService.vim.ManagedObjectReference;
            hostname: string;
            vm: Array<vimService.vim.ManagedObjectReference>;
         }
         interface VmConfigFault extends vimService.vim.VimFault {
         }
         interface VmConfigIncompatibleForFaultTolerance extends vimService.vim.VmConfigFault {
            fault?: vimService.vim.LocalizedMethodFault;
         }
         interface VmConfigIncompatibleForRecordReplay extends vimService.vim.VmConfigFault {
            fault?: vimService.vim.LocalizedMethodFault;
         }
         enum VmFaultToleranceConfigIssueReasonForIssue {
            "haNotEnabled",
            "moreThanOneSecondary",
            "recordReplayNotSupported",
            "replayNotSupported",
            "templateVm",
            "multipleVCPU",
            "hostInactive",
            "ftUnsupportedHardware",
            "ftUnsupportedProduct",
            "missingVMotionNic",
            "missingFTLoggingNic",
            "thinDisk",
            "verifySSLCertificateFlagNotSet",
            "hasSnapshots",
            "noConfig",
            "ftSecondaryVm",
            "hasLocalDisk",
            "esxAgentVm",
            "video3dEnabled",
            "hasUnsupportedDisk",
            "insufficientBandwidth",
            "hasNestedHVConfiguration",
            "hasVFlashConfiguration",
            "unsupportedProduct",
            "cpuHvUnsupported",
            "cpuHwmmuUnsupported",
            "cpuHvDisabled",
            "hasEFIFirmware",
         }
         interface VmFaultToleranceConfigIssue extends vimService.vim.VmFaultToleranceIssue {
            reason?: string;
            entityName?: string;
            entity?: vimService.vim.ManagedObjectReference;
         }
         interface VmFaultToleranceConfigIssueWrapper extends vimService.vim.VmFaultToleranceIssue {
            entityName?: string;
            entity?: vimService.vim.ManagedObjectReference;
            error?: vimService.vim.LocalizedMethodFault;
         }
         enum VmFaultToleranceInvalidFileBackingDeviceType {
            "virtualFloppy",
            "virtualCdrom",
            "virtualSerialPort",
            "virtualParallelPort",
            "virtualDisk",
         }
         interface VmFaultToleranceInvalidFileBacking extends vimService.vim.VmFaultToleranceIssue {
            backingType?: string;
            backingFilename?: string;
         }
         interface VmFaultToleranceIssue extends vimService.vim.VimFault {
         }
         interface VmFaultToleranceOpIssuesList extends vimService.vim.VmFaultToleranceIssue {
            errors?: Array<vimService.vim.LocalizedMethodFault>;
            warnings?: Array<vimService.vim.LocalizedMethodFault>;
         }
         interface VmFaultToleranceTooManyFtVcpusOnHost extends vimService.vim.InsufficientResourcesFault {
            hostName?: string;
            maxNumFtVcpus: number;
         }
         interface VmFaultToleranceTooManyVMsOnHost extends vimService.vim.InsufficientResourcesFault {
            hostName?: string;
            maxNumFtVms: number;
         }
         interface VmHostAffinityRuleViolation extends vimService.vim.VmConfigFault {
            vmName: string;
            hostName: string;
         }
         interface VmLimitLicense extends vimService.vim.NotEnoughLicenses {
            limit: number;
         }
         interface VmMetadataManagerFault extends vimService.vim.VimFault {
         }
         interface VmMonitorIncompatibleForFaultTolerance extends vimService.vim.VimFault {
         }
         interface VmPowerOnDisabled extends vimService.vim.InvalidState {
         }
         interface VmSmpFaultToleranceTooManyVMsOnHost extends vimService.vim.InsufficientResourcesFault {
            hostName?: string;
            maxNumSmpFtVms: number;
         }
         interface VmToolsUpgradeFault extends vimService.vim.VimFault {
         }
         interface VmValidateMaxDevice extends vimService.vim.VimFault {
            device: string;
            max: number;
            count: number;
         }
         interface VmWwnConflict extends vimService.vim.InvalidVmConfig {
            vm?: vimService.vim.ManagedObjectReference;
            host?: vimService.vim.ManagedObjectReference;
            name?: string;
            wwn?: number;
         }
         interface VmfsAlreadyMounted extends vimService.vim.VmfsMountFault {
         }
         interface VmfsAmbiguousMount extends vimService.vim.VmfsMountFault {
         }
         interface VmfsMountFault extends vimService.vim.HostConfigFault {
            uuid: string;
         }
         interface VmotionInterfaceNotEnabled extends vimService.vim.HostPowerOpFailed {
         }
         interface VolumeEditorError extends vimService.vim.CustomizationFault {
         }
         interface VramLimitLicense extends vimService.vim.NotEnoughLicenses {
            limit: number;
         }
         interface VsanClusterUuidMismatch extends vimService.vim.CannotMoveVsanEnabledHost {
            hostClusterUuid: string;
            destinationClusterUuid: string;
         }
         interface VsanDiskFault extends vimService.vim.VsanFault {
            device?: string;
         }
         interface VsanFault extends vimService.vim.VimFault {
         }
         interface VsanIncompatibleDiskMapping extends vimService.vim.VsanDiskFault {
         }
         interface VspanDestPortConflict extends vimService.vim.DvsFault {
            vspanSessionKey1: string;
            vspanSessionKey2: string;
            portKey: string;
         }
         interface VspanPortConflict extends vimService.vim.DvsFault {
            vspanSessionKey1: string;
            vspanSessionKey2: string;
            portKey: string;
         }
         interface VspanPortMoveFault extends vimService.vim.DvsFault {
            srcPortgroupName: string;
            destPortgroupName: string;
            portKey: string;
         }
         interface VspanPortPromiscChangeFault extends vimService.vim.DvsFault {
            portKey: string;
         }
         interface VspanPortgroupPromiscChangeFault extends vimService.vim.DvsFault {
            portgroupName: string;
         }
         interface VspanPortgroupTypeChangeFault extends vimService.vim.DvsFault {
            portgroupName: string;
         }
         interface VspanPromiscuousPortNotSupported extends vimService.vim.DvsFault {
            vspanSessionKey: string;
            portKey: string;
         }
         interface VspanSameSessionPortConflict extends vimService.vim.DvsFault {
            vspanSessionKey: string;
            portKey: string;
         }
         interface WakeOnLanNotSupported extends vimService.vim.VirtualHardwareCompatibilityIssue {
         }
         interface WakeOnLanNotSupportedByVmotionNIC extends vimService.vim.HostPowerOpFailed {
         }
         enum WillLoseHAProtectionResolution {
            "svmotion",
            "relocate",
         }
         interface WillLoseHAProtection extends vimService.vim.MigrationFault {
            resolution: string;
         }
         interface WillModifyConfigCpuRequirements extends vimService.vim.MigrationFault {
         }
         interface WillResetSnapshotDirectory extends vimService.vim.MigrationFault {
         }
         interface WipeDiskFault extends vimService.vim.VimFault {
         }
         enum HostActiveDirectoryAuthenticationCertificateDigest {
            "SHA1",
         }
         enum HostActiveDirectoryInfoDomainMembershipStatus {
            "unknown",
            "ok",
            "noServers",
            "clientTrustBroken",
            "serverTrustBroken",
            "inconsistentTrust",
            "otherProblem",
         }
         interface HostActiveDirectoryInfo extends vimService.vim.HostDirectoryStoreInfo {
            joinedDomain?: string;
            trustedDomain?: Array<string>;
            domainMembershipStatus?: string;
            smartCardAuthenticationEnabled?: boolean;
         }
         interface HostActiveDirectorySpec extends vimService.vim.DynamicData {
            domainName?: string;
            userName?: string;
            password?: string;
            camServer?: string;
            thumbprint?: string;
            smartCardAuthenticationEnabled?: boolean;
            smartCardTrustAnchors?: Array<string>;
         }
         interface HostActiveDirectory extends vimService.vim.DynamicData {
            changeOperation: string;
            spec?: vimService.vim.HostActiveDirectorySpec;
         }
         interface ArrayOfHostActiveDirectory {
            HostActiveDirectory?: Array<vimService.vim.HostActiveDirectory>;
         }
         interface HostAuthenticationManagerInfo extends vimService.vim.DynamicData {
            authConfig: Array<vimService.vim.HostAuthenticationStoreInfo>;
         }
         interface HostAuthenticationStoreInfo extends vimService.vim.DynamicData {
            enabled: boolean;
         }
         interface ArrayOfHostAuthenticationStoreInfo {
            HostAuthenticationStoreInfo?: Array<vimService.vim.HostAuthenticationStoreInfo>;
         }
         enum AutoStartAction {
            "none",
            "systemDefault",
            "powerOn",
            "powerOff",
            "guestShutdown",
            "suspend",
         }
         interface AutoStartDefaults extends vimService.vim.DynamicData {
            enabled?: boolean;
            startDelay?: number;
            stopDelay?: number;
            waitForHeartbeat?: boolean;
            stopAction?: string;
         }
         enum AutoStartWaitHeartbeatSetting {
            "yes",
            "no",
            "systemDefault",
         }
         interface AutoStartPowerInfo extends vimService.vim.DynamicData {
            key: vimService.vim.ManagedObjectReference;
            startOrder: number;
            startDelay: number;
            waitForHeartbeat: vimService.vim.AutoStartWaitHeartbeatSetting;
            startAction: string;
            stopDelay: number;
            stopAction: string;
         }
         interface ArrayOfAutoStartPowerInfo {
            AutoStartPowerInfo?: Array<vimService.vim.AutoStartPowerInfo>;
         }
         interface HostAutoStartManagerConfig extends vimService.vim.DynamicData {
            defaults?: vimService.vim.AutoStartDefaults;
            powerInfo?: Array<vimService.vim.AutoStartPowerInfo>;
         }
         interface HostBootDeviceInfo extends vimService.vim.DynamicData {
            bootDevices?: Array<vimService.vim.HostBootDevice>;
            currentBootDeviceKey?: string;
         }
         interface HostBootDevice extends vimService.vim.DynamicData {
            key: string;
            description: string;
         }
         interface ArrayOfHostBootDevice {
            HostBootDevice?: Array<vimService.vim.HostBootDevice>;
         }
         interface HostCacheConfigurationSpec extends vimService.vim.DynamicData {
            datastore: vimService.vim.ManagedObjectReference;
            swapSize: number;
         }
         interface HostCacheConfigurationInfo extends vimService.vim.DynamicData {
            key: vimService.vim.ManagedObjectReference;
            swapSize: number;
         }
         interface ArrayOfHostCacheConfigurationInfo {
            HostCacheConfigurationInfo?: Array<vimService.vim.HostCacheConfigurationInfo>;
         }
         enum HostReplayUnsupportedReason {
            "incompatibleProduct",
            "incompatibleCpu",
            "hvDisabled",
            "cpuidLimitSet",
            "oldBIOS",
            "unknown",
         }
         enum HostCapabilityFtUnsupportedReason {
            "vMotionNotLicensed",
            "missingVMotionNic",
            "missingFTLoggingNic",
            "ftNotLicensed",
            "haAgentIssue",
            "unsupportedProduct",
            "cpuHvUnsupported",
            "cpuHwmmuUnsupported",
            "cpuHvDisabled",
         }
         enum HostCapabilityVmDirectPathGen2UnsupportedReason {
            "hostNptIncompatibleProduct",
            "hostNptIncompatibleHardware",
            "hostNptDisabled",
         }
         interface HostCapability extends vimService.vim.DynamicData {
            recursiveResourcePoolsSupported: boolean;
            cpuMemoryResourceConfigurationSupported: boolean;
            rebootSupported: boolean;
            shutdownSupported: boolean;
            vmotionSupported: boolean;
            standbySupported: boolean;
            ipmiSupported?: boolean;
            maxSupportedVMs?: number;
            maxRunningVMs?: number;
            maxSupportedVcpus?: number;
            maxRegisteredVMs?: number;
            datastorePrincipalSupported: boolean;
            sanSupported: boolean;
            nfsSupported: boolean;
            iscsiSupported: boolean;
            vlanTaggingSupported: boolean;
            nicTeamingSupported: boolean;
            highGuestMemSupported: boolean;
            maintenanceModeSupported: boolean;
            suspendedRelocateSupported: boolean;
            restrictedSnapshotRelocateSupported: boolean;
            perVmSwapFiles: boolean;
            localSwapDatastoreSupported: boolean;
            unsharedSwapVMotionSupported: boolean;
            backgroundSnapshotsSupported: boolean;
            preAssignedPCIUnitNumbersSupported: boolean;
            screenshotSupported: boolean;
            scaledScreenshotSupported: boolean;
            storageVMotionSupported?: boolean;
            vmotionWithStorageVMotionSupported?: boolean;
            vmotionAcrossNetworkSupported?: boolean;
            maxNumDisksSVMotion?: number;
            hbrNicSelectionSupported?: boolean;
            vrNfcNicSelectionSupported?: boolean;
            recordReplaySupported?: boolean;
            ftSupported?: boolean;
            replayUnsupportedReason?: string;
            replayCompatibilityIssues?: Array<string>;
            smpFtSupported?: boolean;
            ftCompatibilityIssues?: Array<string>;
            smpFtCompatibilityIssues?: Array<string>;
            maxVcpusPerFtVm?: number;
            loginBySSLThumbprintSupported?: boolean;
            cloneFromSnapshotSupported?: boolean;
            deltaDiskBackingsSupported?: boolean;
            perVMNetworkTrafficShapingSupported?: boolean;
            tpmSupported?: boolean;
            supportedCpuFeature?: Array<vimService.vim.HostCpuIdInfo>;
            virtualExecUsageSupported?: boolean;
            storageIORMSupported?: boolean;
            vmDirectPathGen2Supported?: boolean;
            vmDirectPathGen2UnsupportedReason?: Array<string>;
            vmDirectPathGen2UnsupportedReasonExtended?: string;
            supportedVmfsMajorVersion?: Array<number>;
            vStorageCapable?: boolean;
            snapshotRelayoutSupported?: boolean;
            firewallIpRulesSupported?: boolean;
            servicePackageInfoSupported?: boolean;
            maxHostRunningVms?: number;
            maxHostSupportedVcpus?: number;
            vmfsDatastoreMountCapable?: boolean;
            eightPlusHostVmfsSharedAccessSupported?: boolean;
            nestedHVSupported?: boolean;
            vPMCSupported?: boolean;
            interVMCommunicationThroughVMCISupported?: boolean;
            scheduledHardwareUpgradeSupported?: boolean;
            featureCapabilitiesSupported?: boolean;
            latencySensitivitySupported?: boolean;
            storagePolicySupported?: boolean;
            accel3dSupported?: boolean;
            reliableMemoryAware?: boolean;
            multipleNetworkStackInstanceSupported?: boolean;
            messageBusProxySupported?: boolean;
            vsanSupported?: boolean;
            vFlashSupported?: boolean;
            hostAccessManagerSupported?: boolean;
            provisioningNicSelectionSupported?: boolean;
            nfs41Supported?: boolean;
            nfs41Krb5iSupported?: boolean;
            turnDiskLocatorLedSupported?: boolean;
            virtualVolumeDatastoreSupported?: boolean;
            markAsSsdSupported?: boolean;
            markAsLocalSupported?: boolean;
            smartCardAuthenticationSupported?: boolean;
            cryptoSupported?: boolean;
            oneKVolumeAPIsSupported?: boolean;
            gatewayOnNicSupported?: boolean;
            upitSupported?: boolean;
            cpuHwMmuSupported?: boolean;
            encryptedVMotionSupported?: boolean;
            encryptionChangeOnAddRemoveSupported?: boolean;
            encryptionHotOperationSupported?: boolean;
            encryptionWithSnapshotsSupported?: boolean;
            encryptionFaultToleranceSupported?: boolean;
            encryptionMemorySaveSupported?: boolean;
            encryptionRDMSupported?: boolean;
            encryptionVFlashSupported?: boolean;
            encryptionCBRCSupported?: boolean;
            encryptionHBRSupported?: boolean;
         }
         enum HostCertificateManagerCertificateInfoCertificateStatus {
            "unknown",
            "expired",
            "expiring",
            "expiringShortly",
            "expirationImminent",
            "good",
         }
         interface HostCertificateManagerCertificateInfo extends vimService.vim.DynamicData {
            issuer?: string;
            notBefore?: Date;
            notAfter?: Date;
            subject?: string;
            status: string;
         }
         enum HostConfigChangeMode {
            "modify",
            "replace",
         }
         enum HostConfigChangeOperation {
            "add",
            "remove",
            "edit",
            "ignore",
         }
         interface HostConfigChange extends vimService.vim.DynamicData {
         }
         interface HostConfigInfo extends vimService.vim.DynamicData {
            host: vimService.vim.ManagedObjectReference;
            product: vimService.vim.AboutInfo;
            deploymentInfo?: vimService.vim.HostDeploymentInfo;
            hyperThread?: vimService.vim.HostHyperThreadScheduleInfo;
            consoleReservation?: vimService.vim.ServiceConsoleReservationInfo;
            virtualMachineReservation?: vimService.vim.VirtualMachineMemoryReservationInfo;
            storageDevice?: vimService.vim.HostStorageDeviceInfo;
            multipathState?: vimService.vim.HostMultipathStateInfo;
            fileSystemVolume?: vimService.vim.HostFileSystemVolumeInfo;
            systemFile?: Array<string>;
            network?: vimService.vim.HostNetworkInfo;
            vmotion?: vimService.vim.HostVMotionInfo;
            virtualNicManagerInfo?: vimService.vim.HostVirtualNicManagerInfo;
            capabilities?: vimService.vim.HostNetCapabilities;
            datastoreCapabilities?: vimService.vim.HostDatastoreSystemCapabilities;
            offloadCapabilities?: vimService.vim.HostNetOffloadCapabilities;
            service?: vimService.vim.HostServiceInfo;
            firewall?: vimService.vim.HostFirewallInfo;
            autoStart?: vimService.vim.HostAutoStartManagerConfig;
            activeDiagnosticPartition?: vimService.vim.HostDiagnosticPartition;
            option?: Array<vimService.vim.OptionValue>;
            optionDef?: Array<vimService.vim.OptionDef>;
            datastorePrincipal?: string;
            localSwapDatastore?: vimService.vim.ManagedObjectReference;
            systemSwapConfiguration?: vimService.vim.HostSystemSwapConfiguration;
            systemResources?: vimService.vim.HostSystemResourceInfo;
            dateTimeInfo?: vimService.vim.HostDateTimeInfo;
            flags?: vimService.vim.HostFlagInfo;
            adminDisabled?: boolean;
            lockdownMode?: vimService.vim.HostLockdownMode;
            ipmi?: vimService.vim.HostIpmiInfo;
            sslThumbprintInfo?: vimService.vim.HostSslThumbprintInfo;
            sslThumbprintData?: Array<vimService.vim.HostSslThumbprintInfo>;
            certificate?: Array<number>;
            pciPassthruInfo?: Array<vimService.vim.HostPciPassthruInfo>;
            authenticationManagerInfo?: vimService.vim.HostAuthenticationManagerInfo;
            featureVersion?: Array<vimService.vim.HostFeatureVersionInfo>;
            powerSystemCapability?: vimService.vim.PowerSystemCapability;
            powerSystemInfo?: vimService.vim.PowerSystemInfo;
            cacheConfigurationInfo?: Array<vimService.vim.HostCacheConfigurationInfo>;
            wakeOnLanCapable?: boolean;
            featureCapability?: Array<vimService.vim.HostFeatureCapability>;
            maskedFeatureCapability?: Array<vimService.vim.HostFeatureCapability>;
            vFlashConfigInfo?: vimService.vim.HostVFlashManagerVFlashConfigInfo;
            vsanHostConfig?: vimService.vim.VsanHostConfigInfo;
            domainList?: Array<string>;
            scriptCheckSum?: string;
            hostConfigCheckSum?: string;
            graphicsInfo?: Array<vimService.vim.HostGraphicsInfo>;
            sharedPassthruGpuTypes?: Array<string>;
            graphicsConfig?: vimService.vim.HostGraphicsConfig;
            ioFilterInfo?: Array<vimService.vim.HostIoFilterInfo>;
            sriovDevicePool?: Array<vimService.vim.HostSriovDevicePoolInfo>;
         }
         interface HostConfigManager extends vimService.vim.DynamicData {
            cpuScheduler?: vimService.vim.ManagedObjectReference;
            datastoreSystem?: vimService.vim.ManagedObjectReference;
            memoryManager?: vimService.vim.ManagedObjectReference;
            storageSystem?: vimService.vim.ManagedObjectReference;
            networkSystem?: vimService.vim.ManagedObjectReference;
            vmotionSystem?: vimService.vim.ManagedObjectReference;
            virtualNicManager?: vimService.vim.ManagedObjectReference;
            serviceSystem?: vimService.vim.ManagedObjectReference;
            firewallSystem?: vimService.vim.ManagedObjectReference;
            advancedOption?: vimService.vim.ManagedObjectReference;
            diagnosticSystem?: vimService.vim.ManagedObjectReference;
            autoStartManager?: vimService.vim.ManagedObjectReference;
            snmpSystem?: vimService.vim.ManagedObjectReference;
            dateTimeSystem?: vimService.vim.ManagedObjectReference;
            patchManager?: vimService.vim.ManagedObjectReference;
            imageConfigManager?: vimService.vim.ManagedObjectReference;
            bootDeviceSystem?: vimService.vim.ManagedObjectReference;
            firmwareSystem?: vimService.vim.ManagedObjectReference;
            healthStatusSystem?: vimService.vim.ManagedObjectReference;
            pciPassthruSystem?: vimService.vim.ManagedObjectReference;
            licenseManager?: vimService.vim.ManagedObjectReference;
            kernelModuleSystem?: vimService.vim.ManagedObjectReference;
            authenticationManager?: vimService.vim.ManagedObjectReference;
            powerSystem?: vimService.vim.ManagedObjectReference;
            cacheConfigurationManager?: vimService.vim.ManagedObjectReference;
            esxAgentHostManager?: vimService.vim.ManagedObjectReference;
            iscsiManager?: vimService.vim.ManagedObjectReference;
            vFlashManager?: vimService.vim.ManagedObjectReference;
            vsanSystem?: vimService.vim.ManagedObjectReference;
            messageBusProxy?: vimService.vim.ManagedObjectReference;
            userDirectory?: vimService.vim.ManagedObjectReference;
            accountManager?: vimService.vim.ManagedObjectReference;
            hostAccessManager?: vimService.vim.ManagedObjectReference;
            graphicsManager?: vimService.vim.ManagedObjectReference;
            vsanInternalSystem?: vimService.vim.ManagedObjectReference;
            certificateManager?: vimService.vim.ManagedObjectReference;
            cryptoManager?: vimService.vim.ManagedObjectReference;
         }
         interface HostConfigSpec extends vimService.vim.DynamicData {
            nasDatastore?: Array<vimService.vim.HostNasVolumeConfig>;
            network?: vimService.vim.HostNetworkConfig;
            nicTypeSelection?: Array<vimService.vim.HostVirtualNicManagerNicTypeSelection>;
            service?: Array<vimService.vim.HostServiceConfig>;
            firewall?: vimService.vim.HostFirewallConfig;
            option?: Array<vimService.vim.OptionValue>;
            datastorePrincipal?: string;
            datastorePrincipalPasswd?: string;
            datetime?: vimService.vim.HostDateTimeConfig;
            storageDevice?: vimService.vim.HostStorageDeviceInfo;
            license?: vimService.vim.HostLicenseSpec;
            security?: vimService.vim.HostSecuritySpec;
            userAccount?: Array<vimService.vim.HostAccountSpec>;
            usergroupAccount?: Array<vimService.vim.HostAccountSpec>;
            memory?: vimService.vim.HostMemorySpec;
            activeDirectory?: Array<vimService.vim.HostActiveDirectory>;
            genericConfig?: Array<vimService.vim.KeyAnyValue>;
            graphicsConfig?: vimService.vim.HostGraphicsConfig;
         }
         interface HostConnectInfoNetworkInfo extends vimService.vim.DynamicData {
            summary: vimService.vim.NetworkSummary;
         }
         interface ArrayOfHostConnectInfoNetworkInfo {
            HostConnectInfoNetworkInfo?: Array<vimService.vim.HostConnectInfoNetworkInfo>;
         }
         interface HostNewNetworkConnectInfo extends vimService.vim.HostConnectInfoNetworkInfo {
         }
         interface HostDatastoreConnectInfo extends vimService.vim.DynamicData {
            summary: vimService.vim.DatastoreSummary;
         }
         interface ArrayOfHostDatastoreConnectInfo {
            HostDatastoreConnectInfo?: Array<vimService.vim.HostDatastoreConnectInfo>;
         }
         interface HostDatastoreExistsConnectInfo extends vimService.vim.HostDatastoreConnectInfo {
            newDatastoreName: string;
         }
         interface HostDatastoreNameConflictConnectInfo extends vimService.vim.HostDatastoreConnectInfo {
            newDatastoreName: string;
         }
         interface HostLicenseConnectInfo extends vimService.vim.DynamicData {
            license: vimService.vim.LicenseManagerLicenseInfo;
            evaluation: vimService.vim.LicenseManagerEvaluationInfo;
            resource?: vimService.vim.HostLicensableResourceInfo;
         }
         interface HostConnectInfo extends vimService.vim.DynamicData {
            serverIp?: string;
            inDasCluster?: boolean;
            host: vimService.vim.HostListSummary;
            vm?: Array<vimService.vim.VirtualMachineSummary>;
            vimAccountNameRequired?: boolean;
            clusterSupported?: boolean;
            network?: Array<vimService.vim.HostConnectInfoNetworkInfo>;
            datastore?: Array<vimService.vim.HostDatastoreConnectInfo>;
            license?: vimService.vim.HostLicenseConnectInfo;
            capability?: vimService.vim.HostCapability;
         }
         interface HostConnectSpec extends vimService.vim.DynamicData {
            hostName?: string;
            port?: number;
            sslThumbprint?: string;
            userName?: string;
            password?: string;
            vmFolder?: vimService.vim.ManagedObjectReference;
            force: boolean;
            vimAccountName?: string;
            vimAccountPassword?: string;
            managementIp?: string;
            lockdownMode?: vimService.vim.HostLockdownMode;
            hostGateway?: vimService.vim.HostGatewaySpec;
         }
         interface HostCpuIdInfo extends vimService.vim.DynamicData {
            level: number;
            vendor?: string;
            eax?: string;
            ebx?: string;
            ecx?: string;
            edx?: string;
         }
         interface ArrayOfHostCpuIdInfo {
            HostCpuIdInfo?: Array<vimService.vim.HostCpuIdInfo>;
         }
         interface HostHyperThreadScheduleInfo extends vimService.vim.DynamicData {
            available: boolean;
            active: boolean;
            config: boolean;
         }
         interface FileQueryFlags extends vimService.vim.DynamicData {
            fileType: boolean;
            fileSize: boolean;
            modification: boolean;
            fileOwner?: boolean;
         }
         interface FileInfo extends vimService.vim.DynamicData {
            path: string;
            friendlyName?: string;
            fileSize?: number;
            modification?: Date;
            owner?: string;
         }
         interface ArrayOfFileInfo {
            FileInfo?: Array<vimService.vim.FileInfo>;
         }
         interface FileQuery extends vimService.vim.DynamicData {
         }
         interface ArrayOfFileQuery {
            FileQuery?: Array<vimService.vim.FileQuery>;
         }
         interface VmConfigFileQueryFilter extends vimService.vim.DynamicData {
            matchConfigVersion?: Array<number>;
            encrypted?: boolean;
         }
         interface VmConfigFileQueryFlags extends vimService.vim.DynamicData {
            configVersion: boolean;
            encryption?: boolean;
         }
         interface VmConfigFileQuery extends vimService.vim.FileQuery {
            filter?: vimService.vim.VmConfigFileQueryFilter;
            details?: vimService.vim.VmConfigFileQueryFlags;
         }
         interface TemplateConfigFileQuery extends vimService.vim.VmConfigFileQuery {
         }
         interface VmDiskFileQueryFilter extends vimService.vim.DynamicData {
            diskType?: Array<string>;
            matchHardwareVersion?: Array<number>;
            controllerType?: Array<string>;
            thin?: boolean;
            encrypted?: boolean;
         }
         interface VmDiskFileQueryFlags extends vimService.vim.DynamicData {
            diskType: boolean;
            capacityKb: boolean;
            hardwareVersion: boolean;
            controllerType?: boolean;
            diskExtents?: boolean;
            thin?: boolean;
            encryption?: boolean;
         }
         interface VmDiskFileQuery extends vimService.vim.FileQuery {
            filter?: vimService.vim.VmDiskFileQueryFilter;
            details?: vimService.vim.VmDiskFileQueryFlags;
         }
         interface FolderFileQuery extends vimService.vim.FileQuery {
         }
         interface VmSnapshotFileQuery extends vimService.vim.FileQuery {
         }
         interface IsoImageFileQuery extends vimService.vim.FileQuery {
         }
         interface FloppyImageFileQuery extends vimService.vim.FileQuery {
         }
         interface VmNvramFileQuery extends vimService.vim.FileQuery {
         }
         interface VmLogFileQuery extends vimService.vim.FileQuery {
         }
         interface VmConfigFileEncryptionInfo extends vimService.vim.DynamicData {
            keyId?: vimService.vim.CryptoKeyId;
         }
         interface VmConfigFileInfo extends vimService.vim.FileInfo {
            configVersion?: number;
            encryption?: vimService.vim.VmConfigFileEncryptionInfo;
         }
         interface TemplateConfigFileInfo extends vimService.vim.VmConfigFileInfo {
         }
         interface VmDiskFileEncryptionInfo extends vimService.vim.DynamicData {
            keyId?: vimService.vim.CryptoKeyId;
         }
         interface VmDiskFileInfo extends vimService.vim.FileInfo {
            diskType?: string;
            capacityKb?: number;
            hardwareVersion?: number;
            controllerType?: string;
            diskExtents?: Array<string>;
            thin?: boolean;
            encryption?: vimService.vim.VmDiskFileEncryptionInfo;
         }
         interface FolderFileInfo extends vimService.vim.FileInfo {
         }
         interface VmSnapshotFileInfo extends vimService.vim.FileInfo {
         }
         interface IsoImageFileInfo extends vimService.vim.FileInfo {
         }
         interface FloppyImageFileInfo extends vimService.vim.FileInfo {
         }
         interface VmNvramFileInfo extends vimService.vim.FileInfo {
         }
         interface VmLogFileInfo extends vimService.vim.FileInfo {
         }
         interface HostDatastoreBrowserSearchSpec extends vimService.vim.DynamicData {
            query?: Array<vimService.vim.FileQuery>;
            details?: vimService.vim.FileQueryFlags;
            searchCaseInsensitive?: boolean;
            matchPattern?: Array<string>;
            sortFoldersFirst?: boolean;
         }
         interface HostDatastoreBrowserSearchResults extends vimService.vim.DynamicData {
            datastore?: vimService.vim.ManagedObjectReference;
            folderPath?: string;
            file?: Array<vimService.vim.FileInfo>;
         }
         interface ArrayOfHostDatastoreBrowserSearchResults {
            HostDatastoreBrowserSearchResults?: Array<vimService.vim.HostDatastoreBrowserSearchResults>;
         }
         interface HostDatastoreSystemCapabilities extends vimService.vim.DynamicData {
            nfsMountCreationRequired: boolean;
            nfsMountCreationSupported: boolean;
            localDatastoreSupported: boolean;
            vmfsExtentExpansionSupported?: boolean;
         }
         interface HostDatastoreSystemVvolDatastoreSpec extends vimService.vim.DynamicData {
            name: string;
            scId: string;
         }
         interface HostDatastoreSystemDatastoreResult extends vimService.vim.DynamicData {
            key: vimService.vim.ManagedObjectReference;
            fault?: vimService.vim.LocalizedMethodFault;
         }
         interface ArrayOfHostDatastoreSystemDatastoreResult {
            HostDatastoreSystemDatastoreResult?: Array<vimService.vim.HostDatastoreSystemDatastoreResult>;
         }
         interface VmfsDatastoreInfo extends vimService.vim.DatastoreInfo {
            maxPhysicalRDMFileSize?: number;
            maxVirtualRDMFileSize?: number;
            vmfs?: vimService.vim.HostVmfsVolume;
         }
         interface NasDatastoreInfo extends vimService.vim.DatastoreInfo {
            nas?: vimService.vim.HostNasVolume;
         }
         interface LocalDatastoreInfo extends vimService.vim.DatastoreInfo {
            path?: string;
         }
         interface VmfsDatastoreSpec extends vimService.vim.DynamicData {
            diskUuid: string;
         }
         interface VmfsDatastoreCreateSpec extends vimService.vim.VmfsDatastoreSpec {
            partition: vimService.vim.HostDiskPartitionSpec;
            vmfs: vimService.vim.HostVmfsSpec;
            extent?: Array<vimService.vim.HostScsiDiskPartition>;
         }
         interface VmfsDatastoreExtendSpec extends vimService.vim.VmfsDatastoreSpec {
            partition: vimService.vim.HostDiskPartitionSpec;
            extent: Array<vimService.vim.HostScsiDiskPartition>;
         }
         interface VmfsDatastoreExpandSpec extends vimService.vim.VmfsDatastoreSpec {
            partition: vimService.vim.HostDiskPartitionSpec;
            extent: vimService.vim.HostScsiDiskPartition;
         }
         interface VmfsDatastoreBaseOption extends vimService.vim.DynamicData {
            layout: vimService.vim.HostDiskPartitionLayout;
            partitionFormatChange?: boolean;
         }
         interface VmfsDatastoreSingleExtentOption extends vimService.vim.VmfsDatastoreBaseOption {
            vmfsExtent: vimService.vim.HostDiskPartitionBlockRange;
         }
         interface VmfsDatastoreAllExtentOption extends vimService.vim.VmfsDatastoreSingleExtentOption {
         }
         interface VmfsDatastoreMultipleExtentOption extends vimService.vim.VmfsDatastoreBaseOption {
            vmfsExtent: Array<vimService.vim.HostDiskPartitionBlockRange>;
         }
         interface VmfsDatastoreOption extends vimService.vim.DynamicData {
            info: vimService.vim.VmfsDatastoreBaseOption;
            spec: vimService.vim.VmfsDatastoreSpec;
         }
         interface ArrayOfVmfsDatastoreOption {
            VmfsDatastoreOption?: Array<vimService.vim.VmfsDatastoreOption>;
         }
         interface VvolDatastoreInfo extends vimService.vim.DatastoreInfo {
            vvolDS?: vimService.vim.HostVvolVolume;
         }
         interface HostDateTimeConfig extends vimService.vim.DynamicData {
            timeZone?: string;
            ntpConfig?: vimService.vim.HostNtpConfig;
         }
         interface HostDateTimeInfo extends vimService.vim.DynamicData {
            timeZone: vimService.vim.HostDateTimeSystemTimeZone;
            ntpConfig?: vimService.vim.HostNtpConfig;
         }
         interface HostDateTimeSystemTimeZone extends vimService.vim.DynamicData {
            key: string;
            name: string;
            description: string;
            gmtOffset: number;
         }
         interface ArrayOfHostDateTimeSystemTimeZone {
            HostDateTimeSystemTimeZone?: Array<vimService.vim.HostDateTimeSystemTimeZone>;
         }
         interface HostDeploymentInfo extends vimService.vim.DynamicData {
            bootedFromStatelessCache?: boolean;
         }
         interface HostDevice extends vimService.vim.DynamicData {
            deviceName: string;
            deviceType: string;
         }
         interface HostDhcpServiceSpec extends vimService.vim.DynamicData {
            virtualSwitch: string;
            defaultLeaseDuration: number;
            leaseBeginIp: string;
            leaseEndIp: string;
            maxLeaseDuration: number;
            unlimitedLease: boolean;
            ipSubnetAddr: string;
            ipSubnetMask: string;
         }
         interface HostDhcpServiceConfig extends vimService.vim.DynamicData {
            changeOperation?: string;
            key: string;
            spec: vimService.vim.HostDhcpServiceSpec;
         }
         interface ArrayOfHostDhcpServiceConfig {
            HostDhcpServiceConfig?: Array<vimService.vim.HostDhcpServiceConfig>;
         }
         interface HostDhcpService extends vimService.vim.DynamicData {
            key: string;
            spec: vimService.vim.HostDhcpServiceSpec;
         }
         interface ArrayOfHostDhcpService {
            HostDhcpService?: Array<vimService.vim.HostDhcpService>;
         }
         enum DiagnosticPartitionStorageType {
            "directAttached",
            "networkAttached",
         }
         enum DiagnosticPartitionType {
            "singleHost",
            "multiHost",
         }
         interface HostDiagnosticPartitionCreateOption extends vimService.vim.DynamicData {
            storageType: string;
            diagnosticType: string;
            disk: vimService.vim.HostScsiDisk;
         }
         interface ArrayOfHostDiagnosticPartitionCreateOption {
            HostDiagnosticPartitionCreateOption?: Array<vimService.vim.HostDiagnosticPartitionCreateOption>;
         }
         interface HostDiagnosticPartitionCreateSpec extends vimService.vim.DynamicData {
            storageType: string;
            diagnosticType: string;
            id: vimService.vim.HostScsiDiskPartition;
            partition: vimService.vim.HostDiskPartitionSpec;
            active?: boolean;
         }
         interface HostDiagnosticPartitionCreateDescription extends vimService.vim.DynamicData {
            layout: vimService.vim.HostDiskPartitionLayout;
            diskUuid: string;
            spec: vimService.vim.HostDiagnosticPartitionCreateSpec;
         }
         interface HostDiagnosticPartition extends vimService.vim.DynamicData {
            storageType: string;
            diagnosticType: string;
            slots: number;
            id: vimService.vim.HostScsiDiskPartition;
         }
         interface ArrayOfHostDiagnosticPartition {
            HostDiagnosticPartition?: Array<vimService.vim.HostDiagnosticPartition>;
         }
         interface HostDirectoryStoreInfo extends vimService.vim.HostAuthenticationStoreInfo {
         }
         interface HostDiskConfigurationResult extends vimService.vim.DynamicData {
            devicePath?: string;
            success?: boolean;
            fault?: vimService.vim.LocalizedMethodFault;
         }
         interface ArrayOfHostDiskConfigurationResult {
            HostDiskConfigurationResult?: Array<vimService.vim.HostDiskConfigurationResult>;
         }
         interface HostDiskDimensionsChs extends vimService.vim.DynamicData {
            cylinder: number;
            head: number;
            sector: number;
         }
         interface HostDiskDimensionsLba extends vimService.vim.DynamicData {
            blockSize: number;
            block: number;
         }
         interface HostDiskDimensions extends vimService.vim.DynamicData {
         }
         enum HostDiskPartitionInfoPartitionFormat {
            "gpt",
            "mbr",
            "unknown",
         }
         enum HostDiskPartitionInfoType {
            "none",
            "vmfs",
            "linuxNative",
            "linuxSwap",
            "extended",
            "ntfs",
            "vmkDiagnostic",
            "vffs",
         }
         interface HostDiskPartitionAttributes extends vimService.vim.DynamicData {
            partition: number;
            startSector: number;
            endSector: number;
            type: string;
            guid?: string;
            logical: boolean;
            attributes: number;
            partitionAlignment?: number;
         }
         interface ArrayOfHostDiskPartitionAttributes {
            HostDiskPartitionAttributes?: Array<vimService.vim.HostDiskPartitionAttributes>;
         }
         interface HostDiskPartitionBlockRange extends vimService.vim.DynamicData {
            partition?: number;
            type: string;
            start: vimService.vim.HostDiskDimensionsLba;
            end: vimService.vim.HostDiskDimensionsLba;
         }
         interface ArrayOfHostDiskPartitionBlockRange {
            HostDiskPartitionBlockRange?: Array<vimService.vim.HostDiskPartitionBlockRange>;
         }
         interface HostDiskPartitionSpec extends vimService.vim.DynamicData {
            partitionFormat?: string;
            chs?: vimService.vim.HostDiskDimensionsChs;
            totalSectors?: number;
            partition?: Array<vimService.vim.HostDiskPartitionAttributes>;
         }
         interface HostDiskPartitionLayout extends vimService.vim.DynamicData {
            total?: vimService.vim.HostDiskDimensionsLba;
            partition: Array<vimService.vim.HostDiskPartitionBlockRange>;
         }
         interface HostDiskPartitionInfo extends vimService.vim.DynamicData {
            deviceName: string;
            spec: vimService.vim.HostDiskPartitionSpec;
            layout: vimService.vim.HostDiskPartitionLayout;
         }
         interface ArrayOfHostDiskPartitionInfo {
            HostDiskPartitionInfo?: Array<vimService.vim.HostDiskPartitionInfo>;
         }
         interface HostDnsConfig extends vimService.vim.DynamicData {
            dhcp: boolean;
            virtualNicDevice?: string;
            hostName: string;
            domainName: string;
            address?: Array<string>;
            searchDomain?: Array<string>;
         }
         interface HostDnsConfigSpec extends vimService.vim.HostDnsConfig {
            virtualNicConnection?: vimService.vim.HostVirtualNicConnection;
         }
         interface HostEsxAgentHostManagerConfigInfo extends vimService.vim.DynamicData {
            agentVmDatastore?: vimService.vim.ManagedObjectReference;
            agentVmNetwork?: vimService.vim.ManagedObjectReference;
         }
         interface HostFaultToleranceManagerComponentHealthInfo extends vimService.vim.DynamicData {
            isStorageHealthy: boolean;
            isNetworkHealthy: boolean;
         }
         interface FcoeConfigVlanRange extends vimService.vim.DynamicData {
            vlanLow: number;
            vlanHigh: number;
         }
         interface ArrayOfFcoeConfigVlanRange {
            FcoeConfigVlanRange?: Array<vimService.vim.FcoeConfigVlanRange>;
         }
         interface FcoeConfigFcoeCapabilities extends vimService.vim.DynamicData {
            priorityClass: boolean;
            sourceMacAddress: boolean;
            vlanRange: boolean;
         }
         interface FcoeConfigFcoeSpecification extends vimService.vim.DynamicData {
            underlyingPnic: string;
            priorityClass?: number;
            sourceMac?: string;
            vlanRange?: Array<vimService.vim.FcoeConfigVlanRange>;
         }
         interface FcoeConfig extends vimService.vim.DynamicData {
            priorityClass: number;
            sourceMac: string;
            vlanRange: Array<vimService.vim.FcoeConfigVlanRange>;
            capabilities: vimService.vim.FcoeConfigFcoeCapabilities;
            fcoeActive: boolean;
         }
         interface HostFeatureCapability extends vimService.vim.DynamicData {
            key: string;
            featureName: string;
            value: string;
         }
         interface ArrayOfHostFeatureCapability {
            HostFeatureCapability?: Array<vimService.vim.HostFeatureCapability>;
         }
         interface HostFeatureMask extends vimService.vim.DynamicData {
            key: string;
            featureName: string;
            value: string;
         }
         interface ArrayOfHostFeatureMask {
            HostFeatureMask?: Array<vimService.vim.HostFeatureMask>;
         }
         enum HostFeatureVersionKey {
            "faultTolerance",
         }
         interface HostFeatureVersionInfo extends vimService.vim.DynamicData {
            key: string;
            value: string;
         }
         interface ArrayOfHostFeatureVersionInfo {
            HostFeatureVersionInfo?: Array<vimService.vim.HostFeatureVersionInfo>;
         }
         interface ModeInfo extends vimService.vim.DynamicData {
            browse?: string;
            read: string;
            modify: string;
            use: string;
            admin?: string;
            full: string;
         }
         interface HostFileAccess extends vimService.vim.DynamicData {
            who: string;
            what: string;
         }
         interface HostFileSystemVolumeInfo extends vimService.vim.DynamicData {
            volumeTypeList?: Array<string>;
            mountInfo?: Array<vimService.vim.HostFileSystemMountInfo>;
         }
         enum FileSystemMountInfoVStorageSupportStatus {
            "vStorageSupported",
            "vStorageUnsupported",
            "vStorageUnknown",
         }
         interface HostFileSystemMountInfo extends vimService.vim.DynamicData {
            mountInfo: vimService.vim.HostMountInfo;
            volume: vimService.vim.HostFileSystemVolume;
            vStorageSupport?: string;
         }
         interface ArrayOfHostFileSystemMountInfo {
            HostFileSystemMountInfo?: Array<vimService.vim.HostFileSystemMountInfo>;
         }
         enum HostFileSystemVolumeFileSystemType {
            "VMFS",
            "NFS",
            "NFS41",
            "CIFS",
            "vsan",
            "VFFS",
            "VVOL",
            "OTHER",
         }
         interface HostFileSystemVolume extends vimService.vim.DynamicData {
            type: string;
            name: string;
            capacity: number;
         }
         interface HostNasVolumeUserInfo extends vimService.vim.DynamicData {
            user: string;
         }
         enum HostNasVolumeSecurityType {
            "AUTH_SYS",
            "SEC_KRB5",
            "SEC_KRB5I",
         }
         interface HostNasVolumeSpec extends vimService.vim.DynamicData {
            remoteHost: string;
            remotePath: string;
            localPath: string;
            accessMode: string;
            type?: string;
            userName?: string;
            password?: string;
            remoteHostNames?: Array<string>;
            securityType?: string;
         }
         interface HostNasVolumeConfig extends vimService.vim.DynamicData {
            changeOperation?: string;
            spec?: vimService.vim.HostNasVolumeSpec;
         }
         interface ArrayOfHostNasVolumeConfig {
            HostNasVolumeConfig?: Array<vimService.vim.HostNasVolumeConfig>;
         }
         interface HostNasVolume extends vimService.vim.HostFileSystemVolume {
            remoteHost: string;
            remotePath: string;
            userName?: string;
            remoteHostNames?: Array<string>;
            securityType?: string;
            protocolEndpoint?: boolean;
         }
         interface HostLocalFileSystemVolumeSpec extends vimService.vim.DynamicData {
            device: string;
            localPath: string;
         }
         interface HostLocalFileSystemVolume extends vimService.vim.HostFileSystemVolume {
            device: string;
         }
         interface HostVfatVolume extends vimService.vim.HostFileSystemVolume {
         }
         interface HostFirewallConfigRuleSetConfig extends vimService.vim.DynamicData {
            rulesetId: string;
            enabled: boolean;
            allowedHosts?: vimService.vim.HostFirewallRulesetIpList;
         }
         interface ArrayOfHostFirewallConfigRuleSetConfig {
            HostFirewallConfigRuleSetConfig?: Array<vimService.vim.HostFirewallConfigRuleSetConfig>;
         }
         interface HostFirewallConfig extends vimService.vim.DynamicData {
            rule?: Array<vimService.vim.HostFirewallConfigRuleSetConfig>;
            defaultBlockingPolicy: vimService.vim.HostFirewallDefaultPolicy;
         }
         interface HostFirewallDefaultPolicy extends vimService.vim.DynamicData {
            incomingBlocked?: boolean;
            outgoingBlocked?: boolean;
         }
         interface HostFirewallInfo extends vimService.vim.DynamicData {
            defaultPolicy: vimService.vim.HostFirewallDefaultPolicy;
            ruleset?: Array<vimService.vim.HostFirewallRuleset>;
         }
         interface HostFlagInfo extends vimService.vim.DynamicData {
            backgroundSnapshotsEnabled?: boolean;
         }
         interface HostForceMountedInfo extends vimService.vim.DynamicData {
            persist: boolean;
            mounted: boolean;
         }
         interface HostGatewaySpec extends vimService.vim.DynamicData {
            gatewayType: string;
            gatewayId?: string;
            trustVerificationToken?: string;
            hostAuthParams?: Array<vimService.vim.KeyValue>;
         }
         enum HostGraphicsConfigGraphicsType {
            "shared",
            "sharedDirect",
         }
         enum HostGraphicsConfigSharedPassthruAssignmentPolicy {
            "performance",
            "consolidation",
         }
         interface HostGraphicsConfigDeviceType extends vimService.vim.DynamicData {
            deviceId: string;
            graphicsType: string;
         }
         interface ArrayOfHostGraphicsConfigDeviceType {
            HostGraphicsConfigDeviceType?: Array<vimService.vim.HostGraphicsConfigDeviceType>;
         }
         interface HostGraphicsConfig extends vimService.vim.DynamicData {
            hostDefaultGraphicsType: string;
            sharedPassthruAssignmentPolicy: string;
            deviceType?: Array<vimService.vim.HostGraphicsConfigDeviceType>;
         }
         enum HostGraphicsInfoGraphicsType {
            "basic",
            "shared",
            "direct",
            "sharedDirect",
         }
         interface HostGraphicsInfo extends vimService.vim.DynamicData {
            deviceName: string;
            vendorName: string;
            pciId: string;
            graphicsType: string;
            memorySizeInKB: number;
            vm?: Array<vimService.vim.ManagedObjectReference>;
         }
         interface ArrayOfHostGraphicsInfo {
            HostGraphicsInfo?: Array<vimService.vim.HostGraphicsInfo>;
         }
         interface HostHardwareInfo extends vimService.vim.DynamicData {
            systemInfo: vimService.vim.HostSystemInfo;
            cpuPowerManagementInfo?: vimService.vim.HostCpuPowerManagementInfo;
            cpuInfo: vimService.vim.HostCpuInfo;
            cpuPkg: Array<vimService.vim.HostCpuPackage>;
            memorySize: number;
            numaInfo?: vimService.vim.HostNumaInfo;
            smcPresent?: boolean;
            pciDevice?: Array<vimService.vim.HostPciDevice>;
            cpuFeature?: Array<vimService.vim.HostCpuIdInfo>;
            biosInfo?: vimService.vim.HostBIOSInfo;
            reliableMemoryInfo?: vimService.vim.HostReliableMemoryInfo;
         }
         interface HostSystemInfo extends vimService.vim.DynamicData {
            vendor: string;
            model: string;
            uuid: string;
            otherIdentifyingInfo?: Array<vimService.vim.HostSystemIdentificationInfo>;
         }
         enum HostCpuPowerManagementInfoPolicyType {
            "off",
            "staticPolicy",
            "dynamicPolicy",
         }
         interface HostCpuPowerManagementInfo extends vimService.vim.DynamicData {
            currentPolicy?: string;
            hardwareSupport?: string;
         }
         interface HostCpuInfo extends vimService.vim.DynamicData {
            numCpuPackages: number;
            numCpuCores: number;
            numCpuThreads: number;
            hz: number;
         }
         enum HostCpuPackageVendor {
            "unknown",
            "intel",
            "amd",
         }
         interface HostCpuPackage extends vimService.vim.DynamicData {
            index: number;
            vendor: string;
            hz: number;
            busHz: number;
            description: string;
            threadId: Array<number>;
            cpuFeature?: Array<vimService.vim.HostCpuIdInfo>;
         }
         interface ArrayOfHostCpuPackage {
            HostCpuPackage?: Array<vimService.vim.HostCpuPackage>;
         }
         interface HostNumaInfo extends vimService.vim.DynamicData {
            type: string;
            numNodes: number;
            numaNode?: Array<vimService.vim.HostNumaNode>;
         }
         interface HostNumaNode extends vimService.vim.DynamicData {
            typeId: number;
            cpuID: Array<number>;
            memoryRangeBegin: number;
            memoryRangeLength: number;
         }
         interface ArrayOfHostNumaNode {
            HostNumaNode?: Array<vimService.vim.HostNumaNode>;
         }
         interface HostBIOSInfo extends vimService.vim.DynamicData {
            biosVersion?: string;
            releaseDate?: Date;
            vendor?: string;
            majorRelease?: number;
            minorRelease?: number;
            firmwareMajorRelease?: number;
            firmwareMinorRelease?: number;
         }
         interface HostReliableMemoryInfo extends vimService.vim.DynamicData {
            memorySize: number;
         }
         enum HostHardwareElementStatus {
            "Unknown",
            "Green",
            "Yellow",
            "Red",
         }
         interface HostHardwareElementInfo extends vimService.vim.DynamicData {
            name: string;
            status: vimService.vim.ElementDescription;
         }
         interface ArrayOfHostHardwareElementInfo {
            HostHardwareElementInfo?: Array<vimService.vim.HostHardwareElementInfo>;
         }
         interface HostStorageOperationalInfo extends vimService.vim.DynamicData {
            property: string;
            value: string;
         }
         interface ArrayOfHostStorageOperationalInfo {
            HostStorageOperationalInfo?: Array<vimService.vim.HostStorageOperationalInfo>;
         }
         interface HostStorageElementInfo extends vimService.vim.HostHardwareElementInfo {
            operationalInfo?: Array<vimService.vim.HostStorageOperationalInfo>;
         }
         interface ArrayOfHostStorageElementInfo {
            HostStorageElementInfo?: Array<vimService.vim.HostStorageElementInfo>;
         }
         interface HostHardwareStatusInfo extends vimService.vim.DynamicData {
            memoryStatusInfo?: Array<vimService.vim.HostHardwareElementInfo>;
            cpuStatusInfo?: Array<vimService.vim.HostHardwareElementInfo>;
            storageStatusInfo?: Array<vimService.vim.HostStorageElementInfo>;
         }
         interface HealthSystemRuntime extends vimService.vim.DynamicData {
            systemHealthInfo?: vimService.vim.HostSystemHealthInfo;
            hardwareStatusInfo?: vimService.vim.HostHardwareStatusInfo;
         }
         enum HostAccessMode {
            "accessNone",
            "accessAdmin",
            "accessNoAccess",
            "accessReadOnly",
            "accessOther",
         }
         interface HostAccessControlEntry extends vimService.vim.DynamicData {
            principal: string;
            group: boolean;
            accessMode: vimService.vim.HostAccessMode;
         }
         interface ArrayOfHostAccessControlEntry {
            HostAccessControlEntry?: Array<vimService.vim.HostAccessControlEntry>;
         }
         enum HostLockdownMode {
            "lockdownDisabled",
            "lockdownNormal",
            "lockdownStrict",
         }
         interface HostHostBusAdapter extends vimService.vim.DynamicData {
            key?: string;
            device: string;
            bus: number;
            status: string;
            model: string;
            driver?: string;
            pci?: string;
         }
         interface ArrayOfHostHostBusAdapter {
            HostHostBusAdapter?: Array<vimService.vim.HostHostBusAdapter>;
         }
         interface HostParallelScsiHba extends vimService.vim.HostHostBusAdapter {
         }
         interface HostSerialAttachedHba extends vimService.vim.HostHostBusAdapter {
            nodeWorldWideName: string;
         }
         interface HostBlockHba extends vimService.vim.HostHostBusAdapter {
         }
         enum FibreChannelPortType {
            "fabric",
            "loop",
            "pointToPoint",
            "unknown",
         }
         interface HostFibreChannelHba extends vimService.vim.HostHostBusAdapter {
            portWorldWideName: number;
            nodeWorldWideName: number;
            portType: vimService.vim.FibreChannelPortType;
            speed: number;
         }
         interface HostInternetScsiHbaParamValue extends vimService.vim.OptionValue {
            isInherited?: boolean;
         }
         interface ArrayOfHostInternetScsiHbaParamValue {
            HostInternetScsiHbaParamValue?: Array<vimService.vim.HostInternetScsiHbaParamValue>;
         }
         interface HostInternetScsiHbaDiscoveryCapabilities extends vimService.vim.DynamicData {
            iSnsDiscoverySettable: boolean;
            slpDiscoverySettable: boolean;
            staticTargetDiscoverySettable: boolean;
            sendTargetsDiscoverySettable: boolean;
         }
         enum InternetScsiSnsDiscoveryMethod {
            "isnsStatic",
            "isnsDhcp",
            "isnsSlp",
         }
         enum SlpDiscoveryMethod {
            "slpDhcp",
            "slpAutoUnicast",
            "slpAutoMulticast",
            "slpManual",
         }
         interface HostInternetScsiHbaDiscoveryProperties extends vimService.vim.DynamicData {
            iSnsDiscoveryEnabled: boolean;
            iSnsDiscoveryMethod?: string;
            iSnsHost?: string;
            slpDiscoveryEnabled: boolean;
            slpDiscoveryMethod?: string;
            slpHost?: string;
            staticTargetDiscoveryEnabled: boolean;
            sendTargetsDiscoveryEnabled: boolean;
         }
         enum HostInternetScsiHbaChapAuthenticationType {
            "chapProhibited",
            "chapDiscouraged",
            "chapPreferred",
            "chapRequired",
         }
         interface HostInternetScsiHbaAuthenticationCapabilities extends vimService.vim.DynamicData {
            chapAuthSettable: boolean;
            krb5AuthSettable: boolean;
            srpAuthSettable: boolean;
            spkmAuthSettable: boolean;
            mutualChapSettable?: boolean;
            targetChapSettable?: boolean;
            targetMutualChapSettable?: boolean;
         }
         interface HostInternetScsiHbaAuthenticationProperties extends vimService.vim.DynamicData {
            chapAuthEnabled: boolean;
            chapName?: string;
            chapSecret?: string;
            chapAuthenticationType?: string;
            chapInherited?: boolean;
            mutualChapName?: string;
            mutualChapSecret?: string;
            mutualChapAuthenticationType?: string;
            mutualChapInherited?: boolean;
         }
         enum HostInternetScsiHbaDigestType {
            "digestProhibited",
            "digestDiscouraged",
            "digestPreferred",
            "digestRequired",
         }
         interface HostInternetScsiHbaDigestCapabilities extends vimService.vim.DynamicData {
            headerDigestSettable?: boolean;
            dataDigestSettable?: boolean;
            targetHeaderDigestSettable?: boolean;
            targetDataDigestSettable?: boolean;
         }
         interface HostInternetScsiHbaDigestProperties extends vimService.vim.DynamicData {
            headerDigestType?: string;
            headerDigestInherited?: boolean;
            dataDigestType?: string;
            dataDigestInherited?: boolean;
         }
         interface HostInternetScsiHbaIPCapabilities extends vimService.vim.DynamicData {
            addressSettable: boolean;
            ipConfigurationMethodSettable: boolean;
            subnetMaskSettable: boolean;
            defaultGatewaySettable: boolean;
            primaryDnsServerAddressSettable: boolean;
            alternateDnsServerAddressSettable: boolean;
            ipv6Supported?: boolean;
            arpRedirectSettable?: boolean;
            mtuSettable?: boolean;
            hostNameAsTargetAddress?: boolean;
            nameAliasSettable?: boolean;
            ipv4EnableSettable?: boolean;
            ipv6EnableSettable?: boolean;
            ipv6PrefixLengthSettable?: boolean;
            ipv6PrefixLength?: number;
            ipv6DhcpConfigurationSettable?: boolean;
            ipv6LinkLocalAutoConfigurationSettable?: boolean;
            ipv6RouterAdvertisementConfigurationSettable?: boolean;
            ipv6DefaultGatewaySettable?: boolean;
            ipv6MaxStaticAddressesSupported?: number;
         }
         enum HostInternetScsiHbaIscsiIpv6AddressAddressConfigurationType {
            "DHCP",
            "AutoConfigured",
            "Static",
            "Other",
         }
         enum HostInternetScsiHbaIscsiIpv6AddressIPv6AddressOperation {
            "add",
            "remove",
         }
         interface HostInternetScsiHbaIscsiIpv6Address extends vimService.vim.DynamicData {
            address: string;
            prefixLength: number;
            origin: string;
            operation?: string;
         }
         interface ArrayOfHostInternetScsiHbaIscsiIpv6Address {
            HostInternetScsiHbaIscsiIpv6Address?: Array<vimService.vim.HostInternetScsiHbaIscsiIpv6Address>;
         }
         interface HostInternetScsiHbaIPv6Properties extends vimService.vim.DynamicData {
            iscsiIpv6Address?: Array<vimService.vim.HostInternetScsiHbaIscsiIpv6Address>;
            ipv6DhcpConfigurationEnabled?: boolean;
            ipv6LinkLocalAutoConfigurationEnabled?: boolean;
            ipv6RouterAdvertisementConfigurationEnabled?: boolean;
            ipv6DefaultGateway?: string;
         }
         interface HostInternetScsiHbaIPProperties extends vimService.vim.DynamicData {
            mac?: string;
            address?: string;
            dhcpConfigurationEnabled: boolean;
            subnetMask?: string;
            defaultGateway?: string;
            primaryDnsServerAddress?: string;
            alternateDnsServerAddress?: string;
            ipv6Address?: string;
            ipv6SubnetMask?: string;
            ipv6DefaultGateway?: string;
            arpRedirectEnabled?: boolean;
            mtu?: number;
            jumboFramesEnabled?: boolean;
            ipv4Enabled?: boolean;
            ipv6Enabled?: boolean;
            ipv6properties?: vimService.vim.HostInternetScsiHbaIPv6Properties;
         }
         interface HostInternetScsiHbaSendTarget extends vimService.vim.DynamicData {
            address: string;
            port?: number;
            authenticationProperties?: vimService.vim.HostInternetScsiHbaAuthenticationProperties;
            digestProperties?: vimService.vim.HostInternetScsiHbaDigestProperties;
            supportedAdvancedOptions?: Array<vimService.vim.OptionDef>;
            advancedOptions?: Array<vimService.vim.HostInternetScsiHbaParamValue>;
            parent?: string;
         }
         interface ArrayOfHostInternetScsiHbaSendTarget {
            HostInternetScsiHbaSendTarget?: Array<vimService.vim.HostInternetScsiHbaSendTarget>;
         }
         enum HostInternetScsiHbaStaticTargetTargetDiscoveryMethod {
            "staticMethod",
            "sendTargetMethod",
            "slpMethod",
            "isnsMethod",
            "unknownMethod",
         }
         interface HostInternetScsiHbaStaticTarget extends vimService.vim.DynamicData {
            address: string;
            port?: number;
            iScsiName: string;
            discoveryMethod?: string;
            authenticationProperties?: vimService.vim.HostInternetScsiHbaAuthenticationProperties;
            digestProperties?: vimService.vim.HostInternetScsiHbaDigestProperties;
            supportedAdvancedOptions?: Array<vimService.vim.OptionDef>;
            advancedOptions?: Array<vimService.vim.HostInternetScsiHbaParamValue>;
            parent?: string;
         }
         interface ArrayOfHostInternetScsiHbaStaticTarget {
            HostInternetScsiHbaStaticTarget?: Array<vimService.vim.HostInternetScsiHbaStaticTarget>;
         }
         interface HostInternetScsiHbaTargetSet extends vimService.vim.DynamicData {
            staticTargets?: Array<vimService.vim.HostInternetScsiHbaStaticTarget>;
            sendTargets?: Array<vimService.vim.HostInternetScsiHbaSendTarget>;
         }
         enum HostInternetScsiHbaNetworkBindingSupportType {
            "notsupported",
            "optional",
            "required",
         }
         interface HostInternetScsiHba extends vimService.vim.HostHostBusAdapter {
            isSoftwareBased: boolean;
            canBeDisabled?: boolean;
            networkBindingSupport?: vimService.vim.HostInternetScsiHbaNetworkBindingSupportType;
            discoveryCapabilities: vimService.vim.HostInternetScsiHbaDiscoveryCapabilities;
            discoveryProperties: vimService.vim.HostInternetScsiHbaDiscoveryProperties;
            authenticationCapabilities: vimService.vim.HostInternetScsiHbaAuthenticationCapabilities;
            authenticationProperties: vimService.vim.HostInternetScsiHbaAuthenticationProperties;
            digestCapabilities?: vimService.vim.HostInternetScsiHbaDigestCapabilities;
            digestProperties?: vimService.vim.HostInternetScsiHbaDigestProperties;
            ipCapabilities: vimService.vim.HostInternetScsiHbaIPCapabilities;
            ipProperties: vimService.vim.HostInternetScsiHbaIPProperties;
            supportedAdvancedOptions?: Array<vimService.vim.OptionDef>;
            advancedOptions?: Array<vimService.vim.HostInternetScsiHbaParamValue>;
            iScsiName: string;
            iScsiAlias?: string;
            configuredSendTarget?: Array<vimService.vim.HostInternetScsiHbaSendTarget>;
            configuredStaticTarget?: Array<vimService.vim.HostInternetScsiHbaStaticTarget>;
            maxSpeedMb?: number;
            currentSpeedMb?: number;
         }
         interface HostFibreChannelOverEthernetHbaLinkInfo extends vimService.vim.DynamicData {
            vnportMac: string;
            fcfMac: string;
            vlanId: number;
         }
         interface HostFibreChannelOverEthernetHba extends vimService.vim.HostFibreChannelHba {
            underlyingNic: string;
            linkInfo: vimService.vim.HostFibreChannelOverEthernetHbaLinkInfo;
            isSoftwareFcoe: boolean;
            markedForRemoval: boolean;
         }
         interface HostProxySwitchSpec extends vimService.vim.DynamicData {
            backing?: vimService.vim.DistributedVirtualSwitchHostMemberBacking;
         }
         interface HostProxySwitchConfig extends vimService.vim.DynamicData {
            changeOperation?: string;
            uuid: string;
            spec?: vimService.vim.HostProxySwitchSpec;
         }
         interface ArrayOfHostProxySwitchConfig {
            HostProxySwitchConfig?: Array<vimService.vim.HostProxySwitchConfig>;
         }
         interface HostProxySwitchHostLagConfig extends vimService.vim.DynamicData {
            lagKey: string;
            lagName?: string;
            uplinkPort?: Array<vimService.vim.KeyValue>;
         }
         interface ArrayOfHostProxySwitchHostLagConfig {
            HostProxySwitchHostLagConfig?: Array<vimService.vim.HostProxySwitchHostLagConfig>;
         }
         interface HostProxySwitch extends vimService.vim.DynamicData {
            dvsUuid: string;
            dvsName: string;
            key: string;
            numPorts: number;
            configNumPorts?: number;
            numPortsAvailable: number;
            uplinkPort?: Array<vimService.vim.KeyValue>;
            mtu?: number;
            pnic?: Array<string>;
            spec: vimService.vim.HostProxySwitchSpec;
            hostLag?: Array<vimService.vim.HostProxySwitchHostLagConfig>;
            networkReservationSupported?: boolean;
         }
         interface ArrayOfHostProxySwitch {
            HostProxySwitch?: Array<vimService.vim.HostProxySwitch>;
         }
         enum HostImageAcceptanceLevel {
            "vmware_certified",
            "vmware_accepted",
            "partner",
            "community",
         }
         interface HostImageProfileSummary extends vimService.vim.DynamicData {
            name: string;
            vendor: string;
         }
         enum HostIpConfigIpV6AddressConfigType {
            "other",
            "manual",
            "dhcp",
            "linklayer",
            "random",
         }
         enum HostIpConfigIpV6AddressStatus {
            "preferred",
            "deprecated",
            "invalid",
            "inaccessible",
            "unknown",
            "tentative",
            "duplicate",
         }
         interface HostIpConfigIpV6Address extends vimService.vim.DynamicData {
            ipAddress: string;
            prefixLength: number;
            origin?: string;
            dadState?: string;
            lifetime?: Date;
            operation?: string;
         }
         interface ArrayOfHostIpConfigIpV6Address {
            HostIpConfigIpV6Address?: Array<vimService.vim.HostIpConfigIpV6Address>;
         }
         interface HostIpConfigIpV6AddressConfiguration extends vimService.vim.DynamicData {
            ipV6Address?: Array<vimService.vim.HostIpConfigIpV6Address>;
            autoConfigurationEnabled?: boolean;
            dhcpV6Enabled?: boolean;
         }
         interface HostIpConfig extends vimService.vim.DynamicData {
            dhcp: boolean;
            ipAddress?: string;
            subnetMask?: string;
            ipV6Config?: vimService.vim.HostIpConfigIpV6AddressConfiguration;
         }
         interface HostIpRouteConfig extends vimService.vim.DynamicData {
            defaultGateway?: string;
            gatewayDevice?: string;
            ipV6DefaultGateway?: string;
            ipV6GatewayDevice?: string;
         }
         interface HostIpRouteConfigSpec extends vimService.vim.HostIpRouteConfig {
            gatewayDeviceConnection?: vimService.vim.HostVirtualNicConnection;
            ipV6GatewayDeviceConnection?: vimService.vim.HostVirtualNicConnection;
         }
         interface HostIpRouteEntry extends vimService.vim.DynamicData {
            network: string;
            prefixLength: number;
            gateway: string;
            deviceName?: string;
         }
         interface ArrayOfHostIpRouteEntry {
            HostIpRouteEntry?: Array<vimService.vim.HostIpRouteEntry>;
         }
         interface HostIpRouteOp extends vimService.vim.DynamicData {
            changeOperation: string;
            route: vimService.vim.HostIpRouteEntry;
         }
         interface ArrayOfHostIpRouteOp {
            HostIpRouteOp?: Array<vimService.vim.HostIpRouteOp>;
         }
         interface HostIpRouteTableConfig extends vimService.vim.DynamicData {
            ipRoute?: Array<vimService.vim.HostIpRouteOp>;
            ipv6Route?: Array<vimService.vim.HostIpRouteOp>;
         }
         interface HostIpRouteTableInfo extends vimService.vim.DynamicData {
            ipRoute?: Array<vimService.vim.HostIpRouteEntry>;
            ipv6Route?: Array<vimService.vim.HostIpRouteEntry>;
         }
         interface HostIpmiInfo extends vimService.vim.DynamicData {
            bmcIpAddress?: string;
            bmcMacAddress?: string;
            login?: string;
            password?: string;
         }
         interface IscsiStatus extends vimService.vim.DynamicData {
            reason?: Array<vimService.vim.LocalizedMethodFault>;
         }
         enum IscsiPortInfoPathStatus {
            "notUsed",
            "active",
            "standBy",
            "lastActive",
         }
         interface IscsiPortInfo extends vimService.vim.DynamicData {
            vnicDevice?: string;
            vnic?: vimService.vim.HostVirtualNic;
            pnicDevice?: string;
            pnic?: vimService.vim.PhysicalNic;
            switchName?: string;
            switchUuid?: string;
            portgroupName?: string;
            portgroupKey?: string;
            portKey?: string;
            opaqueNetworkId?: string;
            opaqueNetworkType?: string;
            opaqueNetworkName?: string;
            externalId?: string;
            complianceStatus?: vimService.vim.IscsiStatus;
            pathStatus?: string;
         }
         interface ArrayOfIscsiPortInfo {
            IscsiPortInfo?: Array<vimService.vim.IscsiPortInfo>;
         }
         interface IscsiDependencyEntity extends vimService.vim.DynamicData {
            pnicDevice: string;
            vnicDevice: string;
            vmhbaName: string;
         }
         interface ArrayOfIscsiDependencyEntity {
            IscsiDependencyEntity?: Array<vimService.vim.IscsiDependencyEntity>;
         }
         interface IscsiMigrationDependency extends vimService.vim.DynamicData {
            migrationAllowed: boolean;
            disallowReason?: vimService.vim.IscsiStatus;
            dependency?: Array<vimService.vim.IscsiDependencyEntity>;
         }
         interface KernelModuleSectionInfo extends vimService.vim.DynamicData {
            address: number;
            length?: number;
         }
         interface KernelModuleInfo extends vimService.vim.DynamicData {
            id: number;
            name: string;
            version: string;
            filename: string;
            optionString: string;
            loaded: boolean;
            enabled: boolean;
            useCount: number;
            readOnlySection: vimService.vim.KernelModuleSectionInfo;
            writableSection: vimService.vim.KernelModuleSectionInfo;
            textSection: vimService.vim.KernelModuleSectionInfo;
            dataSection: vimService.vim.KernelModuleSectionInfo;
            bssSection: vimService.vim.KernelModuleSectionInfo;
         }
         interface ArrayOfKernelModuleInfo {
            KernelModuleInfo?: Array<vimService.vim.KernelModuleInfo>;
         }
         interface HostLicenseSpec extends vimService.vim.DynamicData {
            source?: vimService.vim.LicenseSource;
            editionKey?: string;
            disabledFeatureKey?: Array<string>;
            enabledFeatureKey?: Array<string>;
         }
         enum LinkDiscoveryProtocolConfigProtocolType {
            "cdp",
            "lldp",
         }
         enum LinkDiscoveryProtocolConfigOperationType {
            "none",
            "listen",
            "advertise",
            "both",
         }
         interface LinkDiscoveryProtocolConfig extends vimService.vim.DynamicData {
            protocol: string;
            operation: string;
         }
         interface HostAccountSpec extends vimService.vim.DynamicData {
            id: string;
            password?: string;
            description?: string;
         }
         interface ArrayOfHostAccountSpec {
            HostAccountSpec?: Array<vimService.vim.HostAccountSpec>;
         }
         interface HostPosixAccountSpec extends vimService.vim.HostAccountSpec {
            posixId?: number;
            shellAccess?: boolean;
         }
         interface HostLocalAuthenticationInfo extends vimService.vim.HostAuthenticationStoreInfo {
         }
         interface HostLowLevelProvisioningManagerVmRecoveryInfo extends vimService.vim.DynamicData {
            version: string;
            biosUUID: string;
            instanceUUID: string;
            ftInfo?: vimService.vim.FaultToleranceConfigInfo;
         }
         interface HostLowLevelProvisioningManagerVmMigrationStatus extends vimService.vim.DynamicData {
            migrationId: number;
            type: string;
            source: boolean;
            consideredSuccessful: boolean;
         }
         enum HostLowLevelProvisioningManagerReloadTarget {
            "currentConfig",
            "snapshotConfig",
         }
         interface HostLowLevelProvisioningManagerDiskLayoutSpec extends vimService.vim.DynamicData {
            controllerType: string;
            busNumber: number;
            unitNumber: number;
            srcFilename: string;
            dstFilename: string;
         }
         interface ArrayOfHostLowLevelProvisioningManagerDiskLayoutSpec {
            HostLowLevelProvisioningManagerDiskLayoutSpec?: Array<vimService.vim.HostLowLevelProvisioningManagerDiskLayoutSpec>;
         }
         interface HostLowLevelProvisioningManagerSnapshotLayoutSpec extends vimService.vim.DynamicData {
            id: number;
            srcFilename: string;
            dstFilename: string;
            disk?: Array<vimService.vim.HostLowLevelProvisioningManagerDiskLayoutSpec>;
         }
         interface ArrayOfHostLowLevelProvisioningManagerSnapshotLayoutSpec {
            HostLowLevelProvisioningManagerSnapshotLayoutSpec?: Array<vimService.vim.HostLowLevelProvisioningManagerSnapshotLayoutSpec>;
         }
         enum HostLowLevelProvisioningManagerFileType {
            "File",
            "VirtualDisk",
            "Directory",
         }
         interface HostLowLevelProvisioningManagerFileReserveSpec extends vimService.vim.DynamicData {
            baseName: string;
            parentDir: string;
            fileType: string;
            storageProfile: string;
         }
         interface ArrayOfHostLowLevelProvisioningManagerFileReserveSpec {
            HostLowLevelProvisioningManagerFileReserveSpec?: Array<vimService.vim.HostLowLevelProvisioningManagerFileReserveSpec>;
         }
         interface HostLowLevelProvisioningManagerFileReserveResult extends vimService.vim.DynamicData {
            baseName: string;
            parentDir: string;
            reservedName: string;
         }
         interface ArrayOfHostLowLevelProvisioningManagerFileReserveResult {
            HostLowLevelProvisioningManagerFileReserveResult?: Array<vimService.vim.HostLowLevelProvisioningManagerFileReserveResult>;
         }
         interface HostLowLevelProvisioningManagerFileDeleteSpec extends vimService.vim.DynamicData {
            fileName: string;
            fileType: string;
         }
         interface ArrayOfHostLowLevelProvisioningManagerFileDeleteSpec {
            HostLowLevelProvisioningManagerFileDeleteSpec?: Array<vimService.vim.HostLowLevelProvisioningManagerFileDeleteSpec>;
         }
         interface HostLowLevelProvisioningManagerFileDeleteResult extends vimService.vim.DynamicData {
            fileName: string;
            fault: vimService.vim.LocalizedMethodFault;
         }
         interface ArrayOfHostLowLevelProvisioningManagerFileDeleteResult {
            HostLowLevelProvisioningManagerFileDeleteResult?: Array<vimService.vim.HostLowLevelProvisioningManagerFileDeleteResult>;
         }
         interface HostMaintenanceSpec extends vimService.vim.DynamicData {
            vsanMode?: vimService.vim.VsanHostDecommissionMode;
         }
         interface ServiceConsoleReservationInfo extends vimService.vim.DynamicData {
            serviceConsoleReservedCfg: number;
            serviceConsoleReserved: number;
            unreserved: number;
         }
         enum VirtualMachineMemoryAllocationPolicy {
            "swapNone",
            "swapSome",
            "swapMost",
         }
         interface VirtualMachineMemoryReservationInfo extends vimService.vim.DynamicData {
            virtualMachineMin: number;
            virtualMachineMax: number;
            virtualMachineReserved: number;
            allocationPolicy: string;
         }
         interface VirtualMachineMemoryReservationSpec extends vimService.vim.DynamicData {
            virtualMachineReserved?: number;
            allocationPolicy?: string;
         }
         interface HostMemorySpec extends vimService.vim.DynamicData {
            serviceConsoleReservation?: number;
         }
         enum HostMountMode {
            "readWrite",
            "readOnly",
         }
         enum HostMountInfoInaccessibleReason {
            "AllPathsDown_Start",
            "AllPathsDown_Timeout",
            "PermanentDeviceLoss",
         }
         interface HostMountInfo extends vimService.vim.DynamicData {
            path?: string;
            accessMode: string;
            mounted?: boolean;
            accessible?: boolean;
            inaccessibleReason?: string;
         }
         enum MultipathState {
            "standby",
            "active",
            "disabled",
            "dead",
            "unknown",
         }
         interface HostMultipathInfoLogicalUnitPolicy extends vimService.vim.DynamicData {
            policy: string;
         }
         interface HostMultipathInfoLogicalUnitStorageArrayTypePolicy extends vimService.vim.DynamicData {
            policy: string;
         }
         interface HostMultipathInfoFixedLogicalUnitPolicy extends vimService.vim.HostMultipathInfoLogicalUnitPolicy {
            prefer: string;
         }
         interface HostMultipathInfoLogicalUnit extends vimService.vim.DynamicData {
            key: string;
            id: string;
            lun: string;
            path: Array<vimService.vim.HostMultipathInfoPath>;
            policy: vimService.vim.HostMultipathInfoLogicalUnitPolicy;
            storageArrayTypePolicy?: vimService.vim.HostMultipathInfoLogicalUnitStorageArrayTypePolicy;
         }
         interface ArrayOfHostMultipathInfoLogicalUnit {
            HostMultipathInfoLogicalUnit?: Array<vimService.vim.HostMultipathInfoLogicalUnit>;
         }
         interface HostMultipathInfoPath extends vimService.vim.DynamicData {
            key: string;
            name: string;
            pathState: string;
            state?: string;
            isWorkingPath?: boolean;
            adapter: string;
            lun: string;
            transport?: vimService.vim.HostTargetTransport;
         }
         interface ArrayOfHostMultipathInfoPath {
            HostMultipathInfoPath?: Array<vimService.vim.HostMultipathInfoPath>;
         }
         interface HostMultipathInfo extends vimService.vim.DynamicData {
            lun?: Array<vimService.vim.HostMultipathInfoLogicalUnit>;
         }
         interface HostMultipathStateInfoPath extends vimService.vim.DynamicData {
            name: string;
            pathState: string;
         }
         interface ArrayOfHostMultipathStateInfoPath {
            HostMultipathStateInfoPath?: Array<vimService.vim.HostMultipathStateInfoPath>;
         }
         interface HostMultipathStateInfo extends vimService.vim.DynamicData {
            path?: Array<vimService.vim.HostMultipathStateInfoPath>;
         }
         interface HostNatServicePortForwardSpec extends vimService.vim.DynamicData {
            type: string;
            name: string;
            hostPort: number;
            guestPort: number;
            guestIpAddress: string;
         }
         interface ArrayOfHostNatServicePortForwardSpec {
            HostNatServicePortForwardSpec?: Array<vimService.vim.HostNatServicePortForwardSpec>;
         }
         interface HostNatServiceNameServiceSpec extends vimService.vim.DynamicData {
            dnsAutoDetect: boolean;
            dnsPolicy: string;
            dnsRetries: number;
            dnsTimeout: number;
            dnsNameServer?: Array<string>;
            nbdsTimeout: number;
            nbnsRetries: number;
            nbnsTimeout: number;
         }
         interface HostNatServiceSpec extends vimService.vim.DynamicData {
            virtualSwitch: string;
            activeFtp: boolean;
            allowAnyOui: boolean;
            configPort: boolean;
            ipGatewayAddress: string;
            udpTimeout: number;
            portForward?: Array<vimService.vim.HostNatServicePortForwardSpec>;
            nameService?: vimService.vim.HostNatServiceNameServiceSpec;
         }
         interface HostNatServiceConfig extends vimService.vim.DynamicData {
            changeOperation?: string;
            key: string;
            spec: vimService.vim.HostNatServiceSpec;
         }
         interface ArrayOfHostNatServiceConfig {
            HostNatServiceConfig?: Array<vimService.vim.HostNatServiceConfig>;
         }
         interface HostNatService extends vimService.vim.DynamicData {
            key: string;
            spec: vimService.vim.HostNatServiceSpec;
         }
         interface ArrayOfHostNatService {
            HostNatService?: Array<vimService.vim.HostNatService>;
         }
         interface HostNetCapabilities extends vimService.vim.DynamicData {
            canSetPhysicalNicLinkSpeed: boolean;
            supportsNicTeaming: boolean;
            nicTeamingPolicy?: Array<string>;
            supportsVlan: boolean;
            usesServiceConsoleNic: boolean;
            supportsNetworkHints: boolean;
            maxPortGroupsPerVswitch?: number;
            vswitchConfigSupported: boolean;
            vnicConfigSupported: boolean;
            ipRouteConfigSupported: boolean;
            dnsConfigSupported: boolean;
            dhcpOnVnicSupported: boolean;
            ipV6Supported?: boolean;
         }
         interface HostNetOffloadCapabilities extends vimService.vim.DynamicData {
            csumOffload?: boolean;
            tcpSegmentation?: boolean;
            zeroCopyXmit?: boolean;
         }
         enum HostNetStackInstanceSystemStackKey {
            "defaultTcpipStack",
            "vmotion",
            "vSphereProvisioning",
         }
         enum HostNetStackInstanceCongestionControlAlgorithmType {
            "newreno",
            "cubic",
         }
         interface HostNetStackInstance extends vimService.vim.DynamicData {
            key?: string;
            name?: string;
            dnsConfig?: vimService.vim.HostDnsConfig;
            ipRouteConfig?: vimService.vim.HostIpRouteConfig;
            requestedMaxNumberOfConnections?: number;
            congestionControlAlgorithm?: string;
            ipV6Enabled?: boolean;
            routeTableConfig?: vimService.vim.HostIpRouteTableConfig;
         }
         interface ArrayOfHostNetStackInstance {
            HostNetStackInstance?: Array<vimService.vim.HostNetStackInstance>;
         }
         interface HostNetworkConfigResult extends vimService.vim.DynamicData {
            vnicDevice?: Array<string>;
            consoleVnicDevice?: Array<string>;
         }
         interface HostNetworkConfigNetStackSpec extends vimService.vim.DynamicData {
            netStackInstance: vimService.vim.HostNetStackInstance;
            operation?: string;
         }
         interface ArrayOfHostNetworkConfigNetStackSpec {
            HostNetworkConfigNetStackSpec?: Array<vimService.vim.HostNetworkConfigNetStackSpec>;
         }
         interface HostNetworkConfig extends vimService.vim.DynamicData {
            vswitch?: Array<vimService.vim.HostVirtualSwitchConfig>;
            proxySwitch?: Array<vimService.vim.HostProxySwitchConfig>;
            portgroup?: Array<vimService.vim.HostPortGroupConfig>;
            pnic?: Array<vimService.vim.PhysicalNicConfig>;
            vnic?: Array<vimService.vim.HostVirtualNicConfig>;
            consoleVnic?: Array<vimService.vim.HostVirtualNicConfig>;
            dnsConfig?: vimService.vim.HostDnsConfig;
            ipRouteConfig?: vimService.vim.HostIpRouteConfig;
            consoleIpRouteConfig?: vimService.vim.HostIpRouteConfig;
            routeTableConfig?: vimService.vim.HostIpRouteTableConfig;
            dhcp?: Array<vimService.vim.HostDhcpServiceConfig>;
            nat?: Array<vimService.vim.HostNatServiceConfig>;
            ipV6Enabled?: boolean;
            netStackSpec?: Array<vimService.vim.HostNetworkConfigNetStackSpec>;
         }
         interface HostNetworkInfo extends vimService.vim.DynamicData {
            vswitch?: Array<vimService.vim.HostVirtualSwitch>;
            proxySwitch?: Array<vimService.vim.HostProxySwitch>;
            portgroup?: Array<vimService.vim.HostPortGroup>;
            pnic?: Array<vimService.vim.PhysicalNic>;
            vnic?: Array<vimService.vim.HostVirtualNic>;
            consoleVnic?: Array<vimService.vim.HostVirtualNic>;
            dnsConfig?: vimService.vim.HostDnsConfig;
            ipRouteConfig?: vimService.vim.HostIpRouteConfig;
            consoleIpRouteConfig?: vimService.vim.HostIpRouteConfig;
            routeTableInfo?: vimService.vim.HostIpRouteTableInfo;
            dhcp?: Array<vimService.vim.HostDhcpService>;
            nat?: Array<vimService.vim.HostNatService>;
            ipV6Enabled?: boolean;
            atBootIpV6Enabled?: boolean;
            netStackInstance?: Array<vimService.vim.HostNetStackInstance>;
            opaqueSwitch?: Array<vimService.vim.HostOpaqueSwitch>;
            opaqueNetwork?: Array<vimService.vim.HostOpaqueNetworkInfo>;
         }
         interface HostNetworkSecurityPolicy extends vimService.vim.DynamicData {
            allowPromiscuous?: boolean;
            macChanges?: boolean;
            forgedTransmits?: boolean;
         }
         interface HostNetworkTrafficShapingPolicy extends vimService.vim.DynamicData {
            enabled?: boolean;
            averageBandwidth?: number;
            peakBandwidth?: number;
            burstSize?: number;
         }
         interface HostNicFailureCriteria extends vimService.vim.DynamicData {
            checkSpeed?: string;
            speed?: number;
            checkDuplex?: boolean;
            fullDuplex?: boolean;
            checkErrorPercent?: boolean;
            percentage?: number;
            checkBeacon?: boolean;
         }
         interface HostNicOrderPolicy extends vimService.vim.DynamicData {
            activeNic?: Array<string>;
            standbyNic?: Array<string>;
         }
         interface HostNicTeamingPolicy extends vimService.vim.DynamicData {
            policy?: string;
            reversePolicy?: boolean;
            notifySwitches?: boolean;
            rollingOrder?: boolean;
            failureCriteria?: vimService.vim.HostNicFailureCriteria;
            nicOrder?: vimService.vim.HostNicOrderPolicy;
         }
         interface HostNetworkPolicy extends vimService.vim.DynamicData {
            security?: vimService.vim.HostNetworkSecurityPolicy;
            nicTeaming?: vimService.vim.HostNicTeamingPolicy;
            offloadPolicy?: vimService.vim.HostNetOffloadCapabilities;
            shapingPolicy?: vimService.vim.HostNetworkTrafficShapingPolicy;
         }
         interface HostNtpConfig extends vimService.vim.DynamicData {
            server?: Array<string>;
            configFile?: Array<string>;
         }
         enum HostNumericSensorHealthState {
            "unknown",
            "green",
            "yellow",
            "red",
         }
         enum HostNumericSensorType {
            "fan",
            "power",
            "temperature",
            "voltage",
            "other",
            "processor",
            "memory",
            "storage",
            "systemBoard",
            "battery",
            "bios",
            "cable",
            "watchdog",
         }
         interface HostNumericSensorInfo extends vimService.vim.DynamicData {
            name: string;
            healthState?: vimService.vim.ElementDescription;
            currentReading: number;
            unitModifier: number;
            baseUnits: string;
            rateUnits?: string;
            sensorType: string;
            id?: string;
            timeStamp?: string;
         }
         interface ArrayOfHostNumericSensorInfo {
            HostNumericSensorInfo?: Array<vimService.vim.HostNumericSensorInfo>;
         }
         interface HostOpaqueNetworkInfo extends vimService.vim.DynamicData {
            opaqueNetworkId: string;
            opaqueNetworkName: string;
            opaqueNetworkType: string;
            pnicZone?: Array<string>;
            capability?: vimService.vim.OpaqueNetworkCapability;
            extraConfig?: Array<vimService.vim.OptionValue>;
         }
         interface ArrayOfHostOpaqueNetworkInfo {
            HostOpaqueNetworkInfo?: Array<vimService.vim.HostOpaqueNetworkInfo>;
         }
         enum HostOpaqueSwitchOpaqueSwitchState {
            "up",
            "warning",
            "down",
         }
         interface HostOpaqueSwitchPhysicalNicZone extends vimService.vim.DynamicData {
            key: string;
            pnicDevice?: Array<string>;
         }
         interface ArrayOfHostOpaqueSwitchPhysicalNicZone {
            HostOpaqueSwitchPhysicalNicZone?: Array<vimService.vim.HostOpaqueSwitchPhysicalNicZone>;
         }
         interface HostOpaqueSwitch extends vimService.vim.DynamicData {
            key: string;
            name?: string;
            pnic?: Array<string>;
            pnicZone?: Array<vimService.vim.HostOpaqueSwitchPhysicalNicZone>;
            status?: string;
            vtep?: Array<vimService.vim.HostVirtualNic>;
            extraConfig?: Array<vimService.vim.OptionValue>;
         }
         interface ArrayOfHostOpaqueSwitch {
            HostOpaqueSwitch?: Array<vimService.vim.HostOpaqueSwitch>;
         }
         interface HostPatchManagerResult extends vimService.vim.DynamicData {
            version: string;
            status?: Array<vimService.vim.HostPatchManagerStatus>;
            xmlResult?: string;
         }
         enum HostPatchManagerReason {
            "obsoleted",
            "missingPatch",
            "missingLib",
            "hasDependentPatch",
            "conflictPatch",
            "conflictLib",
         }
         enum HostPatchManagerIntegrityStatus {
            "validated",
            "keyNotFound",
            "keyRevoked",
            "keyExpired",
            "digestMismatch",
            "notEnoughSignatures",
            "validationError",
         }
         enum HostPatchManagerInstallState {
            "hostRestarted",
            "imageActive",
         }
         interface HostPatchManagerStatusPrerequisitePatch extends vimService.vim.DynamicData {
            id: string;
            installState?: Array<string>;
         }
         interface ArrayOfHostPatchManagerStatusPrerequisitePatch {
            HostPatchManagerStatusPrerequisitePatch?: Array<vimService.vim.HostPatchManagerStatusPrerequisitePatch>;
         }
         interface HostPatchManagerStatus extends vimService.vim.DynamicData {
            id: string;
            applicable: boolean;
            reason?: Array<string>;
            integrity?: string;
            installed: boolean;
            installState?: Array<string>;
            prerequisitePatch?: Array<vimService.vim.HostPatchManagerStatusPrerequisitePatch>;
            restartRequired: boolean;
            reconnectRequired: boolean;
            vmOffRequired: boolean;
            supersededPatchIds?: Array<string>;
         }
         interface ArrayOfHostPatchManagerStatus {
            HostPatchManagerStatus?: Array<vimService.vim.HostPatchManagerStatus>;
         }
         interface HostPatchManagerLocator extends vimService.vim.DynamicData {
            url: string;
            proxy?: string;
         }
         interface HostPatchManagerPatchManagerOperationSpec extends vimService.vim.DynamicData {
            proxy?: string;
            port?: number;
            userName?: string;
            password?: string;
            cmdOption?: string;
         }
         interface HostPathSelectionPolicyOption extends vimService.vim.DynamicData {
            policy: vimService.vim.ElementDescription;
         }
         interface ArrayOfHostPathSelectionPolicyOption {
            HostPathSelectionPolicyOption?: Array<vimService.vim.HostPathSelectionPolicyOption>;
         }
         interface HostPciDevice extends vimService.vim.DynamicData {
            id: string;
            classId: number;
            bus: number;
            slot: number;
            function: number;
            vendorId: number;
            subVendorId: number;
            vendorName: string;
            deviceId: number;
            subDeviceId: number;
            parentBridge?: string;
            deviceName: string;
         }
         interface ArrayOfHostPciDevice {
            HostPciDevice?: Array<vimService.vim.HostPciDevice>;
         }
         interface HostPciPassthruConfig extends vimService.vim.DynamicData {
            id: string;
            passthruEnabled: boolean;
         }
         interface ArrayOfHostPciPassthruConfig {
            HostPciPassthruConfig?: Array<vimService.vim.HostPciPassthruConfig>;
         }
         interface HostPciPassthruInfo extends vimService.vim.DynamicData {
            id: string;
            dependentDevice: string;
            passthruEnabled: boolean;
            passthruCapable: boolean;
            passthruActive: boolean;
         }
         interface ArrayOfHostPciPassthruInfo {
            HostPciPassthruInfo?: Array<vimService.vim.HostPciPassthruInfo>;
         }
         interface PhysicalNicSpec extends vimService.vim.DynamicData {
            ip?: vimService.vim.HostIpConfig;
            linkSpeed?: vimService.vim.PhysicalNicLinkInfo;
         }
         interface PhysicalNicConfig extends vimService.vim.DynamicData {
            device: string;
            spec: vimService.vim.PhysicalNicSpec;
         }
         interface ArrayOfPhysicalNicConfig {
            PhysicalNicConfig?: Array<vimService.vim.PhysicalNicConfig>;
         }
         interface PhysicalNicLinkInfo extends vimService.vim.DynamicData {
            speedMb: number;
            duplex: boolean;
         }
         interface ArrayOfPhysicalNicLinkInfo {
            PhysicalNicLinkInfo?: Array<vimService.vim.PhysicalNicLinkInfo>;
         }
         interface PhysicalNicHint extends vimService.vim.DynamicData {
            vlanId?: number;
         }
         interface PhysicalNicIpHint extends vimService.vim.PhysicalNicHint {
            ipSubnet: string;
         }
         interface ArrayOfPhysicalNicIpHint {
            PhysicalNicIpHint?: Array<vimService.vim.PhysicalNicIpHint>;
         }
         interface PhysicalNicNameHint extends vimService.vim.PhysicalNicHint {
            network: string;
         }
         interface ArrayOfPhysicalNicNameHint {
            PhysicalNicNameHint?: Array<vimService.vim.PhysicalNicNameHint>;
         }
         interface PhysicalNicHintInfo extends vimService.vim.DynamicData {
            device: string;
            subnet?: Array<vimService.vim.PhysicalNicIpHint>;
            network?: Array<vimService.vim.PhysicalNicNameHint>;
            connectedSwitchPort?: vimService.vim.PhysicalNicCdpInfo;
            lldpInfo?: vimService.vim.LinkLayerDiscoveryProtocolInfo;
         }
         interface ArrayOfPhysicalNicHintInfo {
            PhysicalNicHintInfo?: Array<vimService.vim.PhysicalNicHintInfo>;
         }
         interface PhysicalNicCdpDeviceCapability extends vimService.vim.DynamicData {
            router: boolean;
            transparentBridge: boolean;
            sourceRouteBridge: boolean;
            networkSwitch: boolean;
            host: boolean;
            igmpEnabled: boolean;
            repeater: boolean;
         }
         interface PhysicalNicCdpInfo extends vimService.vim.DynamicData {
            cdpVersion?: number;
            timeout?: number;
            ttl?: number;
            samples?: number;
            devId?: string;
            address?: string;
            portId?: string;
            deviceCapability?: vimService.vim.PhysicalNicCdpDeviceCapability;
            softwareVersion?: string;
            hardwarePlatform?: string;
            ipPrefix?: string;
            ipPrefixLen?: number;
            vlan?: number;
            fullDuplex?: boolean;
            mtu?: number;
            systemName?: string;
            systemOID?: string;
            mgmtAddr?: string;
            location?: string;
         }
         interface LinkLayerDiscoveryProtocolInfo extends vimService.vim.DynamicData {
            chassisId: string;
            portId: string;
            timeToLive: number;
            parameter?: Array<vimService.vim.KeyAnyValue>;
         }
         enum PhysicalNicVmDirectPathGen2SupportedMode {
            "upt",
         }
         enum PhysicalNicResourcePoolSchedulerDisallowedReason {
            "userOptOut",
            "hardwareUnsupported",
         }
         interface PhysicalNic extends vimService.vim.DynamicData {
            key?: string;
            device: string;
            pci: string;
            driver?: string;
            linkSpeed?: vimService.vim.PhysicalNicLinkInfo;
            validLinkSpecification?: Array<vimService.vim.PhysicalNicLinkInfo>;
            spec: vimService.vim.PhysicalNicSpec;
            wakeOnLanSupported: boolean;
            mac: string;
            fcoeConfiguration?: vimService.vim.FcoeConfig;
            vmDirectPathGen2Supported?: boolean;
            vmDirectPathGen2SupportedMode?: string;
            resourcePoolSchedulerAllowed?: boolean;
            resourcePoolSchedulerDisallowedReason?: Array<string>;
            autoNegotiateSupported?: boolean;
         }
         interface ArrayOfPhysicalNic {
            PhysicalNic?: Array<vimService.vim.PhysicalNic>;
         }
         interface HostPlugStoreTopologyAdapter extends vimService.vim.DynamicData {
            key: string;
            adapter: string;
            path?: Array<string>;
         }
         interface ArrayOfHostPlugStoreTopologyAdapter {
            HostPlugStoreTopologyAdapter?: Array<vimService.vim.HostPlugStoreTopologyAdapter>;
         }
         interface HostPlugStoreTopologyPath extends vimService.vim.DynamicData {
            key: string;
            name: string;
            channelNumber?: number;
            targetNumber?: number;
            lunNumber?: number;
            adapter?: string;
            target?: string;
            device?: string;
         }
         interface ArrayOfHostPlugStoreTopologyPath {
            HostPlugStoreTopologyPath?: Array<vimService.vim.HostPlugStoreTopologyPath>;
         }
         interface HostPlugStoreTopologyDevice extends vimService.vim.DynamicData {
            key: string;
            lun: string;
            path?: Array<string>;
         }
         interface ArrayOfHostPlugStoreTopologyDevice {
            HostPlugStoreTopologyDevice?: Array<vimService.vim.HostPlugStoreTopologyDevice>;
         }
         interface HostPlugStoreTopologyPlugin extends vimService.vim.DynamicData {
            key: string;
            name: string;
            device?: Array<string>;
            claimedPath?: Array<string>;
         }
         interface ArrayOfHostPlugStoreTopologyPlugin {
            HostPlugStoreTopologyPlugin?: Array<vimService.vim.HostPlugStoreTopologyPlugin>;
         }
         interface HostPlugStoreTopologyTarget extends vimService.vim.DynamicData {
            key: string;
            transport?: vimService.vim.HostTargetTransport;
         }
         interface ArrayOfHostPlugStoreTopologyTarget {
            HostPlugStoreTopologyTarget?: Array<vimService.vim.HostPlugStoreTopologyTarget>;
         }
         interface HostPlugStoreTopology extends vimService.vim.DynamicData {
            adapter?: Array<vimService.vim.HostPlugStoreTopologyAdapter>;
            path?: Array<vimService.vim.HostPlugStoreTopologyPath>;
            target?: Array<vimService.vim.HostPlugStoreTopologyTarget>;
            device?: Array<vimService.vim.HostPlugStoreTopologyDevice>;
            plugin?: Array<vimService.vim.HostPlugStoreTopologyPlugin>;
         }
         enum PortGroupConnecteeType {
            "virtualMachine",
            "systemManagement",
            "host",
            "unknown",
         }
         interface HostPortGroupSpec extends vimService.vim.DynamicData {
            name: string;
            vlanId: number;
            vswitchName: string;
            policy: vimService.vim.HostNetworkPolicy;
         }
         interface HostPortGroupConfig extends vimService.vim.DynamicData {
            changeOperation?: string;
            spec?: vimService.vim.HostPortGroupSpec;
         }
         interface ArrayOfHostPortGroupConfig {
            HostPortGroupConfig?: Array<vimService.vim.HostPortGroupConfig>;
         }
         interface HostPortGroupPort extends vimService.vim.DynamicData {
            key?: string;
            mac?: Array<string>;
            type: string;
         }
         interface ArrayOfHostPortGroupPort {
            HostPortGroupPort?: Array<vimService.vim.HostPortGroupPort>;
         }
         interface HostPortGroup extends vimService.vim.DynamicData {
            key?: string;
            port?: Array<vimService.vim.HostPortGroupPort>;
            vswitch?: string;
            computedPolicy: vimService.vim.HostNetworkPolicy;
            spec: vimService.vim.HostPortGroupSpec;
         }
         interface ArrayOfHostPortGroup {
            HostPortGroup?: Array<vimService.vim.HostPortGroup>;
         }
         interface HostPowerPolicy extends vimService.vim.DynamicData {
            key: number;
            name: string;
            shortName: string;
            description: string;
         }
         interface ArrayOfHostPowerPolicy {
            HostPowerPolicy?: Array<vimService.vim.HostPowerPolicy>;
         }
         interface PowerSystemCapability extends vimService.vim.DynamicData {
            availablePolicy: Array<vimService.vim.HostPowerPolicy>;
         }
         interface PowerSystemInfo extends vimService.vim.DynamicData {
            currentPolicy: vimService.vim.HostPowerPolicy;
         }
         enum HostProtocolEndpointPEType {
            "block",
            "nas",
         }
         enum HostProtocolEndpointProtocolEndpointType {
            "scsi",
            "nfs",
            "nfs4x",
         }
         interface HostProtocolEndpoint extends vimService.vim.DynamicData {
            peType: string;
            type?: string;
            uuid: string;
            hostKey?: Array<vimService.vim.ManagedObjectReference>;
            storageArray?: string;
            nfsServer?: string;
            nfsDir?: string;
            nfsServerScope?: string;
            nfsServerMajor?: string;
            nfsServerAuthType?: string;
            nfsServerUser?: string;
            deviceId?: string;
         }
         interface ArrayOfHostProtocolEndpoint {
            HostProtocolEndpoint?: Array<vimService.vim.HostProtocolEndpoint>;
         }
         interface HostResignatureRescanResult extends vimService.vim.DynamicData {
            rescan?: Array<vimService.vim.HostVmfsRescanResult>;
            result: vimService.vim.ManagedObjectReference;
         }
         interface HostFirewallRulesetIpNetwork extends vimService.vim.DynamicData {
            network: string;
            prefixLength: number;
         }
         interface ArrayOfHostFirewallRulesetIpNetwork {
            HostFirewallRulesetIpNetwork?: Array<vimService.vim.HostFirewallRulesetIpNetwork>;
         }
         interface HostFirewallRulesetIpList extends vimService.vim.DynamicData {
            ipAddress?: Array<string>;
            ipNetwork?: Array<vimService.vim.HostFirewallRulesetIpNetwork>;
            allIp: boolean;
         }
         interface HostFirewallRulesetRulesetSpec extends vimService.vim.DynamicData {
            allowedHosts: vimService.vim.HostFirewallRulesetIpList;
         }
         enum HostFirewallRuleDirection {
            "inbound",
            "outbound",
         }
         enum HostFirewallRulePortType {
            "src",
            "dst",
         }
         enum HostFirewallRuleProtocol {
            "tcp",
            "udp",
         }
         interface HostFirewallRule extends vimService.vim.DynamicData {
            port: number;
            endPort?: number;
            direction: vimService.vim.HostFirewallRuleDirection;
            portType?: vimService.vim.HostFirewallRulePortType;
            protocol: string;
         }
         interface ArrayOfHostFirewallRule {
            HostFirewallRule?: Array<vimService.vim.HostFirewallRule>;
         }
         interface HostFirewallRuleset extends vimService.vim.DynamicData {
            key: string;
            label: string;
            required: boolean;
            rule: Array<vimService.vim.HostFirewallRule>;
            service?: string;
            enabled: boolean;
            allowedHosts?: vimService.vim.HostFirewallRulesetIpList;
         }
         interface ArrayOfHostFirewallRuleset {
            HostFirewallRuleset?: Array<vimService.vim.HostFirewallRuleset>;
         }
         enum HostRuntimeInfoNetStackInstanceRuntimeInfoState {
            "inactive",
            "active",
            "deactivating",
            "activating",
         }
         interface HostRuntimeInfoNetStackInstanceRuntimeInfo extends vimService.vim.DynamicData {
            netStackInstanceKey: string;
            state?: string;
            vmknicKeys?: Array<string>;
            maxNumberOfConnections?: number;
            currentIpV6Enabled?: boolean;
         }
         interface ArrayOfHostRuntimeInfoNetStackInstanceRuntimeInfo {
            HostRuntimeInfoNetStackInstanceRuntimeInfo?: Array<vimService.vim.HostRuntimeInfoNetStackInstanceRuntimeInfo>;
         }
         interface HostPlacedVirtualNicIdentifier extends vimService.vim.DynamicData {
            vm: vimService.vim.ManagedObjectReference;
            vnicKey: string;
            reservation?: number;
         }
         interface ArrayOfHostPlacedVirtualNicIdentifier {
            HostPlacedVirtualNicIdentifier?: Array<vimService.vim.HostPlacedVirtualNicIdentifier>;
         }
         interface HostPnicNetworkResourceInfo extends vimService.vim.DynamicData {
            pnicDevice: string;
            availableBandwidthForVMTraffic?: number;
            unusedBandwidthForVMTraffic?: number;
            placedVirtualNics?: Array<vimService.vim.HostPlacedVirtualNicIdentifier>;
         }
         interface ArrayOfHostPnicNetworkResourceInfo {
            HostPnicNetworkResourceInfo?: Array<vimService.vim.HostPnicNetworkResourceInfo>;
         }
         interface HostNetworkResourceRuntime extends vimService.vim.DynamicData {
            pnicResourceInfo: Array<vimService.vim.HostPnicNetworkResourceInfo>;
         }
         interface HostRuntimeInfoNetworkRuntimeInfo extends vimService.vim.DynamicData {
            netStackInstanceRuntimeInfo?: Array<vimService.vim.HostRuntimeInfoNetStackInstanceRuntimeInfo>;
            networkResourceRuntime?: vimService.vim.HostNetworkResourceRuntime;
         }
         interface HostRuntimeInfo extends vimService.vim.DynamicData {
            connectionState: vimService.vim.HostSystemConnectionState;
            powerState: vimService.vim.HostSystemPowerState;
            standbyMode?: string;
            inMaintenanceMode: boolean;
            inQuarantineMode?: boolean;
            bootTime?: Date;
            healthSystemRuntime?: vimService.vim.HealthSystemRuntime;
            dasHostState?: vimService.vim.ClusterDasFdmHostState;
            tpmPcrValues?: Array<vimService.vim.HostTpmDigestInfo>;
            vsanRuntimeInfo?: vimService.vim.VsanHostRuntimeInfo;
            networkRuntimeInfo?: vimService.vim.HostRuntimeInfoNetworkRuntimeInfo;
            vFlashResourceRuntimeInfo?: vimService.vim.HostVFlashManagerVFlashResourceRunTimeInfo;
            hostMaxVirtualDiskCapacity?: number;
            cryptoState?: string;
            cryptoKeyId?: vimService.vim.CryptoKeyId;
         }
         interface HostScsiDiskPartition extends vimService.vim.DynamicData {
            diskName: string;
            partition: number;
         }
         interface ArrayOfHostScsiDiskPartition {
            HostScsiDiskPartition?: Array<vimService.vim.HostScsiDiskPartition>;
         }
         enum ScsiDiskType {
            "native512",
            "emulated512",
            "native4k",
            "unknown",
         }
         interface HostScsiDisk extends vimService.vim.ScsiLun {
            capacity: vimService.vim.HostDiskDimensionsLba;
            devicePath: string;
            ssd?: boolean;
            localDisk?: boolean;
            physicalLocation?: Array<string>;
            emulatedDIXDIFEnabled?: boolean;
            vsanDiskInfo?: vimService.vim.VsanHostVsanDiskInfo;
            scsiDiskType?: string;
         }
         interface ArrayOfHostScsiDisk {
            HostScsiDisk?: Array<vimService.vim.HostScsiDisk>;
         }
         enum ScsiLunType {
            "disk",
            "tape",
            "printer",
            "processor",
            "worm",
            "cdrom",
            "scanner",
            "opticalDevice",
            "mediaChanger",
            "communications",
            "storageArrayController",
            "enclosure",
            "unknown",
         }
         interface ScsiLunCapabilities extends vimService.vim.DynamicData {
            updateDisplayNameSupported: boolean;
         }
         interface ScsiLunDurableName extends vimService.vim.DynamicData {
            namespace: string;
            namespaceId: number;
            data?: Array<number>;
         }
         interface ArrayOfScsiLunDurableName {
            ScsiLunDurableName?: Array<vimService.vim.ScsiLunDurableName>;
         }
         enum ScsiLunState {
            "unknownState",
            "ok",
            "error",
            "off",
            "quiesced",
            "degraded",
            "lostCommunication",
            "timeout",
         }
         enum ScsiLunDescriptorQuality {
            "highQuality",
            "mediumQuality",
            "lowQuality",
            "unknownQuality",
         }
         interface ScsiLunDescriptor extends vimService.vim.DynamicData {
            quality: string;
            id: string;
         }
         interface ArrayOfScsiLunDescriptor {
            ScsiLunDescriptor?: Array<vimService.vim.ScsiLunDescriptor>;
         }
         enum ScsiLunVStorageSupportStatus {
            "vStorageSupported",
            "vStorageUnsupported",
            "vStorageUnknown",
         }
         interface ScsiLun extends vimService.vim.HostDevice {
            key?: string;
            uuid: string;
            descriptor?: Array<vimService.vim.ScsiLunDescriptor>;
            canonicalName?: string;
            displayName?: string;
            lunType: string;
            vendor?: string;
            model?: string;
            revision?: string;
            scsiLevel?: number;
            serialNumber?: string;
            durableName?: vimService.vim.ScsiLunDurableName;
            alternateName?: Array<vimService.vim.ScsiLunDurableName>;
            standardInquiry?: Array<number>;
            queueDepth?: number;
            operationalState: Array<string>;
            capabilities?: vimService.vim.ScsiLunCapabilities;
            vStorageSupport?: string;
            protocolEndpoint?: boolean;
         }
         interface ArrayOfScsiLun {
            ScsiLun?: Array<vimService.vim.ScsiLun>;
         }
         interface HostScsiTopologyInterface extends vimService.vim.DynamicData {
            key: string;
            adapter: string;
            target?: Array<vimService.vim.HostScsiTopologyTarget>;
         }
         interface ArrayOfHostScsiTopologyInterface {
            HostScsiTopologyInterface?: Array<vimService.vim.HostScsiTopologyInterface>;
         }
         interface HostScsiTopologyTarget extends vimService.vim.DynamicData {
            key: string;
            target: number;
            lun?: Array<vimService.vim.HostScsiTopologyLun>;
            transport?: vimService.vim.HostTargetTransport;
         }
         interface ArrayOfHostScsiTopologyTarget {
            HostScsiTopologyTarget?: Array<vimService.vim.HostScsiTopologyTarget>;
         }
         interface HostScsiTopologyLun extends vimService.vim.DynamicData {
            key: string;
            lun: number;
            scsiLun: string;
         }
         interface ArrayOfHostScsiTopologyLun {
            HostScsiTopologyLun?: Array<vimService.vim.HostScsiTopologyLun>;
         }
         interface HostScsiTopology extends vimService.vim.DynamicData {
            adapter?: Array<vimService.vim.HostScsiTopologyInterface>;
         }
         interface HostSecuritySpec extends vimService.vim.DynamicData {
            adminPassword?: string;
            removePermission?: Array<vimService.vim.Permission>;
            addPermission?: Array<vimService.vim.Permission>;
         }
         enum HostServicePolicy {
            "on",
            "automatic",
            "off",
         }
         interface HostServiceSourcePackage extends vimService.vim.DynamicData {
            sourcePackageName: string;
            description: string;
         }
         interface HostService extends vimService.vim.DynamicData {
            key: string;
            label: string;
            required: boolean;
            uninstallable: boolean;
            running: boolean;
            ruleset?: Array<string>;
            policy: string;
            sourcePackage?: vimService.vim.HostServiceSourcePackage;
         }
         interface ArrayOfHostService {
            HostService?: Array<vimService.vim.HostService>;
         }
         interface HostServiceConfig extends vimService.vim.DynamicData {
            serviceId: string;
            startupPolicy: string;
         }
         interface ArrayOfHostServiceConfig {
            HostServiceConfig?: Array<vimService.vim.HostServiceConfig>;
         }
         interface HostServiceInfo extends vimService.vim.DynamicData {
            service?: Array<vimService.vim.HostService>;
         }
         interface HostSnmpDestination extends vimService.vim.DynamicData {
            hostName: string;
            port: number;
            community: string;
         }
         interface ArrayOfHostSnmpDestination {
            HostSnmpDestination?: Array<vimService.vim.HostSnmpDestination>;
         }
         interface HostSnmpConfigSpec extends vimService.vim.DynamicData {
            enabled?: boolean;
            port?: number;
            readOnlyCommunities?: Array<string>;
            trapTargets?: Array<vimService.vim.HostSnmpDestination>;
            option?: Array<vimService.vim.KeyValue>;
         }
         enum HostSnmpAgentCapability {
            "COMPLETE",
            "DIAGNOSTICS",
            "CONFIGURATION",
         }
         interface HostSnmpSystemAgentLimits extends vimService.vim.DynamicData {
            maxReadOnlyCommunities: number;
            maxTrapDestinations: number;
            maxCommunityLength: number;
            maxBufferSize: number;
            capability?: vimService.vim.HostSnmpAgentCapability;
         }
         enum SoftwarePackageVibType {
            "bootbank",
            "tools",
            "meta",
         }
         interface SoftwarePackageCapability extends vimService.vim.DynamicData {
            liveInstallAllowed?: boolean;
            liveRemoveAllowed?: boolean;
            statelessReady?: boolean;
            overlay?: boolean;
         }
         enum SoftwarePackageConstraint {
            "equals",
            "lessThan",
            "lessThanEqual",
            "greaterThanEqual",
            "greaterThan",
         }
         interface Relation extends vimService.vim.DynamicData {
            constraint?: string;
            name: string;
            version?: string;
         }
         interface ArrayOfRelation {
            Relation?: Array<vimService.vim.Relation>;
         }
         interface SoftwarePackage extends vimService.vim.DynamicData {
            name: string;
            version: string;
            type: string;
            vendor: string;
            acceptanceLevel: string;
            summary: string;
            description: string;
            referenceURL?: Array<string>;
            creationDate?: Date;
            depends?: Array<vimService.vim.Relation>;
            conflicts?: Array<vimService.vim.Relation>;
            replaces?: Array<vimService.vim.Relation>;
            provides?: Array<string>;
            maintenanceModeRequired?: boolean;
            hardwarePlatformsRequired?: Array<string>;
            capability: vimService.vim.SoftwarePackageCapability;
            tag?: Array<string>;
            payload?: Array<string>;
         }
         interface ArrayOfSoftwarePackage {
            SoftwarePackage?: Array<vimService.vim.SoftwarePackage>;
         }
         interface HostSriovConfig extends vimService.vim.HostPciPassthruConfig {
            sriovEnabled: boolean;
            numVirtualFunction: number;
         }
         interface HostSriovDevicePoolInfo extends vimService.vim.DynamicData {
            key: string;
         }
         interface ArrayOfHostSriovDevicePoolInfo {
            HostSriovDevicePoolInfo?: Array<vimService.vim.HostSriovDevicePoolInfo>;
         }
         interface HostSriovInfo extends vimService.vim.HostPciPassthruInfo {
            sriovEnabled: boolean;
            sriovCapable: boolean;
            sriovActive: boolean;
            numVirtualFunctionRequested: number;
            numVirtualFunction: number;
            maxVirtualFunctionSupported: number;
         }
         interface HostSriovNetworkDevicePoolInfo extends vimService.vim.HostSriovDevicePoolInfo {
            switchKey?: string;
            switchUuid?: string;
            pnic?: Array<vimService.vim.PhysicalNic>;
         }
         interface HostSslThumbprintInfo extends vimService.vim.DynamicData {
            principal: string;
            ownerTag?: string;
            sslThumbprints?: Array<string>;
         }
         interface ArrayOfHostSslThumbprintInfo {
            HostSslThumbprintInfo?: Array<vimService.vim.HostSslThumbprintInfo>;
         }
         interface HostStorageArrayTypePolicyOption extends vimService.vim.DynamicData {
            policy: vimService.vim.ElementDescription;
         }
         interface ArrayOfHostStorageArrayTypePolicyOption {
            HostStorageArrayTypePolicyOption?: Array<vimService.vim.HostStorageArrayTypePolicyOption>;
         }
         interface HostStorageDeviceInfo extends vimService.vim.DynamicData {
            hostBusAdapter?: Array<vimService.vim.HostHostBusAdapter>;
            scsiLun?: Array<vimService.vim.ScsiLun>;
            scsiTopology?: vimService.vim.HostScsiTopology;
            multipathInfo?: vimService.vim.HostMultipathInfo;
            plugStoreTopology?: vimService.vim.HostPlugStoreTopology;
            softwareInternetScsiEnabled: boolean;
         }
         interface HostStorageSystemVmfsVolumeResult extends vimService.vim.DynamicData {
            key: string;
            fault?: vimService.vim.LocalizedMethodFault;
         }
         interface ArrayOfHostStorageSystemVmfsVolumeResult {
            HostStorageSystemVmfsVolumeResult?: Array<vimService.vim.HostStorageSystemVmfsVolumeResult>;
         }
         interface HostStorageSystemScsiLunResult extends vimService.vim.DynamicData {
            key: string;
            fault?: vimService.vim.LocalizedMethodFault;
         }
         interface ArrayOfHostStorageSystemScsiLunResult {
            HostStorageSystemScsiLunResult?: Array<vimService.vim.HostStorageSystemScsiLunResult>;
         }
         interface HostStorageSystemDiskLocatorLedResult extends vimService.vim.DynamicData {
            key: string;
            fault: vimService.vim.LocalizedMethodFault;
         }
         interface ArrayOfHostStorageSystemDiskLocatorLedResult {
            HostStorageSystemDiskLocatorLedResult?: Array<vimService.vim.HostStorageSystemDiskLocatorLedResult>;
         }
         interface HostHardwareSummary extends vimService.vim.DynamicData {
            vendor: string;
            model: string;
            uuid: string;
            otherIdentifyingInfo?: Array<vimService.vim.HostSystemIdentificationInfo>;
            memorySize: number;
            cpuModel: string;
            cpuMhz: number;
            numCpuPkgs: number;
            numCpuCores: number;
            numCpuThreads: number;
            numNics: number;
            numHBAs: number;
         }
         interface HostListSummaryQuickStats extends vimService.vim.DynamicData {
            overallCpuUsage?: number;
            overallMemoryUsage?: number;
            distributedCpuFairness?: number;
            distributedMemoryFairness?: number;
            uptime?: number;
         }
         interface HostConfigSummary extends vimService.vim.DynamicData {
            name: string;
            port: number;
            sslThumbprint?: string;
            product?: vimService.vim.AboutInfo;
            vmotionEnabled: boolean;
            faultToleranceEnabled?: boolean;
            featureVersion?: Array<vimService.vim.HostFeatureVersionInfo>;
            agentVmDatastore?: vimService.vim.ManagedObjectReference;
            agentVmNetwork?: vimService.vim.ManagedObjectReference;
         }
         interface HostListSummaryGatewaySummary extends vimService.vim.DynamicData {
            gatewayType: string;
            gatewayId: string;
         }
         interface HostListSummary extends vimService.vim.DynamicData {
            host?: vimService.vim.ManagedObjectReference;
            hardware?: vimService.vim.HostHardwareSummary;
            runtime?: vimService.vim.HostRuntimeInfo;
            config: vimService.vim.HostConfigSummary;
            quickStats: vimService.vim.HostListSummaryQuickStats;
            overallStatus: vimService.vim.ManagedEntityStatus;
            rebootRequired: boolean;
            customValue?: Array<vimService.vim.CustomFieldValue>;
            managementServerIp?: string;
            maxEVCModeKey?: string;
            currentEVCModeKey?: string;
            gateway?: vimService.vim.HostListSummaryGatewaySummary;
         }
         interface SystemEventInfo extends vimService.vim.DynamicData {
            recordId: number;
            when: string;
            selType: number;
            message: string;
            sensorNumber: number;
         }
         interface ArrayOfSystemEventInfo {
            SystemEventInfo?: Array<vimService.vim.SystemEventInfo>;
         }
         interface HostSystemHealthInfo extends vimService.vim.DynamicData {
            numericSensorInfo?: Array<vimService.vim.HostNumericSensorInfo>;
         }
         enum HostSystemIdentificationInfoIdentifier {
            "AssetTag",
            "ServiceTag",
            "OemSpecificString",
         }
         interface HostSystemIdentificationInfo extends vimService.vim.DynamicData {
            identifierValue: string;
            identifierType: vimService.vim.ElementDescription;
         }
         interface ArrayOfHostSystemIdentificationInfo {
            HostSystemIdentificationInfo?: Array<vimService.vim.HostSystemIdentificationInfo>;
         }
         interface HostSystemResourceInfo extends vimService.vim.DynamicData {
            key: string;
            config?: vimService.vim.ResourceConfigSpec;
            child?: Array<vimService.vim.HostSystemResourceInfo>;
         }
         interface ArrayOfHostSystemResourceInfo {
            HostSystemResourceInfo?: Array<vimService.vim.HostSystemResourceInfo>;
         }
         interface HostSystemSwapConfigurationSystemSwapOption extends vimService.vim.DynamicData {
            key: number;
         }
         interface ArrayOfHostSystemSwapConfigurationSystemSwapOption {
            HostSystemSwapConfigurationSystemSwapOption?: Array<vimService.vim.HostSystemSwapConfigurationSystemSwapOption>;
         }
         interface HostSystemSwapConfigurationDisabledOption extends vimService.vim.HostSystemSwapConfigurationSystemSwapOption {
         }
         interface HostSystemSwapConfigurationHostCacheOption extends vimService.vim.HostSystemSwapConfigurationSystemSwapOption {
         }
         interface HostSystemSwapConfigurationHostLocalSwapOption extends vimService.vim.HostSystemSwapConfigurationSystemSwapOption {
         }
         interface HostSystemSwapConfigurationDatastoreOption extends vimService.vim.HostSystemSwapConfigurationSystemSwapOption {
            datastore: string;
         }
         interface HostSystemSwapConfiguration extends vimService.vim.DynamicData {
            option?: Array<vimService.vim.HostSystemSwapConfigurationSystemSwapOption>;
         }
         interface HostTargetTransport extends vimService.vim.DynamicData {
         }
         interface HostParallelScsiTargetTransport extends vimService.vim.HostTargetTransport {
         }
         interface HostBlockAdapterTargetTransport extends vimService.vim.HostTargetTransport {
         }
         interface HostSerialAttachedTargetTransport extends vimService.vim.HostTargetTransport {
         }
         interface HostFibreChannelTargetTransport extends vimService.vim.HostTargetTransport {
            portWorldWideName: number;
            nodeWorldWideName: number;
         }
         interface HostInternetScsiTargetTransport extends vimService.vim.HostTargetTransport {
            iScsiName: string;
            iScsiAlias: string;
            address?: Array<string>;
         }
         interface HostFibreChannelOverEthernetTargetTransport extends vimService.vim.HostFibreChannelTargetTransport {
            vnportMac: string;
            fcfMac: string;
            vlanId: number;
         }
         interface HostTpmAttestationReport extends vimService.vim.DynamicData {
            tpmPcrValues: Array<vimService.vim.HostTpmDigestInfo>;
            tpmEvents: Array<vimService.vim.HostTpmEventLogEntry>;
            tpmLogReliable: boolean;
         }
         interface HostTpmBootSecurityOptionEventDetails extends vimService.vim.HostTpmEventDetails {
            bootSecurityOption: string;
         }
         interface HostTpmCommandEventDetails extends vimService.vim.HostTpmEventDetails {
            commandLine: string;
         }
         enum HostDigestInfoDigestMethodType {
            "SHA1",
            "MD5",
         }
         interface HostDigestInfo extends vimService.vim.DynamicData {
            digestMethod: string;
            digestValue: Array<number>;
            objectName?: string;
         }
         interface HostTpmDigestInfo extends vimService.vim.HostDigestInfo {
            pcrNumber: number;
         }
         interface ArrayOfHostTpmDigestInfo {
            HostTpmDigestInfo?: Array<vimService.vim.HostTpmDigestInfo>;
         }
         interface HostTpmEventDetails extends vimService.vim.DynamicData {
            dataHash: Array<number>;
         }
         interface HostTpmEventLogEntry extends vimService.vim.DynamicData {
            pcrIndex: number;
            eventDetails: vimService.vim.HostTpmEventDetails;
         }
         interface ArrayOfHostTpmEventLogEntry {
            HostTpmEventLogEntry?: Array<vimService.vim.HostTpmEventLogEntry>;
         }
         interface HostTpmOptionEventDetails extends vimService.vim.HostTpmEventDetails {
            optionsFileName: string;
            bootOptions?: Array<number>;
         }
         interface HostTpmSoftwareComponentEventDetails extends vimService.vim.HostTpmEventDetails {
            componentName: string;
            vibName: string;
            vibVersion: string;
            vibVendor: string;
         }
         enum HostUnresolvedVmfsExtentUnresolvedReason {
            "diskIdMismatch",
            "uuidConflict",
         }
         interface HostUnresolvedVmfsExtent extends vimService.vim.DynamicData {
            device: vimService.vim.HostScsiDiskPartition;
            devicePath: string;
            vmfsUuid: string;
            isHeadExtent: boolean;
            ordinal: number;
            startBlock: number;
            endBlock: number;
            reason: string;
         }
         interface ArrayOfHostUnresolvedVmfsExtent {
            HostUnresolvedVmfsExtent?: Array<vimService.vim.HostUnresolvedVmfsExtent>;
         }
         interface HostUnresolvedVmfsResignatureSpec extends vimService.vim.DynamicData {
            extentDevicePath: Array<string>;
         }
         interface HostUnresolvedVmfsResolutionResult extends vimService.vim.DynamicData {
            spec: vimService.vim.HostUnresolvedVmfsResolutionSpec;
            vmfs?: vimService.vim.HostVmfsVolume;
            fault?: vimService.vim.LocalizedMethodFault;
         }
         interface ArrayOfHostUnresolvedVmfsResolutionResult {
            HostUnresolvedVmfsResolutionResult?: Array<vimService.vim.HostUnresolvedVmfsResolutionResult>;
         }
         enum HostUnresolvedVmfsResolutionSpecVmfsUuidResolution {
            "resignature",
            "forceMount",
         }
         interface HostUnresolvedVmfsResolutionSpec extends vimService.vim.DynamicData {
            extentDevicePath: Array<string>;
            uuidResolution: string;
         }
         interface ArrayOfHostUnresolvedVmfsResolutionSpec {
            HostUnresolvedVmfsResolutionSpec?: Array<vimService.vim.HostUnresolvedVmfsResolutionSpec>;
         }
         interface HostUnresolvedVmfsVolumeResolveStatus extends vimService.vim.DynamicData {
            resolvable: boolean;
            incompleteExtents?: boolean;
            multipleCopies?: boolean;
         }
         interface HostUnresolvedVmfsVolume extends vimService.vim.DynamicData {
            extent: Array<vimService.vim.HostUnresolvedVmfsExtent>;
            vmfsLabel: string;
            vmfsUuid: string;
            totalBlocks: number;
            resolveStatus: vimService.vim.HostUnresolvedVmfsVolumeResolveStatus;
         }
         interface ArrayOfHostUnresolvedVmfsVolume {
            HostUnresolvedVmfsVolume?: Array<vimService.vim.HostUnresolvedVmfsVolume>;
         }
         interface HostVFlashManagerVFlashResourceConfigSpec extends vimService.vim.DynamicData {
            vffsUuid: string;
         }
         interface HostVFlashManagerVFlashResourceConfigInfo extends vimService.vim.DynamicData {
            vffs?: vimService.vim.HostVffsVolume;
            capacity: number;
         }
         interface HostVFlashManagerVFlashResourceRunTimeInfo extends vimService.vim.DynamicData {
            usage: number;
            capacity: number;
            accessible: boolean;
            capacityForVmCache: number;
            freeForVmCache: number;
         }
         interface HostVFlashManagerVFlashCacheConfigSpec extends vimService.vim.DynamicData {
            defaultVFlashModule: string;
            swapCacheReservationInGB: number;
         }
         interface HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption extends vimService.vim.DynamicData {
            vFlashModule: string;
            vFlashModuleVersion: string;
            minSupportedModuleVersion: string;
            cacheConsistencyType: vimService.vim.ChoiceOption;
            cacheMode: vimService.vim.ChoiceOption;
            blockSizeInKBOption: vimService.vim.LongOption;
            reservationInMBOption: vimService.vim.LongOption;
            maxDiskSizeInKB: number;
         }
         interface ArrayOfHostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption {
            HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption?: Array<vimService.vim.HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption>;
         }
         interface HostVFlashManagerVFlashCacheConfigInfo extends vimService.vim.DynamicData {
            vFlashModuleConfigOption?: Array<vimService.vim.HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption>;
            defaultVFlashModule?: string;
            swapCacheReservationInGB?: number;
         }
         interface HostVFlashManagerVFlashConfigInfo extends vimService.vim.DynamicData {
            vFlashResourceConfigInfo?: vimService.vim.HostVFlashManagerVFlashResourceConfigInfo;
            vFlashCacheConfigInfo?: vimService.vim.HostVFlashManagerVFlashCacheConfigInfo;
         }
         interface HostVFlashResourceConfigurationResult extends vimService.vim.DynamicData {
            devicePath?: Array<string>;
            vffs?: vimService.vim.HostVffsVolume;
            diskConfigurationResult?: Array<vimService.vim.HostDiskConfigurationResult>;
         }
         interface HostVMotionConfig extends vimService.vim.DynamicData {
            vmotionNicKey?: string;
            enabled: boolean;
         }
         interface HostVMotionInfo extends vimService.vim.DynamicData {
            netConfig?: vimService.vim.HostVMotionNetConfig;
            ipConfig?: vimService.vim.HostIpConfig;
         }
         interface HostVMotionNetConfig extends vimService.vim.DynamicData {
            candidateVnic?: Array<vimService.vim.HostVirtualNic>;
            selectedVnic?: string;
         }
         interface HostVffsSpec extends vimService.vim.DynamicData {
            devicePath: string;
            partition?: vimService.vim.HostDiskPartitionSpec;
            majorVersion: number;
            volumeName: string;
         }
         interface HostVffsVolume extends vimService.vim.HostFileSystemVolume {
            majorVersion: number;
            version: string;
            uuid: string;
            extent: Array<vimService.vim.HostScsiDiskPartition>;
         }
         interface HostVirtualNicSpec extends vimService.vim.DynamicData {
            ip?: vimService.vim.HostIpConfig;
            mac?: string;
            distributedVirtualPort?: vimService.vim.DistributedVirtualSwitchPortConnection;
            portgroup?: string;
            mtu?: number;
            tsoEnabled?: boolean;
            netStackInstanceKey?: string;
            opaqueNetwork?: vimService.vim.HostVirtualNicOpaqueNetworkSpec;
            externalId?: string;
            pinnedPnic?: string;
            ipRouteSpec?: vimService.vim.HostVirtualNicIpRouteSpec;
         }
         interface HostVirtualNicConfig extends vimService.vim.DynamicData {
            changeOperation?: string;
            device?: string;
            portgroup: string;
            spec?: vimService.vim.HostVirtualNicSpec;
         }
         interface ArrayOfHostVirtualNicConfig {
            HostVirtualNicConfig?: Array<vimService.vim.HostVirtualNicConfig>;
         }
         interface HostVirtualNicOpaqueNetworkSpec extends vimService.vim.DynamicData {
            opaqueNetworkId: string;
            opaqueNetworkType: string;
         }
         interface HostVirtualNicIpRouteSpec extends vimService.vim.DynamicData {
            ipRouteConfig?: vimService.vim.HostIpRouteConfig;
         }
         interface HostVirtualNic extends vimService.vim.DynamicData {
            device: string;
            key: string;
            portgroup: string;
            spec: vimService.vim.HostVirtualNicSpec;
            port?: string;
         }
         interface ArrayOfHostVirtualNic {
            HostVirtualNic?: Array<vimService.vim.HostVirtualNic>;
         }
         interface HostVirtualNicConnection extends vimService.vim.DynamicData {
            portgroup?: string;
            dvPort?: vimService.vim.DistributedVirtualSwitchPortConnection;
         }
         enum HostVirtualNicManagerNicType {
            "vmotion",
            "faultToleranceLogging",
            "vSphereReplication",
            "vSphereReplicationNFC",
            "management",
            "vsan",
            "vSphereProvisioning",
            "vsanWitness",
         }
         interface HostVirtualNicManagerNicTypeSelection extends vimService.vim.DynamicData {
            vnic: vimService.vim.HostVirtualNicConnection;
            nicType?: Array<string>;
         }
         interface ArrayOfHostVirtualNicManagerNicTypeSelection {
            HostVirtualNicManagerNicTypeSelection?: Array<vimService.vim.HostVirtualNicManagerNicTypeSelection>;
         }
         interface VirtualNicManagerNetConfig extends vimService.vim.DynamicData {
            nicType: string;
            multiSelectAllowed: boolean;
            candidateVnic?: Array<vimService.vim.HostVirtualNic>;
            selectedVnic?: Array<string>;
         }
         interface ArrayOfVirtualNicManagerNetConfig {
            VirtualNicManagerNetConfig?: Array<vimService.vim.VirtualNicManagerNetConfig>;
         }
         interface HostVirtualNicManagerInfo extends vimService.vim.DynamicData {
            netConfig?: Array<vimService.vim.VirtualNicManagerNetConfig>;
         }
         interface HostVirtualSwitchBridge extends vimService.vim.DynamicData {
         }
         interface HostVirtualSwitchAutoBridge extends vimService.vim.HostVirtualSwitchBridge {
            excludedNicDevice?: Array<string>;
         }
         interface HostVirtualSwitchSimpleBridge extends vimService.vim.HostVirtualSwitchBridge {
            nicDevice: string;
         }
         interface HostVirtualSwitchBondBridge extends vimService.vim.HostVirtualSwitchBridge {
            nicDevice: Array<string>;
            beacon?: vimService.vim.HostVirtualSwitchBeaconConfig;
            linkDiscoveryProtocolConfig?: vimService.vim.LinkDiscoveryProtocolConfig;
         }
         interface HostVirtualSwitchBeaconConfig extends vimService.vim.DynamicData {
            interval: number;
         }
         interface HostVirtualSwitchSpec extends vimService.vim.DynamicData {
            numPorts: number;
            bridge?: vimService.vim.HostVirtualSwitchBridge;
            policy?: vimService.vim.HostNetworkPolicy;
            mtu?: number;
         }
         interface HostVirtualSwitchConfig extends vimService.vim.DynamicData {
            changeOperation?: string;
            name: string;
            spec?: vimService.vim.HostVirtualSwitchSpec;
         }
         interface ArrayOfHostVirtualSwitchConfig {
            HostVirtualSwitchConfig?: Array<vimService.vim.HostVirtualSwitchConfig>;
         }
         interface HostVirtualSwitch extends vimService.vim.DynamicData {
            name: string;
            key: string;
            numPorts: number;
            numPortsAvailable: number;
            mtu?: number;
            portgroup?: Array<string>;
            pnic?: Array<string>;
            spec: vimService.vim.HostVirtualSwitchSpec;
         }
         interface ArrayOfHostVirtualSwitch {
            HostVirtualSwitch?: Array<vimService.vim.HostVirtualSwitch>;
         }
         enum HostVmciAccessManagerMode {
            "grant",
            "replace",
            "revoke",
         }
         interface HostVmciAccessManagerAccessSpec extends vimService.vim.DynamicData {
            vm: vimService.vim.ManagedObjectReference;
            services?: Array<string>;
            mode: string;
         }
         interface ArrayOfHostVmciAccessManagerAccessSpec {
            HostVmciAccessManagerAccessSpec?: Array<vimService.vim.HostVmciAccessManagerAccessSpec>;
         }
         interface HostVmfsRescanResult extends vimService.vim.DynamicData {
            host: vimService.vim.ManagedObjectReference;
            fault?: vimService.vim.LocalizedMethodFault;
         }
         interface ArrayOfHostVmfsRescanResult {
            HostVmfsRescanResult?: Array<vimService.vim.HostVmfsRescanResult>;
         }
         interface HostVmfsSpec extends vimService.vim.DynamicData {
            extent: vimService.vim.HostScsiDiskPartition;
            blockSizeMb?: number;
            majorVersion: number;
            volumeName: string;
            blockSize?: number;
            unmapGranularity?: number;
            unmapPriority?: string;
         }
         enum HostVmfsVolumeUnmapPriority {
            "none",
            "low",
         }
         interface VmfsConfigOption extends vimService.vim.DynamicData {
            blockSizeOption: number;
            unmapGranularityOption?: Array<number>;
         }
         interface ArrayOfVmfsConfigOption {
            VmfsConfigOption?: Array<vimService.vim.VmfsConfigOption>;
         }
         interface HostVmfsVolume extends vimService.vim.HostFileSystemVolume {
            blockSizeMb: number;
            blockSize?: number;
            unmapGranularity?: number;
            unmapPriority?: string;
            maxBlocks: number;
            majorVersion: number;
            version: string;
            uuid: string;
            extent: Array<vimService.vim.HostScsiDiskPartition>;
            vmfsUpgradable: boolean;
            forceMountedInfo?: vimService.vim.HostForceMountedInfo;
            ssd?: boolean;
            local?: boolean;
            scsiDiskType?: string;
         }
         interface HostVsanInternalSystemCmmdsQuery extends vimService.vim.DynamicData {
            type?: string;
            uuid?: string;
            owner?: string;
         }
         interface ArrayOfHostVsanInternalSystemCmmdsQuery {
            HostVsanInternalSystemCmmdsQuery?: Array<vimService.vim.HostVsanInternalSystemCmmdsQuery>;
         }
         interface VsanPolicyCost extends vimService.vim.DynamicData {
            changeDataSize?: number;
            currentDataSize?: number;
            tempDataSize?: number;
            copyDataSize?: number;
            changeFlashReadCacheSize?: number;
            currentFlashReadCacheSize?: number;
            currentDiskSpaceToAddressSpaceRatio?: number;
            diskSpaceToAddressSpaceRatio?: number;
         }
         interface VsanPolicySatisfiability extends vimService.vim.DynamicData {
            uuid?: string;
            isSatisfiable: boolean;
            reason?: vimService.vim.LocalizableMessage;
            cost?: vimService.vim.VsanPolicyCost;
         }
         interface ArrayOfVsanPolicySatisfiability {
            VsanPolicySatisfiability?: Array<vimService.vim.VsanPolicySatisfiability>;
         }
         interface VsanPolicyChangeBatch extends vimService.vim.DynamicData {
            uuid?: Array<string>;
            policy?: string;
         }
         interface ArrayOfVsanPolicyChangeBatch {
            VsanPolicyChangeBatch?: Array<vimService.vim.VsanPolicyChangeBatch>;
         }
         interface VsanNewPolicyBatch extends vimService.vim.DynamicData {
            size?: Array<number>;
            policy?: string;
         }
         interface ArrayOfVsanNewPolicyBatch {
            VsanNewPolicyBatch?: Array<vimService.vim.VsanNewPolicyBatch>;
         }
         interface HostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult extends vimService.vim.DynamicData {
            diskUuid: string;
            success: boolean;
            failureReason?: string;
         }
         interface ArrayOfHostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult {
            HostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult?: Array<vimService.vim.HostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult>;
         }
         interface HostVsanInternalSystemDeleteVsanObjectsResult extends vimService.vim.DynamicData {
            uuid: string;
            success: boolean;
            failureReason?: Array<vimService.vim.LocalizableMessage>;
         }
         interface ArrayOfHostVsanInternalSystemDeleteVsanObjectsResult {
            HostVsanInternalSystemDeleteVsanObjectsResult?: Array<vimService.vim.HostVsanInternalSystemDeleteVsanObjectsResult>;
         }
         interface HostVsanInternalSystemVsanObjectOperationResult extends vimService.vim.DynamicData {
            uuid: string;
            failureReason?: Array<vimService.vim.LocalizableMessage>;
         }
         interface ArrayOfHostVsanInternalSystemVsanObjectOperationResult {
            HostVsanInternalSystemVsanObjectOperationResult?: Array<vimService.vim.HostVsanInternalSystemVsanObjectOperationResult>;
         }
         interface HostVvolVolumeSpecification extends vimService.vim.DynamicData {
            maxSizeInMB: number;
            volumeName: string;
            vasaProviderInfo?: Array<vimService.vim.VimVasaProviderInfo>;
            storageArray?: Array<vimService.vim.VASAStorageArray>;
            uuid: string;
         }
         interface VVolHostPE extends vimService.vim.DynamicData {
            key: vimService.vim.ManagedObjectReference;
            protocolEndpoint: Array<vimService.vim.HostProtocolEndpoint>;
         }
         interface ArrayOfVVolHostPE {
            VVolHostPE?: Array<vimService.vim.VVolHostPE>;
         }
         interface HostVvolVolume extends vimService.vim.HostFileSystemVolume {
            scId: string;
            hostPE?: Array<vimService.vim.VVolHostPE>;
            vasaProviderInfo?: Array<vimService.vim.VimVasaProviderInfo>;
            storageArray?: Array<vimService.vim.VASAStorageArray>;
         }
         interface NetDhcpConfigInfoDhcpOptions extends vimService.vim.DynamicData {
            enable: boolean;
            config?: Array<vimService.vim.KeyValue>;
         }
         interface NetDhcpConfigInfo extends vimService.vim.DynamicData {
            ipv6?: vimService.vim.NetDhcpConfigInfoDhcpOptions;
            ipv4?: vimService.vim.NetDhcpConfigInfoDhcpOptions;
         }
         interface NetDhcpConfigSpecDhcpOptionsSpec extends vimService.vim.DynamicData {
            enable?: boolean;
            config: Array<vimService.vim.KeyValue>;
            operation: string;
         }
         interface NetDhcpConfigSpec extends vimService.vim.DynamicData {
            ipv6?: vimService.vim.NetDhcpConfigSpecDhcpOptionsSpec;
            ipv4?: vimService.vim.NetDhcpConfigSpecDhcpOptionsSpec;
         }
         interface NetDnsConfigInfo extends vimService.vim.DynamicData {
            dhcp: boolean;
            hostName: string;
            domainName: string;
            ipAddress?: Array<string>;
            searchDomain?: Array<string>;
         }
         interface NetDnsConfigSpec extends vimService.vim.DynamicData {
            dhcp?: boolean;
            hostName?: string;
            domainName?: string;
            ipAddress?: Array<string>;
            searchDomain?: Array<string>;
         }
         enum NetIpConfigInfoIpAddressOrigin {
            "other",
            "manual",
            "dhcp",
            "linklayer",
            "random",
         }
         enum NetIpConfigInfoIpAddressStatus {
            "preferred",
            "deprecated",
            "invalid",
            "inaccessible",
            "unknown",
            "tentative",
            "duplicate",
         }
         interface NetIpConfigInfoIpAddress extends vimService.vim.DynamicData {
            ipAddress: string;
            prefixLength: number;
            origin?: string;
            state?: string;
            lifetime?: Date;
         }
         interface ArrayOfNetIpConfigInfoIpAddress {
            NetIpConfigInfoIpAddress?: Array<vimService.vim.NetIpConfigInfoIpAddress>;
         }
         interface NetIpConfigInfo extends vimService.vim.DynamicData {
            ipAddress?: Array<vimService.vim.NetIpConfigInfoIpAddress>;
            dhcp?: vimService.vim.NetDhcpConfigInfo;
            autoConfigurationEnabled?: boolean;
         }
         interface NetIpConfigSpecIpAddressSpec extends vimService.vim.DynamicData {
            ipAddress: string;
            prefixLength: number;
            operation: string;
         }
         interface ArrayOfNetIpConfigSpecIpAddressSpec {
            NetIpConfigSpecIpAddressSpec?: Array<vimService.vim.NetIpConfigSpecIpAddressSpec>;
         }
         interface NetIpConfigSpec extends vimService.vim.DynamicData {
            ipAddress?: Array<vimService.vim.NetIpConfigSpecIpAddressSpec>;
            dhcp?: vimService.vim.NetDhcpConfigSpec;
            autoConfigurationEnabled?: boolean;
         }
         interface NetIpRouteConfigInfoGateway extends vimService.vim.DynamicData {
            ipAddress?: string;
            device?: string;
         }
         interface NetIpRouteConfigInfoIpRoute extends vimService.vim.DynamicData {
            network: string;
            prefixLength: number;
            gateway: vimService.vim.NetIpRouteConfigInfoGateway;
         }
         interface ArrayOfNetIpRouteConfigInfoIpRoute {
            NetIpRouteConfigInfoIpRoute?: Array<vimService.vim.NetIpRouteConfigInfoIpRoute>;
         }
         interface NetIpRouteConfigInfo extends vimService.vim.DynamicData {
            ipRoute?: Array<vimService.vim.NetIpRouteConfigInfoIpRoute>;
         }
         interface NetIpRouteConfigSpecGatewaySpec extends vimService.vim.DynamicData {
            ipAddress?: string;
            device?: string;
         }
         interface NetIpRouteConfigSpecIpRouteSpec extends vimService.vim.DynamicData {
            network: string;
            prefixLength: number;
            gateway: vimService.vim.NetIpRouteConfigSpecGatewaySpec;
            operation: string;
         }
         interface ArrayOfNetIpRouteConfigSpecIpRouteSpec {
            NetIpRouteConfigSpecIpRouteSpec?: Array<vimService.vim.NetIpRouteConfigSpecIpRouteSpec>;
         }
         interface NetIpRouteConfigSpec extends vimService.vim.DynamicData {
            ipRoute?: Array<vimService.vim.NetIpRouteConfigSpecIpRouteSpec>;
         }
         enum NetIpStackInfoEntryType {
            "other",
            "invalid",
            "dynamic",
            "manual",
         }
         enum NetIpStackInfoPreference {
            "reserved",
            "low",
            "medium",
            "high",
         }
         interface NetIpStackInfoNetToMedia extends vimService.vim.DynamicData {
            ipAddress: string;
            physicalAddress: string;
            device: string;
            type: string;
         }
         interface ArrayOfNetIpStackInfoNetToMedia {
            NetIpStackInfoNetToMedia?: Array<vimService.vim.NetIpStackInfoNetToMedia>;
         }
         interface NetIpStackInfoDefaultRouter extends vimService.vim.DynamicData {
            ipAddress: string;
            device: string;
            lifetime: Date;
            preference: string;
         }
         interface ArrayOfNetIpStackInfoDefaultRouter {
            NetIpStackInfoDefaultRouter?: Array<vimService.vim.NetIpStackInfoDefaultRouter>;
         }
         interface NetIpStackInfo extends vimService.vim.DynamicData {
            neighbor?: Array<vimService.vim.NetIpStackInfoNetToMedia>;
            defaultRouter?: Array<vimService.vim.NetIpStackInfoDefaultRouter>;
         }
         enum NetBIOSConfigInfoMode {
            "unknown",
            "enabled",
            "disabled",
            "enabledViaDHCP",
         }
         interface NetBIOSConfigInfo extends vimService.vim.DynamicData {
            mode: string;
         }
         interface WinNetBIOSConfigInfo extends vimService.vim.NetBIOSConfigInfo {
            primaryWINS: string;
            secondaryWINS?: string;
         }
         enum ArrayUpdateOperation {
            "add",
            "remove",
            "edit",
         }
         interface ArrayUpdateSpec extends vimService.vim.DynamicData {
            operation: vimService.vim.ArrayUpdateOperation;
            removeKey?: any;
         }
         interface BoolOption extends vimService.vim.OptionType {
            supported: boolean;
            defaultValue: boolean;
         }
         interface ChoiceOption extends vimService.vim.OptionType {
            choiceInfo: Array<vimService.vim.ElementDescription>;
            defaultIndex?: number;
         }
         interface FloatOption extends vimService.vim.OptionType {
            min: number;
            max: number;
            defaultValue: number;
         }
         interface IntOption extends vimService.vim.OptionType {
            min: number;
            max: number;
            defaultValue: number;
         }
         interface LongOption extends vimService.vim.OptionType {
            min: number;
            max: number;
            defaultValue: number;
         }
         interface OptionDef extends vimService.vim.ElementDescription {
            optionType: vimService.vim.OptionType;
         }
         interface ArrayOfOptionDef {
            OptionDef?: Array<vimService.vim.OptionDef>;
         }
         interface OptionType extends vimService.vim.DynamicData {
            valueIsReadonly?: boolean;
         }
         interface OptionValue extends vimService.vim.DynamicData {
            key: string;
            value?: any;
         }
         interface ArrayOfOptionValue {
            OptionValue?: Array<vimService.vim.OptionValue>;
         }
         interface StringOption extends vimService.vim.OptionType {
            defaultValue: string;
            validCharacters?: string;
         }
         interface ApplyProfile extends vimService.vim.DynamicData {
            enabled: boolean;
            policy?: Array<vimService.vim.ProfilePolicy>;
            profileTypeName?: string;
            profileVersion?: string;
            property?: Array<vimService.vim.ProfileApplyProfileProperty>;
            favorite?: boolean;
            toBeMerged?: boolean;
            toReplaceWith?: boolean;
            toBeDeleted?: boolean;
            copyEnableStatus?: boolean;
         }
         interface ArrayOfApplyProfile {
            ApplyProfile?: Array<vimService.vim.ApplyProfile>;
         }
         interface ProfileApplyProfileElement extends vimService.vim.ApplyProfile {
            key: string;
         }
         interface ProfileApplyProfileProperty extends vimService.vim.DynamicData {
            propertyName: string;
            array: boolean;
            profile?: Array<vimService.vim.ApplyProfile>;
         }
         interface ArrayOfProfileApplyProfileProperty {
            ProfileApplyProfileProperty?: Array<vimService.vim.ProfileApplyProfileProperty>;
         }
         interface ComplianceLocator extends vimService.vim.DynamicData {
            expressionName: string;
            applyPath: vimService.vim.ProfilePropertyPath;
         }
         interface ArrayOfComplianceLocator {
            ComplianceLocator?: Array<vimService.vim.ComplianceLocator>;
         }
         interface ComplianceProfile extends vimService.vim.DynamicData {
            expression: Array<vimService.vim.ProfileExpression>;
            rootExpression: string;
         }
         enum ComplianceResultStatus {
            "compliant",
            "nonCompliant",
            "unknown",
         }
         interface ComplianceFailureComplianceFailureValues extends vimService.vim.DynamicData {
            comparisonIdentifier: string;
            profileInstance?: string;
            hostValue?: any;
            profileValue?: any;
         }
         interface ArrayOfComplianceFailureComplianceFailureValues {
            ComplianceFailureComplianceFailureValues?: Array<vimService.vim.ComplianceFailureComplianceFailureValues>;
         }
         interface ComplianceFailure extends vimService.vim.DynamicData {
            failureType: string;
            message: vimService.vim.LocalizableMessage;
            expressionName?: string;
            failureValues?: Array<vimService.vim.ComplianceFailureComplianceFailureValues>;
         }
         interface ArrayOfComplianceFailure {
            ComplianceFailure?: Array<vimService.vim.ComplianceFailure>;
         }
         interface ComplianceResult extends vimService.vim.DynamicData {
            profile?: vimService.vim.ManagedObjectReference;
            complianceStatus: string;
            entity?: vimService.vim.ManagedObjectReference;
            checkTime?: Date;
            failure?: Array<vimService.vim.ComplianceFailure>;
         }
         interface ArrayOfComplianceResult {
            ComplianceResult?: Array<vimService.vim.ComplianceResult>;
         }
         interface ProfileDeferredPolicyOptionParameter extends vimService.vim.DynamicData {
            inputPath: vimService.vim.ProfilePropertyPath;
            parameter?: Array<vimService.vim.KeyAnyValue>;
         }
         interface ArrayOfProfileDeferredPolicyOptionParameter {
            ProfileDeferredPolicyOptionParameter?: Array<vimService.vim.ProfileDeferredPolicyOptionParameter>;
         }
         interface ProfileExpression extends vimService.vim.DynamicData {
            id: string;
            displayName: string;
            negated: boolean;
         }
         interface ArrayOfProfileExpression {
            ProfileExpression?: Array<vimService.vim.ProfileExpression>;
         }
         interface ProfileSimpleExpression extends vimService.vim.ProfileExpression {
            expressionType: string;
            parameter?: Array<vimService.vim.KeyAnyValue>;
         }
         interface ProfileCompositeExpression extends vimService.vim.ProfileExpression {
            operator: string;
            expressionName: Array<string>;
         }
         interface ProfileExpressionMetadata extends vimService.vim.DynamicData {
            expressionId: vimService.vim.ExtendedElementDescription;
            parameter?: Array<vimService.vim.ProfileParameterMetadata>;
         }
         interface ArrayOfProfileExpressionMetadata {
            ProfileExpressionMetadata?: Array<vimService.vim.ProfileExpressionMetadata>;
         }
         enum ProfileNumericComparator {
            "lessThan",
            "lessThanEqual",
            "equal",
            "notEqual",
            "greaterThanEqual",
            "greaterThan",
         }
         interface ProfileParameterMetadata extends vimService.vim.DynamicData {
            id: vimService.vim.ExtendedElementDescription;
            type: string;
            optional: boolean;
            defaultValue?: any;
            hidden?: boolean;
            securitySensitive?: boolean;
            readOnly?: boolean;
         }
         interface ArrayOfProfileParameterMetadata {
            ProfileParameterMetadata?: Array<vimService.vim.ProfileParameterMetadata>;
         }
         interface ProfilePolicy extends vimService.vim.DynamicData {
            id: string;
            policyOption: vimService.vim.PolicyOption;
         }
         interface ArrayOfProfilePolicy {
            ProfilePolicy?: Array<vimService.vim.ProfilePolicy>;
         }
         interface ProfilePolicyOptionMetadata extends vimService.vim.DynamicData {
            id: vimService.vim.ExtendedElementDescription;
            parameter?: Array<vimService.vim.ProfileParameterMetadata>;
         }
         interface ArrayOfProfilePolicyOptionMetadata {
            ProfilePolicyOptionMetadata?: Array<vimService.vim.ProfilePolicyOptionMetadata>;
         }
         interface ProfileCompositePolicyOptionMetadata extends vimService.vim.ProfilePolicyOptionMetadata {
            option: Array<string>;
         }
         interface UserInputRequiredParameterMetadata extends vimService.vim.ProfilePolicyOptionMetadata {
            userInputParameter?: Array<vimService.vim.ProfileParameterMetadata>;
         }
         interface ProfilePolicyMetadata extends vimService.vim.DynamicData {
            id: vimService.vim.ExtendedElementDescription;
            possibleOption: Array<vimService.vim.ProfilePolicyOptionMetadata>;
         }
         interface ArrayOfProfilePolicyMetadata {
            ProfilePolicyMetadata?: Array<vimService.vim.ProfilePolicyMetadata>;
         }
         interface PolicyOption extends vimService.vim.DynamicData {
            id: string;
            parameter?: Array<vimService.vim.KeyAnyValue>;
         }
         interface ArrayOfPolicyOption {
            PolicyOption?: Array<vimService.vim.PolicyOption>;
         }
         interface CompositePolicyOption extends vimService.vim.PolicyOption {
            option?: Array<vimService.vim.PolicyOption>;
         }
         interface ProfileCreateSpec extends vimService.vim.DynamicData {
            name?: string;
            annotation?: string;
            enabled?: boolean;
         }
         interface ProfileSerializedCreateSpec extends vimService.vim.ProfileCreateSpec {
            profileConfigString: string;
         }
         interface ProfileConfigInfo extends vimService.vim.DynamicData {
            name: string;
            annotation?: string;
            enabled: boolean;
         }
         interface ProfileDescriptionSection extends vimService.vim.DynamicData {
            description: vimService.vim.ExtendedElementDescription;
            message?: Array<vimService.vim.LocalizableMessage>;
         }
         interface ArrayOfProfileDescriptionSection {
            ProfileDescriptionSection?: Array<vimService.vim.ProfileDescriptionSection>;
         }
         interface ProfileDescription extends vimService.vim.DynamicData {
            section: Array<vimService.vim.ProfileDescriptionSection>;
         }
         interface ProfileMetadataProfileSortSpec extends vimService.vim.DynamicData {
            policyId: string;
            parameter: string;
         }
         interface ArrayOfProfileMetadataProfileSortSpec {
            ProfileMetadataProfileSortSpec?: Array<vimService.vim.ProfileMetadataProfileSortSpec>;
         }
         interface ProfileMetadata extends vimService.vim.DynamicData {
            key: string;
            profileTypeName?: string;
            description?: vimService.vim.ExtendedDescription;
            sortSpec?: Array<vimService.vim.ProfileMetadataProfileSortSpec>;
            profileCategory?: string;
            profileComponent?: string;
         }
         interface ArrayOfProfileMetadata {
            ProfileMetadata?: Array<vimService.vim.ProfileMetadata>;
         }
         interface ProfilePropertyPath extends vimService.vim.DynamicData {
            profilePath: string;
            policyId?: string;
            parameterId?: string;
         }
         interface ArrayOfProfilePropertyPath {
            ProfilePropertyPath?: Array<vimService.vim.ProfilePropertyPath>;
         }
         interface ProfileProfileStructure extends vimService.vim.DynamicData {
            profileTypeName: string;
            child?: Array<vimService.vim.ProfileProfileStructureProperty>;
         }
         interface ProfileProfileStructureProperty extends vimService.vim.DynamicData {
            propertyName: string;
            array: boolean;
            element: vimService.vim.ProfileProfileStructure;
         }
         interface ArrayOfProfileProfileStructureProperty {
            ProfileProfileStructureProperty?: Array<vimService.vim.ProfileProfileStructureProperty>;
         }
         interface ClusterProfileConfigInfo extends vimService.vim.ProfileConfigInfo {
            complyProfile?: vimService.vim.ComplianceProfile;
         }
         interface ClusterProfileCreateSpec extends vimService.vim.ProfileCreateSpec {
         }
         interface ClusterProfileConfigSpec extends vimService.vim.ClusterProfileCreateSpec {
         }
         interface ClusterProfileCompleteConfigSpec extends vimService.vim.ClusterProfileConfigSpec {
            complyProfile?: vimService.vim.ComplianceProfile;
         }
         enum ClusterProfileServiceType {
            "DRS",
            "HA",
            "DPM",
            "FT",
         }
         interface ClusterProfileConfigServiceCreateSpec extends vimService.vim.ClusterProfileConfigSpec {
            serviceType?: Array<string>;
         }
         interface AnswerFile extends vimService.vim.DynamicData {
            userInput?: Array<vimService.vim.ProfileDeferredPolicyOptionParameter>;
            createdTime: Date;
            modifiedTime: Date;
         }
         interface AnswerFileStatusError extends vimService.vim.DynamicData {
            userInputPath: vimService.vim.ProfilePropertyPath;
            errMsg: vimService.vim.LocalizableMessage;
         }
         interface ArrayOfAnswerFileStatusError {
            AnswerFileStatusError?: Array<vimService.vim.AnswerFileStatusError>;
         }
         interface AnswerFileStatusResult extends vimService.vim.DynamicData {
            checkedTime: Date;
            host: vimService.vim.ManagedObjectReference;
            status: string;
            error?: Array<vimService.vim.AnswerFileStatusError>;
         }
         interface ArrayOfAnswerFileStatusResult {
            AnswerFileStatusResult?: Array<vimService.vim.AnswerFileStatusResult>;
         }
         enum ProfileExecuteResultStatus {
            "success",
            "needInput",
            "error",
         }
         interface ProfileExecuteError extends vimService.vim.DynamicData {
            path?: vimService.vim.ProfilePropertyPath;
            message: vimService.vim.LocalizableMessage;
         }
         interface ArrayOfProfileExecuteError {
            ProfileExecuteError?: Array<vimService.vim.ProfileExecuteError>;
         }
         interface ProfileExecuteResult extends vimService.vim.DynamicData {
            status: string;
            configSpec?: vimService.vim.HostConfigSpec;
            inapplicablePath?: Array<string>;
            requireInput?: Array<vimService.vim.ProfileDeferredPolicyOptionParameter>;
            error?: Array<vimService.vim.ProfileExecuteError>;
         }
         interface HostApplyProfile extends vimService.vim.ApplyProfile {
            memory?: vimService.vim.HostMemoryProfile;
            storage?: vimService.vim.StorageProfile;
            network?: vimService.vim.NetworkProfile;
            datetime?: vimService.vim.DateTimeProfile;
            firewall?: vimService.vim.FirewallProfile;
            security?: vimService.vim.SecurityProfile;
            service?: Array<vimService.vim.ServiceProfile>;
            option?: Array<vimService.vim.OptionProfile>;
            userAccount?: Array<vimService.vim.UserProfile>;
            usergroupAccount?: Array<vimService.vim.UserGroupProfile>;
            authentication?: vimService.vim.AuthenticationProfile;
         }
         interface PhysicalNicProfile extends vimService.vim.ApplyProfile {
            key: string;
         }
         interface ArrayOfPhysicalNicProfile {
            PhysicalNicProfile?: Array<vimService.vim.PhysicalNicProfile>;
         }
         interface HostMemoryProfile extends vimService.vim.ApplyProfile {
         }
         interface UserProfile extends vimService.vim.ApplyProfile {
            key: string;
         }
         interface ArrayOfUserProfile {
            UserProfile?: Array<vimService.vim.UserProfile>;
         }
         interface UserGroupProfile extends vimService.vim.ApplyProfile {
            key: string;
         }
         interface ArrayOfUserGroupProfile {
            UserGroupProfile?: Array<vimService.vim.UserGroupProfile>;
         }
         interface SecurityProfile extends vimService.vim.ApplyProfile {
            permission?: Array<vimService.vim.PermissionProfile>;
         }
         interface OptionProfile extends vimService.vim.ApplyProfile {
            key: string;
         }
         interface ArrayOfOptionProfile {
            OptionProfile?: Array<vimService.vim.OptionProfile>;
         }
         interface DateTimeProfile extends vimService.vim.ApplyProfile {
         }
         interface ServiceProfile extends vimService.vim.ApplyProfile {
            key: string;
         }
         interface ArrayOfServiceProfile {
            ServiceProfile?: Array<vimService.vim.ServiceProfile>;
         }
         interface FirewallProfileRulesetProfile extends vimService.vim.ApplyProfile {
            key: string;
         }
         interface ArrayOfFirewallProfileRulesetProfile {
            FirewallProfileRulesetProfile?: Array<vimService.vim.FirewallProfileRulesetProfile>;
         }
         interface FirewallProfile extends vimService.vim.ApplyProfile {
            ruleset?: Array<vimService.vim.FirewallProfileRulesetProfile>;
         }
         interface NasStorageProfile extends vimService.vim.ApplyProfile {
            key: string;
         }
         interface ArrayOfNasStorageProfile {
            NasStorageProfile?: Array<vimService.vim.NasStorageProfile>;
         }
         interface StorageProfile extends vimService.vim.ApplyProfile {
            nasStorage?: Array<vimService.vim.NasStorageProfile>;
         }
         interface NetworkProfileDnsConfigProfile extends vimService.vim.ApplyProfile {
         }
         interface NetworkProfile extends vimService.vim.ApplyProfile {
            vswitch?: Array<vimService.vim.VirtualSwitchProfile>;
            vmPortGroup?: Array<vimService.vim.VmPortGroupProfile>;
            hostPortGroup?: Array<vimService.vim.HostPortGroupProfile>;
            serviceConsolePortGroup?: Array<vimService.vim.ServiceConsolePortGroupProfile>;
            dnsConfig?: vimService.vim.NetworkProfileDnsConfigProfile;
            ipRouteConfig?: vimService.vim.IpRouteProfile;
            consoleIpRouteConfig?: vimService.vim.IpRouteProfile;
            pnic?: Array<vimService.vim.PhysicalNicProfile>;
            dvswitch?: Array<vimService.vim.DvsProfile>;
            dvsServiceConsoleNic?: Array<vimService.vim.DvsServiceConsoleVNicProfile>;
            dvsHostNic?: Array<vimService.vim.DvsHostVNicProfile>;
            netStackInstance?: Array<vimService.vim.NetStackInstanceProfile>;
         }
         interface DvsVNicProfile extends vimService.vim.ApplyProfile {
            key: string;
            ipConfig: vimService.vim.IpAddressProfile;
         }
         interface DvsServiceConsoleVNicProfile extends vimService.vim.DvsVNicProfile {
         }
         interface ArrayOfDvsServiceConsoleVNicProfile {
            DvsServiceConsoleVNicProfile?: Array<vimService.vim.DvsServiceConsoleVNicProfile>;
         }
         interface DvsHostVNicProfile extends vimService.vim.DvsVNicProfile {
         }
         interface ArrayOfDvsHostVNicProfile {
            DvsHostVNicProfile?: Array<vimService.vim.DvsHostVNicProfile>;
         }
         interface DvsProfile extends vimService.vim.ApplyProfile {
            key: string;
            name: string;
            uplink?: Array<vimService.vim.PnicUplinkProfile>;
         }
         interface ArrayOfDvsProfile {
            DvsProfile?: Array<vimService.vim.DvsProfile>;
         }
         interface PnicUplinkProfile extends vimService.vim.ApplyProfile {
            key: string;
         }
         interface ArrayOfPnicUplinkProfile {
            PnicUplinkProfile?: Array<vimService.vim.PnicUplinkProfile>;
         }
         interface IpRouteProfile extends vimService.vim.ApplyProfile {
            staticRoute?: Array<vimService.vim.StaticRouteProfile>;
         }
         interface StaticRouteProfile extends vimService.vim.ApplyProfile {
            key?: string;
         }
         interface ArrayOfStaticRouteProfile {
            StaticRouteProfile?: Array<vimService.vim.StaticRouteProfile>;
         }
         interface LinkProfile extends vimService.vim.ApplyProfile {
         }
         interface NumPortsProfile extends vimService.vim.ApplyProfile {
         }
         interface VirtualSwitchProfile extends vimService.vim.ApplyProfile {
            key: string;
            name: string;
            link: vimService.vim.LinkProfile;
            numPorts: vimService.vim.NumPortsProfile;
            networkPolicy: vimService.vim.NetworkPolicyProfile;
         }
         interface ArrayOfVirtualSwitchProfile {
            VirtualSwitchProfile?: Array<vimService.vim.VirtualSwitchProfile>;
         }
         interface NetStackInstanceProfile extends vimService.vim.ApplyProfile {
            key: string;
            dnsConfig: vimService.vim.NetworkProfileDnsConfigProfile;
            ipRouteConfig: vimService.vim.IpRouteProfile;
         }
         interface ArrayOfNetStackInstanceProfile {
            NetStackInstanceProfile?: Array<vimService.vim.NetStackInstanceProfile>;
         }
         interface VlanProfile extends vimService.vim.ApplyProfile {
         }
         interface VirtualSwitchSelectionProfile extends vimService.vim.ApplyProfile {
         }
         interface PortGroupProfile extends vimService.vim.ApplyProfile {
            key: string;
            name: string;
            vlan: vimService.vim.VlanProfile;
            vswitch: vimService.vim.VirtualSwitchSelectionProfile;
            networkPolicy: vimService.vim.NetworkPolicyProfile;
         }
         interface VmPortGroupProfile extends vimService.vim.PortGroupProfile {
         }
         interface ArrayOfVmPortGroupProfile {
            VmPortGroupProfile?: Array<vimService.vim.VmPortGroupProfile>;
         }
         interface HostPortGroupProfile extends vimService.vim.PortGroupProfile {
            ipConfig: vimService.vim.IpAddressProfile;
         }
         interface ArrayOfHostPortGroupProfile {
            HostPortGroupProfile?: Array<vimService.vim.HostPortGroupProfile>;
         }
         interface ServiceConsolePortGroupProfile extends vimService.vim.PortGroupProfile {
            ipConfig: vimService.vim.IpAddressProfile;
         }
         interface ArrayOfServiceConsolePortGroupProfile {
            ServiceConsolePortGroupProfile?: Array<vimService.vim.ServiceConsolePortGroupProfile>;
         }
         interface NetworkPolicyProfile extends vimService.vim.ApplyProfile {
         }
         interface IpAddressProfile extends vimService.vim.ApplyProfile {
         }
         interface AuthenticationProfile extends vimService.vim.ApplyProfile {
            activeDirectory?: vimService.vim.ActiveDirectoryProfile;
         }
         interface ActiveDirectoryProfile extends vimService.vim.ApplyProfile {
         }
         interface PermissionProfile extends vimService.vim.ApplyProfile {
            key: string;
         }
         interface ArrayOfPermissionProfile {
            PermissionProfile?: Array<vimService.vim.PermissionProfile>;
         }
         interface HostProfileConfigInfo extends vimService.vim.ProfileConfigInfo {
            applyProfile?: vimService.vim.HostApplyProfile;
            defaultComplyProfile?: vimService.vim.ComplianceProfile;
            defaultComplyLocator?: Array<vimService.vim.ComplianceLocator>;
            customComplyProfile?: vimService.vim.ComplianceProfile;
            disabledExpressionList?: Array<string>;
            description?: vimService.vim.ProfileDescription;
         }
         interface HostProfileConfigSpec extends vimService.vim.ProfileCreateSpec {
         }
         interface HostProfileSerializedHostProfileSpec extends vimService.vim.ProfileSerializedCreateSpec {
            validatorHost?: vimService.vim.ManagedObjectReference;
            validating?: boolean;
         }
         interface HostProfileCompleteConfigSpec extends vimService.vim.HostProfileConfigSpec {
            applyProfile?: vimService.vim.HostApplyProfile;
            customComplyProfile?: vimService.vim.ComplianceProfile;
            disabledExpressionListChanged: boolean;
            disabledExpressionList?: Array<string>;
            validatorHost?: vimService.vim.ManagedObjectReference;
            validating?: boolean;
            hostConfig?: vimService.vim.HostProfileConfigInfo;
         }
         interface HostProfileHostBasedConfigSpec extends vimService.vim.HostProfileConfigSpec {
            host: vimService.vim.ManagedObjectReference;
            useHostProfileEngine?: boolean;
         }
         interface HostSpecification extends vimService.vim.DynamicData {
            createdTime: Date;
            lastModified?: Date;
            host: vimService.vim.ManagedObjectReference;
            subSpecs?: Array<vimService.vim.HostSubSpecification>;
            changeID?: string;
         }
         interface HostSubSpecification extends vimService.vim.DynamicData {
            name: string;
            createdTime: Date;
            data?: Array<number>;
         }
         interface ArrayOfHostSubSpecification {
            HostSubSpecification?: Array<vimService.vim.HostSubSpecification>;
         }
         enum HostProfileManagerTaskListRequirement {
            "maintenanceModeRequired",
            "rebootRequired",
         }
         interface HostProfileManagerConfigTaskList extends vimService.vim.DynamicData {
            configSpec?: vimService.vim.HostConfigSpec;
            taskDescription?: Array<vimService.vim.LocalizableMessage>;
            taskListRequirement?: Array<string>;
         }
         interface AnswerFileCreateSpec extends vimService.vim.DynamicData {
            validating?: boolean;
         }
         interface AnswerFileOptionsCreateSpec extends vimService.vim.AnswerFileCreateSpec {
            userInput?: Array<vimService.vim.ProfileDeferredPolicyOptionParameter>;
         }
         interface AnswerFileSerializedCreateSpec extends vimService.vim.AnswerFileCreateSpec {
            answerFileConfigString: string;
         }
         enum HostProfileManagerAnswerFileStatus {
            "valid",
            "invalid",
            "unknown",
         }
         interface HostProfilesEntityCustomizations extends vimService.vim.DynamicData {
         }
         interface ArrayOfHostProfilesEntityCustomizations {
            HostProfilesEntityCustomizations?: Array<vimService.vim.HostProfilesEntityCustomizations>;
         }
         interface StructuredCustomizations extends vimService.vim.HostProfilesEntityCustomizations {
            entity: vimService.vim.ManagedObjectReference;
            customizations?: vimService.vim.AnswerFile;
         }
         interface ArrayOfStructuredCustomizations {
            StructuredCustomizations?: Array<vimService.vim.StructuredCustomizations>;
         }
         interface HostProfileManagerHostToConfigSpecMap extends vimService.vim.DynamicData {
            host: vimService.vim.ManagedObjectReference;
            configSpec: vimService.vim.AnswerFileCreateSpec;
         }
         interface ArrayOfHostProfileManagerHostToConfigSpecMap {
            HostProfileManagerHostToConfigSpecMap?: Array<vimService.vim.HostProfileManagerHostToConfigSpecMap>;
         }
         interface ApplyHostProfileConfigurationSpec extends vimService.vim.ProfileExecuteResult {
            host: vimService.vim.ManagedObjectReference;
            taskListRequirement?: Array<string>;
            taskDescription?: Array<vimService.vim.LocalizableMessage>;
            rebootStateless?: boolean;
            rebootHost?: boolean;
            faultData?: vimService.vim.LocalizedMethodFault;
         }
         interface ArrayOfApplyHostProfileConfigurationSpec {
            ApplyHostProfileConfigurationSpec?: Array<vimService.vim.ApplyHostProfileConfigurationSpec>;
         }
         interface HostProfileManagerCompositionValidationResultResultElement extends vimService.vim.DynamicData {
            target: vimService.vim.ManagedObjectReference;
            status: string;
            errors?: Array<vimService.vim.LocalizableMessage>;
            sourceDiffForToBeMerged?: vimService.vim.HostApplyProfile;
            targetDiffForToBeMerged?: vimService.vim.HostApplyProfile;
            toBeAdded?: vimService.vim.HostApplyProfile;
            toBeDeleted?: vimService.vim.HostApplyProfile;
            toBeDisabled?: vimService.vim.HostApplyProfile;
            toBeEnabled?: vimService.vim.HostApplyProfile;
            toBeReenableCC?: vimService.vim.HostApplyProfile;
         }
         interface ArrayOfHostProfileManagerCompositionValidationResultResultElement {
            HostProfileManagerCompositionValidationResultResultElement?: Array<vimService.vim.HostProfileManagerCompositionValidationResultResultElement>;
         }
         interface ScheduledTaskDetail extends vimService.vim.TypeDescription {
            frequency: string;
         }
         interface ArrayOfScheduledTaskDetail {
            ScheduledTaskDetail?: Array<vimService.vim.ScheduledTaskDetail>;
         }
         interface ScheduledTaskDescription extends vimService.vim.DynamicData {
            action: Array<vimService.vim.TypeDescription>;
            schedulerInfo: Array<vimService.vim.ScheduledTaskDetail>;
            state: Array<vimService.vim.ElementDescription>;
            dayOfWeek: Array<vimService.vim.ElementDescription>;
            weekOfMonth: Array<vimService.vim.ElementDescription>;
         }
         interface ScheduledTaskInfo extends vimService.vim.ScheduledTaskSpec {
            scheduledTask: vimService.vim.ManagedObjectReference;
            entity: vimService.vim.ManagedObjectReference;
            lastModifiedTime: Date;
            lastModifiedUser: string;
            nextRunTime?: Date;
            prevRunTime?: Date;
            state: vimService.vim.TaskInfoState;
            error?: vimService.vim.LocalizedMethodFault;
            result?: any;
            progress?: number;
            activeTask?: vimService.vim.ManagedObjectReference;
            taskObject?: vimService.vim.ManagedObjectReference;
         }
         interface TaskScheduler extends vimService.vim.DynamicData {
            activeTime?: Date;
            expireTime?: Date;
         }
         interface AfterStartupTaskScheduler extends vimService.vim.TaskScheduler {
            minute: number;
         }
         interface OnceTaskScheduler extends vimService.vim.TaskScheduler {
            runAt?: Date;
         }
         interface RecurrentTaskScheduler extends vimService.vim.TaskScheduler {
            interval: number;
         }
         interface HourlyTaskScheduler extends vimService.vim.RecurrentTaskScheduler {
            minute: number;
         }
         interface DailyTaskScheduler extends vimService.vim.HourlyTaskScheduler {
            hour: number;
         }
         interface WeeklyTaskScheduler extends vimService.vim.DailyTaskScheduler {
            sunday: boolean;
            monday: boolean;
            tuesday: boolean;
            wednesday: boolean;
            thursday: boolean;
            friday: boolean;
            saturday: boolean;
         }
         interface MonthlyTaskScheduler extends vimService.vim.DailyTaskScheduler {
         }
         interface MonthlyByDayTaskScheduler extends vimService.vim.MonthlyTaskScheduler {
            day: number;
         }
         enum DayOfWeek {
            "sunday",
            "monday",
            "tuesday",
            "wednesday",
            "thursday",
            "friday",
            "saturday",
         }
         enum WeekOfMonth {
            "first",
            "second",
            "third",
            "fourth",
            "last",
         }
         interface MonthlyByWeekdayTaskScheduler extends vimService.vim.MonthlyTaskScheduler {
            offset: vimService.vim.WeekOfMonth;
            weekday: vimService.vim.DayOfWeek;
         }
         interface ScheduledTaskSpec extends vimService.vim.DynamicData {
            name: string;
            description: string;
            enabled: boolean;
            scheduler: vimService.vim.TaskScheduler;
            action: vimService.vim.Action;
            notification?: string;
         }
         interface ApplyStorageRecommendationResult extends vimService.vim.DynamicData {
            vm?: vimService.vim.ManagedObjectReference;
         }
         interface StorageDrsConfigInfo extends vimService.vim.DynamicData {
            podConfig: vimService.vim.StorageDrsPodConfigInfo;
            vmConfig?: Array<vimService.vim.StorageDrsVmConfigInfo>;
         }
         interface StorageDrsConfigSpec extends vimService.vim.DynamicData {
            podConfigSpec?: vimService.vim.StorageDrsPodConfigSpec;
            vmConfigSpec?: Array<vimService.vim.StorageDrsVmConfigSpec>;
         }
         interface StorageDrsVmConfigSpec extends vimService.vim.ArrayUpdateSpec {
            info?: vimService.vim.StorageDrsVmConfigInfo;
         }
         interface ArrayOfStorageDrsVmConfigSpec {
            StorageDrsVmConfigSpec?: Array<vimService.vim.StorageDrsVmConfigSpec>;
         }
         interface HbrDiskMigrationAction extends vimService.vim.ClusterAction {
            collectionId: string;
            collectionName: string;
            diskIds: Array<string>;
            source: vimService.vim.ManagedObjectReference;
            destination: vimService.vim.ManagedObjectReference;
            sizeTransferred: number;
            spaceUtilSrcBefore?: number;
            spaceUtilDstBefore?: number;
            spaceUtilSrcAfter?: number;
            spaceUtilDstAfter?: number;
            ioLatencySrcBefore?: number;
            ioLatencyDstBefore?: number;
         }
         enum PlacementAffinityRuleRuleType {
            "affinity",
            "antiAffinity",
            "softAffinity",
            "softAntiAffinity",
         }
         enum PlacementAffinityRuleRuleScope {
            "cluster",
            "host",
            "storagePod",
            "datastore",
         }
         interface PlacementAffinityRule extends vimService.vim.DynamicData {
            ruleType: string;
            ruleScope: string;
            vms?: Array<vimService.vim.ManagedObjectReference>;
            keys?: Array<string>;
         }
         interface ArrayOfPlacementAffinityRule {
            PlacementAffinityRule?: Array<vimService.vim.PlacementAffinityRule>;
         }
         interface PlacementRankResult extends vimService.vim.DynamicData {
            key: string;
            candidate: vimService.vim.ManagedObjectReference;
            reservedSpaceMB: number;
            usedSpaceMB: number;
            totalSpaceMB: number;
            utilization: number;
            faults?: Array<vimService.vim.LocalizedMethodFault>;
         }
         interface PlacementRankSpec extends vimService.vim.DynamicData {
            specs: Array<vimService.vim.PlacementSpec>;
            clusters: Array<vimService.vim.ManagedObjectReference>;
            rules?: Array<vimService.vim.PlacementAffinityRule>;
            placementRankByVm?: Array<vimService.vim.StorageDrsPlacementRankVmSpec>;
         }
         interface StorageDrsPlacementRankVmSpec extends vimService.vim.DynamicData {
            vmPlacementSpec: vimService.vim.PlacementSpec;
            vmClusters: Array<vimService.vim.ManagedObjectReference>;
         }
         interface ArrayOfStorageDrsPlacementRankVmSpec {
            StorageDrsPlacementRankVmSpec?: Array<vimService.vim.StorageDrsPlacementRankVmSpec>;
         }
         enum StorageDrsPodConfigInfoBehavior {
            "manual",
            "automated",
         }
         interface StorageDrsPodConfigInfo extends vimService.vim.DynamicData {
            enabled: boolean;
            ioLoadBalanceEnabled: boolean;
            defaultVmBehavior: string;
            loadBalanceInterval?: number;
            defaultIntraVmAffinity?: boolean;
            spaceLoadBalanceConfig?: vimService.vim.StorageDrsSpaceLoadBalanceConfig;
            ioLoadBalanceConfig?: vimService.vim.StorageDrsIoLoadBalanceConfig;
            automationOverrides?: vimService.vim.StorageDrsAutomationConfig;
            rule?: Array<vimService.vim.ClusterRuleInfo>;
            option?: Array<vimService.vim.OptionValue>;
         }
         enum StorageDrsSpaceLoadBalanceConfigSpaceThresholdMode {
            "utilization",
            "freeSpace",
         }
         interface StorageDrsSpaceLoadBalanceConfig extends vimService.vim.DynamicData {
            spaceThresholdMode?: string;
            spaceUtilizationThreshold?: number;
            freeSpaceThresholdGB?: number;
            minSpaceUtilizationDifference?: number;
         }
         interface StorageDrsIoLoadBalanceConfig extends vimService.vim.DynamicData {
            reservablePercentThreshold?: number;
            reservableIopsThreshold?: number;
            reservableThresholdMode?: string;
            ioLatencyThreshold?: number;
            ioLoadImbalanceThreshold?: number;
         }
         interface StorageDrsAutomationConfig extends vimService.vim.DynamicData {
            spaceLoadBalanceAutomationMode?: string;
            ioLoadBalanceAutomationMode?: string;
            ruleEnforcementAutomationMode?: string;
            policyEnforcementAutomationMode?: string;
            vmEvacuationAutomationMode?: string;
         }
         interface StorageDrsPodConfigSpec extends vimService.vim.DynamicData {
            enabled?: boolean;
            ioLoadBalanceEnabled?: boolean;
            defaultVmBehavior?: string;
            loadBalanceInterval?: number;
            defaultIntraVmAffinity?: boolean;
            spaceLoadBalanceConfig?: vimService.vim.StorageDrsSpaceLoadBalanceConfig;
            ioLoadBalanceConfig?: vimService.vim.StorageDrsIoLoadBalanceConfig;
            automationOverrides?: vimService.vim.StorageDrsAutomationConfig;
            rule?: Array<vimService.vim.ClusterRuleSpec>;
            option?: Array<vimService.vim.StorageDrsOptionSpec>;
         }
         interface StorageDrsOptionSpec extends vimService.vim.ArrayUpdateSpec {
            option?: vimService.vim.OptionValue;
         }
         interface ArrayOfStorageDrsOptionSpec {
            StorageDrsOptionSpec?: Array<vimService.vim.StorageDrsOptionSpec>;
         }
         interface VmPodConfigForPlacement extends vimService.vim.DynamicData {
            storagePod: vimService.vim.ManagedObjectReference;
            disk?: Array<vimService.vim.PodDiskLocator>;
            vmConfig?: vimService.vim.StorageDrsVmConfigInfo;
            interVmRule?: Array<vimService.vim.ClusterRuleInfo>;
         }
         interface ArrayOfVmPodConfigForPlacement {
            VmPodConfigForPlacement?: Array<vimService.vim.VmPodConfigForPlacement>;
         }
         interface PodDiskLocator extends vimService.vim.DynamicData {
            diskId: number;
            diskMoveType?: string;
            diskBackingInfo?: vimService.vim.VirtualDeviceBackingInfo;
            profile?: Array<vimService.vim.VirtualMachineProfileSpec>;
         }
         interface ArrayOfPodDiskLocator {
            PodDiskLocator?: Array<vimService.vim.PodDiskLocator>;
         }
         interface StorageDrsPodSelectionSpec extends vimService.vim.DynamicData {
            initialVmConfig?: Array<vimService.vim.VmPodConfigForPlacement>;
            storagePod?: vimService.vim.ManagedObjectReference;
         }
         interface StorageMigrationAction extends vimService.vim.ClusterAction {
            vm: vimService.vim.ManagedObjectReference;
            relocateSpec: vimService.vim.VirtualMachineRelocateSpec;
            source: vimService.vim.ManagedObjectReference;
            destination: vimService.vim.ManagedObjectReference;
            sizeTransferred: number;
            spaceUtilSrcBefore?: number;
            spaceUtilDstBefore?: number;
            spaceUtilSrcAfter?: number;
            spaceUtilDstAfter?: number;
            ioLatencySrcBefore?: number;
            ioLatencyDstBefore?: number;
         }
         interface StoragePlacementAction extends vimService.vim.ClusterAction {
            vm?: vimService.vim.ManagedObjectReference;
            relocateSpec: vimService.vim.VirtualMachineRelocateSpec;
            destination: vimService.vim.ManagedObjectReference;
            spaceUtilBefore?: number;
            spaceDemandBefore?: number;
            spaceUtilAfter?: number;
            spaceDemandAfter?: number;
            ioLatencyBefore?: number;
         }
         interface StoragePlacementResult extends vimService.vim.DynamicData {
            recommendations?: Array<vimService.vim.ClusterRecommendation>;
            drsFault?: vimService.vim.ClusterDrsFaults;
            task?: vimService.vim.ManagedObjectReference;
         }
         enum StoragePlacementSpecPlacementType {
            "create",
            "reconfigure",
            "relocate",
            "clone",
         }
         interface StoragePlacementSpec extends vimService.vim.DynamicData {
            type: string;
            priority?: vimService.vim.VirtualMachineMovePriority;
            vm?: vimService.vim.ManagedObjectReference;
            podSelectionSpec: vimService.vim.StorageDrsPodSelectionSpec;
            cloneSpec?: vimService.vim.VirtualMachineCloneSpec;
            cloneName?: string;
            configSpec?: vimService.vim.VirtualMachineConfigSpec;
            relocateSpec?: vimService.vim.VirtualMachineRelocateSpec;
            resourcePool?: vimService.vim.ManagedObjectReference;
            host?: vimService.vim.ManagedObjectReference;
            folder?: vimService.vim.ManagedObjectReference;
            disallowPrerequisiteMoves?: boolean;
            resourceLeaseDurationSec?: number;
         }
         interface VirtualDiskAntiAffinityRuleSpec extends vimService.vim.ClusterRuleInfo {
            diskId: Array<number>;
         }
         interface StorageDrsVmConfigInfo extends vimService.vim.DynamicData {
            vm?: vimService.vim.ManagedObjectReference;
            enabled?: boolean;
            behavior?: string;
            intraVmAffinity?: boolean;
            intraVmAntiAffinity?: vimService.vim.VirtualDiskAntiAffinityRuleSpec;
         }
         interface ArrayOfStorageDrsVmConfigInfo {
            StorageDrsVmConfigInfo?: Array<vimService.vim.StorageDrsVmConfigInfo>;
         }
         interface VAppCloneSpecNetworkMappingPair extends vimService.vim.DynamicData {
            source: vimService.vim.ManagedObjectReference;
            destination: vimService.vim.ManagedObjectReference;
         }
         interface ArrayOfVAppCloneSpecNetworkMappingPair {
            VAppCloneSpecNetworkMappingPair?: Array<vimService.vim.VAppCloneSpecNetworkMappingPair>;
         }
         interface VAppCloneSpecResourceMap extends vimService.vim.DynamicData {
            source: vimService.vim.ManagedObjectReference;
            parent?: vimService.vim.ManagedObjectReference;
            resourceSpec?: vimService.vim.ResourceConfigSpec;
            location?: vimService.vim.ManagedObjectReference;
         }
         interface ArrayOfVAppCloneSpecResourceMap {
            VAppCloneSpecResourceMap?: Array<vimService.vim.VAppCloneSpecResourceMap>;
         }
         enum VAppCloneSpecProvisioningType {
            "sameAsSource",
            "thin",
            "thick",
         }
         interface VAppCloneSpec extends vimService.vim.DynamicData {
            location: vimService.vim.ManagedObjectReference;
            host?: vimService.vim.ManagedObjectReference;
            resourceSpec?: vimService.vim.ResourceConfigSpec;
            vmFolder?: vimService.vim.ManagedObjectReference;
            networkMapping?: Array<vimService.vim.VAppCloneSpecNetworkMappingPair>;
            property?: Array<vimService.vim.KeyValue>;
            resourceMapping?: Array<vimService.vim.VAppCloneSpecResourceMap>;
            provisioning?: string;
         }
         enum VAppAutoStartAction {
            "none",
            "powerOn",
            "powerOff",
            "guestShutdown",
            "suspend",
         }
         interface VAppEntityConfigInfo extends vimService.vim.DynamicData {
            key?: vimService.vim.ManagedObjectReference;
            tag?: string;
            startOrder?: number;
            startDelay?: number;
            waitingForGuest?: boolean;
            startAction?: string;
            stopDelay?: number;
            stopAction?: string;
            destroyWithParent?: boolean;
         }
         interface ArrayOfVAppEntityConfigInfo {
            VAppEntityConfigInfo?: Array<vimService.vim.VAppEntityConfigInfo>;
         }
         enum VAppIPAssignmentInfoIpAllocationPolicy {
            "dhcpPolicy",
            "transientPolicy",
            "fixedPolicy",
            "fixedAllocatedPolicy",
         }
         enum VAppIPAssignmentInfoAllocationSchemes {
            "dhcp",
            "ovfenv",
         }
         enum VAppIPAssignmentInfoProtocols {
            "IPv4",
            "IPv6",
         }
         interface VAppIPAssignmentInfo extends vimService.vim.DynamicData {
            supportedAllocationScheme?: Array<string>;
            ipAllocationPolicy?: string;
            supportedIpProtocol?: Array<string>;
            ipProtocol?: string;
         }
         interface IpPoolIpPoolConfigInfo extends vimService.vim.DynamicData {
            subnetAddress?: string;
            netmask?: string;
            gateway?: string;
            range?: string;
            dns?: Array<string>;
            dhcpServerAvailable?: boolean;
            ipPoolEnabled?: boolean;
         }
         interface IpPoolAssociation extends vimService.vim.DynamicData {
            network?: vimService.vim.ManagedObjectReference;
            networkName: string;
         }
         interface ArrayOfIpPoolAssociation {
            IpPoolAssociation?: Array<vimService.vim.IpPoolAssociation>;
         }
         interface IpPool extends vimService.vim.DynamicData {
            id?: number;
            name?: string;
            ipv4Config?: vimService.vim.IpPoolIpPoolConfigInfo;
            ipv6Config?: vimService.vim.IpPoolIpPoolConfigInfo;
            dnsDomain?: string;
            dnsSearchPath?: string;
            hostPrefix?: string;
            httpProxy?: string;
            networkAssociation?: Array<vimService.vim.IpPoolAssociation>;
            availableIpv4Addresses?: number;
            availableIpv6Addresses?: number;
            allocatedIpv4Addresses?: number;
            allocatedIpv6Addresses?: number;
         }
         interface ArrayOfIpPool {
            IpPool?: Array<vimService.vim.IpPool>;
         }
         interface VAppOvfSectionInfo extends vimService.vim.DynamicData {
            key?: number;
            namespace?: string;
            type?: string;
            atEnvelopeLevel?: boolean;
            contents?: string;
         }
         interface ArrayOfVAppOvfSectionInfo {
            VAppOvfSectionInfo?: Array<vimService.vim.VAppOvfSectionInfo>;
         }
         interface VAppProductInfo extends vimService.vim.DynamicData {
            key: number;
            classId?: string;
            instanceId?: string;
            name?: string;
            vendor?: string;
            version?: string;
            fullVersion?: string;
            vendorUrl?: string;
            productUrl?: string;
            appUrl?: string;
         }
         interface ArrayOfVAppProductInfo {
            VAppProductInfo?: Array<vimService.vim.VAppProductInfo>;
         }
         interface VAppPropertyInfo extends vimService.vim.DynamicData {
            key: number;
            classId?: string;
            instanceId?: string;
            id?: string;
            category?: string;
            label?: string;
            type?: string;
            typeReference?: string;
            userConfigurable?: boolean;
            defaultValue?: string;
            value?: string;
            description?: string;
         }
         interface ArrayOfVAppPropertyInfo {
            VAppPropertyInfo?: Array<vimService.vim.VAppPropertyInfo>;
         }
         interface VAppConfigInfo extends vimService.vim.VmConfigInfo {
            entityConfig?: Array<vimService.vim.VAppEntityConfigInfo>;
            annotation: string;
            instanceUuid?: string;
            managedBy?: vimService.vim.ManagedByInfo;
         }
         interface VAppConfigSpec extends vimService.vim.VmConfigSpec {
            entityConfig?: Array<vimService.vim.VAppEntityConfigInfo>;
            annotation?: string;
            instanceUuid?: string;
            managedBy?: vimService.vim.ManagedByInfo;
         }
         interface VirtualAppImportSpec extends vimService.vim.ImportSpec {
            name: string;
            vAppConfigSpec: vimService.vim.VAppConfigSpec;
            resourcePoolSpec: vimService.vim.ResourceConfigSpec;
            child?: Array<vimService.vim.ImportSpec>;
         }
         interface VmConfigInfo extends vimService.vim.DynamicData {
            product?: Array<vimService.vim.VAppProductInfo>;
            property?: Array<vimService.vim.VAppPropertyInfo>;
            ipAssignment: vimService.vim.VAppIPAssignmentInfo;
            eula?: Array<string>;
            ovfSection?: Array<vimService.vim.VAppOvfSectionInfo>;
            ovfEnvironmentTransport?: Array<string>;
            installBootRequired: boolean;
            installBootStopDelay: number;
         }
         interface VmConfigSpec extends vimService.vim.DynamicData {
            product?: Array<vimService.vim.VAppProductSpec>;
            property?: Array<vimService.vim.VAppPropertySpec>;
            ipAssignment?: vimService.vim.VAppIPAssignmentInfo;
            eula?: Array<string>;
            ovfSection?: Array<vimService.vim.VAppOvfSectionSpec>;
            ovfEnvironmentTransport?: Array<string>;
            installBootRequired?: boolean;
            installBootStopDelay?: number;
         }
         interface VAppProductSpec extends vimService.vim.ArrayUpdateSpec {
            info?: vimService.vim.VAppProductInfo;
         }
         interface ArrayOfVAppProductSpec {
            VAppProductSpec?: Array<vimService.vim.VAppProductSpec>;
         }
         interface VAppPropertySpec extends vimService.vim.ArrayUpdateSpec {
            info?: vimService.vim.VAppPropertyInfo;
         }
         interface ArrayOfVAppPropertySpec {
            VAppPropertySpec?: Array<vimService.vim.VAppPropertySpec>;
         }
         interface VAppOvfSectionSpec extends vimService.vim.ArrayUpdateSpec {
            info?: vimService.vim.VAppOvfSectionInfo;
         }
         interface ArrayOfVAppOvfSectionSpec {
            VAppOvfSectionSpec?: Array<vimService.vim.VAppOvfSectionSpec>;
         }
         interface ClusterNetworkConfigSpec extends vimService.vim.DynamicData {
            networkPortGroup: vimService.vim.ManagedObjectReference;
            ipSettings: vimService.vim.CustomizationIPSettings;
         }
         interface SourceNodeSpec extends vimService.vim.DynamicData {
            managementVc: vimService.vim.ServiceLocator;
            activeVc: vimService.vim.ManagedObjectReference;
         }
         interface NodeNetworkSpec extends vimService.vim.DynamicData {
            ipSettings: vimService.vim.CustomizationIPSettings;
         }
         interface PassiveNodeNetworkSpec extends vimService.vim.NodeNetworkSpec {
            failoverIpSettings?: vimService.vim.CustomizationIPSettings;
         }
         interface VchaClusterNetworkSpec extends vimService.vim.DynamicData {
            witnessNetworkSpec: vimService.vim.NodeNetworkSpec;
            passiveNetworkSpec: vimService.vim.PassiveNodeNetworkSpec;
         }
         interface NodeDeploymentSpec extends vimService.vim.DynamicData {
            esxHost?: vimService.vim.ManagedObjectReference;
            datastore?: vimService.vim.ManagedObjectReference;
            publicNetworkPortGroup?: vimService.vim.ManagedObjectReference;
            clusterNetworkPortGroup?: vimService.vim.ManagedObjectReference;
            folder: vimService.vim.ManagedObjectReference;
            resourcePool?: vimService.vim.ManagedObjectReference;
            managementVc?: vimService.vim.ServiceLocator;
            nodeName: string;
            ipSettings: vimService.vim.CustomizationIPSettings;
         }
         interface PassiveNodeDeploymentSpec extends vimService.vim.NodeDeploymentSpec {
            failoverIpSettings?: vimService.vim.CustomizationIPSettings;
         }
         interface VchaClusterConfigSpec extends vimService.vim.DynamicData {
            passiveIp: string;
            witnessIp: string;
         }
         interface VchaClusterDeploymentSpec extends vimService.vim.DynamicData {
            passiveDeploymentSpec: vimService.vim.PassiveNodeDeploymentSpec;
            witnessDeploymentSpec: vimService.vim.NodeDeploymentSpec;
            activeVcSpec: vimService.vim.SourceNodeSpec;
            activeVcNetworkConfig?: vimService.vim.ClusterNetworkConfigSpec;
         }
         interface FailoverNodeInfo extends vimService.vim.DynamicData {
            clusterIpSettings: vimService.vim.CustomizationIPSettings;
            failoverIp?: vimService.vim.CustomizationIPSettings;
            biosUuid?: string;
         }
         interface WitnessNodeInfo extends vimService.vim.DynamicData {
            ipSettings: vimService.vim.CustomizationIPSettings;
            biosUuid?: string;
         }
         enum VchaState {
            "configured",
            "notConfigured",
            "invalid",
            "prepared",
         }
         interface VchaClusterConfigInfo extends vimService.vim.DynamicData {
            failoverNodeInfo1?: vimService.vim.FailoverNodeInfo;
            failoverNodeInfo2?: vimService.vim.FailoverNodeInfo;
            witnessNodeInfo?: vimService.vim.WitnessNodeInfo;
            state: string;
         }
         enum VchaNodeRole {
            "active",
            "passive",
            "witness",
         }
         enum VchaClusterMode {
            "enabled",
            "disabled",
            "maintenance",
         }
         enum VchaClusterState {
            "healthy",
            "degraded",
            "isolated",
         }
         enum VchaNodeState {
            "up",
            "down",
         }
         interface VchaNodeRuntimeInfo extends vimService.vim.DynamicData {
            nodeState: string;
            nodeRole: string;
            nodeIp: string;
         }
         interface ArrayOfVchaNodeRuntimeInfo {
            VchaNodeRuntimeInfo?: Array<vimService.vim.VchaNodeRuntimeInfo>;
         }
         interface VchaClusterRuntimeInfo extends vimService.vim.DynamicData {
            clusterState: string;
            nodeInfo?: Array<vimService.vim.VchaNodeRuntimeInfo>;
            clusterMode: string;
         }
         interface VchaClusterHealth extends vimService.vim.DynamicData {
            runtimeInfo: vimService.vim.VchaClusterRuntimeInfo;
            healthMessages?: Array<vimService.vim.LocalizableMessage>;
            additionalInformation?: Array<vimService.vim.LocalizableMessage>;
         }
         interface VirtualMachineAffinityInfo extends vimService.vim.DynamicData {
            affinitySet?: Array<number>;
         }
         enum VirtualMachineBootOptionsNetworkBootProtocolType {
            "ipv4",
            "ipv6",
         }
         interface VirtualMachineBootOptionsBootableDevice extends vimService.vim.DynamicData {
         }
         interface ArrayOfVirtualMachineBootOptionsBootableDevice {
            VirtualMachineBootOptionsBootableDevice?: Array<vimService.vim.VirtualMachineBootOptionsBootableDevice>;
         }
         interface VirtualMachineBootOptionsBootableDiskDevice extends vimService.vim.VirtualMachineBootOptionsBootableDevice {
            deviceKey: number;
         }
         interface VirtualMachineBootOptionsBootableEthernetDevice extends vimService.vim.VirtualMachineBootOptionsBootableDevice {
            deviceKey: number;
         }
         interface VirtualMachineBootOptionsBootableFloppyDevice extends vimService.vim.VirtualMachineBootOptionsBootableDevice {
         }
         interface VirtualMachineBootOptionsBootableCdromDevice extends vimService.vim.VirtualMachineBootOptionsBootableDevice {
         }
         interface VirtualMachineBootOptions extends vimService.vim.DynamicData {
            bootDelay?: number;
            enterBIOSSetup?: boolean;
            efiSecureBootEnabled?: boolean;
            bootRetryEnabled?: boolean;
            bootRetryDelay?: number;
            bootOrder?: Array<vimService.vim.VirtualMachineBootOptionsBootableDevice>;
            networkBootProtocol?: string;
         }
         interface VirtualMachineCapability extends vimService.vim.DynamicData {
            snapshotOperationsSupported: boolean;
            multipleSnapshotsSupported: boolean;
            snapshotConfigSupported: boolean;
            poweredOffSnapshotsSupported: boolean;
            memorySnapshotsSupported: boolean;
            revertToSnapshotSupported: boolean;
            quiescedSnapshotsSupported: boolean;
            disableSnapshotsSupported: boolean;
            lockSnapshotsSupported: boolean;
            consolePreferencesSupported: boolean;
            cpuFeatureMaskSupported: boolean;
            s1AcpiManagementSupported: boolean;
            settingScreenResolutionSupported: boolean;
            toolsAutoUpdateSupported: boolean;
            vmNpivWwnSupported: boolean;
            npivWwnOnNonRdmVmSupported: boolean;
            vmNpivWwnDisableSupported?: boolean;
            vmNpivWwnUpdateSupported?: boolean;
            swapPlacementSupported: boolean;
            toolsSyncTimeSupported: boolean;
            virtualMmuUsageSupported: boolean;
            diskSharesSupported: boolean;
            bootOptionsSupported: boolean;
            bootRetryOptionsSupported?: boolean;
            settingVideoRamSizeSupported: boolean;
            settingDisplayTopologySupported?: boolean;
            recordReplaySupported?: boolean;
            changeTrackingSupported?: boolean;
            multipleCoresPerSocketSupported?: boolean;
            hostBasedReplicationSupported?: boolean;
            guestAutoLockSupported?: boolean;
            memoryReservationLockSupported?: boolean;
            featureRequirementSupported?: boolean;
            poweredOnMonitorTypeChangeSupported?: boolean;
            seSparseDiskSupported?: boolean;
            nestedHVSupported?: boolean;
            vPMCSupported?: boolean;
            secureBootSupported?: boolean;
         }
         interface VirtualMachineCdromInfo extends vimService.vim.VirtualMachineTargetInfo {
            description?: string;
         }
         interface ArrayOfVirtualMachineCdromInfo {
            VirtualMachineCdromInfo?: Array<vimService.vim.VirtualMachineCdromInfo>;
         }
         interface VirtualMachineCloneSpec extends vimService.vim.DynamicData {
            location: vimService.vim.VirtualMachineRelocateSpec;
            template: boolean;
            config?: vimService.vim.VirtualMachineConfigSpec;
            customization?: vimService.vim.CustomizationSpec;
            powerOn: boolean;
            snapshot?: vimService.vim.ManagedObjectReference;
            memory?: boolean;
         }
         enum VirtualMachineConfigInfoNpivWwnType {
            "vc",
            "host",
            "external",
         }
         enum VirtualMachineConfigInfoSwapPlacementType {
            "inherit",
            "vmDirectory",
            "hostLocal",
         }
         interface VirtualMachineConfigInfoDatastoreUrlPair extends vimService.vim.DynamicData {
            name: string;
            url: string;
         }
         interface ArrayOfVirtualMachineConfigInfoDatastoreUrlPair {
            VirtualMachineConfigInfoDatastoreUrlPair?: Array<vimService.vim.VirtualMachineConfigInfoDatastoreUrlPair>;
         }
         interface VirtualMachineConfigInfoOverheadInfo extends vimService.vim.DynamicData {
            initialMemoryReservation?: number;
            initialSwapReservation?: number;
         }
         interface VirtualMachineConfigInfo extends vimService.vim.DynamicData {
            changeVersion: string;
            modified: Date;
            name: string;
            guestFullName: string;
            version: string;
            uuid: string;
            instanceUuid?: string;
            npivNodeWorldWideName?: Array<number>;
            npivPortWorldWideName?: Array<number>;
            npivWorldWideNameType?: string;
            npivDesiredNodeWwns?: number;
            npivDesiredPortWwns?: number;
            npivTemporaryDisabled?: boolean;
            npivOnNonRdmDisks?: boolean;
            locationId?: string;
            template: boolean;
            guestId: string;
            alternateGuestName: string;
            annotation?: string;
            files: vimService.vim.VirtualMachineFileInfo;
            tools?: vimService.vim.ToolsConfigInfo;
            flags: vimService.vim.VirtualMachineFlagInfo;
            consolePreferences?: vimService.vim.VirtualMachineConsolePreferences;
            defaultPowerOps: vimService.vim.VirtualMachineDefaultPowerOpInfo;
            hardware: vimService.vim.VirtualHardware;
            cpuAllocation?: vimService.vim.ResourceAllocationInfo;
            memoryAllocation?: vimService.vim.ResourceAllocationInfo;
            latencySensitivity?: vimService.vim.LatencySensitivity;
            memoryHotAddEnabled?: boolean;
            cpuHotAddEnabled?: boolean;
            cpuHotRemoveEnabled?: boolean;
            hotPlugMemoryLimit?: number;
            hotPlugMemoryIncrementSize?: number;
            cpuAffinity?: vimService.vim.VirtualMachineAffinityInfo;
            memoryAffinity?: vimService.vim.VirtualMachineAffinityInfo;
            networkShaper?: vimService.vim.VirtualMachineNetworkShaperInfo;
            extraConfig?: Array<vimService.vim.OptionValue>;
            cpuFeatureMask?: Array<vimService.vim.HostCpuIdInfo>;
            datastoreUrl?: Array<vimService.vim.VirtualMachineConfigInfoDatastoreUrlPair>;
            swapPlacement?: string;
            bootOptions?: vimService.vim.VirtualMachineBootOptions;
            ftInfo?: vimService.vim.FaultToleranceConfigInfo;
            repConfig?: vimService.vim.ReplicationConfigSpec;
            vAppConfig?: vimService.vim.VmConfigInfo;
            vAssertsEnabled?: boolean;
            changeTrackingEnabled?: boolean;
            firmware?: string;
            maxMksConnections?: number;
            guestAutoLockEnabled?: boolean;
            managedBy?: vimService.vim.ManagedByInfo;
            memoryReservationLockedToMax?: boolean;
            initialOverhead?: vimService.vim.VirtualMachineConfigInfoOverheadInfo;
            nestedHVEnabled?: boolean;
            vPMCEnabled?: boolean;
            scheduledHardwareUpgradeInfo?: vimService.vim.ScheduledHardwareUpgradeInfo;
            forkConfigInfo?: vimService.vim.VirtualMachineForkConfigInfo;
            vFlashCacheReservation?: number;
            vmxConfigChecksum?: string;
            messageBusTunnelEnabled?: boolean;
            vmStorageObjectId?: string;
            swapStorageObjectId?: string;
            keyId?: vimService.vim.CryptoKeyId;
            guestIntegrityInfo?: vimService.vim.VirtualMachineGuestIntegrityInfo;
            migrateEncryption?: string;
         }
         interface VirtualMachineConfigOption extends vimService.vim.DynamicData {
            version: string;
            description: string;
            guestOSDescriptor: Array<vimService.vim.GuestOsDescriptor>;
            guestOSDefaultIndex: number;
            hardwareOptions: vimService.vim.VirtualHardwareOption;
            capabilities: vimService.vim.VirtualMachineCapability;
            datastore: vimService.vim.DatastoreOption;
            defaultDevice?: Array<vimService.vim.VirtualDevice>;
            supportedMonitorType: Array<string>;
            supportedOvfEnvironmentTransport?: Array<string>;
            supportedOvfInstallTransport?: Array<string>;
         }
         interface VirtualMachineConfigOptionDescriptor extends vimService.vim.DynamicData {
            key: string;
            description?: string;
            host?: Array<vimService.vim.ManagedObjectReference>;
            createSupported?: boolean;
            defaultConfigOption?: boolean;
            runSupported?: boolean;
            upgradeSupported?: boolean;
         }
         interface ArrayOfVirtualMachineConfigOptionDescriptor {
            VirtualMachineConfigOptionDescriptor?: Array<vimService.vim.VirtualMachineConfigOptionDescriptor>;
         }
         enum VirtualMachineConfigSpecNpivWwnOp {
            "generate",
            "set",
            "remove",
            "extend",
         }
         enum VirtualMachineConfigSpecEncryptedVMotionModes {
            "disabled",
            "opportunistic",
            "required",
         }
         interface VirtualMachineCpuIdInfoSpec extends vimService.vim.ArrayUpdateSpec {
            info?: vimService.vim.HostCpuIdInfo;
         }
         interface ArrayOfVirtualMachineCpuIdInfoSpec {
            VirtualMachineCpuIdInfoSpec?: Array<vimService.vim.VirtualMachineCpuIdInfoSpec>;
         }
         interface VirtualMachineConfigSpec extends vimService.vim.DynamicData {
            changeVersion?: string;
            name?: string;
            version?: string;
            uuid?: string;
            instanceUuid?: string;
            npivNodeWorldWideName?: Array<number>;
            npivPortWorldWideName?: Array<number>;
            npivWorldWideNameType?: string;
            npivDesiredNodeWwns?: number;
            npivDesiredPortWwns?: number;
            npivTemporaryDisabled?: boolean;
            npivOnNonRdmDisks?: boolean;
            npivWorldWideNameOp?: string;
            locationId?: string;
            guestId?: string;
            alternateGuestName?: string;
            annotation?: string;
            files?: vimService.vim.VirtualMachineFileInfo;
            tools?: vimService.vim.ToolsConfigInfo;
            flags?: vimService.vim.VirtualMachineFlagInfo;
            consolePreferences?: vimService.vim.VirtualMachineConsolePreferences;
            powerOpInfo?: vimService.vim.VirtualMachineDefaultPowerOpInfo;
            numCPUs?: number;
            numCoresPerSocket?: number;
            memoryMB?: number;
            memoryHotAddEnabled?: boolean;
            cpuHotAddEnabled?: boolean;
            cpuHotRemoveEnabled?: boolean;
            virtualICH7MPresent?: boolean;
            virtualSMCPresent?: boolean;
            deviceChange?: Array<vimService.vim.VirtualDeviceConfigSpec>;
            cpuAllocation?: vimService.vim.ResourceAllocationInfo;
            memoryAllocation?: vimService.vim.ResourceAllocationInfo;
            latencySensitivity?: vimService.vim.LatencySensitivity;
            cpuAffinity?: vimService.vim.VirtualMachineAffinityInfo;
            memoryAffinity?: vimService.vim.VirtualMachineAffinityInfo;
            networkShaper?: vimService.vim.VirtualMachineNetworkShaperInfo;
            cpuFeatureMask?: Array<vimService.vim.VirtualMachineCpuIdInfoSpec>;
            extraConfig?: Array<vimService.vim.OptionValue>;
            swapPlacement?: string;
            bootOptions?: vimService.vim.VirtualMachineBootOptions;
            vAppConfig?: vimService.vim.VmConfigSpec;
            ftInfo?: vimService.vim.FaultToleranceConfigInfo;
            repConfig?: vimService.vim.ReplicationConfigSpec;
            vAppConfigRemoved?: boolean;
            vAssertsEnabled?: boolean;
            changeTrackingEnabled?: boolean;
            firmware?: string;
            maxMksConnections?: number;
            guestAutoLockEnabled?: boolean;
            managedBy?: vimService.vim.ManagedByInfo;
            memoryReservationLockedToMax?: boolean;
            nestedHVEnabled?: boolean;
            vPMCEnabled?: boolean;
            scheduledHardwareUpgradeInfo?: vimService.vim.ScheduledHardwareUpgradeInfo;
            vmProfile?: Array<vimService.vim.VirtualMachineProfileSpec>;
            messageBusTunnelEnabled?: boolean;
            crypto?: vimService.vim.CryptoSpec;
            migrateEncryption?: string;
         }
         interface ConfigTarget extends vimService.vim.DynamicData {
            numCpus: number;
            numCpuCores: number;
            numNumaNodes: number;
            smcPresent?: boolean;
            datastore?: Array<vimService.vim.VirtualMachineDatastoreInfo>;
            network?: Array<vimService.vim.VirtualMachineNetworkInfo>;
            opaqueNetwork?: Array<vimService.vim.OpaqueNetworkTargetInfo>;
            distributedVirtualPortgroup?: Array<vimService.vim.DistributedVirtualPortgroupInfo>;
            distributedVirtualSwitch?: Array<vimService.vim.DistributedVirtualSwitchInfo>;
            cdRom?: Array<vimService.vim.VirtualMachineCdromInfo>;
            serial?: Array<vimService.vim.VirtualMachineSerialInfo>;
            parallel?: Array<vimService.vim.VirtualMachineParallelInfo>;
            sound?: Array<vimService.vim.VirtualMachineSoundInfo>;
            usb?: Array<vimService.vim.VirtualMachineUsbInfo>;
            floppy?: Array<vimService.vim.VirtualMachineFloppyInfo>;
            legacyNetworkInfo?: Array<vimService.vim.VirtualMachineLegacyNetworkSwitchInfo>;
            scsiPassthrough?: Array<vimService.vim.VirtualMachineScsiPassthroughInfo>;
            scsiDisk?: Array<vimService.vim.VirtualMachineScsiDiskDeviceInfo>;
            ideDisk?: Array<vimService.vim.VirtualMachineIdeDiskDeviceInfo>;
            maxMemMBOptimalPerf: number;
            resourcePool?: vimService.vim.ResourcePoolRuntimeInfo;
            autoVmotion?: boolean;
            pciPassthrough?: Array<vimService.vim.VirtualMachinePciPassthroughInfo>;
            sriov?: Array<vimService.vim.VirtualMachineSriovInfo>;
            vFlashModule?: Array<vimService.vim.VirtualMachineVFlashModuleInfo>;
            sharedGpuPassthroughTypes?: Array<vimService.vim.VirtualMachinePciSharedGpuPassthroughInfo>;
         }
         interface VirtualMachineConsolePreferences extends vimService.vim.DynamicData {
            powerOnWhenOpened?: boolean;
            enterFullScreenOnPowerOn?: boolean;
            closeOnPowerOffOrSuspend?: boolean;
         }
         interface VirtualMachineDatastoreInfo extends vimService.vim.VirtualMachineTargetInfo {
            datastore: vimService.vim.DatastoreSummary;
            capability: vimService.vim.DatastoreCapability;
            maxFileSize: number;
            maxVirtualDiskCapacity?: number;
            maxPhysicalRDMFileSize?: number;
            maxVirtualRDMFileSize?: number;
            mode: string;
            vStorageSupport?: string;
         }
         interface ArrayOfVirtualMachineDatastoreInfo {
            VirtualMachineDatastoreInfo?: Array<vimService.vim.VirtualMachineDatastoreInfo>;
         }
         interface VirtualMachineDatastoreVolumeOption extends vimService.vim.DynamicData {
            fileSystemType: string;
            majorVersion?: number;
         }
         interface ArrayOfVirtualMachineDatastoreVolumeOption {
            VirtualMachineDatastoreVolumeOption?: Array<vimService.vim.VirtualMachineDatastoreVolumeOption>;
         }
         interface DatastoreOption extends vimService.vim.DynamicData {
            unsupportedVolumes?: Array<vimService.vim.VirtualMachineDatastoreVolumeOption>;
         }
         enum VirtualMachinePowerOpType {
            "soft",
            "hard",
            "preset",
         }
         enum VirtualMachineStandbyActionType {
            "checkpoint",
            "powerOnSuspend",
         }
         interface VirtualMachineDefaultPowerOpInfo extends vimService.vim.DynamicData {
            powerOffType?: string;
            suspendType?: string;
            resetType?: string;
            defaultPowerOffType?: string;
            defaultSuspendType?: string;
            defaultResetType?: string;
            standbyAction?: string;
         }
         interface VirtualMachineDefaultProfileSpec extends vimService.vim.VirtualMachineProfileSpec {
         }
         interface VirtualMachineDefinedProfileSpec extends vimService.vim.VirtualMachineProfileSpec {
            profileId: string;
            replicationSpec?: vimService.vim.ReplicationSpec;
            profileData?: vimService.vim.VirtualMachineProfileRawData;
         }
         interface VirtualMachineDeviceRuntimeInfoDeviceRuntimeState extends vimService.vim.DynamicData {
         }
         enum VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm {
            "vmNptIncompatibleGuest",
            "vmNptIncompatibleGuestDriver",
            "vmNptIncompatibleAdapterType",
            "vmNptDisabledOrDisconnectedAdapter",
            "vmNptIncompatibleAdapterFeatures",
            "vmNptIncompatibleBackingType",
            "vmNptInsufficientMemoryReservation",
            "vmNptFaultToleranceOrRecordReplayConfigured",
            "vmNptConflictingIOChainConfigured",
            "vmNptMonitorBlocks",
            "vmNptConflictingOperationInProgress",
            "vmNptRuntimeError",
            "vmNptOutOfIntrVector",
            "vmNptVMCIActive",
         }
         enum VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOther {
            "vmNptIncompatibleHost",
            "vmNptIncompatibleNetwork",
         }
         interface VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState extends vimService.vim.VirtualMachineDeviceRuntimeInfoDeviceRuntimeState {
            vmDirectPathGen2Active: boolean;
            vmDirectPathGen2InactiveReasonVm?: Array<string>;
            vmDirectPathGen2InactiveReasonOther?: Array<string>;
            vmDirectPathGen2InactiveReasonExtended?: string;
            reservationStatus?: string;
         }
         interface VirtualMachineDeviceRuntimeInfo extends vimService.vim.DynamicData {
            runtimeState: vimService.vim.VirtualMachineDeviceRuntimeInfoDeviceRuntimeState;
            key: number;
         }
         interface ArrayOfVirtualMachineDeviceRuntimeInfo {
            VirtualMachineDeviceRuntimeInfo?: Array<vimService.vim.VirtualMachineDeviceRuntimeInfo>;
         }
         interface VirtualMachineDiskDeviceInfo extends vimService.vim.VirtualMachineTargetInfo {
            capacity?: number;
            vm?: Array<vimService.vim.ManagedObjectReference>;
         }
         interface VirtualMachineEmptyProfileSpec extends vimService.vim.VirtualMachineProfileSpec {
         }
         interface FaultToleranceConfigInfo extends vimService.vim.DynamicData {
            role: number;
            instanceUuids: Array<string>;
            configPaths: Array<string>;
            orphaned?: boolean;
         }
         interface FaultTolerancePrimaryConfigInfo extends vimService.vim.FaultToleranceConfigInfo {
            secondaries: Array<vimService.vim.ManagedObjectReference>;
         }
         interface FaultToleranceSecondaryConfigInfo extends vimService.vim.FaultToleranceConfigInfo {
            primaryVM: vimService.vim.ManagedObjectReference;
         }
         interface FaultToleranceConfigSpec extends vimService.vim.DynamicData {
            metaDataPath?: vimService.vim.FaultToleranceMetaSpec;
            secondaryVmSpec?: vimService.vim.FaultToleranceVMConfigSpec;
         }
         interface FaultToleranceMetaSpec extends vimService.vim.DynamicData {
            metaDataDatastore: vimService.vim.ManagedObjectReference;
         }
         interface FaultToleranceSecondaryOpResult extends vimService.vim.DynamicData {
            vm: vimService.vim.ManagedObjectReference;
            powerOnAttempted: boolean;
            powerOnResult?: vimService.vim.ClusterPowerOnVmResult;
         }
         interface FaultToleranceDiskSpec extends vimService.vim.DynamicData {
            disk: vimService.vim.VirtualDevice;
            datastore: vimService.vim.ManagedObjectReference;
         }
         interface ArrayOfFaultToleranceDiskSpec {
            FaultToleranceDiskSpec?: Array<vimService.vim.FaultToleranceDiskSpec>;
         }
         interface FaultToleranceVMConfigSpec extends vimService.vim.DynamicData {
            vmConfig?: vimService.vim.ManagedObjectReference;
            disks?: Array<vimService.vim.FaultToleranceDiskSpec>;
         }
         interface VirtualMachineFeatureRequirement extends vimService.vim.DynamicData {
            key: string;
            featureName: string;
            value: string;
         }
         interface ArrayOfVirtualMachineFeatureRequirement {
            VirtualMachineFeatureRequirement?: Array<vimService.vim.VirtualMachineFeatureRequirement>;
         }
         interface VirtualMachineFileInfo extends vimService.vim.DynamicData {
            vmPathName?: string;
            snapshotDirectory?: string;
            suspendDirectory?: string;
            logDirectory?: string;
            ftMetadataDirectory?: string;
         }
         interface VirtualMachineFileLayoutDiskLayout extends vimService.vim.DynamicData {
            key: number;
            diskFile: Array<string>;
         }
         interface ArrayOfVirtualMachineFileLayoutDiskLayout {
            VirtualMachineFileLayoutDiskLayout?: Array<vimService.vim.VirtualMachineFileLayoutDiskLayout>;
         }
         interface VirtualMachineFileLayoutSnapshotLayout extends vimService.vim.DynamicData {
            key: vimService.vim.ManagedObjectReference;
            snapshotFile: Array<string>;
         }
         interface ArrayOfVirtualMachineFileLayoutSnapshotLayout {
            VirtualMachineFileLayoutSnapshotLayout?: Array<vimService.vim.VirtualMachineFileLayoutSnapshotLayout>;
         }
         interface VirtualMachineFileLayout extends vimService.vim.DynamicData {
            configFile?: Array<string>;
            logFile?: Array<string>;
            disk?: Array<vimService.vim.VirtualMachineFileLayoutDiskLayout>;
            snapshot?: Array<vimService.vim.VirtualMachineFileLayoutSnapshotLayout>;
            swapFile?: string;
         }
         enum VirtualMachineFileLayoutExFileType {
            "config",
            "extendedConfig",
            "diskDescriptor",
            "diskExtent",
            "digestDescriptor",
            "digestExtent",
            "diskReplicationState",
            "log",
            "stat",
            "namespaceData",
            "nvram",
            "snapshotData",
            "snapshotMemory",
            "snapshotList",
            "snapshotManifestList",
            "suspend",
            "suspendMemory",
            "swap",
            "uwswap",
            "core",
            "screenshot",
            "ftMetadata",
            "guestCustomization",
         }
         interface VirtualMachineFileLayoutExFileInfo extends vimService.vim.DynamicData {
            key: number;
            name: string;
            type: string;
            size: number;
            uniqueSize?: number;
            backingObjectId?: string;
            accessible?: boolean;
         }
         interface ArrayOfVirtualMachineFileLayoutExFileInfo {
            VirtualMachineFileLayoutExFileInfo?: Array<vimService.vim.VirtualMachineFileLayoutExFileInfo>;
         }
         interface VirtualMachineFileLayoutExDiskUnit extends vimService.vim.DynamicData {
            fileKey: Array<number>;
         }
         interface ArrayOfVirtualMachineFileLayoutExDiskUnit {
            VirtualMachineFileLayoutExDiskUnit?: Array<vimService.vim.VirtualMachineFileLayoutExDiskUnit>;
         }
         interface VirtualMachineFileLayoutExDiskLayout extends vimService.vim.DynamicData {
            key: number;
            chain?: Array<vimService.vim.VirtualMachineFileLayoutExDiskUnit>;
         }
         interface ArrayOfVirtualMachineFileLayoutExDiskLayout {
            VirtualMachineFileLayoutExDiskLayout?: Array<vimService.vim.VirtualMachineFileLayoutExDiskLayout>;
         }
         interface VirtualMachineFileLayoutExSnapshotLayout extends vimService.vim.DynamicData {
            key: vimService.vim.ManagedObjectReference;
            dataKey: number;
            memoryKey?: number;
            disk?: Array<vimService.vim.VirtualMachineFileLayoutExDiskLayout>;
         }
         interface ArrayOfVirtualMachineFileLayoutExSnapshotLayout {
            VirtualMachineFileLayoutExSnapshotLayout?: Array<vimService.vim.VirtualMachineFileLayoutExSnapshotLayout>;
         }
         interface VirtualMachineFileLayoutEx extends vimService.vim.DynamicData {
            file?: Array<vimService.vim.VirtualMachineFileLayoutExFileInfo>;
            disk?: Array<vimService.vim.VirtualMachineFileLayoutExDiskLayout>;
            snapshot?: Array<vimService.vim.VirtualMachineFileLayoutExSnapshotLayout>;
            timestamp: Date;
         }
         enum VirtualMachineHtSharing {
            "any",
            "none",
            "internal",
         }
         enum VirtualMachinePowerOffBehavior {
            "powerOff",
            "revert",
            "prompt",
            "take",
         }
         enum VirtualMachineFlagInfoMonitorType {
            "release",
            "debug",
            "stats",
         }
         enum VirtualMachineFlagInfoVirtualMmuUsage {
            "automatic",
            "on",
            "off",
         }
         enum VirtualMachineFlagInfoVirtualExecUsage {
            "hvAuto",
            "hvOn",
            "hvOff",
         }
         interface VirtualMachineFlagInfo extends vimService.vim.DynamicData {
            disableAcceleration?: boolean;
            enableLogging?: boolean;
            useToe?: boolean;
            runWithDebugInfo?: boolean;
            monitorType?: string;
            htSharing?: string;
            snapshotDisabled?: boolean;
            snapshotLocked?: boolean;
            diskUuidEnabled?: boolean;
            virtualMmuUsage?: string;
            virtualExecUsage?: string;
            snapshotPowerOffBehavior?: string;
            recordReplayEnabled?: boolean;
            faultToleranceType?: string;
            cbrcCacheEnabled?: boolean;
         }
         interface VirtualMachineFloppyInfo extends vimService.vim.VirtualMachineTargetInfo {
         }
         interface ArrayOfVirtualMachineFloppyInfo {
            VirtualMachineFloppyInfo?: Array<vimService.vim.VirtualMachineFloppyInfo>;
         }
         enum VirtualMachineForkConfigInfoChildType {
            "none",
            "persistent",
            "nonpersistent",
         }
         interface VirtualMachineForkConfigInfo extends vimService.vim.DynamicData {
            parentEnabled?: boolean;
            childForkGroupId?: string;
            parentForkGroupId?: string;
            childType?: string;
         }
         enum VirtualMachineToolsStatus {
            "toolsNotInstalled",
            "toolsNotRunning",
            "toolsOld",
            "toolsOk",
         }
         enum VirtualMachineToolsVersionStatus {
            "guestToolsNotInstalled",
            "guestToolsNeedUpgrade",
            "guestToolsCurrent",
            "guestToolsUnmanaged",
            "guestToolsTooOld",
            "guestToolsSupportedOld",
            "guestToolsSupportedNew",
            "guestToolsTooNew",
            "guestToolsBlacklisted",
         }
         enum VirtualMachineToolsRunningStatus {
            "guestToolsNotRunning",
            "guestToolsRunning",
            "guestToolsExecutingScripts",
         }
         enum VirtualMachineToolsInstallType {
            "guestToolsTypeUnknown",
            "guestToolsTypeMSI",
            "guestToolsTypeTar",
            "guestToolsTypeOSP",
            "guestToolsTypeOpenVMTools",
         }
         interface GuestDiskInfo extends vimService.vim.DynamicData {
            diskPath?: string;
            capacity?: number;
            freeSpace?: number;
         }
         interface ArrayOfGuestDiskInfo {
            GuestDiskInfo?: Array<vimService.vim.GuestDiskInfo>;
         }
         interface GuestNicInfo extends vimService.vim.DynamicData {
            network?: string;
            ipAddress?: Array<string>;
            macAddress?: string;
            connected: boolean;
            deviceConfigId: number;
            dnsConfig?: vimService.vim.NetDnsConfigInfo;
            ipConfig?: vimService.vim.NetIpConfigInfo;
            netBIOSConfig?: vimService.vim.NetBIOSConfigInfo;
         }
         interface ArrayOfGuestNicInfo {
            GuestNicInfo?: Array<vimService.vim.GuestNicInfo>;
         }
         interface GuestStackInfo extends vimService.vim.DynamicData {
            dnsConfig?: vimService.vim.NetDnsConfigInfo;
            ipRouteConfig?: vimService.vim.NetIpRouteConfigInfo;
            ipStackConfig?: Array<vimService.vim.KeyValue>;
            dhcpConfig?: vimService.vim.NetDhcpConfigInfo;
         }
         interface ArrayOfGuestStackInfo {
            GuestStackInfo?: Array<vimService.vim.GuestStackInfo>;
         }
         interface GuestScreenInfo extends vimService.vim.DynamicData {
            width: number;
            height: number;
         }
         enum VirtualMachineGuestState {
            "running",
            "shuttingDown",
            "resetting",
            "standby",
            "notRunning",
            "unknown",
         }
         enum GuestInfoAppStateType {
            "none",
            "appStateOk",
            "appStateNeedReset",
         }
         interface GuestInfoNamespaceGenerationInfo extends vimService.vim.DynamicData {
            key: string;
            generationNo: number;
         }
         interface ArrayOfGuestInfoNamespaceGenerationInfo {
            GuestInfoNamespaceGenerationInfo?: Array<vimService.vim.GuestInfoNamespaceGenerationInfo>;
         }
         interface GuestInfo extends vimService.vim.DynamicData {
            toolsStatus?: vimService.vim.VirtualMachineToolsStatus;
            toolsVersionStatus?: string;
            toolsVersionStatus2?: string;
            toolsRunningStatus?: string;
            toolsVersion?: string;
            toolsInstallType?: string;
            guestId?: string;
            guestFamily?: string;
            guestFullName?: string;
            hostName?: string;
            ipAddress?: string;
            net?: Array<vimService.vim.GuestNicInfo>;
            ipStack?: Array<vimService.vim.GuestStackInfo>;
            disk?: Array<vimService.vim.GuestDiskInfo>;
            screen?: vimService.vim.GuestScreenInfo;
            guestState: string;
            appHeartbeatStatus?: string;
            guestKernelCrashed?: boolean;
            appState?: string;
            guestOperationsReady?: boolean;
            interactiveGuestOperationsReady?: boolean;
            guestStateChangeSupported?: boolean;
            generationInfo?: Array<vimService.vim.GuestInfoNamespaceGenerationInfo>;
         }
         interface VirtualMachineGuestIntegrityInfo extends vimService.vim.DynamicData {
            enabled?: boolean;
         }
         enum VirtualMachineGuestOsFamily {
            "windowsGuest",
            "linuxGuest",
            "netwareGuest",
            "solarisGuest",
            "darwinGuestFamily",
            "otherGuestFamily",
         }
         enum VirtualMachineGuestOsIdentifier {
            "dosGuest",
            "win31Guest",
            "win95Guest",
            "win98Guest",
            "winMeGuest",
            "winNTGuest",
            "win2000ProGuest",
            "win2000ServGuest",
            "win2000AdvServGuest",
            "winXPHomeGuest",
            "winXPProGuest",
            "winXPPro64Guest",
            "winNetWebGuest",
            "winNetStandardGuest",
            "winNetEnterpriseGuest",
            "winNetDatacenterGuest",
            "winNetBusinessGuest",
            "winNetStandard64Guest",
            "winNetEnterprise64Guest",
            "winLonghornGuest",
            "winLonghorn64Guest",
            "winNetDatacenter64Guest",
            "winVistaGuest",
            "winVista64Guest",
            "windows7Guest",
            "windows7_64Guest",
            "windows7Server64Guest",
            "windows8Guest",
            "windows8_64Guest",
            "windows8Server64Guest",
            "windows9Guest",
            "windows9_64Guest",
            "windows9Server64Guest",
            "windowsHyperVGuest",
            "freebsdGuest",
            "freebsd64Guest",
            "redhatGuest",
            "rhel2Guest",
            "rhel3Guest",
            "rhel3_64Guest",
            "rhel4Guest",
            "rhel4_64Guest",
            "rhel5Guest",
            "rhel5_64Guest",
            "rhel6Guest",
            "rhel6_64Guest",
            "rhel7Guest",
            "rhel7_64Guest",
            "centosGuest",
            "centos64Guest",
            "centos6Guest",
            "centos6_64Guest",
            "centos7Guest",
            "centos7_64Guest",
            "oracleLinuxGuest",
            "oracleLinux64Guest",
            "oracleLinux6Guest",
            "oracleLinux6_64Guest",
            "oracleLinux7Guest",
            "oracleLinux7_64Guest",
            "suseGuest",
            "suse64Guest",
            "slesGuest",
            "sles64Guest",
            "sles10Guest",
            "sles10_64Guest",
            "sles11Guest",
            "sles11_64Guest",
            "sles12Guest",
            "sles12_64Guest",
            "nld9Guest",
            "oesGuest",
            "sjdsGuest",
            "mandrakeGuest",
            "mandrivaGuest",
            "mandriva64Guest",
            "turboLinuxGuest",
            "turboLinux64Guest",
            "ubuntuGuest",
            "ubuntu64Guest",
            "debian4Guest",
            "debian4_64Guest",
            "debian5Guest",
            "debian5_64Guest",
            "debian6Guest",
            "debian6_64Guest",
            "debian7Guest",
            "debian7_64Guest",
            "debian8Guest",
            "debian8_64Guest",
            "debian9Guest",
            "debian9_64Guest",
            "debian10Guest",
            "debian10_64Guest",
            "asianux3Guest",
            "asianux3_64Guest",
            "asianux4Guest",
            "asianux4_64Guest",
            "asianux5_64Guest",
            "asianux7_64Guest",
            "opensuseGuest",
            "opensuse64Guest",
            "fedoraGuest",
            "fedora64Guest",
            "coreos64Guest",
            "vmwarePhoton64Guest",
            "other24xLinuxGuest",
            "other26xLinuxGuest",
            "otherLinuxGuest",
            "other3xLinuxGuest",
            "genericLinuxGuest",
            "other24xLinux64Guest",
            "other26xLinux64Guest",
            "other3xLinux64Guest",
            "otherLinux64Guest",
            "solaris6Guest",
            "solaris7Guest",
            "solaris8Guest",
            "solaris9Guest",
            "solaris10Guest",
            "solaris10_64Guest",
            "solaris11_64Guest",
            "os2Guest",
            "eComStationGuest",
            "eComStation2Guest",
            "netware4Guest",
            "netware5Guest",
            "netware6Guest",
            "openServer5Guest",
            "openServer6Guest",
            "unixWare7Guest",
            "darwinGuest",
            "darwin64Guest",
            "darwin10Guest",
            "darwin10_64Guest",
            "darwin11Guest",
            "darwin11_64Guest",
            "darwin12_64Guest",
            "darwin13_64Guest",
            "darwin14_64Guest",
            "darwin15_64Guest",
            "darwin16_64Guest",
            "vmkernelGuest",
            "vmkernel5Guest",
            "vmkernel6Guest",
            "vmkernel65Guest",
            "otherGuest",
            "otherGuest64",
         }
         enum GuestOsDescriptorFirmwareType {
            "bios",
            "efi",
         }
         enum GuestOsDescriptorSupportLevel {
            "experimental",
            "legacy",
            "terminated",
            "supported",
            "unsupported",
            "deprecated",
            "techPreview",
         }
         interface GuestOsDescriptor extends vimService.vim.DynamicData {
            id: string;
            family: string;
            fullName: string;
            supportedMaxCPUs: number;
            numSupportedPhysicalSockets?: number;
            numSupportedCoresPerSocket?: number;
            supportedMinMemMB: number;
            supportedMaxMemMB: number;
            recommendedMemMB: number;
            recommendedColorDepth: number;
            supportedDiskControllerList: Array<string>;
            recommendedSCSIController?: string;
            recommendedDiskController: string;
            supportedNumDisks: number;
            recommendedDiskSizeMB: number;
            recommendedCdromController?: string;
            supportedEthernetCard: Array<string>;
            recommendedEthernetCard?: string;
            supportsSlaveDisk?: boolean;
            cpuFeatureMask?: Array<vimService.vim.HostCpuIdInfo>;
            smcRequired?: boolean;
            supportsWakeOnLan: boolean;
            supportsVMI?: boolean;
            supportsMemoryHotAdd?: boolean;
            supportsCpuHotAdd?: boolean;
            supportsCpuHotRemove?: boolean;
            supportedFirmware?: Array<string>;
            recommendedFirmware?: string;
            supportedUSBControllerList?: Array<string>;
            recommendedUSBController?: string;
            supports3D?: boolean;
            recommended3D?: boolean;
            smcRecommended?: boolean;
            ich7mRecommended?: boolean;
            usbRecommended?: boolean;
            supportLevel?: string;
            supportedForCreate?: boolean;
            vRAMSizeInKB?: vimService.vim.IntOption;
            numSupportedFloppyDevices?: number;
            wakeOnLanEthernetCard?: Array<string>;
            supportsPvscsiControllerForBoot?: boolean;
            diskUuidEnabled?: boolean;
            supportsHotPlugPCI?: boolean;
            supportsSecureBoot?: boolean;
            defaultSecureBoot?: boolean;
         }
         interface ArrayOfGuestOsDescriptor {
            GuestOsDescriptor?: Array<vimService.vim.GuestOsDescriptor>;
         }
         interface VirtualMachineGuestQuiesceSpec extends vimService.vim.DynamicData {
            timeout?: number;
         }
         interface VirtualMachineIdeDiskDevicePartitionInfo extends vimService.vim.DynamicData {
            id: number;
            capacity: number;
         }
         interface ArrayOfVirtualMachineIdeDiskDevicePartitionInfo {
            VirtualMachineIdeDiskDevicePartitionInfo?: Array<vimService.vim.VirtualMachineIdeDiskDevicePartitionInfo>;
         }
         interface VirtualMachineIdeDiskDeviceInfo extends vimService.vim.VirtualMachineDiskDeviceInfo {
            partitionTable?: Array<vimService.vim.VirtualMachineIdeDiskDevicePartitionInfo>;
         }
         interface ArrayOfVirtualMachineIdeDiskDeviceInfo {
            VirtualMachineIdeDiskDeviceInfo?: Array<vimService.vim.VirtualMachineIdeDiskDeviceInfo>;
         }
         interface VirtualMachineLegacyNetworkSwitchInfo extends vimService.vim.DynamicData {
            name: string;
         }
         interface ArrayOfVirtualMachineLegacyNetworkSwitchInfo {
            VirtualMachineLegacyNetworkSwitchInfo?: Array<vimService.vim.VirtualMachineLegacyNetworkSwitchInfo>;
         }
         interface VirtualMachineMessage extends vimService.vim.DynamicData {
            id: string;
            argument?: Array<any>;
            text?: string;
         }
         interface ArrayOfVirtualMachineMessage {
            VirtualMachineMessage?: Array<vimService.vim.VirtualMachineMessage>;
         }
         enum VirtualMachineMetadataManagerVmMetadataOwnerOwner {
            "ComVmwareVsphereHA",
         }
         interface VirtualMachineMetadataManagerVmMetadataOwner extends vimService.vim.DynamicData {
            name: string;
         }
         enum VirtualMachineMetadataManagerVmMetadataOp {
            "Update",
            "Remove",
         }
         interface VirtualMachineMetadataManagerVmMetadata extends vimService.vim.DynamicData {
            vmId: string;
            metadata?: string;
         }
         interface VirtualMachineMetadataManagerVmMetadataInput extends vimService.vim.DynamicData {
            operation: string;
            vmMetadata: vimService.vim.VirtualMachineMetadataManagerVmMetadata;
         }
         interface ArrayOfVirtualMachineMetadataManagerVmMetadataInput {
            VirtualMachineMetadataManagerVmMetadataInput?: Array<vimService.vim.VirtualMachineMetadataManagerVmMetadataInput>;
         }
         interface VirtualMachineMetadataManagerVmMetadataResult extends vimService.vim.DynamicData {
            vmMetadata: vimService.vim.VirtualMachineMetadataManagerVmMetadata;
            error?: vimService.vim.LocalizedMethodFault;
         }
         interface ArrayOfVirtualMachineMetadataManagerVmMetadataResult {
            VirtualMachineMetadataManagerVmMetadataResult?: Array<vimService.vim.VirtualMachineMetadataManagerVmMetadataResult>;
         }
         interface VirtualMachineNetworkInfo extends vimService.vim.VirtualMachineTargetInfo {
            network: vimService.vim.NetworkSummary;
            vswitch?: string;
         }
         interface ArrayOfVirtualMachineNetworkInfo {
            VirtualMachineNetworkInfo?: Array<vimService.vim.VirtualMachineNetworkInfo>;
         }
         interface VirtualMachineNetworkShaperInfo extends vimService.vim.DynamicData {
            enabled?: boolean;
            peakBps?: number;
            averageBps?: number;
            burstSize?: number;
         }
         interface OpaqueNetworkTargetInfo extends vimService.vim.VirtualMachineTargetInfo {
            network: vimService.vim.OpaqueNetworkSummary;
            networkReservationSupported?: boolean;
         }
         interface ArrayOfOpaqueNetworkTargetInfo {
            OpaqueNetworkTargetInfo?: Array<vimService.vim.OpaqueNetworkTargetInfo>;
         }
         interface VirtualMachineParallelInfo extends vimService.vim.VirtualMachineTargetInfo {
         }
         interface ArrayOfVirtualMachineParallelInfo {
            VirtualMachineParallelInfo?: Array<vimService.vim.VirtualMachineParallelInfo>;
         }
         interface VirtualMachinePciPassthroughInfo extends vimService.vim.VirtualMachineTargetInfo {
            pciDevice: vimService.vim.HostPciDevice;
            systemId: string;
         }
         interface ArrayOfVirtualMachinePciPassthroughInfo {
            VirtualMachinePciPassthroughInfo?: Array<vimService.vim.VirtualMachinePciPassthroughInfo>;
         }
         interface VirtualMachinePciSharedGpuPassthroughInfo extends vimService.vim.VirtualMachineTargetInfo {
            vgpu: string;
         }
         interface ArrayOfVirtualMachinePciSharedGpuPassthroughInfo {
            VirtualMachinePciSharedGpuPassthroughInfo?: Array<vimService.vim.VirtualMachinePciSharedGpuPassthroughInfo>;
         }
         interface VirtualMachineProfileRawData extends vimService.vim.DynamicData {
            extensionKey: string;
            objectData?: string;
         }
         interface VirtualMachineProfileSpec extends vimService.vim.DynamicData {
         }
         interface ArrayOfVirtualMachineProfileSpec {
            VirtualMachineProfileSpec?: Array<vimService.vim.VirtualMachineProfileSpec>;
         }
         interface VirtualMachineQuestionInfo extends vimService.vim.DynamicData {
            id: string;
            text: string;
            choice: vimService.vim.ChoiceOption;
            message?: Array<vimService.vim.VirtualMachineMessage>;
         }
         enum VirtualMachineRelocateTransformation {
            "flat",
            "sparse",
         }
         interface VirtualMachineRelocateSpecDiskLocator extends vimService.vim.DynamicData {
            diskId: number;
            datastore: vimService.vim.ManagedObjectReference;
            diskMoveType?: string;
            diskBackingInfo?: vimService.vim.VirtualDeviceBackingInfo;
            profile?: Array<vimService.vim.VirtualMachineProfileSpec>;
         }
         interface ArrayOfVirtualMachineRelocateSpecDiskLocator {
            VirtualMachineRelocateSpecDiskLocator?: Array<vimService.vim.VirtualMachineRelocateSpecDiskLocator>;
         }
         enum VirtualMachineRelocateDiskMoveOptions {
            "moveAllDiskBackingsAndAllowSharing",
            "moveAllDiskBackingsAndDisallowSharing",
            "moveChildMostDiskBacking",
            "createNewChildDiskBacking",
            "moveAllDiskBackingsAndConsolidate",
         }
         interface VirtualMachineRelocateSpec extends vimService.vim.DynamicData {
            service?: vimService.vim.ServiceLocator;
            folder?: vimService.vim.ManagedObjectReference;
            datastore?: vimService.vim.ManagedObjectReference;
            diskMoveType?: string;
            pool?: vimService.vim.ManagedObjectReference;
            host?: vimService.vim.ManagedObjectReference;
            disk?: Array<vimService.vim.VirtualMachineRelocateSpecDiskLocator>;
            transform?: vimService.vim.VirtualMachineRelocateTransformation;
            deviceChange?: Array<vimService.vim.VirtualDeviceConfigSpec>;
            profile?: Array<vimService.vim.VirtualMachineProfileSpec>;
         }
         interface ReplicationInfoDiskSettings extends vimService.vim.DynamicData {
            key: number;
            diskReplicationId: string;
         }
         interface ArrayOfReplicationInfoDiskSettings {
            ReplicationInfoDiskSettings?: Array<vimService.vim.ReplicationInfoDiskSettings>;
         }
         interface ReplicationConfigSpec extends vimService.vim.DynamicData {
            generation: number;
            vmReplicationId: string;
            destination: string;
            port: number;
            rpo: number;
            quiesceGuestEnabled: boolean;
            paused: boolean;
            oppUpdatesEnabled: boolean;
            netCompressionEnabled?: boolean;
            disk?: Array<vimService.vim.ReplicationInfoDiskSettings>;
         }
         interface VirtualMachineRuntimeInfoDasProtectionState extends vimService.vim.DynamicData {
            dasProtected: boolean;
         }
         interface VirtualMachineRuntimeInfo extends vimService.vim.DynamicData {
            device?: Array<vimService.vim.VirtualMachineDeviceRuntimeInfo>;
            host?: vimService.vim.ManagedObjectReference;
            connectionState: vimService.vim.VirtualMachineConnectionState;
            powerState: vimService.vim.VirtualMachinePowerState;
            faultToleranceState?: vimService.vim.VirtualMachineFaultToleranceState;
            dasVmProtection?: vimService.vim.VirtualMachineRuntimeInfoDasProtectionState;
            toolsInstallerMounted: boolean;
            suspendTime?: Date;
            bootTime?: Date;
            suspendInterval?: number;
            question?: vimService.vim.VirtualMachineQuestionInfo;
            memoryOverhead?: number;
            maxCpuUsage?: number;
            maxMemoryUsage?: number;
            numMksConnections: number;
            recordReplayState?: vimService.vim.VirtualMachineRecordReplayState;
            cleanPowerOff?: boolean;
            needSecondaryReason?: string;
            onlineStandby?: boolean;
            minRequiredEVCModeKey?: string;
            consolidationNeeded?: boolean;
            offlineFeatureRequirement?: Array<vimService.vim.VirtualMachineFeatureRequirement>;
            featureRequirement?: Array<vimService.vim.VirtualMachineFeatureRequirement>;
            featureMask?: Array<vimService.vim.HostFeatureMask>;
            vFlashCacheAllocation?: number;
            paused?: boolean;
            snapshotInBackground?: boolean;
            quiescedForkParent?: boolean;
         }
         enum ScheduledHardwareUpgradeInfoHardwareUpgradePolicy {
            "never",
            "onSoftPowerOff",
            "always",
         }
         enum ScheduledHardwareUpgradeInfoHardwareUpgradeStatus {
            "none",
            "pending",
            "success",
            "failed",
         }
         interface ScheduledHardwareUpgradeInfo extends vimService.vim.DynamicData {
            upgradePolicy?: string;
            versionKey?: string;
            scheduledHardwareUpgradeStatus?: string;
            fault?: vimService.vim.LocalizedMethodFault;
         }
         interface VirtualMachineScsiDiskDeviceInfo extends vimService.vim.VirtualMachineDiskDeviceInfo {
            disk?: vimService.vim.HostScsiDisk;
            transportHint?: string;
            lunNumber?: number;
         }
         interface ArrayOfVirtualMachineScsiDiskDeviceInfo {
            VirtualMachineScsiDiskDeviceInfo?: Array<vimService.vim.VirtualMachineScsiDiskDeviceInfo>;
         }
         enum VirtualMachineScsiPassthroughType {
            "disk",
            "tape",
            "printer",
            "processor",
            "worm",
            "cdrom",
            "scanner",
            "optical",
            "media",
            "com",
            "raid",
            "unknown",
         }
         interface VirtualMachineScsiPassthroughInfo extends vimService.vim.VirtualMachineTargetInfo {
            scsiClass: string;
            vendor: string;
            physicalUnitNumber: number;
         }
         interface ArrayOfVirtualMachineScsiPassthroughInfo {
            VirtualMachineScsiPassthroughInfo?: Array<vimService.vim.VirtualMachineScsiPassthroughInfo>;
         }
         interface VirtualMachineSerialInfo extends vimService.vim.VirtualMachineTargetInfo {
         }
         interface ArrayOfVirtualMachineSerialInfo {
            VirtualMachineSerialInfo?: Array<vimService.vim.VirtualMachineSerialInfo>;
         }
         interface VirtualMachineSnapshotInfo extends vimService.vim.DynamicData {
            currentSnapshot?: vimService.vim.ManagedObjectReference;
            rootSnapshotList: Array<vimService.vim.VirtualMachineSnapshotTree>;
         }
         interface VirtualMachineSnapshotTree extends vimService.vim.DynamicData {
            snapshot: vimService.vim.ManagedObjectReference;
            vm: vimService.vim.ManagedObjectReference;
            name: string;
            description: string;
            id?: number;
            createTime: Date;
            state: vimService.vim.VirtualMachinePowerState;
            quiesced: boolean;
            backupManifest?: string;
            childSnapshotList?: Array<vimService.vim.VirtualMachineSnapshotTree>;
            replaySupported?: boolean;
         }
         interface ArrayOfVirtualMachineSnapshotTree {
            VirtualMachineSnapshotTree?: Array<vimService.vim.VirtualMachineSnapshotTree>;
         }
         interface VirtualMachineSoundInfo extends vimService.vim.VirtualMachineTargetInfo {
         }
         interface ArrayOfVirtualMachineSoundInfo {
            VirtualMachineSoundInfo?: Array<vimService.vim.VirtualMachineSoundInfo>;
         }
         interface VirtualMachineSriovDevicePoolInfo extends vimService.vim.DynamicData {
            key: string;
         }
         interface VirtualMachineSriovInfo extends vimService.vim.VirtualMachinePciPassthroughInfo {
            virtualFunction: boolean;
            pnic?: string;
            devicePool?: vimService.vim.VirtualMachineSriovDevicePoolInfo;
         }
         interface ArrayOfVirtualMachineSriovInfo {
            VirtualMachineSriovInfo?: Array<vimService.vim.VirtualMachineSriovInfo>;
         }
         interface VirtualMachineSriovNetworkDevicePoolInfo extends vimService.vim.VirtualMachineSriovDevicePoolInfo {
            switchKey?: string;
            switchUuid?: string;
         }
         interface VirtualMachineUsageOnDatastore extends vimService.vim.DynamicData {
            datastore: vimService.vim.ManagedObjectReference;
            committed: number;
            uncommitted: number;
            unshared: number;
         }
         interface ArrayOfVirtualMachineUsageOnDatastore {
            VirtualMachineUsageOnDatastore?: Array<vimService.vim.VirtualMachineUsageOnDatastore>;
         }
         interface VirtualMachineStorageInfo extends vimService.vim.DynamicData {
            perDatastoreUsage?: Array<vimService.vim.VirtualMachineUsageOnDatastore>;
            timestamp: Date;
         }
         interface VirtualMachineConfigSummary extends vimService.vim.DynamicData {
            name: string;
            template: boolean;
            vmPathName: string;
            memorySizeMB?: number;
            cpuReservation?: number;
            memoryReservation?: number;
            numCpu?: number;
            numEthernetCards?: number;
            numVirtualDisks?: number;
            uuid?: string;
            instanceUuid?: string;
            guestId?: string;
            guestFullName?: string;
            annotation?: string;
            product?: vimService.vim.VAppProductInfo;
            installBootRequired?: boolean;
            ftInfo?: vimService.vim.FaultToleranceConfigInfo;
            managedBy?: vimService.vim.ManagedByInfo;
         }
         interface VirtualMachineQuickStats extends vimService.vim.DynamicData {
            overallCpuUsage?: number;
            overallCpuDemand?: number;
            guestMemoryUsage?: number;
            hostMemoryUsage?: number;
            guestHeartbeatStatus: vimService.vim.ManagedEntityStatus;
            distributedCpuEntitlement?: number;
            distributedMemoryEntitlement?: number;
            staticCpuEntitlement?: number;
            staticMemoryEntitlement?: number;
            privateMemory?: number;
            sharedMemory?: number;
            swappedMemory?: number;
            balloonedMemory?: number;
            consumedOverheadMemory?: number;
            ftLogBandwidth?: number;
            ftSecondaryLatency?: number;
            ftLatencyStatus?: vimService.vim.ManagedEntityStatus;
            compressedMemory?: number;
            uptimeSeconds?: number;
            ssdSwappedMemory?: number;
         }
         interface VirtualMachineGuestSummary extends vimService.vim.DynamicData {
            guestId?: string;
            guestFullName?: string;
            toolsStatus?: vimService.vim.VirtualMachineToolsStatus;
            toolsVersionStatus?: string;
            toolsVersionStatus2?: string;
            toolsRunningStatus?: string;
            hostName?: string;
            ipAddress?: string;
         }
         interface VirtualMachineStorageSummary extends vimService.vim.DynamicData {
            committed: number;
            uncommitted: number;
            unshared: number;
            timestamp: Date;
         }
         interface VirtualMachineSummary extends vimService.vim.DynamicData {
            vm?: vimService.vim.ManagedObjectReference;
            runtime: vimService.vim.VirtualMachineRuntimeInfo;
            guest?: vimService.vim.VirtualMachineGuestSummary;
            config: vimService.vim.VirtualMachineConfigSummary;
            storage?: vimService.vim.VirtualMachineStorageSummary;
            quickStats: vimService.vim.VirtualMachineQuickStats;
            overallStatus: vimService.vim.ManagedEntityStatus;
            customValue?: Array<vimService.vim.CustomFieldValue>;
         }
         interface ArrayOfVirtualMachineSummary {
            VirtualMachineSummary?: Array<vimService.vim.VirtualMachineSummary>;
         }
         enum VirtualMachineTargetInfoConfigurationTag {
            "compliant",
            "clusterWide",
         }
         interface VirtualMachineTargetInfo extends vimService.vim.DynamicData {
            name: string;
            configurationTag?: Array<string>;
         }
         enum UpgradePolicy {
            "manual",
            "upgradeAtPowerCycle",
         }
         interface ToolsConfigInfoToolsLastInstallInfo extends vimService.vim.DynamicData {
            counter: number;
            fault?: vimService.vim.LocalizedMethodFault;
         }
         interface ToolsConfigInfo extends vimService.vim.DynamicData {
            toolsVersion?: number;
            toolsInstallType?: string;
            afterPowerOn?: boolean;
            afterResume?: boolean;
            beforeGuestStandby?: boolean;
            beforeGuestShutdown?: boolean;
            beforeGuestReboot?: boolean;
            toolsUpgradePolicy?: string;
            pendingCustomization?: string;
            customizationKeyId?: vimService.vim.CryptoKeyId;
            syncTimeWithHost?: boolean;
            lastInstallInfo?: vimService.vim.ToolsConfigInfoToolsLastInstallInfo;
         }
         enum VirtualMachineUsbInfoSpeed {
            "low",
            "full",
            "high",
            "superSpeed",
            "unknownSpeed",
         }
         enum VirtualMachineUsbInfoFamily {
            "audio",
            "hid",
            "hid_bootable",
            "physical",
            "communication",
            "imaging",
            "printer",
            "storage",
            "hub",
            "smart_card",
            "security",
            "video",
            "wireless",
            "bluetooth",
            "wusb",
            "pda",
            "vendor_specific",
            "other",
            "unknownFamily",
         }
         interface VirtualMachineUsbInfo extends vimService.vim.VirtualMachineTargetInfo {
            description: string;
            vendor: number;
            product: number;
            physicalPath: string;
            family?: Array<string>;
            speed?: Array<string>;
            summary?: vimService.vim.VirtualMachineSummary;
         }
         interface ArrayOfVirtualMachineUsbInfo {
            VirtualMachineUsbInfo?: Array<vimService.vim.VirtualMachineUsbInfo>;
         }
         interface UsbScanCodeSpecModifierType extends vimService.vim.DynamicData {
            leftControl?: boolean;
            leftShift?: boolean;
            leftAlt?: boolean;
            leftGui?: boolean;
            rightControl?: boolean;
            rightShift?: boolean;
            rightAlt?: boolean;
            rightGui?: boolean;
         }
         interface UsbScanCodeSpecKeyEvent extends vimService.vim.DynamicData {
            usbHidCode: number;
            modifiers?: vimService.vim.UsbScanCodeSpecModifierType;
         }
         interface ArrayOfUsbScanCodeSpecKeyEvent {
            UsbScanCodeSpecKeyEvent?: Array<vimService.vim.UsbScanCodeSpecKeyEvent>;
         }
         interface UsbScanCodeSpec extends vimService.vim.DynamicData {
            keyEvents: Array<vimService.vim.UsbScanCodeSpecKeyEvent>;
         }
         interface VirtualMachineVFlashModuleInfo extends vimService.vim.VirtualMachineTargetInfo {
            vFlashModule: vimService.vim.HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption;
         }
         interface ArrayOfVirtualMachineVFlashModuleInfo {
            VirtualMachineVFlashModuleInfo?: Array<vimService.vim.VirtualMachineVFlashModuleInfo>;
         }
         interface VirtualHardware extends vimService.vim.DynamicData {
            numCPU: number;
            numCoresPerSocket?: number;
            memoryMB: number;
            virtualICH7MPresent?: boolean;
            virtualSMCPresent?: boolean;
            device?: Array<vimService.vim.VirtualDevice>;
         }
         interface VirtualHardwareOption extends vimService.vim.DynamicData {
            hwVersion: number;
            virtualDeviceOption: Array<vimService.vim.VirtualDeviceOption>;
            deviceListReadonly: boolean;
            numCPU: Array<number>;
            numCoresPerSocket?: vimService.vim.IntOption;
            numCpuReadonly: boolean;
            memoryMB: vimService.vim.LongOption;
            numPCIControllers: vimService.vim.IntOption;
            numIDEControllers: vimService.vim.IntOption;
            numUSBControllers: vimService.vim.IntOption;
            numUSBXHCIControllers?: vimService.vim.IntOption;
            numSIOControllers: vimService.vim.IntOption;
            numPS2Controllers: vimService.vim.IntOption;
            licensingLimit?: Array<string>;
            numSupportedWwnPorts?: vimService.vim.IntOption;
            numSupportedWwnNodes?: vimService.vim.IntOption;
            resourceConfigOption?: vimService.vim.ResourceConfigOption;
         }
         interface VirtualMachineImportSpec extends vimService.vim.ImportSpec {
            configSpec: vimService.vim.VirtualMachineConfigSpec;
            resPoolEntity?: vimService.vim.ManagedObjectReference;
         }
         enum VirtualMachineWindowsQuiesceSpecVssBackupContext {
            "ctx_auto",
            "ctx_backup",
            "ctx_file_share_backup",
         }
         interface VirtualMachineWindowsQuiesceSpec extends vimService.vim.VirtualMachineGuestQuiesceSpec {
            vssBackupType?: number;
            vssBootableSystemState?: boolean;
            vssPartialFileSupport?: boolean;
            vssBackupContext?: string;
         }
         interface CheckResult extends vimService.vim.DynamicData {
            vm?: vimService.vim.ManagedObjectReference;
            host?: vimService.vim.ManagedObjectReference;
            warning?: Array<vimService.vim.LocalizedMethodFault>;
            error?: Array<vimService.vim.LocalizedMethodFault>;
         }
         interface ArrayOfCheckResult {
            CheckResult?: Array<vimService.vim.CheckResult>;
         }
         enum CheckTestType {
            "sourceTests",
            "hostTests",
            "resourcePoolTests",
            "datastoreTests",
            "networkTests",
         }
         interface CustomizationIPSettingsIpV6AddressSpec extends vimService.vim.DynamicData {
            ip: Array<vimService.vim.CustomizationIpV6Generator>;
            gateway?: Array<string>;
         }
         enum CustomizationNetBIOSMode {
            "enableNetBIOSViaDhcp",
            "enableNetBIOS",
            "disableNetBIOS",
         }
         interface CustomizationIPSettings extends vimService.vim.DynamicData {
            ip: vimService.vim.CustomizationIpGenerator;
            subnetMask?: string;
            gateway?: Array<string>;
            ipV6Spec?: vimService.vim.CustomizationIPSettingsIpV6AddressSpec;
            dnsServerList?: Array<string>;
            dnsDomain?: string;
            primaryWINS?: string;
            secondaryWINS?: string;
            netBIOS?: vimService.vim.CustomizationNetBIOSMode;
         }
         interface CustomizationSpec extends vimService.vim.DynamicData {
            options?: vimService.vim.CustomizationOptions;
            identity: vimService.vim.CustomizationIdentitySettings;
            globalIPSettings: vimService.vim.CustomizationGlobalIPSettings;
            nicSettingMap?: Array<vimService.vim.CustomizationAdapterMapping>;
            encryptionKey?: Array<number>;
         }
         interface CustomizationName extends vimService.vim.DynamicData {
         }
         interface CustomizationFixedName extends vimService.vim.CustomizationName {
            name: string;
         }
         interface CustomizationPrefixName extends vimService.vim.CustomizationName {
            base: string;
         }
         interface CustomizationVirtualMachineName extends vimService.vim.CustomizationName {
         }
         interface CustomizationUnknownName extends vimService.vim.CustomizationName {
         }
         interface CustomizationCustomName extends vimService.vim.CustomizationName {
            argument?: string;
         }
         interface CustomizationPassword extends vimService.vim.DynamicData {
            value: string;
            plainText: boolean;
         }
         interface CustomizationOptions extends vimService.vim.DynamicData {
         }
         enum CustomizationSysprepRebootOption {
            "reboot",
            "noreboot",
            "shutdown",
         }
         interface CustomizationWinOptions extends vimService.vim.CustomizationOptions {
            changeSID: boolean;
            deleteAccounts: boolean;
            reboot?: vimService.vim.CustomizationSysprepRebootOption;
         }
         interface CustomizationLinuxOptions extends vimService.vim.CustomizationOptions {
         }
         interface CustomizationGuiUnattended extends vimService.vim.DynamicData {
            password?: vimService.vim.CustomizationPassword;
            timeZone: number;
            autoLogon: boolean;
            autoLogonCount: number;
         }
         interface CustomizationUserData extends vimService.vim.DynamicData {
            fullName: string;
            orgName: string;
            computerName: vimService.vim.CustomizationName;
            productId: string;
         }
         interface CustomizationGuiRunOnce extends vimService.vim.DynamicData {
            commandList: Array<string>;
         }
         interface CustomizationIdentification extends vimService.vim.DynamicData {
            joinWorkgroup?: string;
            joinDomain?: string;
            domainAdmin?: string;
            domainAdminPassword?: vimService.vim.CustomizationPassword;
         }
         enum CustomizationLicenseDataMode {
            "perServer",
            "perSeat",
         }
         interface CustomizationLicenseFilePrintData extends vimService.vim.DynamicData {
            autoMode: vimService.vim.CustomizationLicenseDataMode;
            autoUsers?: number;
         }
         interface CustomizationIdentitySettings extends vimService.vim.DynamicData {
         }
         interface CustomizationSysprepText extends vimService.vim.CustomizationIdentitySettings {
            value: string;
         }
         interface CustomizationSysprep extends vimService.vim.CustomizationIdentitySettings {
            guiUnattended: vimService.vim.CustomizationGuiUnattended;
            userData: vimService.vim.CustomizationUserData;
            guiRunOnce?: vimService.vim.CustomizationGuiRunOnce;
            identification: vimService.vim.CustomizationIdentification;
            licenseFilePrintData?: vimService.vim.CustomizationLicenseFilePrintData;
         }
         interface CustomizationLinuxPrep extends vimService.vim.CustomizationIdentitySettings {
            hostName: vimService.vim.CustomizationName;
            domain: string;
            timeZone?: string;
            hwClockUTC?: boolean;
         }
         interface CustomizationGlobalIPSettings extends vimService.vim.DynamicData {
            dnsSuffixList?: Array<string>;
            dnsServerList?: Array<string>;
         }
         interface CustomizationIpGenerator extends vimService.vim.DynamicData {
         }
         interface CustomizationDhcpIpGenerator extends vimService.vim.CustomizationIpGenerator {
         }
         interface CustomizationFixedIp extends vimService.vim.CustomizationIpGenerator {
            ipAddress: string;
         }
         interface CustomizationUnknownIpGenerator extends vimService.vim.CustomizationIpGenerator {
         }
         interface CustomizationCustomIpGenerator extends vimService.vim.CustomizationIpGenerator {
            argument?: string;
         }
         interface CustomizationIpV6Generator extends vimService.vim.DynamicData {
         }
         interface ArrayOfCustomizationIpV6Generator {
            CustomizationIpV6Generator?: Array<vimService.vim.CustomizationIpV6Generator>;
         }
         interface CustomizationDhcpIpV6Generator extends vimService.vim.CustomizationIpV6Generator {
         }
         interface CustomizationStatelessIpV6Generator extends vimService.vim.CustomizationIpV6Generator {
         }
         interface CustomizationFixedIpV6 extends vimService.vim.CustomizationIpV6Generator {
            ipAddress: string;
            subnetMask: number;
         }
         interface CustomizationAutoIpV6Generator extends vimService.vim.CustomizationIpV6Generator {
         }
         interface CustomizationUnknownIpV6Generator extends vimService.vim.CustomizationIpV6Generator {
         }
         interface CustomizationCustomIpV6Generator extends vimService.vim.CustomizationIpV6Generator {
            argument?: string;
         }
         interface CustomizationAdapterMapping extends vimService.vim.DynamicData {
            macAddress?: string;
            adapter: vimService.vim.CustomizationIPSettings;
         }
         interface ArrayOfCustomizationAdapterMapping {
            CustomizationAdapterMapping?: Array<vimService.vim.CustomizationAdapterMapping>;
         }
         interface HostDiskMappingPartitionInfo extends vimService.vim.DynamicData {
            name: string;
            fileSystem: string;
            capacityInKb: number;
         }
         interface HostDiskMappingInfo extends vimService.vim.DynamicData {
            physicalPartition?: vimService.vim.HostDiskMappingPartitionInfo;
            name: string;
            exclusive?: boolean;
         }
         interface HostDiskMappingPartitionOption extends vimService.vim.DynamicData {
            name: string;
            fileSystem: string;
            capacityInKb: number;
         }
         interface ArrayOfHostDiskMappingPartitionOption {
            HostDiskMappingPartitionOption?: Array<vimService.vim.HostDiskMappingPartitionOption>;
         }
         interface HostDiskMappingOption extends vimService.vim.DynamicData {
            physicalPartition?: Array<vimService.vim.HostDiskMappingPartitionOption>;
            name: string;
         }
         interface ParaVirtualSCSIController extends vimService.vim.VirtualSCSIController {
         }
         interface ParaVirtualSCSIControllerOption extends vimService.vim.VirtualSCSIControllerOption {
         }
         interface VirtualAHCIController extends vimService.vim.VirtualSATAController {
         }
         interface VirtualAHCIControllerOption extends vimService.vim.VirtualSATAControllerOption {
         }
         interface VirtualBusLogicController extends vimService.vim.VirtualSCSIController {
         }
         interface VirtualBusLogicControllerOption extends vimService.vim.VirtualSCSIControllerOption {
         }
         interface VirtualCdromIsoBackingInfo extends vimService.vim.VirtualDeviceFileBackingInfo {
         }
         interface VirtualCdromPassthroughBackingInfo extends vimService.vim.VirtualDeviceDeviceBackingInfo {
            exclusive: boolean;
         }
         interface VirtualCdromRemotePassthroughBackingInfo extends vimService.vim.VirtualDeviceRemoteDeviceBackingInfo {
            exclusive: boolean;
         }
         interface VirtualCdromAtapiBackingInfo extends vimService.vim.VirtualDeviceDeviceBackingInfo {
         }
         interface VirtualCdromRemoteAtapiBackingInfo extends vimService.vim.VirtualDeviceRemoteDeviceBackingInfo {
         }
         interface VirtualCdrom extends vimService.vim.VirtualDevice {
         }
         interface VirtualCdromIsoBackingOption extends vimService.vim.VirtualDeviceFileBackingOption {
         }
         interface VirtualCdromPassthroughBackingOption extends vimService.vim.VirtualDeviceDeviceBackingOption {
            exclusive: vimService.vim.BoolOption;
         }
         interface VirtualCdromRemotePassthroughBackingOption extends vimService.vim.VirtualDeviceRemoteDeviceBackingOption {
            exclusive: vimService.vim.BoolOption;
         }
         interface VirtualCdromAtapiBackingOption extends vimService.vim.VirtualDeviceDeviceBackingOption {
         }
         interface VirtualCdromRemoteAtapiBackingOption extends vimService.vim.VirtualDeviceDeviceBackingOption {
         }
         interface VirtualCdromOption extends vimService.vim.VirtualDeviceOption {
         }
         interface VirtualController extends vimService.vim.VirtualDevice {
            busNumber: number;
            device?: Array<number>;
         }
         interface VirtualControllerOption extends vimService.vim.VirtualDeviceOption {
            devices: vimService.vim.IntOption;
            supportedDevice?: Array<string>;
         }
         interface VirtualDeviceBackingInfo extends vimService.vim.DynamicData {
         }
         interface VirtualDeviceFileBackingInfo extends vimService.vim.VirtualDeviceBackingInfo {
            fileName: string;
            datastore?: vimService.vim.ManagedObjectReference;
            backingObjectId?: string;
         }
         interface VirtualDeviceDeviceBackingInfo extends vimService.vim.VirtualDeviceBackingInfo {
            deviceName: string;
            useAutoDetect?: boolean;
         }
         interface VirtualDeviceRemoteDeviceBackingInfo extends vimService.vim.VirtualDeviceBackingInfo {
            deviceName: string;
            useAutoDetect?: boolean;
         }
         interface VirtualDevicePipeBackingInfo extends vimService.vim.VirtualDeviceBackingInfo {
            pipeName: string;
         }
         interface VirtualDeviceURIBackingInfo extends vimService.vim.VirtualDeviceBackingInfo {
            serviceURI: string;
            direction: string;
            proxyURI?: string;
         }
         enum VirtualDeviceConnectInfoStatus {
            "ok",
            "recoverableError",
            "unrecoverableError",
            "untried",
         }
         interface VirtualDeviceConnectInfo extends vimService.vim.DynamicData {
            startConnected: boolean;
            allowGuestControl: boolean;
            connected: boolean;
            status?: string;
         }
         interface VirtualDeviceBusSlotInfo extends vimService.vim.DynamicData {
         }
         interface VirtualDevicePciBusSlotInfo extends vimService.vim.VirtualDeviceBusSlotInfo {
            pciSlotNumber: number;
         }
         interface VirtualDevice extends vimService.vim.DynamicData {
            key: number;
            deviceInfo?: vimService.vim.Description;
            backing?: vimService.vim.VirtualDeviceBackingInfo;
            connectable?: vimService.vim.VirtualDeviceConnectInfo;
            slotInfo?: vimService.vim.VirtualDeviceBusSlotInfo;
            controllerKey?: number;
            unitNumber?: number;
         }
         interface ArrayOfVirtualDevice {
            VirtualDevice?: Array<vimService.vim.VirtualDevice>;
         }
         interface VirtualDeviceBackingOption extends vimService.vim.DynamicData {
            type: string;
         }
         interface ArrayOfVirtualDeviceBackingOption {
            VirtualDeviceBackingOption?: Array<vimService.vim.VirtualDeviceBackingOption>;
         }
         enum VirtualDeviceFileExtension {
            "iso",
            "flp",
            "vmdk",
            "dsk",
            "rdm",
         }
         interface VirtualDeviceFileBackingOption extends vimService.vim.VirtualDeviceBackingOption {
            fileNameExtensions?: vimService.vim.ChoiceOption;
         }
         interface VirtualDeviceDeviceBackingOption extends vimService.vim.VirtualDeviceBackingOption {
            autoDetectAvailable: vimService.vim.BoolOption;
         }
         interface VirtualDeviceRemoteDeviceBackingOption extends vimService.vim.VirtualDeviceBackingOption {
            autoDetectAvailable: vimService.vim.BoolOption;
         }
         interface VirtualDevicePipeBackingOption extends vimService.vim.VirtualDeviceBackingOption {
         }
         enum VirtualDeviceURIBackingOptionDirection {
            "server",
            "client",
         }
         interface VirtualDeviceURIBackingOption extends vimService.vim.VirtualDeviceBackingOption {
            directions: vimService.vim.ChoiceOption;
         }
         interface VirtualDeviceConnectOption extends vimService.vim.DynamicData {
            startConnected: vimService.vim.BoolOption;
            allowGuestControl: vimService.vim.BoolOption;
         }
         interface VirtualDeviceBusSlotOption extends vimService.vim.DynamicData {
            type: string;
         }
         interface VirtualDeviceOption extends vimService.vim.DynamicData {
            type: string;
            connectOption?: vimService.vim.VirtualDeviceConnectOption;
            busSlotOption?: vimService.vim.VirtualDeviceBusSlotOption;
            controllerType?: string;
            autoAssignController?: vimService.vim.BoolOption;
            backingOption?: Array<vimService.vim.VirtualDeviceBackingOption>;
            defaultBackingOptionIndex?: number;
            licensingLimit?: Array<string>;
            deprecated: boolean;
            plugAndPlay: boolean;
            hotRemoveSupported?: boolean;
         }
         interface ArrayOfVirtualDeviceOption {
            VirtualDeviceOption?: Array<vimService.vim.VirtualDeviceOption>;
         }
         enum VirtualDeviceConfigSpecOperation {
            "add",
            "remove",
            "edit",
         }
         enum VirtualDeviceConfigSpecFileOperation {
            "create",
            "destroy",
            "replace",
         }
         interface VirtualDeviceConfigSpecBackingSpec extends vimService.vim.DynamicData {
            parent?: vimService.vim.VirtualDeviceConfigSpecBackingSpec;
            crypto?: vimService.vim.CryptoSpec;
         }
         interface VirtualDeviceConfigSpec extends vimService.vim.DynamicData {
            operation?: vimService.vim.VirtualDeviceConfigSpecOperation;
            fileOperation?: vimService.vim.VirtualDeviceConfigSpecFileOperation;
            device: vimService.vim.VirtualDevice;
            profile?: Array<vimService.vim.VirtualMachineProfileSpec>;
            backing?: vimService.vim.VirtualDeviceConfigSpecBackingSpec;
         }
         interface ArrayOfVirtualDeviceConfigSpec {
            VirtualDeviceConfigSpec?: Array<vimService.vim.VirtualDeviceConfigSpec>;
         }
         enum VirtualDiskDeltaDiskFormat {
            "redoLogFormat",
            "nativeFormat",
            "seSparseFormat",
         }
         enum VirtualDiskDeltaDiskFormatVariant {
            "vmfsSparseVariant",
            "vsanSparseVariant",
         }
         enum VirtualDiskSharing {
            "sharingNone",
            "sharingMultiWriter",
         }
         interface VirtualDiskSparseVer1BackingInfo extends vimService.vim.VirtualDeviceFileBackingInfo {
            diskMode: string;
            split?: boolean;
            writeThrough?: boolean;
            spaceUsedInKB?: number;
            contentId?: string;
            parent?: vimService.vim.VirtualDiskSparseVer1BackingInfo;
         }
         interface VirtualDiskSparseVer2BackingInfo extends vimService.vim.VirtualDeviceFileBackingInfo {
            diskMode: string;
            split?: boolean;
            writeThrough?: boolean;
            spaceUsedInKB?: number;
            uuid?: string;
            contentId?: string;
            changeId?: string;
            parent?: vimService.vim.VirtualDiskSparseVer2BackingInfo;
            keyId?: vimService.vim.CryptoKeyId;
         }
         interface VirtualDiskFlatVer1BackingInfo extends vimService.vim.VirtualDeviceFileBackingInfo {
            diskMode: string;
            split?: boolean;
            writeThrough?: boolean;
            contentId?: string;
            parent?: vimService.vim.VirtualDiskFlatVer1BackingInfo;
         }
         interface VirtualDiskFlatVer2BackingInfo extends vimService.vim.VirtualDeviceFileBackingInfo {
            diskMode: string;
            split?: boolean;
            writeThrough?: boolean;
            thinProvisioned?: boolean;
            eagerlyScrub?: boolean;
            uuid?: string;
            contentId?: string;
            changeId?: string;
            parent?: vimService.vim.VirtualDiskFlatVer2BackingInfo;
            deltaDiskFormat?: string;
            digestEnabled?: boolean;
            deltaGrainSize?: number;
            deltaDiskFormatVariant?: string;
            sharing?: string;
            keyId?: vimService.vim.CryptoKeyId;
         }
         interface VirtualDiskSeSparseBackingInfo extends vimService.vim.VirtualDeviceFileBackingInfo {
            diskMode: string;
            writeThrough?: boolean;
            uuid?: string;
            contentId?: string;
            changeId?: string;
            parent?: vimService.vim.VirtualDiskSeSparseBackingInfo;
            deltaDiskFormat?: string;
            digestEnabled?: boolean;
            grainSize?: number;
            keyId?: vimService.vim.CryptoKeyId;
         }
         interface VirtualDiskRawDiskVer2BackingInfo extends vimService.vim.VirtualDeviceDeviceBackingInfo {
            descriptorFileName: string;
            uuid?: string;
            changeId?: string;
            sharing?: string;
         }
         interface VirtualDiskPartitionedRawDiskVer2BackingInfo extends vimService.vim.VirtualDiskRawDiskVer2BackingInfo {
            partition: Array<number>;
         }
         interface VirtualDiskRawDiskMappingVer1BackingInfo extends vimService.vim.VirtualDeviceFileBackingInfo {
            lunUuid?: string;
            deviceName?: string;
            compatibilityMode?: string;
            diskMode?: string;
            uuid?: string;
            contentId?: string;
            changeId?: string;
            parent?: vimService.vim.VirtualDiskRawDiskMappingVer1BackingInfo;
            sharing?: string;
         }
         enum VirtualDiskVFlashCacheConfigInfoCacheConsistencyType {
            "strong",
            "weak",
         }
         enum VirtualDiskVFlashCacheConfigInfoCacheMode {
            "write_thru",
            "write_back",
         }
         interface VirtualDiskVFlashCacheConfigInfo extends vimService.vim.DynamicData {
            vFlashModule?: string;
            reservationInMB?: number;
            cacheConsistencyType?: string;
            cacheMode?: string;
            blockSizeInKB?: number;
         }
         interface VirtualDisk extends vimService.vim.VirtualDevice {
            capacityInKB: number;
            capacityInBytes?: number;
            shares?: vimService.vim.SharesInfo;
            storageIOAllocation?: vimService.vim.StorageIOAllocationInfo;
            diskObjectId?: string;
            vFlashCacheConfigInfo?: vimService.vim.VirtualDiskVFlashCacheConfigInfo;
            iofilter?: Array<string>;
            vDiskId?: string;
         }
         interface ArrayOfVirtualDisk {
            VirtualDisk?: Array<vimService.vim.VirtualDisk>;
         }
         interface VirtualDiskId extends vimService.vim.DynamicData {
            vm: vimService.vim.ManagedObjectReference;
            diskId: number;
         }
         interface ArrayOfVirtualDiskId {
            VirtualDiskId?: Array<vimService.vim.VirtualDiskId>;
         }
         enum VirtualDiskMode {
            "persistent",
            "nonpersistent",
            "undoable",
            "independent_persistent",
            "independent_nonpersistent",
            "append",
         }
         enum VirtualDiskCompatibilityMode {
            "virtualMode",
            "physicalMode",
         }
         interface VirtualDiskSparseVer1BackingOption extends vimService.vim.VirtualDeviceFileBackingOption {
            diskModes: vimService.vim.ChoiceOption;
            split: vimService.vim.BoolOption;
            writeThrough: vimService.vim.BoolOption;
            growable: boolean;
         }
         interface VirtualDiskSparseVer2BackingOption extends vimService.vim.VirtualDeviceFileBackingOption {
            diskMode: vimService.vim.ChoiceOption;
            split: vimService.vim.BoolOption;
            writeThrough: vimService.vim.BoolOption;
            growable: boolean;
            hotGrowable: boolean;
            uuid: boolean;
         }
         interface VirtualDiskFlatVer1BackingOption extends vimService.vim.VirtualDeviceFileBackingOption {
            diskMode: vimService.vim.ChoiceOption;
            split: vimService.vim.BoolOption;
            writeThrough: vimService.vim.BoolOption;
            growable: boolean;
         }
         interface VirtualDiskDeltaDiskFormatsSupported extends vimService.vim.DynamicData {
            datastoreType: string;
            deltaDiskFormat: vimService.vim.ChoiceOption;
         }
         interface ArrayOfVirtualDiskDeltaDiskFormatsSupported {
            VirtualDiskDeltaDiskFormatsSupported?: Array<vimService.vim.VirtualDiskDeltaDiskFormatsSupported>;
         }
         interface VirtualDiskFlatVer2BackingOption extends vimService.vim.VirtualDeviceFileBackingOption {
            diskMode: vimService.vim.ChoiceOption;
            split: vimService.vim.BoolOption;
            writeThrough: vimService.vim.BoolOption;
            growable: boolean;
            hotGrowable: boolean;
            uuid: boolean;
            thinProvisioned?: vimService.vim.BoolOption;
            eagerlyScrub?: vimService.vim.BoolOption;
            deltaDiskFormat?: vimService.vim.ChoiceOption;
            deltaDiskFormatsSupported?: Array<vimService.vim.VirtualDiskDeltaDiskFormatsSupported>;
         }
         interface VirtualDiskSeSparseBackingOption extends vimService.vim.VirtualDeviceFileBackingOption {
            diskMode: vimService.vim.ChoiceOption;
            writeThrough: vimService.vim.BoolOption;
            growable: boolean;
            hotGrowable: boolean;
            uuid: boolean;
            deltaDiskFormatsSupported: Array<vimService.vim.VirtualDiskDeltaDiskFormatsSupported>;
         }
         interface VirtualDiskRawDiskVer2BackingOption extends vimService.vim.VirtualDeviceDeviceBackingOption {
            descriptorFileNameExtensions: vimService.vim.ChoiceOption;
            uuid: boolean;
         }
         interface VirtualDiskPartitionedRawDiskVer2BackingOption extends vimService.vim.VirtualDiskRawDiskVer2BackingOption {
         }
         interface VirtualDiskRawDiskMappingVer1BackingOption extends vimService.vim.VirtualDeviceDeviceBackingOption {
            descriptorFileNameExtensions?: vimService.vim.ChoiceOption;
            compatibilityMode: vimService.vim.ChoiceOption;
            diskMode: vimService.vim.ChoiceOption;
            uuid: boolean;
         }
         interface VirtualDiskOptionVFlashCacheConfigOption extends vimService.vim.DynamicData {
            cacheConsistencyType: vimService.vim.ChoiceOption;
            cacheMode: vimService.vim.ChoiceOption;
            reservationInMB: vimService.vim.LongOption;
            blockSizeInKB: vimService.vim.LongOption;
         }
         interface VirtualDiskOption extends vimService.vim.VirtualDeviceOption {
            capacityInKB: vimService.vim.LongOption;
            ioAllocationOption?: vimService.vim.StorageIOAllocationOption;
            vFlashCacheConfigOption?: vimService.vim.VirtualDiskOptionVFlashCacheConfigOption;
         }
         interface VirtualDiskConfigSpec extends vimService.vim.VirtualDeviceConfigSpec {
            diskMoveType?: string;
            migrateCache?: boolean;
         }
         interface VirtualE1000 extends vimService.vim.VirtualEthernetCard {
         }
         interface VirtualE1000Option extends vimService.vim.VirtualEthernetCardOption {
         }
         interface VirtualE1000e extends vimService.vim.VirtualEthernetCard {
         }
         interface VirtualE1000eOption extends vimService.vim.VirtualEthernetCardOption {
         }
         interface VirtualEnsoniq1371 extends vimService.vim.VirtualSoundCard {
         }
         interface VirtualEnsoniq1371Option extends vimService.vim.VirtualSoundCardOption {
         }
         interface VirtualEthernetCardNetworkBackingInfo extends vimService.vim.VirtualDeviceDeviceBackingInfo {
            network?: vimService.vim.ManagedObjectReference;
            inPassthroughMode?: boolean;
         }
         interface VirtualEthernetCardLegacyNetworkBackingInfo extends vimService.vim.VirtualDeviceDeviceBackingInfo {
         }
         interface VirtualEthernetCardDistributedVirtualPortBackingInfo extends vimService.vim.VirtualDeviceBackingInfo {
            port: vimService.vim.DistributedVirtualSwitchPortConnection;
         }
         interface VirtualEthernetCardOpaqueNetworkBackingInfo extends vimService.vim.VirtualDeviceBackingInfo {
            opaqueNetworkId: string;
            opaqueNetworkType: string;
         }
         interface VirtualEthernetCardResourceAllocation extends vimService.vim.DynamicData {
            reservation?: number;
            share: vimService.vim.SharesInfo;
            limit?: number;
         }
         interface VirtualEthernetCard extends vimService.vim.VirtualDevice {
            addressType?: string;
            macAddress?: string;
            wakeOnLanEnabled?: boolean;
            resourceAllocation?: vimService.vim.VirtualEthernetCardResourceAllocation;
            externalId?: string;
            uptCompatibilityEnabled?: boolean;
         }
         interface VirtualEthernetCardNetworkBackingOption extends vimService.vim.VirtualDeviceDeviceBackingOption {
         }
         interface VirtualEthernetCardOpaqueNetworkBackingOption extends vimService.vim.VirtualDeviceBackingOption {
         }
         enum VirtualEthernetCardLegacyNetworkDeviceName {
            "bridged",
            "nat",
            "hostonly",
         }
         interface VirtualEthernetCardLegacyNetworkBackingOption extends vimService.vim.VirtualDeviceDeviceBackingOption {
         }
         interface VirtualEthernetCardDVPortBackingOption extends vimService.vim.VirtualDeviceBackingOption {
         }
         enum VirtualEthernetCardMacType {
            "manual",
            "generated",
            "assigned",
         }
         interface VirtualEthernetCardOption extends vimService.vim.VirtualDeviceOption {
            supportedOUI: vimService.vim.ChoiceOption;
            macType: vimService.vim.ChoiceOption;
            wakeOnLanEnabled: vimService.vim.BoolOption;
            vmDirectPathGen2Supported?: boolean;
            uptCompatibilityEnabled?: vimService.vim.BoolOption;
         }
         interface VirtualFloppyImageBackingInfo extends vimService.vim.VirtualDeviceFileBackingInfo {
         }
         interface VirtualFloppyDeviceBackingInfo extends vimService.vim.VirtualDeviceDeviceBackingInfo {
         }
         interface VirtualFloppyRemoteDeviceBackingInfo extends vimService.vim.VirtualDeviceRemoteDeviceBackingInfo {
         }
         interface VirtualFloppy extends vimService.vim.VirtualDevice {
         }
         interface VirtualFloppyImageBackingOption extends vimService.vim.VirtualDeviceFileBackingOption {
         }
         interface VirtualFloppyDeviceBackingOption extends vimService.vim.VirtualDeviceDeviceBackingOption {
         }
         interface VirtualFloppyRemoteDeviceBackingOption extends vimService.vim.VirtualDeviceRemoteDeviceBackingOption {
         }
         interface VirtualFloppyOption extends vimService.vim.VirtualDeviceOption {
         }
         interface VirtualHdAudioCard extends vimService.vim.VirtualSoundCard {
         }
         interface VirtualHdAudioCardOption extends vimService.vim.VirtualSoundCardOption {
         }
         interface VirtualIDEController extends vimService.vim.VirtualController {
         }
         interface VirtualIDEControllerOption extends vimService.vim.VirtualControllerOption {
            numIDEDisks: vimService.vim.IntOption;
            numIDECdroms: vimService.vim.IntOption;
         }
         interface VirtualKeyboard extends vimService.vim.VirtualDevice {
         }
         interface VirtualKeyboardOption extends vimService.vim.VirtualDeviceOption {
         }
         interface VirtualLsiLogicController extends vimService.vim.VirtualSCSIController {
         }
         interface VirtualLsiLogicControllerOption extends vimService.vim.VirtualSCSIControllerOption {
         }
         interface VirtualLsiLogicSASController extends vimService.vim.VirtualSCSIController {
         }
         interface VirtualLsiLogicSASControllerOption extends vimService.vim.VirtualSCSIControllerOption {
         }
         interface VirtualNVMEController extends vimService.vim.VirtualController {
         }
         interface VirtualNVMEControllerOption extends vimService.vim.VirtualControllerOption {
            numNVMEDisks: vimService.vim.IntOption;
         }
         interface VirtualPCIController extends vimService.vim.VirtualController {
         }
         interface VirtualPCIControllerOption extends vimService.vim.VirtualControllerOption {
            numSCSIControllers: vimService.vim.IntOption;
            numEthernetCards: vimService.vim.IntOption;
            numVideoCards: vimService.vim.IntOption;
            numSoundCards: vimService.vim.IntOption;
            numVmiRoms: vimService.vim.IntOption;
            numVmciDevices?: vimService.vim.IntOption;
            numPCIPassthroughDevices?: vimService.vim.IntOption;
            numSasSCSIControllers?: vimService.vim.IntOption;
            numVmxnet3EthernetCards?: vimService.vim.IntOption;
            numParaVirtualSCSIControllers?: vimService.vim.IntOption;
            numSATAControllers?: vimService.vim.IntOption;
            numNVMEControllers?: vimService.vim.IntOption;
         }
         interface VirtualPCIPassthroughDeviceBackingInfo extends vimService.vim.VirtualDeviceDeviceBackingInfo {
            id: string;
            deviceId: string;
            systemId: string;
            vendorId: number;
         }
         interface VirtualPCIPassthroughPluginBackingInfo extends vimService.vim.VirtualDeviceBackingInfo {
         }
         interface VirtualPCIPassthroughVmiopBackingInfo extends vimService.vim.VirtualPCIPassthroughPluginBackingInfo {
            vgpu?: string;
         }
         interface VirtualPCIPassthrough extends vimService.vim.VirtualDevice {
         }
         interface VirtualPCIPassthroughDeviceBackingOption extends vimService.vim.VirtualDeviceDeviceBackingOption {
         }
         interface VirtualPCIPassthroughPluginBackingOption extends vimService.vim.VirtualDeviceBackingOption {
         }
         interface VirtualPCIPassthroughVmiopBackingOption extends vimService.vim.VirtualPCIPassthroughPluginBackingOption {
            vgpu: vimService.vim.StringOption;
            maxInstances: number;
         }
         interface VirtualPCIPassthroughOption extends vimService.vim.VirtualDeviceOption {
         }
         interface VirtualPCNet32 extends vimService.vim.VirtualEthernetCard {
         }
         interface VirtualPCNet32Option extends vimService.vim.VirtualEthernetCardOption {
            supportsMorphing: boolean;
         }
         interface VirtualPS2Controller extends vimService.vim.VirtualController {
         }
         interface VirtualPS2ControllerOption extends vimService.vim.VirtualControllerOption {
            numKeyboards: vimService.vim.IntOption;
            numPointingDevices: vimService.vim.IntOption;
         }
         interface VirtualParallelPortFileBackingInfo extends vimService.vim.VirtualDeviceFileBackingInfo {
         }
         interface VirtualParallelPortDeviceBackingInfo extends vimService.vim.VirtualDeviceDeviceBackingInfo {
         }
         interface VirtualParallelPort extends vimService.vim.VirtualDevice {
         }
         interface VirtualParallelPortFileBackingOption extends vimService.vim.VirtualDeviceFileBackingOption {
         }
         interface VirtualParallelPortDeviceBackingOption extends vimService.vim.VirtualDeviceDeviceBackingOption {
         }
         interface VirtualParallelPortOption extends vimService.vim.VirtualDeviceOption {
         }
         interface VirtualPointingDeviceDeviceBackingInfo extends vimService.vim.VirtualDeviceDeviceBackingInfo {
            hostPointingDevice: string;
         }
         interface VirtualPointingDevice extends vimService.vim.VirtualDevice {
         }
         enum VirtualPointingDeviceHostChoice {
            "autodetect",
            "intellimouseExplorer",
            "intellimousePs2",
            "logitechMouseman",
            "microsoft_serial",
            "mouseSystems",
            "mousemanSerial",
            "ps2",
         }
         interface VirtualPointingDeviceBackingOption extends vimService.vim.VirtualDeviceDeviceBackingOption {
            hostPointingDevice: vimService.vim.ChoiceOption;
         }
         interface VirtualPointingDeviceOption extends vimService.vim.VirtualDeviceOption {
         }
         interface VirtualSATAController extends vimService.vim.VirtualController {
         }
         interface VirtualSATAControllerOption extends vimService.vim.VirtualControllerOption {
            numSATADisks: vimService.vim.IntOption;
            numSATACdroms: vimService.vim.IntOption;
         }
         enum VirtualSCSISharing {
            "noSharing",
            "virtualSharing",
            "physicalSharing",
         }
         interface ArrayOfVirtualSCSISharing {
            VirtualSCSISharing?: Array<vimService.vim.VirtualSCSISharing>;
         }
         interface VirtualSCSIController extends vimService.vim.VirtualController {
            hotAddRemove?: boolean;
            sharedBus: vimService.vim.VirtualSCSISharing;
            scsiCtlrUnitNumber?: number;
         }
         interface VirtualSCSIControllerOption extends vimService.vim.VirtualControllerOption {
            numSCSIDisks: vimService.vim.IntOption;
            numSCSICdroms: vimService.vim.IntOption;
            numSCSIPassthrough: vimService.vim.IntOption;
            sharing: Array<vimService.vim.VirtualSCSISharing>;
            defaultSharedIndex: number;
            hotAddRemove: vimService.vim.BoolOption;
            scsiCtlrUnitNumber: number;
         }
         interface VirtualSCSIPassthroughDeviceBackingInfo extends vimService.vim.VirtualDeviceDeviceBackingInfo {
         }
         interface VirtualSCSIPassthrough extends vimService.vim.VirtualDevice {
         }
         interface VirtualSCSIPassthroughDeviceBackingOption extends vimService.vim.VirtualDeviceDeviceBackingOption {
         }
         interface VirtualSCSIPassthroughOption extends vimService.vim.VirtualDeviceOption {
         }
         interface VirtualSIOController extends vimService.vim.VirtualController {
         }
         interface VirtualSIOControllerOption extends vimService.vim.VirtualControllerOption {
            numFloppyDrives: vimService.vim.IntOption;
            numSerialPorts: vimService.vim.IntOption;
            numParallelPorts: vimService.vim.IntOption;
         }
         interface VirtualSerialPortFileBackingInfo extends vimService.vim.VirtualDeviceFileBackingInfo {
         }
         interface VirtualSerialPortDeviceBackingInfo extends vimService.vim.VirtualDeviceDeviceBackingInfo {
         }
         interface VirtualSerialPortPipeBackingInfo extends vimService.vim.VirtualDevicePipeBackingInfo {
            endpoint: string;
            noRxLoss?: boolean;
         }
         interface VirtualSerialPortURIBackingInfo extends vimService.vim.VirtualDeviceURIBackingInfo {
         }
         interface VirtualSerialPortThinPrintBackingInfo extends vimService.vim.VirtualDeviceBackingInfo {
         }
         interface VirtualSerialPort extends vimService.vim.VirtualDevice {
            yieldOnPoll: boolean;
         }
         enum VirtualSerialPortEndPoint {
            "client",
            "server",
         }
         interface VirtualSerialPortFileBackingOption extends vimService.vim.VirtualDeviceFileBackingOption {
         }
         interface VirtualSerialPortDeviceBackingOption extends vimService.vim.VirtualDeviceDeviceBackingOption {
         }
         interface VirtualSerialPortPipeBackingOption extends vimService.vim.VirtualDevicePipeBackingOption {
            endpoint: vimService.vim.ChoiceOption;
            noRxLoss: vimService.vim.BoolOption;
         }
         interface VirtualSerialPortURIBackingOption extends vimService.vim.VirtualDeviceURIBackingOption {
         }
         interface VirtualSerialPortThinPrintBackingOption extends vimService.vim.VirtualDeviceBackingOption {
         }
         interface VirtualSerialPortOption extends vimService.vim.VirtualDeviceOption {
            yieldOnPoll: vimService.vim.BoolOption;
         }
         interface VirtualSoundBlaster16 extends vimService.vim.VirtualSoundCard {
         }
         interface VirtualSoundBlaster16Option extends vimService.vim.VirtualSoundCardOption {
         }
         interface VirtualSoundCardDeviceBackingInfo extends vimService.vim.VirtualDeviceDeviceBackingInfo {
         }
         interface VirtualSoundCard extends vimService.vim.VirtualDevice {
         }
         interface VirtualSoundCardDeviceBackingOption extends vimService.vim.VirtualDeviceDeviceBackingOption {
         }
         interface VirtualSoundCardOption extends vimService.vim.VirtualDeviceOption {
         }
         interface VirtualSriovEthernetCardSriovBackingInfo extends vimService.vim.VirtualDeviceBackingInfo {
            physicalFunctionBacking?: vimService.vim.VirtualPCIPassthroughDeviceBackingInfo;
            virtualFunctionBacking?: vimService.vim.VirtualPCIPassthroughDeviceBackingInfo;
            virtualFunctionIndex?: number;
         }
         interface VirtualSriovEthernetCard extends vimService.vim.VirtualEthernetCard {
            allowGuestOSMtuChange?: boolean;
            sriovBacking?: vimService.vim.VirtualSriovEthernetCardSriovBackingInfo;
         }
         interface VirtualSriovEthernetCardSriovBackingOption extends vimService.vim.VirtualDeviceBackingOption {
         }
         interface VirtualSriovEthernetCardOption extends vimService.vim.VirtualEthernetCardOption {
         }
         interface VirtualUSBUSBBackingInfo extends vimService.vim.VirtualDeviceDeviceBackingInfo {
         }
         interface VirtualUSBRemoteHostBackingInfo extends vimService.vim.VirtualDeviceDeviceBackingInfo {
            hostname: string;
         }
         interface VirtualUSBRemoteClientBackingInfo extends vimService.vim.VirtualDeviceRemoteDeviceBackingInfo {
            hostname: string;
         }
         interface VirtualUSB extends vimService.vim.VirtualDevice {
            connected: boolean;
            vendor?: number;
            product?: number;
            family?: Array<string>;
            speed?: Array<string>;
         }
         interface VirtualUSBControllerPciBusSlotInfo extends vimService.vim.VirtualDevicePciBusSlotInfo {
            ehciPciSlotNumber?: number;
         }
         interface VirtualUSBController extends vimService.vim.VirtualController {
            autoConnectDevices?: boolean;
            ehciEnabled?: boolean;
         }
         interface VirtualUSBControllerOption extends vimService.vim.VirtualControllerOption {
            autoConnectDevices: vimService.vim.BoolOption;
            ehciSupported: vimService.vim.BoolOption;
            supportedSpeeds?: Array<string>;
         }
         interface VirtualUSBUSBBackingOption extends vimService.vim.VirtualDeviceDeviceBackingOption {
         }
         interface VirtualUSBRemoteHostBackingOption extends vimService.vim.VirtualDeviceDeviceBackingOption {
         }
         interface VirtualUSBRemoteClientBackingOption extends vimService.vim.VirtualDeviceRemoteDeviceBackingOption {
         }
         interface VirtualUSBOption extends vimService.vim.VirtualDeviceOption {
         }
         interface VirtualUSBXHCIController extends vimService.vim.VirtualController {
            autoConnectDevices?: boolean;
         }
         interface VirtualUSBXHCIControllerOption extends vimService.vim.VirtualControllerOption {
            autoConnectDevices: vimService.vim.BoolOption;
            supportedSpeeds: Array<string>;
         }
         enum VirtualMachineVMCIDeviceAction {
            "allow",
            "deny",
         }
         enum VirtualMachineVMCIDeviceProtocol {
            "hypervisor",
            "doorbell",
            "queuepair",
            "datagram",
            "stream",
            "anyProtocol",
         }
         enum VirtualMachineVMCIDeviceDirection {
            "guest",
            "host",
            "anyDirection",
         }
         interface VirtualMachineVMCIDeviceFilterSpec extends vimService.vim.DynamicData {
            rank: number;
            action: string;
            protocol: string;
            direction: string;
            lowerDstPortBoundary?: number;
            upperDstPortBoundary?: number;
         }
         interface ArrayOfVirtualMachineVMCIDeviceFilterSpec {
            VirtualMachineVMCIDeviceFilterSpec?: Array<vimService.vim.VirtualMachineVMCIDeviceFilterSpec>;
         }
         interface VirtualMachineVMCIDeviceFilterInfo extends vimService.vim.DynamicData {
            filters?: Array<vimService.vim.VirtualMachineVMCIDeviceFilterSpec>;
         }
         interface VirtualMachineVMCIDevice extends vimService.vim.VirtualDevice {
            id?: number;
            allowUnrestrictedCommunication?: boolean;
            filterEnable?: boolean;
            filterInfo?: vimService.vim.VirtualMachineVMCIDeviceFilterInfo;
         }
         interface VirtualMachineVMCIDeviceOptionFilterSpecOption extends vimService.vim.DynamicData {
            action: vimService.vim.ChoiceOption;
            protocol: vimService.vim.ChoiceOption;
            direction: vimService.vim.ChoiceOption;
            lowerDstPortBoundary: vimService.vim.LongOption;
            upperDstPortBoundary: vimService.vim.LongOption;
         }
         interface VirtualMachineVMCIDeviceOption extends vimService.vim.VirtualDeviceOption {
            allowUnrestrictedCommunication: vimService.vim.BoolOption;
            filterSpecOption?: vimService.vim.VirtualMachineVMCIDeviceOptionFilterSpecOption;
            filterSupported?: vimService.vim.BoolOption;
         }
         interface VirtualMachineVMIROM extends vimService.vim.VirtualDevice {
         }
         interface VirtualVMIROMOption extends vimService.vim.VirtualDeviceOption {
         }
         enum VirtualMachineVideoCardUse3dRenderer {
            "automatic",
            "software",
            "hardware",
         }
         interface VirtualMachineVideoCard extends vimService.vim.VirtualDevice {
            videoRamSizeInKB?: number;
            numDisplays?: number;
            useAutoDetect?: boolean;
            enable3DSupport?: boolean;
            use3dRenderer?: string;
            graphicsMemorySizeInKB?: number;
         }
         interface VirtualVideoCardOption extends vimService.vim.VirtualDeviceOption {
            videoRamSizeInKB?: vimService.vim.LongOption;
            numDisplays?: vimService.vim.IntOption;
            useAutoDetect?: vimService.vim.BoolOption;
            support3D?: vimService.vim.BoolOption;
            use3dRendererSupported?: vimService.vim.BoolOption;
            graphicsMemorySizeInKB?: vimService.vim.LongOption;
            graphicsMemorySizeSupported?: vimService.vim.BoolOption;
         }
         interface VirtualVmxnet extends vimService.vim.VirtualEthernetCard {
         }
         interface VirtualVmxnet2 extends vimService.vim.VirtualVmxnet {
         }
         interface VirtualVmxnet2Option extends vimService.vim.VirtualVmxnetOption {
         }
         interface VirtualVmxnet3 extends vimService.vim.VirtualVmxnet {
         }
         interface VirtualVmxnet3Option extends vimService.vim.VirtualVmxnetOption {
         }
         interface VirtualVmxnet3Vrdma extends vimService.vim.VirtualVmxnet3 {
         }
         interface VirtualVmxnet3VrdmaOption extends vimService.vim.VirtualVmxnet3Option {
         }
         interface VirtualVmxnetOption extends vimService.vim.VirtualEthernetCardOption {
         }
         interface GuestAuthSubject extends vimService.vim.DynamicData {
         }
         interface ArrayOfGuestAuthSubject {
            GuestAuthSubject?: Array<vimService.vim.GuestAuthSubject>;
         }
         interface GuestAuthAnySubject extends vimService.vim.GuestAuthSubject {
         }
         interface GuestAuthNamedSubject extends vimService.vim.GuestAuthSubject {
            name: string;
         }
         interface GuestAuthAliasInfo extends vimService.vim.DynamicData {
            subject: vimService.vim.GuestAuthSubject;
            comment: string;
         }
         interface ArrayOfGuestAuthAliasInfo {
            GuestAuthAliasInfo?: Array<vimService.vim.GuestAuthAliasInfo>;
         }
         interface GuestAliases extends vimService.vim.DynamicData {
            base64Cert: string;
            aliases: Array<vimService.vim.GuestAuthAliasInfo>;
         }
         interface ArrayOfGuestAliases {
            GuestAliases?: Array<vimService.vim.GuestAliases>;
         }
         interface GuestMappedAliases extends vimService.vim.DynamicData {
            base64Cert: string;
            username: string;
            subjects: Array<vimService.vim.GuestAuthSubject>;
         }
         interface ArrayOfGuestMappedAliases {
            GuestMappedAliases?: Array<vimService.vim.GuestMappedAliases>;
         }
         interface GuestFileAttributes extends vimService.vim.DynamicData {
            modificationTime?: Date;
            accessTime?: Date;
            symlinkTarget?: string;
         }
         interface GuestPosixFileAttributes extends vimService.vim.GuestFileAttributes {
            ownerId?: number;
            groupId?: number;
            permissions?: number;
         }
         interface GuestWindowsFileAttributes extends vimService.vim.GuestFileAttributes {
            hidden?: boolean;
            readOnly?: boolean;
            createTime?: Date;
         }
         enum GuestFileType {
            "file",
            "directory",
            "symlink",
         }
         interface GuestFileInfo extends vimService.vim.DynamicData {
            path: string;
            type: string;
            size: number;
            attributes: vimService.vim.GuestFileAttributes;
         }
         interface ArrayOfGuestFileInfo {
            GuestFileInfo?: Array<vimService.vim.GuestFileInfo>;
         }
         interface GuestListFileInfo extends vimService.vim.DynamicData {
            files?: Array<vimService.vim.GuestFileInfo>;
            remaining: number;
         }
         interface FileTransferInformation extends vimService.vim.DynamicData {
            attributes: vimService.vim.GuestFileAttributes;
            size: number;
            url: string;
         }
         interface GuestAuthentication extends vimService.vim.DynamicData {
            interactiveSession: boolean;
         }
         interface NamePasswordAuthentication extends vimService.vim.GuestAuthentication {
            username: string;
            password: string;
         }
         interface GuestProgramSpec extends vimService.vim.DynamicData {
            programPath: string;
            arguments: string;
            workingDirectory?: string;
            envVariables?: Array<string>;
         }
         interface GuestWindowsProgramSpec extends vimService.vim.GuestProgramSpec {
            startMinimized: boolean;
         }
         interface GuestProcessInfo extends vimService.vim.DynamicData {
            name: string;
            pid: number;
            owner: string;
            cmdLine: string;
            startTime: Date;
            endTime?: Date;
            exitCode?: number;
         }
         interface ArrayOfGuestProcessInfo {
            GuestProcessInfo?: Array<vimService.vim.GuestProcessInfo>;
         }
         interface SAMLTokenAuthentication extends vimService.vim.GuestAuthentication {
            token: string;
            username?: string;
         }
         interface SSPIAuthentication extends vimService.vim.GuestAuthentication {
            sspiToken: string;
         }
         interface TicketedSessionAuthentication extends vimService.vim.GuestAuthentication {
            ticket: string;
         }
         enum GuestRegKeyWowSpec {
            "WOWNative",
            "WOW32",
            "WOW64",
         }
         interface GuestRegKeyNameSpec extends vimService.vim.DynamicData {
            registryPath: string;
            wowBitness: string;
         }
         interface GuestRegKeySpec extends vimService.vim.DynamicData {
            keyName: vimService.vim.GuestRegKeyNameSpec;
            classType: string;
            lastWritten: Date;
         }
         interface GuestRegKeyRecordSpec extends vimService.vim.DynamicData {
            key: vimService.vim.GuestRegKeySpec;
            fault?: vimService.vim.LocalizedMethodFault;
         }
         interface ArrayOfGuestRegKeyRecordSpec {
            GuestRegKeyRecordSpec?: Array<vimService.vim.GuestRegKeyRecordSpec>;
         }
         interface GuestRegValueNameSpec extends vimService.vim.DynamicData {
            keyName: vimService.vim.GuestRegKeyNameSpec;
            name: string;
         }
         interface GuestRegValueDataSpec extends vimService.vim.DynamicData {
         }
         interface GuestRegValueDwordSpec extends vimService.vim.GuestRegValueDataSpec {
            value: number;
         }
         interface GuestRegValueQwordSpec extends vimService.vim.GuestRegValueDataSpec {
            value: number;
         }
         interface GuestRegValueStringSpec extends vimService.vim.GuestRegValueDataSpec {
            value?: string;
         }
         interface GuestRegValueExpandStringSpec extends vimService.vim.GuestRegValueDataSpec {
            value?: string;
         }
         interface GuestRegValueMultiStringSpec extends vimService.vim.GuestRegValueDataSpec {
            value?: Array<string>;
         }
         interface GuestRegValueBinarySpec extends vimService.vim.GuestRegValueDataSpec {
            value?: string;
         }
         interface GuestRegValueSpec extends vimService.vim.DynamicData {
            name: vimService.vim.GuestRegValueNameSpec;
            data: vimService.vim.GuestRegValueDataSpec;
         }
         interface ArrayOfGuestRegValueSpec {
            GuestRegValueSpec?: Array<vimService.vim.GuestRegValueSpec>;
         }
         interface DeviceGroupId extends vimService.vim.DynamicData {
            id: string;
         }
         interface FaultDomainId extends vimService.vim.DynamicData {
            id: string;
         }
         interface ReplicationGroupId extends vimService.vim.DynamicData {
            faultDomainId: vimService.vim.FaultDomainId;
            deviceGroupId: vimService.vim.DeviceGroupId;
         }
         interface ReplicationSpec extends vimService.vim.DynamicData {
            replicationGroupId: vimService.vim.ReplicationGroupId;
         }
         interface VsanClusterConfigInfoHostDefaultInfo extends vimService.vim.DynamicData {
            uuid?: string;
            autoClaimStorage?: boolean;
            checksumEnabled?: boolean;
         }
         interface VsanClusterConfigInfo extends vimService.vim.DynamicData {
            enabled?: boolean;
            defaultConfig?: vimService.vim.VsanClusterConfigInfoHostDefaultInfo;
         }
         interface VsanHostClusterStatusStateCompletionEstimate extends vimService.vim.DynamicData {
            completeTime?: Date;
            percentComplete?: number;
         }
         interface VsanHostClusterStatusState extends vimService.vim.DynamicData {
            state: string;
            completion?: vimService.vim.VsanHostClusterStatusStateCompletionEstimate;
         }
         interface VsanHostClusterStatus extends vimService.vim.DynamicData {
            uuid?: string;
            nodeUuid?: string;
            health: string;
            nodeState: vimService.vim.VsanHostClusterStatusState;
            memberUuid?: Array<string>;
         }
         interface VsanHostConfigInfoStorageInfo extends vimService.vim.DynamicData {
            autoClaimStorage?: boolean;
            diskMapping?: Array<vimService.vim.VsanHostDiskMapping>;
            diskMapInfo?: Array<vimService.vim.VsanHostDiskMapInfo>;
            checksumEnabled?: boolean;
         }
         interface VsanHostConfigInfoClusterInfo extends vimService.vim.DynamicData {
            uuid?: string;
            nodeUuid?: string;
         }
         interface VsanHostConfigInfoNetworkInfoPortConfig extends vimService.vim.DynamicData {
            ipConfig?: vimService.vim.VsanHostIpConfig;
            device: string;
         }
         interface ArrayOfVsanHostConfigInfoNetworkInfoPortConfig {
            VsanHostConfigInfoNetworkInfoPortConfig?: Array<vimService.vim.VsanHostConfigInfoNetworkInfoPortConfig>;
         }
         interface VsanHostConfigInfoNetworkInfo extends vimService.vim.DynamicData {
            port?: Array<vimService.vim.VsanHostConfigInfoNetworkInfoPortConfig>;
         }
         interface VsanHostFaultDomainInfo extends vimService.vim.DynamicData {
            name: string;
         }
         interface VsanHostConfigInfo extends vimService.vim.DynamicData {
            enabled?: boolean;
            hostSystem?: vimService.vim.ManagedObjectReference;
            clusterInfo?: vimService.vim.VsanHostConfigInfoClusterInfo;
            storageInfo?: vimService.vim.VsanHostConfigInfoStorageInfo;
            networkInfo?: vimService.vim.VsanHostConfigInfoNetworkInfo;
            faultDomainInfo?: vimService.vim.VsanHostFaultDomainInfo;
         }
         interface ArrayOfVsanHostConfigInfo {
            VsanHostConfigInfo?: Array<vimService.vim.VsanHostConfigInfo>;
         }
         enum VsanHostDecommissionModeObjectAction {
            "noAction",
            "ensureObjectAccessibility",
            "evacuateAllData",
         }
         interface VsanHostDecommissionMode extends vimService.vim.DynamicData {
            objectAction: string;
         }
         interface VsanHostDiskMapInfo extends vimService.vim.DynamicData {
            mapping: vimService.vim.VsanHostDiskMapping;
            mounted: boolean;
         }
         interface ArrayOfVsanHostDiskMapInfo {
            VsanHostDiskMapInfo?: Array<vimService.vim.VsanHostDiskMapInfo>;
         }
         interface VsanHostDiskMapResult extends vimService.vim.DynamicData {
            mapping: vimService.vim.VsanHostDiskMapping;
            diskResult?: Array<vimService.vim.VsanHostDiskResult>;
            error?: vimService.vim.LocalizedMethodFault;
         }
         interface ArrayOfVsanHostDiskMapResult {
            VsanHostDiskMapResult?: Array<vimService.vim.VsanHostDiskMapResult>;
         }
         interface VsanHostDiskMapping extends vimService.vim.DynamicData {
            ssd: vimService.vim.HostScsiDisk;
            nonSsd: Array<vimService.vim.HostScsiDisk>;
         }
         interface ArrayOfVsanHostDiskMapping {
            VsanHostDiskMapping?: Array<vimService.vim.VsanHostDiskMapping>;
         }
         enum VsanHostDiskResultState {
            "inUse",
            "eligible",
            "ineligible",
         }
         interface VsanHostDiskResult extends vimService.vim.DynamicData {
            disk: vimService.vim.HostScsiDisk;
            state: string;
            vsanUuid?: string;
            error?: vimService.vim.LocalizedMethodFault;
            degraded?: boolean;
         }
         interface ArrayOfVsanHostDiskResult {
            VsanHostDiskResult?: Array<vimService.vim.VsanHostDiskResult>;
         }
         enum VsanHostHealthState {
            "unknown",
            "healthy",
            "unhealthy",
         }
         interface VsanHostIpConfig extends vimService.vim.DynamicData {
            upstreamIpAddress: string;
            downstreamIpAddress: string;
         }
         interface VsanHostMembershipInfo extends vimService.vim.DynamicData {
            nodeUuid: string;
            hostname: string;
         }
         interface ArrayOfVsanHostMembershipInfo {
            VsanHostMembershipInfo?: Array<vimService.vim.VsanHostMembershipInfo>;
         }
         enum VsanHostNodeState {
            "error",
            "disabled",
            "agent",
            "master",
            "backup",
            "starting",
            "stopping",
            "enteringMaintenanceMode",
            "exitingMaintenanceMode",
            "decommissioning",
         }
         interface VsanHostVsanDiskInfo extends vimService.vim.DynamicData {
            vsanUuid: string;
            formatVersion: number;
         }
         enum VsanDiskIssueType {
            "nonExist",
            "stampMismatch",
            "unknown",
         }
         interface VsanHostRuntimeInfoDiskIssue extends vimService.vim.DynamicData {
            diskId: string;
            issue: string;
         }
         interface ArrayOfVsanHostRuntimeInfoDiskIssue {
            VsanHostRuntimeInfoDiskIssue?: Array<vimService.vim.VsanHostRuntimeInfoDiskIssue>;
         }
         interface VsanHostRuntimeInfo extends vimService.vim.DynamicData {
            membershipList?: Array<vimService.vim.VsanHostMembershipInfo>;
            diskIssues?: Array<vimService.vim.VsanHostRuntimeInfoDiskIssue>;
            accessGenNo?: number;
         }
         interface BaseConfigInfoBackingInfo extends vimService.vim.DynamicData {
            datastore: vimService.vim.ManagedObjectReference;
         }
         interface BaseConfigInfoFileBackingInfo extends vimService.vim.BaseConfigInfoBackingInfo {
            filePath: string;
            backingObjectId?: string;
            parent?: vimService.vim.BaseConfigInfoFileBackingInfo;
            deltaSizeInMB?: number;
         }
         enum BaseConfigInfoDiskFileBackingInfoProvisioningType {
            "thin",
            "eagerZeroedThick",
            "lazyZeroedThick",
         }
         interface BaseConfigInfoDiskFileBackingInfo extends vimService.vim.BaseConfigInfoFileBackingInfo {
            provisioningType: string;
         }
         interface BaseConfigInfoRawDiskMappingBackingInfo extends vimService.vim.BaseConfigInfoFileBackingInfo {
            lunUuid: string;
            compatibilityMode: string;
         }
         interface BaseConfigInfo extends vimService.vim.DynamicData {
            id: string;
            name: string;
            createTime: Date;
            backing: vimService.vim.BaseConfigInfoBackingInfo;
         }
         interface VslmCloneSpec extends vimService.vim.VslmMigrateSpec {
            name: string;
         }
         interface VslmCreateSpecBackingSpec extends vimService.vim.DynamicData {
            datastore: vimService.vim.ManagedObjectReference;
         }
         interface VslmCreateSpecDiskFileBackingSpec extends vimService.vim.VslmCreateSpecBackingSpec {
            provisioningType?: string;
         }
         interface VslmCreateSpecRawDiskMappingBackingSpec extends vimService.vim.VslmCreateSpecBackingSpec {
            lunUuid: string;
            compatibilityMode: string;
         }
         interface VslmCreateSpec extends vimService.vim.DynamicData {
            name: string;
            backingSpec: vimService.vim.VslmCreateSpecBackingSpec;
            capacityInMB: number;
         }
         interface ID extends vimService.vim.DynamicData {
            id: string;
         }
         interface ArrayOfID {
            ID?: Array<string>;
         }
         interface VslmMigrateSpec extends vimService.vim.DynamicData {
            backingSpec: vimService.vim.VslmCreateSpecBackingSpec;
            consolidate?: boolean;
         }
         interface VslmRelocateSpec extends vimService.vim.VslmMigrateSpec {
         }
         interface VStorageObjectStateInfo extends vimService.vim.DynamicData {
            tentative?: boolean;
         }
         interface VslmTagEntry extends vimService.vim.DynamicData {
            tagName: string;
            parentCategoryName: string;
         }
         interface ArrayOfVslmTagEntry {
            VslmTagEntry?: Array<vimService.vim.VslmTagEntry>;
         }
         enum VStorageObjectConsumptionType {
            "disk",
         }
         interface VStorageObjectConfigInfo extends vimService.vim.BaseConfigInfo {
            capacityInMB: number;
            consumptionType?: Array<string>;
            consumerId?: Array<string>;
         }
         interface VStorageObject extends vimService.vim.DynamicData {
            config: vimService.vim.VStorageObjectConfigInfo;
         }
      }
      interface vimPort {
         addAuthorizationRole(_this: vimService.vim.ManagedObjectReference, name: string, privIds: Array<string>): Promise<number>;
         removeAuthorizationRole(_this: vimService.vim.ManagedObjectReference, roleId: number, failIfUsed: boolean): Promise<void>;
         updateAuthorizationRole(_this: vimService.vim.ManagedObjectReference, roleId: number, newName: string, privIds: Array<string>): Promise<void>;
         mergePermissions(_this: vimService.vim.ManagedObjectReference, srcRoleId: number, dstRoleId: number): Promise<void>;
         retrieveRolePermissions(_this: vimService.vim.ManagedObjectReference, roleId: number): Promise<Array<vimService.vim.Permission>>;
         retrieveEntityPermissions(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, inherited: boolean): Promise<Array<vimService.vim.Permission>>;
         retrieveAllPermissions(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.Permission>>;
         setEntityPermissions(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, permission: Array<vimService.vim.Permission>): Promise<void>;
         resetEntityPermissions(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, permission: Array<vimService.vim.Permission>): Promise<void>;
         removeEntityPermission(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, user: string, isGroup: boolean): Promise<void>;
         hasPrivilegeOnEntity(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, sessionId: string, privId: Array<string>): Promise<Array<boolean>>;
         hasPrivilegeOnEntities(_this: vimService.vim.ManagedObjectReference, entity: Array<vimService.vim.ManagedObjectReference>, sessionId: string, privId: Array<string>): Promise<Array<vimService.vim.EntityPrivilege>>;
         hasUserPrivilegeOnEntities(_this: vimService.vim.ManagedObjectReference, entities: Array<vimService.vim.ManagedObjectReference>, userName: string, privId: Array<string>): Promise<Array<vimService.vim.EntityPrivilege>>;
         fetchUserPrivilegeOnEntities(_this: vimService.vim.ManagedObjectReference, entities: Array<vimService.vim.ManagedObjectReference>, userName: string): Promise<Array<vimService.vim.UserPrivilegeResult>>;
         certMgrRefreshCACertificatesAndCRLsTask(_this: vimService.vim.ManagedObjectReference, host: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         certMgrRefreshCertificatesTask(_this: vimService.vim.ManagedObjectReference, host: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         certMgrRevokeCertificatesTask(_this: vimService.vim.ManagedObjectReference, host: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         reconfigureClusterTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.ClusterConfigSpec, modify: boolean): Promise<vimService.vim.ManagedObjectReference>;
         applyRecommendation(_this: vimService.vim.ManagedObjectReference, key: string): Promise<void>;
         cancelRecommendation(_this: vimService.vim.ManagedObjectReference, key: string): Promise<void>;
         recommendHostsForVm(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, pool: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ClusterHostRecommendation>>;
         addHostTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostConnectSpec, asConnected: boolean, resourcePool: vimService.vim.ManagedObjectReference, license: string): Promise<vimService.vim.ManagedObjectReference>;
         moveIntoTask(_this: vimService.vim.ManagedObjectReference, host: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         moveHostIntoTask(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, resourcePool: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         refreshRecommendation(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         evcManager(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         retrieveDasAdvancedRuntimeInfo(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ClusterDasAdvancedRuntimeInfo>;
         clusterEnterMaintenanceMode(_this: vimService.vim.ManagedObjectReference, host: Array<vimService.vim.ManagedObjectReference>, option: Array<vimService.vim.OptionValue>): Promise<vimService.vim.ClusterEnterMaintenanceResult>;
         placeVm(_this: vimService.vim.ManagedObjectReference, placementSpec: vimService.vim.PlacementSpec): Promise<vimService.vim.PlacementResult>;
         findRulesForVm(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ClusterRuleInfo>>;
         stampAllRulesWithUuidTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         getResourceUsage(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ClusterResourceUsageSummary>;
         reconfigureComputeResourceTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.ComputeResourceConfigSpec, modify: boolean): Promise<vimService.vim.ManagedObjectReference>;
         addCustomFieldDef(_this: vimService.vim.ManagedObjectReference, name: string, moType: string, fieldDefPolicy: vimService.vim.PrivilegePolicyDef, fieldPolicy: vimService.vim.PrivilegePolicyDef): Promise<vimService.vim.CustomFieldDef>;
         removeCustomFieldDef(_this: vimService.vim.ManagedObjectReference, key: number): Promise<void>;
         renameCustomFieldDef(_this: vimService.vim.ManagedObjectReference, key: number, name: string): Promise<void>;
         setField(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, key: number, value: string): Promise<void>;
         doesCustomizationSpecExist(_this: vimService.vim.ManagedObjectReference, name: string): Promise<boolean>;
         getCustomizationSpec(_this: vimService.vim.ManagedObjectReference, name: string): Promise<vimService.vim.CustomizationSpecItem>;
         createCustomizationSpec(_this: vimService.vim.ManagedObjectReference, item: vimService.vim.CustomizationSpecItem): Promise<void>;
         overwriteCustomizationSpec(_this: vimService.vim.ManagedObjectReference, item: vimService.vim.CustomizationSpecItem): Promise<void>;
         deleteCustomizationSpec(_this: vimService.vim.ManagedObjectReference, name: string): Promise<void>;
         duplicateCustomizationSpec(_this: vimService.vim.ManagedObjectReference, name: string, newName: string): Promise<void>;
         renameCustomizationSpec(_this: vimService.vim.ManagedObjectReference, name: string, newName: string): Promise<void>;
         customizationSpecItemToXml(_this: vimService.vim.ManagedObjectReference, item: vimService.vim.CustomizationSpecItem): Promise<string>;
         xmlToCustomizationSpecItem(_this: vimService.vim.ManagedObjectReference, specItemXml: string): Promise<vimService.vim.CustomizationSpecItem>;
         checkCustomizationResources(_this: vimService.vim.ManagedObjectReference, guestOs: string): Promise<void>;
         queryConnectionInfo(_this: vimService.vim.ManagedObjectReference, hostname: string, port: number, username: string, password: string, sslThumbprint: string): Promise<vimService.vim.HostConnectInfo>;
         queryConnectionInfoViaSpec(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostConnectSpec): Promise<vimService.vim.HostConnectInfo>;
         powerOnMultiVMTask(_this: vimService.vim.ManagedObjectReference, vm: Array<vimService.vim.ManagedObjectReference>, option: Array<vimService.vim.OptionValue>): Promise<vimService.vim.ManagedObjectReference>;
         queryDatacenterConfigOptionDescriptor(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.VirtualMachineConfigOptionDescriptor>>;
         reconfigureDatacenterTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.DatacenterConfigSpec, modify: boolean): Promise<vimService.vim.ManagedObjectReference>;
         refreshDatastore(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         refreshDatastoreStorageInfo(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         updateVirtualMachineFilesTask(_this: vimService.vim.ManagedObjectReference, mountPathDatastoreMapping: Array<vimService.vim.DatastoreMountPathDatastorePair>): Promise<vimService.vim.ManagedObjectReference>;
         renameDatastore(_this: vimService.vim.ManagedObjectReference, newName: string): Promise<void>;
         destroyDatastore(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         datastoreEnterMaintenanceMode(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.StoragePlacementResult>;
         datastoreExitMaintenanceModeTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         updateVVolVirtualMachineFilesTask(_this: vimService.vim.ManagedObjectReference, failoverPair: Array<vimService.vim.DatastoreVVolContainerFailoverPair>): Promise<vimService.vim.ManagedObjectReference>;
         createDirectory(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference, displayName: string, policy: string): Promise<string>;
         deleteDirectory(_this: vimService.vim.ManagedObjectReference, datacenter: vimService.vim.ManagedObjectReference, datastorePath: string): Promise<void>;
         convertNamespacePathToUuidPath(_this: vimService.vim.ManagedObjectReference, datacenter: vimService.vim.ManagedObjectReference, namespaceUrl: string): Promise<string>;
         queryDescriptions(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.DiagnosticManagerLogDescriptor>>;
         browseDiagnosticLog(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, key: string, start: number, lines: number): Promise<vimService.vim.DiagnosticManagerLogHeader>;
         generateLogBundlesTask(_this: vimService.vim.ManagedObjectReference, includeDefault: boolean, host: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         fetchDVPortKeys(_this: vimService.vim.ManagedObjectReference, criteria: vimService.vim.DistributedVirtualSwitchPortCriteria): Promise<Array<string>>;
         fetchDVPorts(_this: vimService.vim.ManagedObjectReference, criteria: vimService.vim.DistributedVirtualSwitchPortCriteria): Promise<Array<vimService.vim.DistributedVirtualPort>>;
         queryUsedVlanIdInDvs(_this: vimService.vim.ManagedObjectReference): Promise<Array<number>>;
         reconfigureDvsTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.DVSConfigSpec): Promise<vimService.vim.ManagedObjectReference>;
         performDvsProductSpecOperationTask(_this: vimService.vim.ManagedObjectReference, operation: string, productSpec: vimService.vim.DistributedVirtualSwitchProductSpec): Promise<vimService.vim.ManagedObjectReference>;
         mergeDvsTask(_this: vimService.vim.ManagedObjectReference, dvs: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         addDVPortgroupTask(_this: vimService.vim.ManagedObjectReference, spec: Array<vimService.vim.DVPortgroupConfigSpec>): Promise<vimService.vim.ManagedObjectReference>;
         moveDVPortTask(_this: vimService.vim.ManagedObjectReference, portKey: Array<string>, destinationPortgroupKey: string): Promise<vimService.vim.ManagedObjectReference>;
         updateDvsCapability(_this: vimService.vim.ManagedObjectReference, capability: vimService.vim.DVSCapability): Promise<void>;
         reconfigureDVPortTask(_this: vimService.vim.ManagedObjectReference, port: Array<vimService.vim.DVPortConfigSpec>): Promise<vimService.vim.ManagedObjectReference>;
         refreshDVPortState(_this: vimService.vim.ManagedObjectReference, portKeys: Array<string>): Promise<void>;
         rectifyDvsHostTask(_this: vimService.vim.ManagedObjectReference, hosts: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         updateNetworkResourcePool(_this: vimService.vim.ManagedObjectReference, configSpec: Array<vimService.vim.DVSNetworkResourcePoolConfigSpec>): Promise<void>;
         addNetworkResourcePool(_this: vimService.vim.ManagedObjectReference, configSpec: Array<vimService.vim.DVSNetworkResourcePoolConfigSpec>): Promise<void>;
         removeNetworkResourcePool(_this: vimService.vim.ManagedObjectReference, key: Array<string>): Promise<void>;
         dvsReconfigureVmVnicNetworkResourcePoolTask(_this: vimService.vim.ManagedObjectReference, configSpec: Array<vimService.vim.DvsVmVnicResourcePoolConfigSpec>): Promise<vimService.vim.ManagedObjectReference>;
         enableNetworkResourceManagement(_this: vimService.vim.ManagedObjectReference, enable: boolean): Promise<void>;
         dVSRollbackTask(_this: vimService.vim.ManagedObjectReference, entityBackup: vimService.vim.EntityBackupConfig): Promise<vimService.vim.ManagedObjectReference>;
         createDVPortgroupTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.DVPortgroupConfigSpec): Promise<vimService.vim.ManagedObjectReference>;
         updateDVSHealthCheckConfigTask(_this: vimService.vim.ManagedObjectReference, healthCheckConfig: Array<vimService.vim.DVSHealthCheckConfig>): Promise<vimService.vim.ManagedObjectReference>;
         lookupDvPortGroup(_this: vimService.vim.ManagedObjectReference, portgroupKey: string): Promise<vimService.vim.ManagedObjectReference>;
         queryConfigOptionDescriptor(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.VirtualMachineConfigOptionDescriptor>>;
         queryConfigOption(_this: vimService.vim.ManagedObjectReference, key: string, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.VirtualMachineConfigOption>;
         queryConfigOptionEx(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.EnvironmentBrowserConfigOptionQuerySpec): Promise<vimService.vim.VirtualMachineConfigOption>;
         queryConfigTarget(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ConfigTarget>;
         queryTargetCapabilities(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.HostCapability>;
         setCustomValue(_this: vimService.vim.ManagedObjectReference, key: string, value: string): Promise<void>;
         unregisterExtension(_this: vimService.vim.ManagedObjectReference, extensionKey: string): Promise<void>;
         findExtension(_this: vimService.vim.ManagedObjectReference, extensionKey: string): Promise<vimService.vim.Extension>;
         registerExtension(_this: vimService.vim.ManagedObjectReference, extension: vimService.vim.Extension): Promise<void>;
         updateExtension(_this: vimService.vim.ManagedObjectReference, extension: vimService.vim.Extension): Promise<void>;
         getPublicKey(_this: vimService.vim.ManagedObjectReference): Promise<string>;
         setPublicKey(_this: vimService.vim.ManagedObjectReference, extensionKey: string, publicKey: string): Promise<void>;
         setExtensionCertificate(_this: vimService.vim.ManagedObjectReference, extensionKey: string, certificatePem: string): Promise<void>;
         queryManagedBy(_this: vimService.vim.ManagedObjectReference, extensionKey: string): Promise<Array<vimService.vim.ManagedObjectReference>>;
         queryExtensionIpAllocationUsage(_this: vimService.vim.ManagedObjectReference, extensionKeys: Array<string>): Promise<Array<vimService.vim.ExtensionManagerIpAllocationUsage>>;
         moveDatastoreFileTask(_this: vimService.vim.ManagedObjectReference, sourceName: string, sourceDatacenter: vimService.vim.ManagedObjectReference, destinationName: string, destinationDatacenter: vimService.vim.ManagedObjectReference, force: boolean): Promise<vimService.vim.ManagedObjectReference>;
         copyDatastoreFileTask(_this: vimService.vim.ManagedObjectReference, sourceName: string, sourceDatacenter: vimService.vim.ManagedObjectReference, destinationName: string, destinationDatacenter: vimService.vim.ManagedObjectReference, force: boolean): Promise<vimService.vim.ManagedObjectReference>;
         deleteDatastoreFileTask(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         makeDirectory(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference, createParentDirectories: boolean): Promise<void>;
         changeOwner(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference, owner: string): Promise<void>;
         createFolder(_this: vimService.vim.ManagedObjectReference, name: string): Promise<vimService.vim.ManagedObjectReference>;
         moveIntoFolderTask(_this: vimService.vim.ManagedObjectReference, list: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         createVMTask(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.VirtualMachineConfigSpec, pool: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         registerVMTask(_this: vimService.vim.ManagedObjectReference, path: string, name: string, asTemplate: boolean, pool: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         createCluster(_this: vimService.vim.ManagedObjectReference, name: string, spec: vimService.vim.ClusterConfigSpec): Promise<vimService.vim.ManagedObjectReference>;
         createClusterEx(_this: vimService.vim.ManagedObjectReference, name: string, spec: vimService.vim.ClusterConfigSpecEx): Promise<vimService.vim.ManagedObjectReference>;
         addStandaloneHostTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostConnectSpec, compResSpec: vimService.vim.ComputeResourceConfigSpec, addConnected: boolean, license: string): Promise<vimService.vim.ManagedObjectReference>;
         createDatacenter(_this: vimService.vim.ManagedObjectReference, name: string): Promise<vimService.vim.ManagedObjectReference>;
         unregisterAndDestroyTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         createDVSTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.DVSCreateSpec): Promise<vimService.vim.ManagedObjectReference>;
         createStoragePod(_this: vimService.vim.ManagedObjectReference, name: string): Promise<vimService.vim.ManagedObjectReference>;
         registerHealthUpdateProvider(_this: vimService.vim.ManagedObjectReference, name: string, healthUpdateInfo: Array<vimService.vim.HealthUpdateInfo>): Promise<string>;
         unregisterHealthUpdateProvider(_this: vimService.vim.ManagedObjectReference, providerId: string): Promise<void>;
         queryProviderList(_this: vimService.vim.ManagedObjectReference): Promise<Array<string>>;
         hasProvider(_this: vimService.vim.ManagedObjectReference, id: string): Promise<boolean>;
         queryProviderName(_this: vimService.vim.ManagedObjectReference, id: string): Promise<string>;
         queryHealthUpdateInfos(_this: vimService.vim.ManagedObjectReference, providerId: string): Promise<Array<vimService.vim.HealthUpdateInfo>>;
         addMonitoredEntities(_this: vimService.vim.ManagedObjectReference, providerId: string, entities: Array<vimService.vim.ManagedObjectReference>): Promise<void>;
         removeMonitoredEntities(_this: vimService.vim.ManagedObjectReference, providerId: string, entities: Array<vimService.vim.ManagedObjectReference>): Promise<void>;
         queryMonitoredEntities(_this: vimService.vim.ManagedObjectReference, providerId: string): Promise<Array<vimService.vim.ManagedObjectReference>>;
         hasMonitoredEntity(_this: vimService.vim.ManagedObjectReference, providerId: string, entity: vimService.vim.ManagedObjectReference): Promise<boolean>;
         queryUnmonitoredHosts(_this: vimService.vim.ManagedObjectReference, providerId: string, cluster: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ManagedObjectReference>>;
         postHealthUpdates(_this: vimService.vim.ManagedObjectReference, providerId: string, updates: Array<vimService.vim.HealthUpdate>): Promise<void>;
         queryHealthUpdates(_this: vimService.vim.ManagedObjectReference, providerId: string): Promise<Array<vimService.vim.HealthUpdate>>;
         addFilter(_this: vimService.vim.ManagedObjectReference, providerId: string, filterName: string, infoIds: Array<string>): Promise<string>;
         queryFilterList(_this: vimService.vim.ManagedObjectReference, providerId: string): Promise<Array<string>>;
         queryFilterName(_this: vimService.vim.ManagedObjectReference, filterId: string): Promise<string>;
         queryFilterInfoIds(_this: vimService.vim.ManagedObjectReference, filterId: string): Promise<Array<string>>;
         queryFilterEntities(_this: vimService.vim.ManagedObjectReference, filterId: string): Promise<Array<vimService.vim.ManagedObjectReference>>;
         addFilterEntities(_this: vimService.vim.ManagedObjectReference, filterId: string, entities: Array<vimService.vim.ManagedObjectReference>): Promise<void>;
         removeFilterEntities(_this: vimService.vim.ManagedObjectReference, filterId: string, entities: Array<vimService.vim.ManagedObjectReference>): Promise<void>;
         removeFilter(_this: vimService.vim.ManagedObjectReference, filterId: string): Promise<void>;
         setCollectorPageSize(_this: vimService.vim.ManagedObjectReference, maxCount: number): Promise<void>;
         rewindCollector(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         resetCollector(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         destroyCollector(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         queryTpmAttestationReport(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.HostTpmAttestationReport>;
         queryHostConnectionInfo(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.HostConnectInfo>;
         updateSystemResources(_this: vimService.vim.ManagedObjectReference, resourceInfo: vimService.vim.HostSystemResourceInfo): Promise<void>;
         updateSystemSwapConfiguration(_this: vimService.vim.ManagedObjectReference, sysSwapConfig: vimService.vim.HostSystemSwapConfiguration): Promise<void>;
         reconnectHostTask(_this: vimService.vim.ManagedObjectReference, cnxSpec: vimService.vim.HostConnectSpec, reconnectSpec: vimService.vim.HostSystemReconnectSpec): Promise<vimService.vim.ManagedObjectReference>;
         disconnectHostTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         enterMaintenanceModeTask(_this: vimService.vim.ManagedObjectReference, timeout: number, evacuatePoweredOffVms: boolean, maintenanceSpec: vimService.vim.HostMaintenanceSpec): Promise<vimService.vim.ManagedObjectReference>;
         exitMaintenanceModeTask(_this: vimService.vim.ManagedObjectReference, timeout: number): Promise<vimService.vim.ManagedObjectReference>;
         rebootHostTask(_this: vimService.vim.ManagedObjectReference, force: boolean): Promise<vimService.vim.ManagedObjectReference>;
         shutdownHostTask(_this: vimService.vim.ManagedObjectReference, force: boolean): Promise<vimService.vim.ManagedObjectReference>;
         powerDownHostToStandByTask(_this: vimService.vim.ManagedObjectReference, timeoutSec: number, evacuatePoweredOffVms: boolean): Promise<vimService.vim.ManagedObjectReference>;
         powerUpHostFromStandByTask(_this: vimService.vim.ManagedObjectReference, timeoutSec: number): Promise<vimService.vim.ManagedObjectReference>;
         queryMemoryOverhead(_this: vimService.vim.ManagedObjectReference, memorySize: number, videoRamSize: number, numVcpus: number): Promise<number>;
         queryMemoryOverheadEx(_this: vimService.vim.ManagedObjectReference, vmConfigInfo: vimService.vim.VirtualMachineConfigInfo): Promise<number>;
         reconfigureHostForDASTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         updateFlags(_this: vimService.vim.ManagedObjectReference, flagInfo: vimService.vim.HostFlagInfo): Promise<void>;
         enterLockdownMode(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         exitLockdownMode(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         acquireCimServicesTicket(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.HostServiceTicket>;
         updateIpmi(_this: vimService.vim.ManagedObjectReference, ipmiInfo: vimService.vim.HostIpmiInfo): Promise<void>;
         retrieveHardwareUptime(_this: vimService.vim.ManagedObjectReference): Promise<number>;
         prepareCrypto(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         enableCrypto(_this: vimService.vim.ManagedObjectReference, keyPlain: vimService.vim.CryptoKeyPlain): Promise<void>;
         configureCryptoKey(_this: vimService.vim.ManagedObjectReference, keyId: vimService.vim.CryptoKeyId): Promise<void>;
         httpNfcLeaseGetManifest(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.HttpNfcLeaseManifestEntry>>;
         httpNfcLeaseComplete(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         httpNfcLeaseAbort(_this: vimService.vim.ManagedObjectReference, fault: vimService.vim.LocalizedMethodFault): Promise<void>;
         httpNfcLeaseProgress(_this: vimService.vim.ManagedObjectReference, percent: number): Promise<void>;
         installIoFilterTask(_this: vimService.vim.ManagedObjectReference, vibUrl: string, compRes: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         uninstallIoFilterTask(_this: vimService.vim.ManagedObjectReference, filterId: string, compRes: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         upgradeIoFilterTask(_this: vimService.vim.ManagedObjectReference, filterId: string, compRes: vimService.vim.ManagedObjectReference, vibUrl: string): Promise<vimService.vim.ManagedObjectReference>;
         queryIoFilterIssues(_this: vimService.vim.ManagedObjectReference, filterId: string, compRes: vimService.vim.ManagedObjectReference): Promise<vimService.vim.IoFilterQueryIssueResult>;
         queryIoFilterInfo(_this: vimService.vim.ManagedObjectReference, compRes: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ClusterIoFilterInfo>>;
         resolveInstallationErrorsOnHostTask(_this: vimService.vim.ManagedObjectReference, filterId: string, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         resolveInstallationErrorsOnClusterTask(_this: vimService.vim.ManagedObjectReference, filterId: string, cluster: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         queryDisksUsingFilter(_this: vimService.vim.ManagedObjectReference, filterId: string, compRes: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.VirtualDiskId>>;
         queryIpPools(_this: vimService.vim.ManagedObjectReference, dc: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.IpPool>>;
         createIpPool(_this: vimService.vim.ManagedObjectReference, dc: vimService.vim.ManagedObjectReference, pool: vimService.vim.IpPool): Promise<number>;
         updateIpPool(_this: vimService.vim.ManagedObjectReference, dc: vimService.vim.ManagedObjectReference, pool: vimService.vim.IpPool): Promise<void>;
         destroyIpPool(_this: vimService.vim.ManagedObjectReference, dc: vimService.vim.ManagedObjectReference, id: number, force: boolean): Promise<void>;
         allocateIpv4Address(_this: vimService.vim.ManagedObjectReference, dc: vimService.vim.ManagedObjectReference, poolId: number, allocationId: string): Promise<string>;
         allocateIpv6Address(_this: vimService.vim.ManagedObjectReference, dc: vimService.vim.ManagedObjectReference, poolId: number, allocationId: string): Promise<string>;
         releaseIpAllocation(_this: vimService.vim.ManagedObjectReference, dc: vimService.vim.ManagedObjectReference, poolId: number, allocationId: string): Promise<void>;
         queryIPAllocations(_this: vimService.vim.ManagedObjectReference, dc: vimService.vim.ManagedObjectReference, poolId: number, extensionKey: string): Promise<Array<vimService.vim.IpPoolManagerIpAllocation>>;
         updateAssignedLicense(_this: vimService.vim.ManagedObjectReference, entity: string, licenseKey: string, entityDisplayName: string): Promise<vimService.vim.LicenseManagerLicenseInfo>;
         removeAssignedLicense(_this: vimService.vim.ManagedObjectReference, entityId: string): Promise<void>;
         queryAssignedLicenses(_this: vimService.vim.ManagedObjectReference, entityId: string): Promise<Array<vimService.vim.LicenseAssignmentManagerLicenseAssignment>>;
         querySupportedFeatures(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.LicenseFeatureInfo>>;
         queryLicenseSourceAvailability(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.LicenseAvailabilityInfo>>;
         queryLicenseUsage(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.LicenseUsageInfo>;
         setLicenseEdition(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, featureKey: string): Promise<void>;
         checkLicenseFeature(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, featureKey: string): Promise<boolean>;
         enableFeature(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, featureKey: string): Promise<boolean>;
         disableFeature(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, featureKey: string): Promise<boolean>;
         configureLicenseSource(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, licenseSource: vimService.vim.LicenseSource): Promise<void>;
         updateLicense(_this: vimService.vim.ManagedObjectReference, licenseKey: string, labels: Array<vimService.vim.KeyValue>): Promise<vimService.vim.LicenseManagerLicenseInfo>;
         addLicense(_this: vimService.vim.ManagedObjectReference, licenseKey: string, labels: Array<vimService.vim.KeyValue>): Promise<vimService.vim.LicenseManagerLicenseInfo>;
         removeLicense(_this: vimService.vim.ManagedObjectReference, licenseKey: string): Promise<void>;
         decodeLicense(_this: vimService.vim.ManagedObjectReference, licenseKey: string): Promise<vimService.vim.LicenseManagerLicenseInfo>;
         updateLicenseLabel(_this: vimService.vim.ManagedObjectReference, licenseKey: string, labelKey: string, labelValue: string): Promise<void>;
         removeLicenseLabel(_this: vimService.vim.ManagedObjectReference, licenseKey: string, labelKey: string): Promise<void>;
         reload(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         renameTask(_this: vimService.vim.ManagedObjectReference, newName: string): Promise<vimService.vim.ManagedObjectReference>;
         destroyTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         destroyNetwork(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         lookupVmOverheadMemory(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<number>;
         validateHost(_this: vimService.vim.ManagedObjectReference, ovfDescriptor: string, host: vimService.vim.ManagedObjectReference, vhp: vimService.vim.OvfValidateHostParams): Promise<vimService.vim.OvfValidateHostResult>;
         parseDescriptor(_this: vimService.vim.ManagedObjectReference, ovfDescriptor: string, pdp: vimService.vim.OvfParseDescriptorParams): Promise<vimService.vim.OvfParseDescriptorResult>;
         createImportSpec(_this: vimService.vim.ManagedObjectReference, ovfDescriptor: string, resourcePool: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference, cisp: vimService.vim.OvfCreateImportSpecParams): Promise<vimService.vim.OvfCreateImportSpecResult>;
         createDescriptor(_this: vimService.vim.ManagedObjectReference, obj: vimService.vim.ManagedObjectReference, cdp: vimService.vim.OvfCreateDescriptorParams): Promise<vimService.vim.OvfCreateDescriptorResult>;
         queryPerfProviderSummary(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference): Promise<vimService.vim.PerfProviderSummary>;
         queryAvailablePerfMetric(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, beginTime: Date, endTime: Date, intervalId: number): Promise<Array<vimService.vim.PerfMetricId>>;
         queryPerfCounter(_this: vimService.vim.ManagedObjectReference, counterId: Array<number>): Promise<Array<vimService.vim.PerfCounterInfo>>;
         queryPerfCounterByLevel(_this: vimService.vim.ManagedObjectReference, level: number): Promise<Array<vimService.vim.PerfCounterInfo>>;
         queryPerf(_this: vimService.vim.ManagedObjectReference, querySpec: Array<vimService.vim.PerfQuerySpec>): Promise<Array<vimService.vim.PerfEntityMetricBase>>;
         queryPerfComposite(_this: vimService.vim.ManagedObjectReference, querySpec: vimService.vim.PerfQuerySpec): Promise<vimService.vim.PerfCompositeMetric>;
         createPerfInterval(_this: vimService.vim.ManagedObjectReference, intervalId: vimService.vim.PerfInterval): Promise<void>;
         removePerfInterval(_this: vimService.vim.ManagedObjectReference, samplePeriod: number): Promise<void>;
         updatePerfInterval(_this: vimService.vim.ManagedObjectReference, interval: vimService.vim.PerfInterval): Promise<void>;
         updateCounterLevelMapping(_this: vimService.vim.ManagedObjectReference, counterLevelMap: Array<vimService.vim.PerformanceManagerCounterLevelMapping>): Promise<void>;
         resetCounterLevelMapping(_this: vimService.vim.ManagedObjectReference, counters: Array<number>): Promise<void>;
         estimateDatabaseSize(_this: vimService.vim.ManagedObjectReference, dbSizeParam: vimService.vim.DatabaseSizeParam): Promise<vimService.vim.DatabaseSizeEstimate>;
         updateConfig(_this: vimService.vim.ManagedObjectReference, name: string, config: vimService.vim.ResourceConfigSpec): Promise<void>;
         moveIntoResourcePool(_this: vimService.vim.ManagedObjectReference, list: Array<vimService.vim.ManagedObjectReference>): Promise<void>;
         updateChildResourceConfiguration(_this: vimService.vim.ManagedObjectReference, spec: Array<vimService.vim.ResourceConfigSpec>): Promise<void>;
         createResourcePool(_this: vimService.vim.ManagedObjectReference, name: string, spec: vimService.vim.ResourceConfigSpec): Promise<vimService.vim.ManagedObjectReference>;
         destroyChildren(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         createVApp(_this: vimService.vim.ManagedObjectReference, name: string, resSpec: vimService.vim.ResourceConfigSpec, configSpec: vimService.vim.VAppConfigSpec, vmFolder: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         createChildVMTask(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.VirtualMachineConfigSpec, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         registerChildVMTask(_this: vimService.vim.ManagedObjectReference, path: string, name: string, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         importVApp(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.ImportSpec, folder: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         queryResourceConfigOption(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ResourceConfigOption>;
         refreshRuntime(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         findByUuid(_this: vimService.vim.ManagedObjectReference, datacenter: vimService.vim.ManagedObjectReference, uuid: string, vmSearch: boolean, instanceUuid: boolean): Promise<vimService.vim.ManagedObjectReference>;
         findByDatastorePath(_this: vimService.vim.ManagedObjectReference, datacenter: vimService.vim.ManagedObjectReference, path: string): Promise<vimService.vim.ManagedObjectReference>;
         findByDnsName(_this: vimService.vim.ManagedObjectReference, datacenter: vimService.vim.ManagedObjectReference, dnsName: string, vmSearch: boolean): Promise<vimService.vim.ManagedObjectReference>;
         findByIp(_this: vimService.vim.ManagedObjectReference, datacenter: vimService.vim.ManagedObjectReference, ip: string, vmSearch: boolean): Promise<vimService.vim.ManagedObjectReference>;
         findByInventoryPath(_this: vimService.vim.ManagedObjectReference, inventoryPath: string): Promise<vimService.vim.ManagedObjectReference>;
         findChild(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, name: string): Promise<vimService.vim.ManagedObjectReference>;
         findAllByUuid(_this: vimService.vim.ManagedObjectReference, datacenter: vimService.vim.ManagedObjectReference, uuid: string, vmSearch: boolean, instanceUuid: boolean): Promise<Array<vimService.vim.ManagedObjectReference>>;
         findAllByDnsName(_this: vimService.vim.ManagedObjectReference, datacenter: vimService.vim.ManagedObjectReference, dnsName: string, vmSearch: boolean): Promise<Array<vimService.vim.ManagedObjectReference>>;
         findAllByIp(_this: vimService.vim.ManagedObjectReference, datacenter: vimService.vim.ManagedObjectReference, ip: string, vmSearch: boolean): Promise<Array<vimService.vim.ManagedObjectReference>>;
         currentTime(_this: vimService.vim.ManagedObjectReference): Promise<Date>;
         retrieveServiceContent(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ServiceContent>;
         validateMigration(_this: vimService.vim.ManagedObjectReference, vm: Array<vimService.vim.ManagedObjectReference>, state: vimService.vim.VirtualMachinePowerState, testType: Array<string>, pool: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.Event>>;
         queryVMotionCompatibility(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, host: Array<vimService.vim.ManagedObjectReference>, compatibility: Array<string>): Promise<Array<vimService.vim.HostVMotionCompatibility>>;
         retrieveProductComponents(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ProductComponentInfo>>;
         queryServiceList(_this: vimService.vim.ManagedObjectReference, serviceName: string, location: Array<string>): Promise<Array<vimService.vim.ServiceManagerServiceInfo>>;
         updateServiceMessage(_this: vimService.vim.ManagedObjectReference, message: string): Promise<void>;
         loginByToken(_this: vimService.vim.ManagedObjectReference, locale: string): Promise<vimService.vim.UserSession>;
         login(_this: vimService.vim.ManagedObjectReference, userName: string, password: string, locale: string): Promise<vimService.vim.UserSession>;
         loginBySSPI(_this: vimService.vim.ManagedObjectReference, base64Token: string, locale: string): Promise<vimService.vim.UserSession>;
         logout(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         acquireLocalTicket(_this: vimService.vim.ManagedObjectReference, userName: string): Promise<vimService.vim.SessionManagerLocalTicket>;
         acquireGenericServiceTicket(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.SessionManagerServiceRequestSpec): Promise<vimService.vim.SessionManagerGenericServiceTicket>;
         terminateSession(_this: vimService.vim.ManagedObjectReference, sessionId: Array<string>): Promise<void>;
         setLocale(_this: vimService.vim.ManagedObjectReference, locale: string): Promise<void>;
         loginExtensionBySubjectName(_this: vimService.vim.ManagedObjectReference, extensionKey: string, locale: string): Promise<vimService.vim.UserSession>;
         loginExtensionByCertificate(_this: vimService.vim.ManagedObjectReference, extensionKey: string, locale: string): Promise<vimService.vim.UserSession>;
         impersonateUser(_this: vimService.vim.ManagedObjectReference, userName: string, locale: string): Promise<vimService.vim.UserSession>;
         sessionIsActive(_this: vimService.vim.ManagedObjectReference, sessionID: string, userName: string): Promise<boolean>;
         acquireCloneTicket(_this: vimService.vim.ManagedObjectReference): Promise<string>;
         cloneSession(_this: vimService.vim.ManagedObjectReference, cloneTicket: string): Promise<vimService.vim.UserSession>;
         executeSimpleCommand(_this: vimService.vim.ManagedObjectReference, argumentsb: Array<string>): Promise<string>;
         configureDatastoreIORMTask(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference, spec: vimService.vim.StorageIORMConfigSpec): Promise<vimService.vim.ManagedObjectReference>;
         queryIORMConfigOption(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.StorageIORMConfigOption>;
         queryDatastorePerformanceSummary(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.StoragePerformanceSummary>>;
         applyStorageDrsRecommendationToPodTask(_this: vimService.vim.ManagedObjectReference, pod: vimService.vim.ManagedObjectReference, key: string): Promise<vimService.vim.ManagedObjectReference>;
         applyStorageDrsRecommendationTask(_this: vimService.vim.ManagedObjectReference, key: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         cancelStorageDrsRecommendation(_this: vimService.vim.ManagedObjectReference, key: Array<string>): Promise<void>;
         refreshStorageDrsRecommendation(_this: vimService.vim.ManagedObjectReference, pod: vimService.vim.ManagedObjectReference): Promise<void>;
         configureStorageDrsForPodTask(_this: vimService.vim.ManagedObjectReference, pod: vimService.vim.ManagedObjectReference, spec: vimService.vim.StorageDrsConfigSpec, modify: boolean): Promise<vimService.vim.ManagedObjectReference>;
         recommendDatastores(_this: vimService.vim.ManagedObjectReference, storageSpec: vimService.vim.StoragePlacementSpec): Promise<vimService.vim.StoragePlacementResult>;
         cancelTask(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         updateProgress(_this: vimService.vim.ManagedObjectReference, percentDone: number): Promise<void>;
         setTaskState(_this: vimService.vim.ManagedObjectReference, state: vimService.vim.TaskInfoState, result: any, fault: vimService.vim.LocalizedMethodFault): Promise<void>;
         setTaskDescription(_this: vimService.vim.ManagedObjectReference, description: vimService.vim.LocalizableMessage): Promise<void>;
         readNextTasks(_this: vimService.vim.ManagedObjectReference, maxCount: number): Promise<Array<vimService.vim.TaskInfo>>;
         readPreviousTasks(_this: vimService.vim.ManagedObjectReference, maxCount: number): Promise<Array<vimService.vim.TaskInfo>>;
         createCollectorForTasks(_this: vimService.vim.ManagedObjectReference, filter: vimService.vim.TaskFilterSpec): Promise<vimService.vim.ManagedObjectReference>;
         createTask(_this: vimService.vim.ManagedObjectReference, obj: vimService.vim.ManagedObjectReference, taskTypeId: string, initiatedBy: string, cancelable: boolean, parentTaskKey: string, activationId: string): Promise<vimService.vim.TaskInfo>;
         retrieveUserGroups(_this: vimService.vim.ManagedObjectReference, domain: string, searchStr: string, belongsToGroup: string, belongsToUser: string, exactMatch: boolean, findUsers: boolean, findGroups: boolean): Promise<Array<vimService.vim.UserSearchResult>>;
         updateVAppConfig(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.VAppConfigSpec): Promise<void>;
         updateLinkedChildren(_this: vimService.vim.ManagedObjectReference, addChangeSet: Array<vimService.vim.VirtualAppLinkInfo>, removeSet: Array<vimService.vim.ManagedObjectReference>): Promise<void>;
         cloneVAppTask(_this: vimService.vim.ManagedObjectReference, name: string, target: vimService.vim.ManagedObjectReference, spec: vimService.vim.VAppCloneSpec): Promise<vimService.vim.ManagedObjectReference>;
         exportVApp(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         powerOnVAppTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         powerOffVAppTask(_this: vimService.vim.ManagedObjectReference, force: boolean): Promise<vimService.vim.ManagedObjectReference>;
         suspendVAppTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         unregisterVAppTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         createVirtualDiskTask(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference, spec: vimService.vim.VirtualDiskSpec): Promise<vimService.vim.ManagedObjectReference>;
         deleteVirtualDiskTask(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         moveVirtualDiskTask(_this: vimService.vim.ManagedObjectReference, sourceName: string, sourceDatacenter: vimService.vim.ManagedObjectReference, destName: string, destDatacenter: vimService.vim.ManagedObjectReference, force: boolean, profile: Array<vimService.vim.VirtualMachineProfileSpec>): Promise<vimService.vim.ManagedObjectReference>;
         copyVirtualDiskTask(_this: vimService.vim.ManagedObjectReference, sourceName: string, sourceDatacenter: vimService.vim.ManagedObjectReference, destName: string, destDatacenter: vimService.vim.ManagedObjectReference, destSpec: vimService.vim.VirtualDiskSpec, force: boolean): Promise<vimService.vim.ManagedObjectReference>;
         extendVirtualDiskTask(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference, newCapacityKb: number, eagerZero: boolean): Promise<vimService.vim.ManagedObjectReference>;
         queryVirtualDiskFragmentation(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference): Promise<number>;
         defragmentVirtualDiskTask(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         shrinkVirtualDiskTask(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference, copy: boolean): Promise<vimService.vim.ManagedObjectReference>;
         inflateVirtualDiskTask(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         eagerZeroVirtualDiskTask(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         zeroFillVirtualDiskTask(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         setVirtualDiskUuid(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference, uuid: string): Promise<void>;
         queryVirtualDiskUuid(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference): Promise<string>;
         queryVirtualDiskGeometry(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference): Promise<vimService.vim.HostDiskDimensionsChs>;
         importUnmanagedSnapshot(_this: vimService.vim.ManagedObjectReference, vdisk: string, datacenter: vimService.vim.ManagedObjectReference, vvolId: string): Promise<void>;
         releaseManagedSnapshot(_this: vimService.vim.ManagedObjectReference, vdisk: string, datacenter: vimService.vim.ManagedObjectReference): Promise<void>;
         refreshStorageInfo(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         createSnapshotTask(_this: vimService.vim.ManagedObjectReference, name: string, description: string, memory: boolean, quiesce: boolean): Promise<vimService.vim.ManagedObjectReference>;
         createSnapshotExTask(_this: vimService.vim.ManagedObjectReference, name: string, description: string, memory: boolean, quiesceSpec: vimService.vim.VirtualMachineGuestQuiesceSpec): Promise<vimService.vim.ManagedObjectReference>;
         revertToCurrentSnapshotTask(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, suppressPowerOn: boolean): Promise<vimService.vim.ManagedObjectReference>;
         removeAllSnapshotsTask(_this: vimService.vim.ManagedObjectReference, consolidate: boolean): Promise<vimService.vim.ManagedObjectReference>;
         consolidateVMDisksTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         estimateStorageForConsolidateSnapshotsTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         reconfigVMTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.VirtualMachineConfigSpec): Promise<vimService.vim.ManagedObjectReference>;
         upgradeVMTask(_this: vimService.vim.ManagedObjectReference, version: string): Promise<vimService.vim.ManagedObjectReference>;
         extractOvfEnvironment(_this: vimService.vim.ManagedObjectReference): Promise<string>;
         powerOnVMTask(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         powerOffVMTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         suspendVMTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         resetVMTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         shutdownGuest(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         rebootGuest(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         standbyGuest(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         answerVM(_this: vimService.vim.ManagedObjectReference, questionId: string, answerChoice: string): Promise<void>;
         customizeVMTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.CustomizationSpec): Promise<vimService.vim.ManagedObjectReference>;
         checkCustomizationSpec(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.CustomizationSpec): Promise<void>;
         migrateVMTask(_this: vimService.vim.ManagedObjectReference, pool: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, priority: vimService.vim.VirtualMachineMovePriority, state: vimService.vim.VirtualMachinePowerState): Promise<vimService.vim.ManagedObjectReference>;
         relocateVMTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.VirtualMachineRelocateSpec, priority: vimService.vim.VirtualMachineMovePriority): Promise<vimService.vim.ManagedObjectReference>;
         cloneVMTask(_this: vimService.vim.ManagedObjectReference, folder: vimService.vim.ManagedObjectReference, name: string, spec: vimService.vim.VirtualMachineCloneSpec): Promise<vimService.vim.ManagedObjectReference>;
         exportVm(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         markAsTemplate(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         markAsVirtualMachine(_this: vimService.vim.ManagedObjectReference, pool: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<void>;
         unregisterVM(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         resetGuestInformation(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         mountToolsInstaller(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         unmountToolsInstaller(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         upgradeToolsTask(_this: vimService.vim.ManagedObjectReference, installerOptions: string): Promise<vimService.vim.ManagedObjectReference>;
         acquireMksTicket(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.VirtualMachineMksTicket>;
         acquireTicket(_this: vimService.vim.ManagedObjectReference, ticketType: string): Promise<vimService.vim.VirtualMachineTicket>;
         setScreenResolution(_this: vimService.vim.ManagedObjectReference, width: number, height: number): Promise<void>;
         defragmentAllDisks(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         createSecondaryVMTask(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         createSecondaryVMExTask(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, spec: vimService.vim.FaultToleranceConfigSpec): Promise<vimService.vim.ManagedObjectReference>;
         turnOffFaultToleranceForVMTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         makePrimaryVMTask(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         terminateFaultTolerantVMTask(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         disableSecondaryVMTask(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         enableSecondaryVMTask(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         setDisplayTopology(_this: vimService.vim.ManagedObjectReference, displays: Array<vimService.vim.VirtualMachineDisplayTopology>): Promise<void>;
         startRecordingTask(_this: vimService.vim.ManagedObjectReference, name: string, description: string): Promise<vimService.vim.ManagedObjectReference>;
         stopRecordingTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         startReplayingTask(_this: vimService.vim.ManagedObjectReference, replaySnapshot: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         stopReplayingTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         promoteDisksTask(_this: vimService.vim.ManagedObjectReference, unlink: boolean, disks: Array<vimService.vim.VirtualDisk>): Promise<vimService.vim.ManagedObjectReference>;
         createScreenshotTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         putUsbScanCodes(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.UsbScanCodeSpec): Promise<number>;
         queryChangedDiskAreas(_this: vimService.vim.ManagedObjectReference, snapshot: vimService.vim.ManagedObjectReference, deviceKey: number, startOffset: number, changeId: string): Promise<vimService.vim.DiskChangeInfo>;
         queryUnownedFiles(_this: vimService.vim.ManagedObjectReference): Promise<Array<string>>;
         reloadVirtualMachineFromPathTask(_this: vimService.vim.ManagedObjectReference, configurationPath: string): Promise<vimService.vim.ManagedObjectReference>;
         queryFaultToleranceCompatibility(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.LocalizedMethodFault>>;
         queryFaultToleranceCompatibilityEx(_this: vimService.vim.ManagedObjectReference, forLegacyFt: boolean): Promise<Array<vimService.vim.LocalizedMethodFault>>;
         terminateVM(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         sendNMI(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         attachDiskTask(_this: vimService.vim.ManagedObjectReference, diskId: string, datastore: vimService.vim.ManagedObjectReference, controllerKey: number, unitNumber: number): Promise<vimService.vim.ManagedObjectReference>;
         detachDiskTask(_this: vimService.vim.ManagedObjectReference, diskId: string): Promise<vimService.vim.ManagedObjectReference>;
         performVsanUpgradePreflightCheck(_this: vimService.vim.ManagedObjectReference, cluster: vimService.vim.ManagedObjectReference, downgradeFormat: boolean): Promise<vimService.vim.VsanUpgradeSystemPreflightCheckResult>;
         queryVsanUpgradeStatus(_this: vimService.vim.ManagedObjectReference, cluster: vimService.vim.ManagedObjectReference): Promise<vimService.vim.VsanUpgradeSystemUpgradeStatus>;
         performVsanUpgradeTask(_this: vimService.vim.ManagedObjectReference, cluster: vimService.vim.ManagedObjectReference, performObjectUpgrade: boolean, downgradeFormat: boolean, allowReducedRedundancy: boolean, excludeHosts: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         removeAlarm(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         reconfigureAlarm(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.AlarmSpec): Promise<void>;
         createAlarm(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, spec: vimService.vim.AlarmSpec): Promise<vimService.vim.ManagedObjectReference>;
         getAlarm(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ManagedObjectReference>>;
         areAlarmActionsEnabled(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference): Promise<boolean>;
         enableAlarmActions(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, enabled: boolean): Promise<void>;
         getAlarmState(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.AlarmState>>;
         acknowledgeAlarm(_this: vimService.vim.ManagedObjectReference, alarm: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference): Promise<void>;
         configureEvcModeTask(_this: vimService.vim.ManagedObjectReference, evcModeKey: string): Promise<vimService.vim.ManagedObjectReference>;
         disableEvcModeTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         checkConfigureEvcModeTask(_this: vimService.vim.ManagedObjectReference, evcModeKey: string): Promise<vimService.vim.ManagedObjectReference>;
         checkAddHostEvcTask(_this: vimService.vim.ManagedObjectReference, cnxSpec: vimService.vim.HostConnectSpec): Promise<vimService.vim.ManagedObjectReference>;
         reconfigureDVPortgroupTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.DVPortgroupConfigSpec): Promise<vimService.vim.ManagedObjectReference>;
         dVPortgroupRollbackTask(_this: vimService.vim.ManagedObjectReference, entityBackup: vimService.vim.EntityBackupConfig): Promise<vimService.vim.ManagedObjectReference>;
         queryAvailableDvsSpec(_this: vimService.vim.ManagedObjectReference, recommended: boolean): Promise<Array<vimService.vim.DistributedVirtualSwitchProductSpec>>;
         queryCompatibleHostForNewDvs(_this: vimService.vim.ManagedObjectReference, container: vimService.vim.ManagedObjectReference, recursive: boolean, switchProductSpec: vimService.vim.DistributedVirtualSwitchProductSpec): Promise<Array<vimService.vim.ManagedObjectReference>>;
         queryCompatibleHostForExistingDvs(_this: vimService.vim.ManagedObjectReference, container: vimService.vim.ManagedObjectReference, recursive: boolean, dvs: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ManagedObjectReference>>;
         queryDvsCompatibleHostSpec(_this: vimService.vim.ManagedObjectReference, switchProductSpec: vimService.vim.DistributedVirtualSwitchProductSpec): Promise<Array<vimService.vim.DistributedVirtualSwitchHostProductSpec>>;
         queryDvsFeatureCapability(_this: vimService.vim.ManagedObjectReference, switchProductSpec: vimService.vim.DistributedVirtualSwitchProductSpec): Promise<vimService.vim.DVSFeatureCapability>;
         queryDvsByUuid(_this: vimService.vim.ManagedObjectReference, uuid: string): Promise<vimService.vim.ManagedObjectReference>;
         queryDvsConfigTarget(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, dvs: vimService.vim.ManagedObjectReference): Promise<vimService.vim.DVSManagerDvsConfigTarget>;
         queryDvsCheckCompatibility(_this: vimService.vim.ManagedObjectReference, hostContainer: vimService.vim.DistributedVirtualSwitchManagerHostContainer, dvsProductSpec: vimService.vim.DistributedVirtualSwitchManagerDvsProductSpec, hostFilterSpec: Array<vimService.vim.DistributedVirtualSwitchManagerHostDvsFilterSpec>): Promise<Array<vimService.vim.DistributedVirtualSwitchManagerCompatibilityResult>>;
         rectifyDvsOnHostTask(_this: vimService.vim.ManagedObjectReference, hosts: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         dVSManagerExportEntityTask(_this: vimService.vim.ManagedObjectReference, selectionSet: Array<vimService.vim.SelectionSet>): Promise<vimService.vim.ManagedObjectReference>;
         dVSManagerImportEntityTask(_this: vimService.vim.ManagedObjectReference, entityBackup: Array<vimService.vim.EntityBackupConfig>, importType: string): Promise<vimService.vim.ManagedObjectReference>;
         dVSManagerLookupDvPortGroup(_this: vimService.vim.ManagedObjectReference, switchUuid: string, portgroupKey: string): Promise<vimService.vim.ManagedObjectReference>;
         updateDVSLacpGroupConfigTask(_this: vimService.vim.ManagedObjectReference, lacpGroupSpec: Array<vimService.vim.VMwareDvsLacpGroupSpec>): Promise<vimService.vim.ManagedObjectReference>;
         addKey(_this: vimService.vim.ManagedObjectReference, key: vimService.vim.CryptoKeyPlain): Promise<void>;
         addKeys(_this: vimService.vim.ManagedObjectReference, keys: Array<vimService.vim.CryptoKeyPlain>): Promise<Array<vimService.vim.CryptoKeyResult>>;
         removeKey(_this: vimService.vim.ManagedObjectReference, key: vimService.vim.CryptoKeyId, force: boolean): Promise<void>;
         removeKeys(_this: vimService.vim.ManagedObjectReference, keys: Array<vimService.vim.CryptoKeyId>, force: boolean): Promise<Array<vimService.vim.CryptoKeyResult>>;
         listKeys(_this: vimService.vim.ManagedObjectReference, limit: number): Promise<Array<vimService.vim.CryptoKeyId>>;
         registerKmipServer(_this: vimService.vim.ManagedObjectReference, server: vimService.vim.KmipServerSpec): Promise<void>;
         markDefault(_this: vimService.vim.ManagedObjectReference, clusterId: vimService.vim.KeyProviderId): Promise<void>;
         updateKmipServer(_this: vimService.vim.ManagedObjectReference, server: vimService.vim.KmipServerSpec): Promise<void>;
         removeKmipServer(_this: vimService.vim.ManagedObjectReference, clusterId: vimService.vim.KeyProviderId, serverName: string): Promise<void>;
         listKmipServers(_this: vimService.vim.ManagedObjectReference, limit: number): Promise<Array<vimService.vim.KmipClusterInfo>>;
         retrieveKmipServersStatusTask(_this: vimService.vim.ManagedObjectReference, clusters: Array<vimService.vim.KmipClusterInfo>): Promise<vimService.vim.ManagedObjectReference>;
         generateKey(_this: vimService.vim.ManagedObjectReference, keyProvider: vimService.vim.KeyProviderId): Promise<vimService.vim.CryptoKeyResult>;
         retrieveKmipServerCert(_this: vimService.vim.ManagedObjectReference, keyProvider: vimService.vim.KeyProviderId, server: vimService.vim.KmipServerInfo): Promise<vimService.vim.CryptoManagerKmipServerCertInfo>;
         uploadKmipServerCert(_this: vimService.vim.ManagedObjectReference, cluster: vimService.vim.KeyProviderId, certificate: string): Promise<void>;
         generateSelfSignedClientCert(_this: vimService.vim.ManagedObjectReference, cluster: vimService.vim.KeyProviderId): Promise<string>;
         generateClientCsr(_this: vimService.vim.ManagedObjectReference, cluster: vimService.vim.KeyProviderId): Promise<string>;
         retrieveSelfSignedClientCert(_this: vimService.vim.ManagedObjectReference, cluster: vimService.vim.KeyProviderId): Promise<string>;
         retrieveClientCsr(_this: vimService.vim.ManagedObjectReference, cluster: vimService.vim.KeyProviderId): Promise<string>;
         retrieveClientCert(_this: vimService.vim.ManagedObjectReference, cluster: vimService.vim.KeyProviderId): Promise<string>;
         updateSelfSignedClientCert(_this: vimService.vim.ManagedObjectReference, cluster: vimService.vim.KeyProviderId, certificate: string): Promise<void>;
         updateKmsSignedCsrClientCert(_this: vimService.vim.ManagedObjectReference, cluster: vimService.vim.KeyProviderId, certificate: string): Promise<void>;
         uploadClientCert(_this: vimService.vim.ManagedObjectReference, cluster: vimService.vim.KeyProviderId, certificate: string, privateKey: string): Promise<void>;
         readNextEvents(_this: vimService.vim.ManagedObjectReference, maxCount: number): Promise<Array<vimService.vim.Event>>;
         readPreviousEvents(_this: vimService.vim.ManagedObjectReference, maxCount: number): Promise<Array<vimService.vim.Event>>;
         retrieveArgumentDescription(_this: vimService.vim.ManagedObjectReference, eventTypeId: string): Promise<Array<vimService.vim.EventArgDesc>>;
         createCollectorForEvents(_this: vimService.vim.ManagedObjectReference, filter: vimService.vim.EventFilterSpec): Promise<vimService.vim.ManagedObjectReference>;
         logUserEvent(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, msg: string): Promise<void>;
         queryEvents(_this: vimService.vim.ManagedObjectReference, filter: vimService.vim.EventFilterSpec): Promise<Array<vimService.vim.Event>>;
         postEvent(_this: vimService.vim.ManagedObjectReference, eventToPost: vimService.vim.Event, taskInfo: vimService.vim.TaskInfo): Promise<void>;
         joinDomainTask(_this: vimService.vim.ManagedObjectReference, domainName: string, userName: string, password: string): Promise<vimService.vim.ManagedObjectReference>;
         joinDomainWithCAMTask(_this: vimService.vim.ManagedObjectReference, domainName: string, camServer: string): Promise<vimService.vim.ManagedObjectReference>;
         importCertificateForCAMTask(_this: vimService.vim.ManagedObjectReference, certPath: string, camServer: string): Promise<vimService.vim.ManagedObjectReference>;
         leaveCurrentDomainTask(_this: vimService.vim.ManagedObjectReference, force: boolean): Promise<vimService.vim.ManagedObjectReference>;
         enableSmartCardAuthentication(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         installSmartCardTrustAnchor(_this: vimService.vim.ManagedObjectReference, cert: string): Promise<void>;
         replaceSmartCardTrustAnchors(_this: vimService.vim.ManagedObjectReference, certs: Array<string>): Promise<void>;
         removeSmartCardTrustAnchor(_this: vimService.vim.ManagedObjectReference, issuer: string, serial: string): Promise<void>;
         removeSmartCardTrustAnchorByFingerprint(_this: vimService.vim.ManagedObjectReference, fingerprint: string, digest: string): Promise<void>;
         listSmartCardTrustAnchors(_this: vimService.vim.ManagedObjectReference): Promise<Array<string>>;
         disableSmartCardAuthentication(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         reconfigureAutostart(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostAutoStartManagerConfig): Promise<void>;
         autoStartPowerOn(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         autoStartPowerOff(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         queryBootDevices(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.HostBootDeviceInfo>;
         updateBootDevice(_this: vimService.vim.ManagedObjectReference, key: string): Promise<void>;
         configureHostCacheTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostCacheConfigurationSpec): Promise<vimService.vim.ManagedObjectReference>;
         generateCertificateSigningRequest(_this: vimService.vim.ManagedObjectReference, useIpAddressAsCommonName: boolean): Promise<string>;
         generateCertificateSigningRequestByDn(_this: vimService.vim.ManagedObjectReference, distinguishedName: string): Promise<string>;
         installServerCertificate(_this: vimService.vim.ManagedObjectReference, cert: string): Promise<void>;
         replaceCACertificatesAndCRLs(_this: vimService.vim.ManagedObjectReference, caCert: Array<string>, caCrl: Array<string>): Promise<void>;
         listCACertificates(_this: vimService.vim.ManagedObjectReference): Promise<Array<string>>;
         listCACertificateRevocationLists(_this: vimService.vim.ManagedObjectReference): Promise<Array<string>>;
         enableHyperThreading(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         disableHyperThreading(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         searchDatastoreTask(_this: vimService.vim.ManagedObjectReference, datastorePath: string, searchSpec: vimService.vim.HostDatastoreBrowserSearchSpec): Promise<vimService.vim.ManagedObjectReference>;
         searchDatastoreSubFoldersTask(_this: vimService.vim.ManagedObjectReference, datastorePath: string, searchSpec: vimService.vim.HostDatastoreBrowserSearchSpec): Promise<vimService.vim.ManagedObjectReference>;
         deleteFile(_this: vimService.vim.ManagedObjectReference, datastorePath: string): Promise<void>;
         updateLocalSwapDatastore(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference): Promise<void>;
         queryAvailableDisksForVmfs(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.HostScsiDisk>>;
         queryVmfsDatastoreCreateOptions(_this: vimService.vim.ManagedObjectReference, devicePath: string, vmfsMajorVersion: number): Promise<Array<vimService.vim.VmfsDatastoreOption>>;
         createVmfsDatastore(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.VmfsDatastoreCreateSpec): Promise<vimService.vim.ManagedObjectReference>;
         queryVmfsDatastoreExtendOptions(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference, devicePath: string, suppressExpandCandidates: boolean): Promise<Array<vimService.vim.VmfsDatastoreOption>>;
         queryVmfsDatastoreExpandOptions(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.VmfsDatastoreOption>>;
         extendVmfsDatastore(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference, spec: vimService.vim.VmfsDatastoreExtendSpec): Promise<vimService.vim.ManagedObjectReference>;
         expandVmfsDatastore(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference, spec: vimService.vim.VmfsDatastoreExpandSpec): Promise<vimService.vim.ManagedObjectReference>;
         createNasDatastore(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostNasVolumeSpec): Promise<vimService.vim.ManagedObjectReference>;
         createLocalDatastore(_this: vimService.vim.ManagedObjectReference, name: string, path: string): Promise<vimService.vim.ManagedObjectReference>;
         createVvolDatastore(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostDatastoreSystemVvolDatastoreSpec): Promise<vimService.vim.ManagedObjectReference>;
         removeDatastore(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference): Promise<void>;
         removeDatastoreExTask(_this: vimService.vim.ManagedObjectReference, datastore: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         configureDatastorePrincipal(_this: vimService.vim.ManagedObjectReference, userName: string, password: string): Promise<void>;
         queryUnresolvedVmfsVolumes(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.HostUnresolvedVmfsVolume>>;
         resignatureUnresolvedVmfsVolumeTask(_this: vimService.vim.ManagedObjectReference, resolutionSpec: vimService.vim.HostUnresolvedVmfsResignatureSpec): Promise<vimService.vim.ManagedObjectReference>;
         updateDateTimeConfig(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.HostDateTimeConfig): Promise<void>;
         queryAvailableTimeZones(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.HostDateTimeSystemTimeZone>>;
         queryDateTime(_this: vimService.vim.ManagedObjectReference): Promise<Date>;
         updateDateTime(_this: vimService.vim.ManagedObjectReference, dateTime: Date): Promise<void>;
         refreshDateTimeSystem(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         queryAvailablePartition(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.HostDiagnosticPartition>>;
         selectActivePartition(_this: vimService.vim.ManagedObjectReference, partition: vimService.vim.HostScsiDiskPartition): Promise<void>;
         queryPartitionCreateOptions(_this: vimService.vim.ManagedObjectReference, storageType: string, diagnosticType: string): Promise<Array<vimService.vim.HostDiagnosticPartitionCreateOption>>;
         queryPartitionCreateDesc(_this: vimService.vim.ManagedObjectReference, diskUuid: string, diagnosticType: string): Promise<vimService.vim.HostDiagnosticPartitionCreateDescription>;
         createDiagnosticPartition(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostDiagnosticPartitionCreateSpec): Promise<void>;
         esxAgentHostManagerUpdateConfig(_this: vimService.vim.ManagedObjectReference, configInfo: vimService.vim.HostEsxAgentHostManagerConfigInfo): Promise<void>;
         updateDefaultPolicy(_this: vimService.vim.ManagedObjectReference, defaultPolicy: vimService.vim.HostFirewallDefaultPolicy): Promise<void>;
         enableRuleset(_this: vimService.vim.ManagedObjectReference, id: string): Promise<void>;
         disableRuleset(_this: vimService.vim.ManagedObjectReference, id: string): Promise<void>;
         updateRuleset(_this: vimService.vim.ManagedObjectReference, id: string, spec: vimService.vim.HostFirewallRulesetRulesetSpec): Promise<void>;
         refreshFirewall(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         resetFirmwareToFactoryDefaults(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         backupFirmwareConfiguration(_this: vimService.vim.ManagedObjectReference): Promise<string>;
         queryFirmwareConfigUploadURL(_this: vimService.vim.ManagedObjectReference): Promise<string>;
         restoreFirmwareConfiguration(_this: vimService.vim.ManagedObjectReference, force: boolean): Promise<void>;
         refreshGraphicsManager(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         isSharedGraphicsActive(_this: vimService.vim.ManagedObjectReference): Promise<boolean>;
         updateGraphicsConfig(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.HostGraphicsConfig): Promise<void>;
         refreshHealthStatusSystem(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         resetSystemHealthInfo(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         clearSystemEventLog(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         fetchSystemEventLog(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.SystemEventInfo>>;
         retrieveHostAccessControlEntries(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.HostAccessControlEntry>>;
         changeAccessMode(_this: vimService.vim.ManagedObjectReference, principal: string, isGroup: boolean, accessMode: vimService.vim.HostAccessMode): Promise<void>;
         querySystemUsers(_this: vimService.vim.ManagedObjectReference): Promise<Array<string>>;
         updateSystemUsers(_this: vimService.vim.ManagedObjectReference, users: Array<string>): Promise<void>;
         queryLockdownExceptions(_this: vimService.vim.ManagedObjectReference): Promise<Array<string>>;
         updateLockdownExceptions(_this: vimService.vim.ManagedObjectReference, users: Array<string>): Promise<void>;
         changeLockdownMode(_this: vimService.vim.ManagedObjectReference, mode: vimService.vim.HostLockdownMode): Promise<void>;
         hostImageConfigGetAcceptance(_this: vimService.vim.ManagedObjectReference): Promise<string>;
         hostImageConfigGetProfile(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.HostImageProfileSummary>;
         updateHostImageAcceptanceLevel(_this: vimService.vim.ManagedObjectReference, newAcceptanceLevel: string): Promise<void>;
         fetchSoftwarePackages(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.SoftwarePackage>>;
         installDate(_this: vimService.vim.ManagedObjectReference): Promise<Date>;
         queryVnicStatus(_this: vimService.vim.ManagedObjectReference, vnicDevice: string): Promise<vimService.vim.IscsiStatus>;
         queryPnicStatus(_this: vimService.vim.ManagedObjectReference, pnicDevice: string): Promise<vimService.vim.IscsiStatus>;
         queryBoundVnics(_this: vimService.vim.ManagedObjectReference, iScsiHbaName: string): Promise<Array<vimService.vim.IscsiPortInfo>>;
         queryCandidateNics(_this: vimService.vim.ManagedObjectReference, iScsiHbaName: string): Promise<Array<vimService.vim.IscsiPortInfo>>;
         bindVnic(_this: vimService.vim.ManagedObjectReference, iScsiHbaName: string, vnicDevice: string): Promise<void>;
         unbindVnic(_this: vimService.vim.ManagedObjectReference, iScsiHbaName: string, vnicDevice: string, force: boolean): Promise<void>;
         queryMigrationDependencies(_this: vimService.vim.ManagedObjectReference, pnicDevice: Array<string>): Promise<vimService.vim.IscsiMigrationDependency>;
         queryModules(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.KernelModuleInfo>>;
         updateModuleOptionString(_this: vimService.vim.ManagedObjectReference, name: string, options: string): Promise<void>;
         queryConfiguredModuleOptionString(_this: vimService.vim.ManagedObjectReference, name: string): Promise<string>;
         createUser(_this: vimService.vim.ManagedObjectReference, user: vimService.vim.HostAccountSpec): Promise<void>;
         updateUser(_this: vimService.vim.ManagedObjectReference, user: vimService.vim.HostAccountSpec): Promise<void>;
         createGroup(_this: vimService.vim.ManagedObjectReference, group: vimService.vim.HostAccountSpec): Promise<void>;
         removeUser(_this: vimService.vim.ManagedObjectReference, userName: string): Promise<void>;
         removeGroup(_this: vimService.vim.ManagedObjectReference, groupName: string): Promise<void>;
         assignUserToGroup(_this: vimService.vim.ManagedObjectReference, user: string, group: string): Promise<void>;
         unassignUserFromGroup(_this: vimService.vim.ManagedObjectReference, user: string, group: string): Promise<void>;
         reconfigureServiceConsoleReservation(_this: vimService.vim.ManagedObjectReference, cfgBytes: number): Promise<void>;
         reconfigureVirtualMachineReservation(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.VirtualMachineMemoryReservationSpec): Promise<void>;
         updateNetworkConfig(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.HostNetworkConfig, changeMode: string): Promise<vimService.vim.HostNetworkConfigResult>;
         updateDnsConfig(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.HostDnsConfig): Promise<void>;
         updateIpRouteConfig(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.HostIpRouteConfig): Promise<void>;
         updateConsoleIpRouteConfig(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.HostIpRouteConfig): Promise<void>;
         updateIpRouteTableConfig(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.HostIpRouteTableConfig): Promise<void>;
         addVirtualSwitch(_this: vimService.vim.ManagedObjectReference, vswitchName: string, spec: vimService.vim.HostVirtualSwitchSpec): Promise<void>;
         removeVirtualSwitch(_this: vimService.vim.ManagedObjectReference, vswitchName: string): Promise<void>;
         updateVirtualSwitch(_this: vimService.vim.ManagedObjectReference, vswitchName: string, spec: vimService.vim.HostVirtualSwitchSpec): Promise<void>;
         addPortGroup(_this: vimService.vim.ManagedObjectReference, portgrp: vimService.vim.HostPortGroupSpec): Promise<void>;
         removePortGroup(_this: vimService.vim.ManagedObjectReference, pgName: string): Promise<void>;
         updatePortGroup(_this: vimService.vim.ManagedObjectReference, pgName: string, portgrp: vimService.vim.HostPortGroupSpec): Promise<void>;
         updatePhysicalNicLinkSpeed(_this: vimService.vim.ManagedObjectReference, device: string, linkSpeed: vimService.vim.PhysicalNicLinkInfo): Promise<void>;
         queryNetworkHint(_this: vimService.vim.ManagedObjectReference, device: Array<string>): Promise<Array<vimService.vim.PhysicalNicHintInfo>>;
         addVirtualNic(_this: vimService.vim.ManagedObjectReference, portgroup: string, nic: vimService.vim.HostVirtualNicSpec): Promise<string>;
         removeVirtualNic(_this: vimService.vim.ManagedObjectReference, device: string): Promise<void>;
         updateVirtualNic(_this: vimService.vim.ManagedObjectReference, device: string, nic: vimService.vim.HostVirtualNicSpec): Promise<void>;
         addServiceConsoleVirtualNic(_this: vimService.vim.ManagedObjectReference, portgroup: string, nic: vimService.vim.HostVirtualNicSpec): Promise<string>;
         removeServiceConsoleVirtualNic(_this: vimService.vim.ManagedObjectReference, device: string): Promise<void>;
         updateServiceConsoleVirtualNic(_this: vimService.vim.ManagedObjectReference, device: string, nic: vimService.vim.HostVirtualNicSpec): Promise<void>;
         restartServiceConsoleVirtualNic(_this: vimService.vim.ManagedObjectReference, device: string): Promise<void>;
         refreshNetworkSystem(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         checkHostPatchTask(_this: vimService.vim.ManagedObjectReference, metaUrls: Array<string>, bundleUrls: Array<string>, spec: vimService.vim.HostPatchManagerPatchManagerOperationSpec): Promise<vimService.vim.ManagedObjectReference>;
         scanHostPatchTask(_this: vimService.vim.ManagedObjectReference, repository: vimService.vim.HostPatchManagerLocator, updateID: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         scanHostPatchV2Task(_this: vimService.vim.ManagedObjectReference, metaUrls: Array<string>, bundleUrls: Array<string>, spec: vimService.vim.HostPatchManagerPatchManagerOperationSpec): Promise<vimService.vim.ManagedObjectReference>;
         stageHostPatchTask(_this: vimService.vim.ManagedObjectReference, metaUrls: Array<string>, bundleUrls: Array<string>, vibUrls: Array<string>, spec: vimService.vim.HostPatchManagerPatchManagerOperationSpec): Promise<vimService.vim.ManagedObjectReference>;
         installHostPatchTask(_this: vimService.vim.ManagedObjectReference, repository: vimService.vim.HostPatchManagerLocator, updateID: string, force: boolean): Promise<vimService.vim.ManagedObjectReference>;
         installHostPatchV2Task(_this: vimService.vim.ManagedObjectReference, metaUrls: Array<string>, bundleUrls: Array<string>, vibUrls: Array<string>, spec: vimService.vim.HostPatchManagerPatchManagerOperationSpec): Promise<vimService.vim.ManagedObjectReference>;
         uninstallHostPatchTask(_this: vimService.vim.ManagedObjectReference, bulletinIds: Array<string>, spec: vimService.vim.HostPatchManagerPatchManagerOperationSpec): Promise<vimService.vim.ManagedObjectReference>;
         queryHostPatchTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostPatchManagerPatchManagerOperationSpec): Promise<vimService.vim.ManagedObjectReference>;
         refresh(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         updatePassthruConfig(_this: vimService.vim.ManagedObjectReference, config: Array<vimService.vim.HostPciPassthruConfig>): Promise<void>;
         configurePowerPolicy(_this: vimService.vim.ManagedObjectReference, key: number): Promise<void>;
         updateServicePolicy(_this: vimService.vim.ManagedObjectReference, id: string, policy: string): Promise<void>;
         startService(_this: vimService.vim.ManagedObjectReference, id: string): Promise<void>;
         stopService(_this: vimService.vim.ManagedObjectReference, id: string): Promise<void>;
         restartService(_this: vimService.vim.ManagedObjectReference, id: string): Promise<void>;
         uninstallService(_this: vimService.vim.ManagedObjectReference, id: string): Promise<void>;
         refreshServices(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         reconfigureSnmpAgent(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostSnmpConfigSpec): Promise<void>;
         sendTestNotification(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         retrieveDiskPartitionInfo(_this: vimService.vim.ManagedObjectReference, devicePath: Array<string>): Promise<Array<vimService.vim.HostDiskPartitionInfo>>;
         computeDiskPartitionInfo(_this: vimService.vim.ManagedObjectReference, devicePath: string, layout: vimService.vim.HostDiskPartitionLayout, partitionFormat: string): Promise<vimService.vim.HostDiskPartitionInfo>;
         computeDiskPartitionInfoForResize(_this: vimService.vim.ManagedObjectReference, partition: vimService.vim.HostScsiDiskPartition, blockRange: vimService.vim.HostDiskPartitionBlockRange, partitionFormat: string): Promise<vimService.vim.HostDiskPartitionInfo>;
         updateDiskPartitions(_this: vimService.vim.ManagedObjectReference, devicePath: string, spec: vimService.vim.HostDiskPartitionSpec): Promise<void>;
         formatVmfs(_this: vimService.vim.ManagedObjectReference, createSpec: vimService.vim.HostVmfsSpec): Promise<vimService.vim.HostVmfsVolume>;
         mountVmfsVolume(_this: vimService.vim.ManagedObjectReference, vmfsUuid: string): Promise<void>;
         unmountVmfsVolume(_this: vimService.vim.ManagedObjectReference, vmfsUuid: string): Promise<void>;
         unmountVmfsVolumeExTask(_this: vimService.vim.ManagedObjectReference, vmfsUuid: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         mountVmfsVolumeExTask(_this: vimService.vim.ManagedObjectReference, vmfsUuid: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         unmapVmfsVolumeExTask(_this: vimService.vim.ManagedObjectReference, vmfsUuid: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         deleteVmfsVolumeState(_this: vimService.vim.ManagedObjectReference, vmfsUuid: string): Promise<void>;
         rescanVmfs(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         attachVmfsExtent(_this: vimService.vim.ManagedObjectReference, vmfsPath: string, extent: vimService.vim.HostScsiDiskPartition): Promise<void>;
         expandVmfsExtent(_this: vimService.vim.ManagedObjectReference, vmfsPath: string, extent: vimService.vim.HostScsiDiskPartition): Promise<void>;
         upgradeVmfs(_this: vimService.vim.ManagedObjectReference, vmfsPath: string): Promise<void>;
         upgradeVmLayout(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         queryUnresolvedVmfsVolume(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.HostUnresolvedVmfsVolume>>;
         resolveMultipleUnresolvedVmfsVolumes(_this: vimService.vim.ManagedObjectReference, resolutionSpec: Array<vimService.vim.HostUnresolvedVmfsResolutionSpec>): Promise<Array<vimService.vim.HostUnresolvedVmfsResolutionResult>>;
         resolveMultipleUnresolvedVmfsVolumesExTask(_this: vimService.vim.ManagedObjectReference, resolutionSpec: Array<vimService.vim.HostUnresolvedVmfsResolutionSpec>): Promise<vimService.vim.ManagedObjectReference>;
         unmountForceMountedVmfsVolume(_this: vimService.vim.ManagedObjectReference, vmfsUuid: string): Promise<void>;
         rescanHba(_this: vimService.vim.ManagedObjectReference, hbaDevice: string): Promise<void>;
         rescanAllHba(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         updateSoftwareInternetScsiEnabled(_this: vimService.vim.ManagedObjectReference, enabled: boolean): Promise<void>;
         updateInternetScsiDiscoveryProperties(_this: vimService.vim.ManagedObjectReference, iScsiHbaDevice: string, discoveryProperties: vimService.vim.HostInternetScsiHbaDiscoveryProperties): Promise<void>;
         updateInternetScsiAuthenticationProperties(_this: vimService.vim.ManagedObjectReference, iScsiHbaDevice: string, authenticationProperties: vimService.vim.HostInternetScsiHbaAuthenticationProperties, targetSet: vimService.vim.HostInternetScsiHbaTargetSet): Promise<void>;
         updateInternetScsiDigestProperties(_this: vimService.vim.ManagedObjectReference, iScsiHbaDevice: string, targetSet: vimService.vim.HostInternetScsiHbaTargetSet, digestProperties: vimService.vim.HostInternetScsiHbaDigestProperties): Promise<void>;
         updateInternetScsiAdvancedOptions(_this: vimService.vim.ManagedObjectReference, iScsiHbaDevice: string, targetSet: vimService.vim.HostInternetScsiHbaTargetSet, options: Array<vimService.vim.HostInternetScsiHbaParamValue>): Promise<void>;
         updateInternetScsiIPProperties(_this: vimService.vim.ManagedObjectReference, iScsiHbaDevice: string, ipProperties: vimService.vim.HostInternetScsiHbaIPProperties): Promise<void>;
         updateInternetScsiName(_this: vimService.vim.ManagedObjectReference, iScsiHbaDevice: string, iScsiName: string): Promise<void>;
         updateInternetScsiAlias(_this: vimService.vim.ManagedObjectReference, iScsiHbaDevice: string, iScsiAlias: string): Promise<void>;
         addInternetScsiSendTargets(_this: vimService.vim.ManagedObjectReference, iScsiHbaDevice: string, targets: Array<vimService.vim.HostInternetScsiHbaSendTarget>): Promise<void>;
         removeInternetScsiSendTargets(_this: vimService.vim.ManagedObjectReference, iScsiHbaDevice: string, targets: Array<vimService.vim.HostInternetScsiHbaSendTarget>): Promise<void>;
         addInternetScsiStaticTargets(_this: vimService.vim.ManagedObjectReference, iScsiHbaDevice: string, targets: Array<vimService.vim.HostInternetScsiHbaStaticTarget>): Promise<void>;
         removeInternetScsiStaticTargets(_this: vimService.vim.ManagedObjectReference, iScsiHbaDevice: string, targets: Array<vimService.vim.HostInternetScsiHbaStaticTarget>): Promise<void>;
         enableMultipathPath(_this: vimService.vim.ManagedObjectReference, pathName: string): Promise<void>;
         disableMultipathPath(_this: vimService.vim.ManagedObjectReference, pathName: string): Promise<void>;
         setMultipathLunPolicy(_this: vimService.vim.ManagedObjectReference, lunId: string, policy: vimService.vim.HostMultipathInfoLogicalUnitPolicy): Promise<void>;
         queryPathSelectionPolicyOptions(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.HostPathSelectionPolicyOption>>;
         queryStorageArrayTypePolicyOptions(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.HostStorageArrayTypePolicyOption>>;
         updateScsiLunDisplayName(_this: vimService.vim.ManagedObjectReference, lunUuid: string, displayName: string): Promise<void>;
         detachScsiLun(_this: vimService.vim.ManagedObjectReference, lunUuid: string): Promise<void>;
         detachScsiLunExTask(_this: vimService.vim.ManagedObjectReference, lunUuid: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         deleteScsiLunState(_this: vimService.vim.ManagedObjectReference, lunCanonicalName: string): Promise<void>;
         attachScsiLun(_this: vimService.vim.ManagedObjectReference, lunUuid: string): Promise<void>;
         attachScsiLunExTask(_this: vimService.vim.ManagedObjectReference, lunUuid: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         refreshStorageSystem(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         discoverFcoeHbas(_this: vimService.vim.ManagedObjectReference, fcoeSpec: vimService.vim.FcoeConfigFcoeSpecification): Promise<void>;
         markForRemoval(_this: vimService.vim.ManagedObjectReference, hbaName: string, remove: boolean): Promise<void>;
         formatVffs(_this: vimService.vim.ManagedObjectReference, createSpec: vimService.vim.HostVffsSpec): Promise<vimService.vim.HostVffsVolume>;
         extendVffs(_this: vimService.vim.ManagedObjectReference, vffsPath: string, devicePath: string, spec: vimService.vim.HostDiskPartitionSpec): Promise<void>;
         destroyVffs(_this: vimService.vim.ManagedObjectReference, vffsPath: string): Promise<void>;
         mountVffsVolume(_this: vimService.vim.ManagedObjectReference, vffsUuid: string): Promise<void>;
         unmountVffsVolume(_this: vimService.vim.ManagedObjectReference, vffsUuid: string): Promise<void>;
         deleteVffsVolumeState(_this: vimService.vim.ManagedObjectReference, vffsUuid: string): Promise<void>;
         rescanVffs(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         queryAvailableSsds(_this: vimService.vim.ManagedObjectReference, vffsPath: string): Promise<Array<vimService.vim.HostScsiDisk>>;
         setNFSUser(_this: vimService.vim.ManagedObjectReference, user: string, password: string): Promise<void>;
         changeNFSUserPassword(_this: vimService.vim.ManagedObjectReference, password: string): Promise<void>;
         queryNFSUser(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.HostNasVolumeUserInfo>;
         clearNFSUser(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         turnDiskLocatorLedOnTask(_this: vimService.vim.ManagedObjectReference, scsiDiskUuids: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         turnDiskLocatorLedOffTask(_this: vimService.vim.ManagedObjectReference, scsiDiskUuids: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         markAsSsdTask(_this: vimService.vim.ManagedObjectReference, scsiDiskUuid: string): Promise<vimService.vim.ManagedObjectReference>;
         markAsNonSsdTask(_this: vimService.vim.ManagedObjectReference, scsiDiskUuid: string): Promise<vimService.vim.ManagedObjectReference>;
         markAsLocalTask(_this: vimService.vim.ManagedObjectReference, scsiDiskUuid: string): Promise<vimService.vim.ManagedObjectReference>;
         markAsNonLocalTask(_this: vimService.vim.ManagedObjectReference, scsiDiskUuid: string): Promise<vimService.vim.ManagedObjectReference>;
         updateVmfsUnmapPriority(_this: vimService.vim.ManagedObjectReference, vmfsUuid: string, unmapPriority: string): Promise<void>;
         queryVmfsConfigOption(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.VmfsConfigOption>>;
         configureVFlashResourceExTask(_this: vimService.vim.ManagedObjectReference, devicePath: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         hostConfigureVFlashResource(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostVFlashManagerVFlashResourceConfigSpec): Promise<void>;
         hostRemoveVFlashResource(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         hostConfigVFlashCache(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostVFlashManagerVFlashCacheConfigSpec): Promise<void>;
         hostGetVFlashModuleDefaultConfig(_this: vimService.vim.ManagedObjectReference, vFlashModule: string): Promise<vimService.vim.VirtualDiskVFlashCacheConfigInfo>;
         updateIpConfig(_this: vimService.vim.ManagedObjectReference, ipConfig: vimService.vim.HostIpConfig): Promise<void>;
         selectVnic(_this: vimService.vim.ManagedObjectReference, device: string): Promise<void>;
         deselectVnic(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         queryNetConfig(_this: vimService.vim.ManagedObjectReference, nicType: string): Promise<vimService.vim.VirtualNicManagerNetConfig>;
         selectVnicForNicType(_this: vimService.vim.ManagedObjectReference, nicType: string, device: string): Promise<void>;
         deselectVnicForNicType(_this: vimService.vim.ManagedObjectReference, nicType: string, device: string): Promise<void>;
         queryCmmds(_this: vimService.vim.ManagedObjectReference, queries: Array<vimService.vim.HostVsanInternalSystemCmmdsQuery>): Promise<string>;
         queryPhysicalVsanDisks(_this: vimService.vim.ManagedObjectReference, props: Array<string>): Promise<string>;
         queryVsanObjects(_this: vimService.vim.ManagedObjectReference, uuids: Array<string>): Promise<string>;
         queryObjectsOnPhysicalVsanDisk(_this: vimService.vim.ManagedObjectReference, disks: Array<string>): Promise<string>;
         abdicateDomOwnership(_this: vimService.vim.ManagedObjectReference, uuids: Array<string>): Promise<Array<string>>;
         queryVsanStatistics(_this: vimService.vim.ManagedObjectReference, labels: Array<string>): Promise<string>;
         reconfigureDomObject(_this: vimService.vim.ManagedObjectReference, uuid: string, policy: string): Promise<void>;
         querySyncingVsanObjects(_this: vimService.vim.ManagedObjectReference, uuids: Array<string>): Promise<string>;
         runVsanPhysicalDiskDiagnostics(_this: vimService.vim.ManagedObjectReference, disks: Array<string>): Promise<Array<vimService.vim.HostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult>>;
         getVsanObjExtAttrs(_this: vimService.vim.ManagedObjectReference, uuids: Array<string>): Promise<string>;
         reconfigurationSatisfiable(_this: vimService.vim.ManagedObjectReference, pcbs: Array<vimService.vim.VsanPolicyChangeBatch>, ignoreSatisfiability: boolean): Promise<Array<vimService.vim.VsanPolicySatisfiability>>;
         canProvisionObjects(_this: vimService.vim.ManagedObjectReference, npbs: Array<vimService.vim.VsanNewPolicyBatch>, ignoreSatisfiability: boolean): Promise<Array<vimService.vim.VsanPolicySatisfiability>>;
         deleteVsanObjects(_this: vimService.vim.ManagedObjectReference, uuids: Array<string>, force: boolean): Promise<Array<vimService.vim.HostVsanInternalSystemDeleteVsanObjectsResult>>;
         upgradeVsanObjects(_this: vimService.vim.ManagedObjectReference, uuids: Array<string>, newVersion: number): Promise<Array<vimService.vim.HostVsanInternalSystemVsanObjectOperationResult>>;
         queryVsanObjectUuidsByFilter(_this: vimService.vim.ManagedObjectReference, uuids: Array<string>, limit: number, version: number): Promise<Array<string>>;
         queryDisksForVsan(_this: vimService.vim.ManagedObjectReference, canonicalName: Array<string>): Promise<Array<vimService.vim.VsanHostDiskResult>>;
         addDisksTask(_this: vimService.vim.ManagedObjectReference, disk: Array<vimService.vim.HostScsiDisk>): Promise<vimService.vim.ManagedObjectReference>;
         initializeDisksTask(_this: vimService.vim.ManagedObjectReference, mapping: Array<vimService.vim.VsanHostDiskMapping>): Promise<vimService.vim.ManagedObjectReference>;
         removeDiskTask(_this: vimService.vim.ManagedObjectReference, disk: Array<vimService.vim.HostScsiDisk>, maintenanceSpec: vimService.vim.HostMaintenanceSpec, timeout: number): Promise<vimService.vim.ManagedObjectReference>;
         removeDiskMappingTask(_this: vimService.vim.ManagedObjectReference, mapping: Array<vimService.vim.VsanHostDiskMapping>, maintenanceSpec: vimService.vim.HostMaintenanceSpec, timeout: number): Promise<vimService.vim.ManagedObjectReference>;
         unmountDiskMappingTask(_this: vimService.vim.ManagedObjectReference, mapping: Array<vimService.vim.VsanHostDiskMapping>): Promise<vimService.vim.ManagedObjectReference>;
         updateVsanTask(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.VsanHostConfigInfo): Promise<vimService.vim.ManagedObjectReference>;
         queryHostStatus(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.VsanHostClusterStatus>;
         evacuateVsanNodeTask(_this: vimService.vim.ManagedObjectReference, maintenanceSpec: vimService.vim.HostMaintenanceSpec, timeout: number): Promise<vimService.vim.ManagedObjectReference>;
         recommissionVsanNodeTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         queryOptions(_this: vimService.vim.ManagedObjectReference, name: string): Promise<Array<vimService.vim.OptionValue>>;
         updateOptions(_this: vimService.vim.ManagedObjectReference, changedValue: Array<vimService.vim.OptionValue>): Promise<void>;
         checkComplianceTask(_this: vimService.vim.ManagedObjectReference, profile: Array<vimService.vim.ManagedObjectReference>, entity: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         queryComplianceStatus(_this: vimService.vim.ManagedObjectReference, profile: Array<vimService.vim.ManagedObjectReference>, entity: Array<vimService.vim.ManagedObjectReference>): Promise<Array<vimService.vim.ComplianceResult>>;
         clearComplianceStatus(_this: vimService.vim.ManagedObjectReference, profile: Array<vimService.vim.ManagedObjectReference>, entity: Array<vimService.vim.ManagedObjectReference>): Promise<void>;
         queryExpressionMetadata(_this: vimService.vim.ManagedObjectReference, expressionName: Array<string>, profile: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ProfileExpressionMetadata>>;
         retrieveDescription(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ProfileDescription>;
         destroyProfile(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         associateProfile(_this: vimService.vim.ManagedObjectReference, entity: Array<vimService.vim.ManagedObjectReference>): Promise<void>;
         dissociateProfile(_this: vimService.vim.ManagedObjectReference, entity: Array<vimService.vim.ManagedObjectReference>): Promise<void>;
         checkProfileComplianceTask(_this: vimService.vim.ManagedObjectReference, entity: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         exportProfile(_this: vimService.vim.ManagedObjectReference): Promise<string>;
         createProfile(_this: vimService.vim.ManagedObjectReference, createSpec: vimService.vim.ProfileCreateSpec): Promise<vimService.vim.ManagedObjectReference>;
         queryPolicyMetadata(_this: vimService.vim.ManagedObjectReference, policyName: Array<string>, profile: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ProfilePolicyMetadata>>;
         findAssociatedProfile(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ManagedObjectReference>>;
         updateClusterProfile(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.ClusterProfileConfigSpec): Promise<void>;
         updateReferenceHost(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<void>;
         updateHostProfile(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.HostProfileConfigSpec): Promise<void>;
         executeHostProfile(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, deferredParam: Array<vimService.vim.ProfileDeferredPolicyOptionParameter>): Promise<vimService.vim.ProfileExecuteResult>;
         updateHostSpecification(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, hostSpec: vimService.vim.HostSpecification): Promise<void>;
         updateHostSubSpecification(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, hostSubSpec: vimService.vim.HostSubSpecification): Promise<void>;
         retrieveHostSpecification(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, fromHost: boolean): Promise<vimService.vim.HostSpecification>;
         deleteHostSubSpecification(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, subSpecName: string): Promise<void>;
         deleteHostSpecification(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<void>;
         hostSpecGetUpdatedHosts(_this: vimService.vim.ManagedObjectReference, startChangeID: string, endChangeID: string): Promise<Array<vimService.vim.ManagedObjectReference>>;
         applyHostConfigTask(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, configSpec: vimService.vim.HostConfigSpec, userInput: Array<vimService.vim.ProfileDeferredPolicyOptionParameter>): Promise<vimService.vim.ManagedObjectReference>;
         generateConfigTaskList(_this: vimService.vim.ManagedObjectReference, configSpec: vimService.vim.HostConfigSpec, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.HostProfileManagerConfigTaskList>;
         generateHostProfileTaskListTask(_this: vimService.vim.ManagedObjectReference, configSpec: vimService.vim.HostConfigSpec, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         queryHostProfileMetadata(_this: vimService.vim.ManagedObjectReference, profileName: Array<string>, profile: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ProfileMetadata>>;
         queryProfileStructure(_this: vimService.vim.ManagedObjectReference, profile: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ProfileProfileStructure>;
         createDefaultProfile(_this: vimService.vim.ManagedObjectReference, profileType: string, profileTypeName: string, profile: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ApplyProfile>;
         updateAnswerFileTask(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, configSpec: vimService.vim.AnswerFileCreateSpec): Promise<vimService.vim.ManagedObjectReference>;
         retrieveAnswerFile(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.AnswerFile>;
         retrieveAnswerFileForProfile(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, applyProfile: vimService.vim.HostApplyProfile): Promise<vimService.vim.AnswerFile>;
         exportAnswerFileTask(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         checkAnswerFileStatusTask(_this: vimService.vim.ManagedObjectReference, host: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         queryAnswerFileStatus(_this: vimService.vim.ManagedObjectReference, host: Array<vimService.vim.ManagedObjectReference>): Promise<Array<vimService.vim.AnswerFileStatusResult>>;
         updateHostCustomizationsTask(_this: vimService.vim.ManagedObjectReference, hostToConfigSpecMap: Array<vimService.vim.HostProfileManagerHostToConfigSpecMap>): Promise<vimService.vim.ManagedObjectReference>;
         retrieveHostCustomizations(_this: vimService.vim.ManagedObjectReference, hosts: Array<vimService.vim.ManagedObjectReference>): Promise<Array<vimService.vim.StructuredCustomizations>>;
         retrieveHostCustomizationsForProfile(_this: vimService.vim.ManagedObjectReference, hosts: Array<vimService.vim.ManagedObjectReference>, applyProfile: vimService.vim.HostApplyProfile): Promise<Array<vimService.vim.StructuredCustomizations>>;
         generateHostConfigTaskSpecTask(_this: vimService.vim.ManagedObjectReference, hostsInfo: Array<vimService.vim.StructuredCustomizations>): Promise<vimService.vim.ManagedObjectReference>;
         applyEntitiesConfigTask(_this: vimService.vim.ManagedObjectReference, applyConfigSpecs: Array<vimService.vim.ApplyHostProfileConfigurationSpec>): Promise<vimService.vim.ManagedObjectReference>;
         removeScheduledTask(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         reconfigureScheduledTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.ScheduledTaskSpec): Promise<void>;
         runScheduledTask(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         createScheduledTask(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, spec: vimService.vim.ScheduledTaskSpec): Promise<vimService.vim.ManagedObjectReference>;
         retrieveEntityScheduledTask(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ManagedObjectReference>>;
         createObjectScheduledTask(_this: vimService.vim.ManagedObjectReference, obj: vimService.vim.ManagedObjectReference, spec: vimService.vim.ScheduledTaskSpec): Promise<vimService.vim.ManagedObjectReference>;
         retrieveObjectScheduledTask(_this: vimService.vim.ManagedObjectReference, obj: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ManagedObjectReference>>;
         prepareVchaTask(_this: vimService.vim.ManagedObjectReference, networkSpec: vimService.vim.VchaClusterNetworkSpec): Promise<vimService.vim.ManagedObjectReference>;
         deployVchaTask(_this: vimService.vim.ManagedObjectReference, deploymentSpec: vimService.vim.VchaClusterDeploymentSpec): Promise<vimService.vim.ManagedObjectReference>;
         configureVchaTask(_this: vimService.vim.ManagedObjectReference, configSpec: vimService.vim.VchaClusterConfigSpec): Promise<vimService.vim.ManagedObjectReference>;
         createPassiveNodeTask(_this: vimService.vim.ManagedObjectReference, passiveDeploymentSpec: vimService.vim.PassiveNodeDeploymentSpec, sourceVcSpec: vimService.vim.SourceNodeSpec): Promise<vimService.vim.ManagedObjectReference>;
         createWitnessNodeTask(_this: vimService.vim.ManagedObjectReference, witnessDeploymentSpec: vimService.vim.NodeDeploymentSpec, sourceVcSpec: vimService.vim.SourceNodeSpec): Promise<vimService.vim.ManagedObjectReference>;
         getVchaConfig(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.VchaClusterConfigInfo>;
         destroyVchaTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         setClusterModeTask(_this: vimService.vim.ManagedObjectReference, mode: string): Promise<vimService.vim.ManagedObjectReference>;
         getClusterMode(_this: vimService.vim.ManagedObjectReference): Promise<string>;
         getVchaClusterHealth(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.VchaClusterHealth>;
         initiateFailoverTask(_this: vimService.vim.ManagedObjectReference, planned: boolean): Promise<vimService.vim.ManagedObjectReference>;
         openInventoryViewFolder(_this: vimService.vim.ManagedObjectReference, entity: Array<vimService.vim.ManagedObjectReference>): Promise<Array<vimService.vim.ManagedObjectReference>>;
         closeInventoryViewFolder(_this: vimService.vim.ManagedObjectReference, entity: Array<vimService.vim.ManagedObjectReference>): Promise<Array<vimService.vim.ManagedObjectReference>>;
         modifyListView(_this: vimService.vim.ManagedObjectReference, add: Array<vimService.vim.ManagedObjectReference>, remove: Array<vimService.vim.ManagedObjectReference>): Promise<Array<vimService.vim.ManagedObjectReference>>;
         resetListView(_this: vimService.vim.ManagedObjectReference, obj: Array<vimService.vim.ManagedObjectReference>): Promise<Array<vimService.vim.ManagedObjectReference>>;
         resetListViewFromView(_this: vimService.vim.ManagedObjectReference, view: vimService.vim.ManagedObjectReference): Promise<void>;
         destroyView(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         createInventoryView(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         createContainerView(_this: vimService.vim.ManagedObjectReference, container: vimService.vim.ManagedObjectReference, type: Array<string>, recursive: boolean): Promise<vimService.vim.ManagedObjectReference>;
         createListView(_this: vimService.vim.ManagedObjectReference, obj: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         createListViewFromView(_this: vimService.vim.ManagedObjectReference, view: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         revertToSnapshotTask(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, suppressPowerOn: boolean): Promise<vimService.vim.ManagedObjectReference>;
         removeSnapshotTask(_this: vimService.vim.ManagedObjectReference, removeChildren: boolean, consolidate: boolean): Promise<vimService.vim.ManagedObjectReference>;
         renameSnapshot(_this: vimService.vim.ManagedObjectReference, name: string, description: string): Promise<void>;
         exportSnapshot(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         checkCompatibilityTask(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, pool: vimService.vim.ManagedObjectReference, testType: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         queryVMotionCompatibilityExTask(_this: vimService.vim.ManagedObjectReference, vm: Array<vimService.vim.ManagedObjectReference>, host: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         checkMigrateTask(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, pool: vimService.vim.ManagedObjectReference, state: vimService.vim.VirtualMachinePowerState, testType: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         checkRelocateTask(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, spec: vimService.vim.VirtualMachineRelocateSpec, testType: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         addGuestAlias(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, username: string, mapCert: boolean, base64Cert: string, aliasInfo: vimService.vim.GuestAuthAliasInfo): Promise<void>;
         removeGuestAlias(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, username: string, base64Cert: string, subject: vimService.vim.GuestAuthSubject): Promise<void>;
         removeGuestAliasByCert(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, username: string, base64Cert: string): Promise<void>;
         listGuestAliases(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, username: string): Promise<Array<vimService.vim.GuestAliases>>;
         listGuestMappedAliases(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication): Promise<Array<vimService.vim.GuestMappedAliases>>;
         validateCredentialsInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication): Promise<void>;
         acquireCredentialsInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, requestedAuth: vimService.vim.GuestAuthentication, sessionID: number): Promise<vimService.vim.GuestAuthentication>;
         releaseCredentialsInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication): Promise<void>;
         makeDirectoryInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, directoryPath: string, createParentDirectories: boolean): Promise<void>;
         deleteFileInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, filePath: string): Promise<void>;
         deleteDirectoryInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, directoryPath: string, recursive: boolean): Promise<void>;
         moveDirectoryInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, srcDirectoryPath: string, dstDirectoryPath: string): Promise<void>;
         moveFileInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, srcFilePath: string, dstFilePath: string, overwrite: boolean): Promise<void>;
         createTemporaryFileInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, prefix: string, suffix: string, directoryPath: string): Promise<string>;
         createTemporaryDirectoryInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, prefix: string, suffix: string, directoryPath: string): Promise<string>;
         listFilesInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, filePath: string, index: number, maxResults: number, matchPattern: string): Promise<vimService.vim.GuestListFileInfo>;
         changeFileAttributesInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, guestFilePath: string, fileAttributes: vimService.vim.GuestFileAttributes): Promise<void>;
         initiateFileTransferFromGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, guestFilePath: string): Promise<vimService.vim.FileTransferInformation>;
         initiateFileTransferToGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, guestFilePath: string, fileAttributes: vimService.vim.GuestFileAttributes, fileSize: number, overwrite: boolean): Promise<string>;
         startProgramInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, spec: vimService.vim.GuestProgramSpec): Promise<number>;
         listProcessesInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, pids: Array<number>): Promise<Array<vimService.vim.GuestProcessInfo>>;
         terminateProcessInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, pid: number): Promise<void>;
         readEnvironmentVariableInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, names: Array<string>): Promise<Array<string>>;
         createRegistryKeyInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, keyName: vimService.vim.GuestRegKeyNameSpec, isVolatile: boolean, classType: string): Promise<void>;
         listRegistryKeysInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, keyName: vimService.vim.GuestRegKeyNameSpec, recursive: boolean, matchPattern: string): Promise<Array<vimService.vim.GuestRegKeyRecordSpec>>;
         deleteRegistryKeyInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, keyName: vimService.vim.GuestRegKeyNameSpec, recursive: boolean): Promise<void>;
         setRegistryValueInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, value: vimService.vim.GuestRegValueSpec): Promise<void>;
         listRegistryValuesInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, keyName: vimService.vim.GuestRegKeyNameSpec, expandStrings: boolean, matchPattern: string): Promise<Array<vimService.vim.GuestRegValueSpec>>;
         deleteRegistryValueInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, valueName: vimService.vim.GuestRegValueNameSpec): Promise<void>;
         hostCreateDiskTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.VslmCreateSpec): Promise<vimService.vim.ManagedObjectReference>;
         hostRegisterDisk(_this: vimService.vim.ManagedObjectReference, path: string, name: string): Promise<vimService.vim.VStorageObject>;
         hostExtendDiskTask(_this: vimService.vim.ManagedObjectReference, id: string, datastore: vimService.vim.ManagedObjectReference, newCapacityInMB: number): Promise<vimService.vim.ManagedObjectReference>;
         hostInflateDiskTask(_this: vimService.vim.ManagedObjectReference, id: string, datastore: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         hostRenameVStorageObject(_this: vimService.vim.ManagedObjectReference, id: string, datastore: vimService.vim.ManagedObjectReference, name: string): Promise<void>;
         hostDeleteVStorageObjectTask(_this: vimService.vim.ManagedObjectReference, id: string, datastore: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         hostRetrieveVStorageObject(_this: vimService.vim.ManagedObjectReference, id: string, datastore: vimService.vim.ManagedObjectReference): Promise<vimService.vim.VStorageObject>;
         hostRetrieveVStorageObjectState(_this: vimService.vim.ManagedObjectReference, id: string, datastore: vimService.vim.ManagedObjectReference): Promise<vimService.vim.VStorageObjectStateInfo>;
         hostListVStorageObject(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference): Promise<Array<string>>;
         hostCloneVStorageObjectTask(_this: vimService.vim.ManagedObjectReference, id: string, datastore: vimService.vim.ManagedObjectReference, spec: vimService.vim.VslmCloneSpec): Promise<vimService.vim.ManagedObjectReference>;
         hostRelocateVStorageObjectTask(_this: vimService.vim.ManagedObjectReference, id: string, datastore: vimService.vim.ManagedObjectReference, spec: vimService.vim.VslmRelocateSpec): Promise<vimService.vim.ManagedObjectReference>;
         hostReconcileDatastoreInventoryTask(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         hostScheduleReconcileDatastoreInventory(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference): Promise<void>;
         createDiskTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.VslmCreateSpec): Promise<vimService.vim.ManagedObjectReference>;
         registerDisk(_this: vimService.vim.ManagedObjectReference, path: string, name: string): Promise<vimService.vim.VStorageObject>;
         extendDiskTask(_this: vimService.vim.ManagedObjectReference, id: string, datastore: vimService.vim.ManagedObjectReference, newCapacityInMB: number): Promise<vimService.vim.ManagedObjectReference>;
         inflateDiskTask(_this: vimService.vim.ManagedObjectReference, id: string, datastore: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         renameVStorageObject(_this: vimService.vim.ManagedObjectReference, id: string, datastore: vimService.vim.ManagedObjectReference, name: string): Promise<void>;
         deleteVStorageObjectTask(_this: vimService.vim.ManagedObjectReference, id: string, datastore: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         retrieveVStorageObject(_this: vimService.vim.ManagedObjectReference, id: string, datastore: vimService.vim.ManagedObjectReference): Promise<vimService.vim.VStorageObject>;
         retrieveVStorageObjectState(_this: vimService.vim.ManagedObjectReference, id: string, datastore: vimService.vim.ManagedObjectReference): Promise<vimService.vim.VStorageObjectStateInfo>;
         listVStorageObject(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference): Promise<Array<string>>;
         cloneVStorageObjectTask(_this: vimService.vim.ManagedObjectReference, id: string, datastore: vimService.vim.ManagedObjectReference, spec: vimService.vim.VslmCloneSpec): Promise<vimService.vim.ManagedObjectReference>;
         relocateVStorageObjectTask(_this: vimService.vim.ManagedObjectReference, id: string, datastore: vimService.vim.ManagedObjectReference, spec: vimService.vim.VslmRelocateSpec): Promise<vimService.vim.ManagedObjectReference>;
         attachTagToVStorageObject(_this: vimService.vim.ManagedObjectReference, id: string, category: string, tag: string): Promise<void>;
         detachTagFromVStorageObject(_this: vimService.vim.ManagedObjectReference, id: string, category: string, tag: string): Promise<void>;
         listVStorageObjectsAttachedToTag(_this: vimService.vim.ManagedObjectReference, category: string, tag: string): Promise<Array<string>>;
         listTagsAttachedToVStorageObject(_this: vimService.vim.ManagedObjectReference, id: string): Promise<Array<vimService.vim.VslmTagEntry>>;
         reconcileDatastoreInventoryTask(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         scheduleReconcileDatastoreInventory(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference): Promise<void>;
         destroyPropertyFilter(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         createFilter(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.PropertyFilterSpec, partialUpdates: boolean): Promise<vimService.vim.ManagedObjectReference>;
         retrieveProperties(_this: vimService.vim.ManagedObjectReference, specSet: Array<vimService.vim.PropertyFilterSpec>): Promise<Array<vimService.vim.ObjectContent>>;
         checkForUpdates(_this: vimService.vim.ManagedObjectReference, version: string): Promise<vimService.vim.UpdateSet>;
         waitForUpdates(_this: vimService.vim.ManagedObjectReference, version: string): Promise<vimService.vim.UpdateSet>;
         cancelWaitForUpdates(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         waitForUpdatesEx(_this: vimService.vim.ManagedObjectReference, version: string, options: vimService.vim.WaitOptions): Promise<vimService.vim.UpdateSet>;
         retrievePropertiesEx(_this: vimService.vim.ManagedObjectReference, specSet: Array<vimService.vim.PropertyFilterSpec>, options: vimService.vim.RetrieveOptions): Promise<vimService.vim.RetrieveResult>;
         continueRetrievePropertiesEx(_this: vimService.vim.ManagedObjectReference, token: string): Promise<vimService.vim.RetrieveResult>;
         cancelRetrievePropertiesEx(_this: vimService.vim.ManagedObjectReference, token: string): Promise<void>;
         createPropertyCollector(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         destroyPropertyCollector(_this: vimService.vim.ManagedObjectReference): Promise<void>;
      }
      namespace vimPort {
      }
   }
}

export = vspherevim;